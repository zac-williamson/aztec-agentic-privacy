"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[267],{1266:function(t,e,a){a.d(e,{v:function(){return r}});var s,n,i=a(357);let r={useMock:!0,pxeUrl:null!==(s=i.env.NEXT_PUBLIC_PXE_URL)&&void 0!==s?s:"http://localhost:8080",contractAddress:null!==(n=i.env.NEXT_PUBLIC_CONTRACT_ADDRESS)&&void 0!==n?n:"0x0000000000000000000000000000000000000000000000000000000000000000",appName:"The Isnad Chain",appDescription:"ZK Skill Attestation & Credential Registry for AI Agents",version:"0.1.0-devnet"}},2267:function(t,e,a){a.d(e,{IsnadProvider:function(){return l},c:function(){return u}});var s=a(7437),n=a(2265),i=a(9768),r=a(1266);let o=(0,n.createContext)(null);function l(t){let{children:e}=t,[l,u]=(0,n.useState)(null),[d,c]=(0,n.useState)(null),[y,h]=(0,n.useState)(!1),[f,w]=(0,n.useState)(null),[g,p]=(0,n.useState)([]),[v,m]=(0,n.useState)([]),A=(0,n.useCallback)(()=>{l&&p(l.getMyAttestations())},[l]),b=(0,n.useCallback)(()=>{l&&m(l.listCredentials())},[l]),C=(0,n.useCallback)(async()=>{h(!0),w(null);try{if(r.v.useMock){let t="0x2f5e9c1a4b8d7f3e6a2c5b8d1f4e7a3c9b6e2d5f8a1c4b7e3d6a9f2c5b8e1d4";await new Promise(t=>setTimeout(t,800));let e=new i.zW(t);u(e),c(t)}else{let{RealSdkWrapper:t}=await a.e(792).then(a.bind(a,2792)),e=await t.create(r.v.pxeUrl,r.v.contractAddress);u(e),c(e.walletAddress)}}catch(t){w(t instanceof Error?t.message:"Connection failed")}finally{h(!1)}},[]),k=(0,n.useCallback)(()=>{u(null),c(null),p([]),m([]),w(null)},[]);(0,n.useEffect)(()=>{l&&(p(l.getMyAttestations()),m(l.listCredentials()))},[l]);let q=d?"".concat(d.slice(0,8),"...").concat(d.slice(-6)):null;return(0,s.jsx)(o.Provider,{value:{sdk:l,isConnected:null!==l,displayAddress:q,walletAddress:d,connect:C,disconnect:k,error:f,isConnecting:y,myAttestations:g,refreshAttestations:A,credentialList:v,refreshCredentials:b},children:e})}function u(){let t=(0,n.useContext)(o);if(!t)throw Error("useIsnad must be used within <IsnadProvider>");return t}},9768:function(t,e,a){a.d(e,{ri:function(){return o},zW:function(){return l}});let s=[{hash:"0x7f3ac4b82d19e8a1f5b6c3d4e9f2a0b7c8d5e6f1a2b3c4d5e6f7a8b9c0d1e2f",score:847n,count:9n,isQuarantined:!1,history:[{quality:95,daysAgo:2,type:"attest"},{quality:88,daysAgo:3,type:"attest"},{quality:92,daysAgo:5,type:"attest"},{quality:78,daysAgo:7,type:"attest"},{quality:100,daysAgo:9,type:"attest"},{quality:85,daysAgo:12,type:"attest"},{quality:90,daysAgo:15,type:"attest"},{quality:72,daysAgo:17,type:"revoke"},{quality:72,daysAgo:18,type:"attest"},{quality:47,daysAgo:21,type:"attest"}]},{hash:"0x1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2",score:312n,count:4n,isQuarantined:!1,history:[{quality:88,daysAgo:1,type:"attest"},{quality:75,daysAgo:4,type:"attest"},{quality:82,daysAgo:6,type:"attest"},{quality:67,daysAgo:10,type:"attest"}]},{hash:"0xdeadbeefcafebabe0102030405060708090a0b0c0d0e0f101112131415161718",score:0n,count:2n,isQuarantined:!0,history:[{quality:61,daysAgo:3,type:"attest"},{quality:58,daysAgo:4,type:"attest"}]}];function n(){let t=new Uint8Array(32);return"undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues(t),"0x"+Array.from(t).map(t=>t.toString(16).padStart(2,"0")).join("")}function i(){let t=3e3+2e3*Math.random();return new Promise(e=>setTimeout(e,t))}function r(){return new Promise(t=>setTimeout(t,300+200*Math.random()))}async function o(t){let e=await t.arrayBuffer();return"0x"+Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256",e))).map(t=>t.toString(16).padStart(2,"0")).join("")}class l{get walletAddress(){return this.state.walletAddress}async getTrustScore(t){var e,a,s;await r();let n=t.toLowerCase(),i=this.state.trustScores.get(n);return{skillHash:t,trustScore:null!==(e=null==i?void 0:i.score)&&void 0!==e?e:0n,attestationCount:null!==(a=null==i?void 0:i.count)&&void 0!==a?a:0n,isQuarantined:null!==(s=null==i?void 0:i.isQuarantined)&&void 0!==s&&s}}async getAttestationHistory(t){var e;await r();let a=t.toLowerCase(),s=this.state.trustScores.get(a);return null!==(e=null==s?void 0:s.history)&&void 0!==e?e:[]}async attest(t,e){var a;let s=t.skillHash.toLowerCase();if(this.state.myAttestations.some(t=>t.skillHash.toLowerCase()===s&&!t.revoked))throw Error("You have already attested this skill (SingleUseClaim prevents double-attestation).");null==e||e("proving"),await i(),null==e||e("submitting"),await new Promise(t=>setTimeout(t,500));let r=n(),o=new Date,l=null!==(a=this.state.trustScores.get(s))&&void 0!==a?a:{score:0n,count:0n,isQuarantined:!1,history:[]};return this.state.trustScores.set(s,{score:l.score+BigInt(t.quality),count:l.count+1n,isQuarantined:l.isQuarantined,history:[{quality:t.quality,ts:o,type:"attest"},...l.history]}),this.state.myAttestations.unshift({skillHash:t.skillHash,quality:t.quality,timestamp:o,txHash:r,revoked:!1}),{txHash:r}}async revokeAttestation(t,e){let a=t.toLowerCase(),s=this.state.myAttestations.find(t=>t.skillHash.toLowerCase()===a&&!t.revoked);if(!s)throw Error("No active attestation found for this skill.");null==e||e("proving"),await i(),null==e||e("submitting"),await new Promise(t=>setTimeout(t,500));let r=n(),o=this.state.trustScores.get(a);return o&&this.state.trustScores.set(a,{score:o.score>=BigInt(s.quality)?o.score-BigInt(s.quality):0n,count:o.count>0n?o.count-1n:0n,isQuarantined:o.isQuarantined,history:[{quality:s.quality,ts:new Date,type:"revoke"},...o.history]}),s.revoked=!0,{txHash:r}}getMyAttestations(){return[...this.state.myAttestations]}async storeCredential(t,e){if(this.state.credentials.has(t.keyId))throw Error("Credential '".concat(t.keyId,"' already exists. Use rotateCredential() to replace."));return null==e||e("proving"),await i(),null==e||e("submitting"),await new Promise(t=>setTimeout(t,500)),this.state.credentials.set(t.keyId,{label:t.label,value:t.value}),{txHash:n()}}async getCredential(t){await r();let e=this.state.credentials.get(t);return e?{keyId:t,value:e.value,label:e.label}:null}async deleteCredential(t,e){if(!this.state.credentials.has(t))throw Error("No credential found with keyId '".concat(t,"'."));return null==e||e("proving"),await i(),null==e||e("submitting"),await new Promise(t=>setTimeout(t,500)),this.state.credentials.delete(t),{txHash:n()}}async rotateCredential(t,e){if(!this.state.credentials.has(t.keyId))throw Error("No credential found with keyId '".concat(t.keyId,"'."));return null==e||e("proving"),await i(),null==e||e("submitting"),await new Promise(t=>setTimeout(t,500)),this.state.credentials.set(t.keyId,{label:t.newLabel,value:t.newValue}),{txHash:n()}}listCredentials(){return Array.from(this.state.credentials.entries()).map(t=>{let[e,{label:a}]=t;return{keyId:e,label:a}})}async grantCredentialAccess(t){var e;return await r(),{authwitNonce:null!==(e=t.nonce)&&void 0!==e?e:BigInt(Date.now())}}constructor(t){this.state=function(t){let e=new Map;for(let t of s){let a=Date.now();e.set(t.hash.toLowerCase(),{score:t.score,count:t.count,isQuarantined:t.isQuarantined,history:t.history.map(t=>{let{quality:e,daysAgo:s,type:n}=t;return{quality:e,ts:new Date(a-864e5*s),type:n}})})}return{trustScores:e,myAttestations:[],credentials:new Map,walletAddress:t}}(t)}}}}]);