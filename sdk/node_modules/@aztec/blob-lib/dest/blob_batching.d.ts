import { BLS12Fr, BLS12Point } from '@aztec/foundation/curves/bls12';
import { Fr } from '@aztec/foundation/curves/bn254';
import { BatchedBlob } from './batched_blob.js';
import { Blob } from './blob.js';
import { BlobAccumulator, FinalBlobAccumulator, FinalBlobBatchingChallenges } from './circuit_types/index.js';
/**
 * A class to create, manage, and prove batched EVM blobs.
 * See noir-projects/noir-protocol-circuits/crates/blob/src/abis/blob_accumulator.nr
 */
export declare class BatchedBlobAccumulator {
    /** Hash of Cs (to link to L1 blob hashes). */
    readonly blobCommitmentsHashAcc: Fr;
    /** Challenge point z_acc. Final value used such that p_i(z) = y_i. */
    readonly zAcc: Fr;
    /** Evaluation y_acc. Final value is is linear combination of all evaluations y_i = p_i(z) with gamma. */
    readonly yAcc: BLS12Fr;
    /** Commitment c_acc. Final value is linear combination of all commitments C_i = [p_i] with gamma. */
    readonly cAcc: BLS12Point;
    /** KZG opening q_acc. Final value is linear combination of all blob kzg 'proofs' Q_i with gamma. */
    readonly qAcc: BLS12Point;
    /**
     * Challenge point gamma_acc for multi opening. Used with y, C, and kzg 'proof' Q above.
     * TODO(#13608): We calculate this by hashing natively in the circuit (hence Fr representation), but it's actually used
     * as a BLS12Fr field elt. Is this safe? Is there a skew?
     */
    readonly gammaAcc: Fr;
    /** Simply gamma^(i + 1) at blob i. Used for calculating the i'th element of the above linear comb.s */
    readonly gammaPow: BLS12Fr;
    /** Final challenge values used in evaluation. Optimistically input and checked in the final acc. */
    readonly finalBlobChallenges: FinalBlobBatchingChallenges;
    constructor(
    /** Hash of Cs (to link to L1 blob hashes). */
    blobCommitmentsHashAcc: Fr, 
    /** Challenge point z_acc. Final value used such that p_i(z) = y_i. */
    zAcc: Fr, 
    /** Evaluation y_acc. Final value is is linear combination of all evaluations y_i = p_i(z) with gamma. */
    yAcc: BLS12Fr, 
    /** Commitment c_acc. Final value is linear combination of all commitments C_i = [p_i] with gamma. */
    cAcc: BLS12Point, 
    /** KZG opening q_acc. Final value is linear combination of all blob kzg 'proofs' Q_i with gamma. */
    qAcc: BLS12Point, 
    /**
     * Challenge point gamma_acc for multi opening. Used with y, C, and kzg 'proof' Q above.
     * TODO(#13608): We calculate this by hashing natively in the circuit (hence Fr representation), but it's actually used
     * as a BLS12Fr field elt. Is this safe? Is there a skew?
     */
    gammaAcc: Fr, 
    /** Simply gamma^(i + 1) at blob i. Used for calculating the i'th element of the above linear comb.s */
    gammaPow: BLS12Fr, 
    /** Final challenge values used in evaluation. Optimistically input and checked in the final acc. */
    finalBlobChallenges: FinalBlobBatchingChallenges);
    /**
     * Create the empty accumulation state of the epoch.
     * @returns An empty blob accumulator with challenges.
     */
    static newWithChallenges(finalBlobChallenges: FinalBlobBatchingChallenges): BatchedBlobAccumulator;
    /**
     * Returns an empty BatchedBlobAccumulator with precomputed challenges from all blobs in the epoch.
     * @dev MUST input all blobs to be broadcast. Does not work in multiple calls because z and gamma are calculated
     *      beforehand from ALL blobs.
     */
    static fromBlobFields(blobFieldsPerCheckpoint: Fr[][]): Promise<BatchedBlobAccumulator>;
    /**
     * Get the final batched opening proof from multiple blobs.
     * @dev MUST input all blobs to be broadcast. Does not work in multiple calls because z and gamma are calculated
     *      beforehand from ALL blobs.
     *
     * @returns A batched blob.
     */
    static batch(blobFieldsPerCheckpoint: Fr[][], verifyProof?: boolean): Promise<BatchedBlob>;
    /**
     * Gets the final challenges based on all blobs and their elements to perform a multi opening proof.
     * Used in BatchedBlobAccumulator as 'finalZ' and finalGamma':
     *  - z = H(...H(H(z_0, z_1) z_2)..z_n)
     *    - where z_i = H(H(fields of blob_i), C_i) = Blob.challengeZ,
     *    - used such that p_i(z) = y_i = Blob.evaluationY for all n blob polynomials p_i().
     *  - gamma = H(H(...H(H(y_0, y_1) y_2)..y_n), z)
     *    - used such that y = sum_i { gamma^i * y_i }, and C = sum_i { gamma^i * C_i }, for all blob evaluations y_i (see above) and commitments C_i.
     *
     * @param blobs - The blobs to precompute the challenges for. Each sub-array is the blobs for an L1 block.
     * @returns Challenges z and gamma.
     */
    static precomputeBatchedBlobChallenges(blobFieldsPerCheckpoint: Fr[][]): Promise<FinalBlobBatchingChallenges>;
    /**
     * Given blob i, accumulate all state.
     * We assume the input blob has not been evaluated at z.
     * @returns An updated blob accumulator.
     */
    accumulateBlob(blob: Blob, blobFieldsHash: Fr): Promise<BatchedBlobAccumulator>;
    /**
     * Given blobs, accumulate all state.
     * We assume the input blobs have not been evaluated at z.
     * @param blobFields - The blob fields of a checkpoint to accumulate.
     * @returns An updated blob accumulator.
     */
    accumulateFields(blobFields: Fr[]): Promise<BatchedBlobAccumulator>;
    /**
     * Finalize accumulation state of the epoch.
     * We assume ALL blobs in the epoch have been accumulated.
     *
     * Final accumulated values:
     * - v := v_acc (hash of all commitments (C_i s) to be checked on L1)
     * - z := z_acc (final challenge, at which all blobs are evaluated)
     * - y := y_acc (final opening to be checked on L1)
     * - c := c_acc (final commitment to be checked on L1)
     * - gamma := poseidon2(gamma_acc, z) (challenge for linear combination of y and C, above)
     *
     * @param verifyProof - Whether to verify the KZG proof.
     * @returns A batched blob.
     */
    finalize(verifyProof?: boolean): Promise<BatchedBlob>;
    verify(): boolean;
    isEmptyState(): boolean;
    clone(): BatchedBlobAccumulator;
    toBlobAccumulator(): BlobAccumulator;
    toFinalBlobAccumulator(): FinalBlobAccumulator;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxvYl9iYXRjaGluZy5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Jsb2JfYmF0Y2hpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNyRSxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFFcEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFFakMsT0FBTyxFQUFFLGVBQWUsRUFBRSxvQkFBb0IsRUFBRSwyQkFBMkIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBSTlHOzs7R0FHRztBQUNILHFCQUFhLHNCQUFzQjtJQUUvQiw4Q0FBOEM7YUFDOUIsc0JBQXNCLEVBQUUsRUFBRTtJQUMxQyxzRUFBc0U7YUFDdEQsSUFBSSxFQUFFLEVBQUU7SUFDeEIseUdBQXlHO2FBQ3pGLElBQUksRUFBRSxPQUFPO0lBQzdCLHFHQUFxRzthQUNyRixJQUFJLEVBQUUsVUFBVTtJQUNoQyxvR0FBb0c7YUFDcEYsSUFBSSxFQUFFLFVBQVU7SUFDaEM7Ozs7T0FJRzthQUNhLFFBQVEsRUFBRSxFQUFFO0lBQzVCLHVHQUF1RzthQUN2RixRQUFRLEVBQUUsT0FBTztJQUNqQyxvR0FBb0c7YUFDcEYsbUJBQW1CLEVBQUUsMkJBQTJCO0lBcEJsRTtJQUNFLDhDQUE4QztJQUM5QixzQkFBc0IsRUFBRSxFQUFFO0lBQzFDLHNFQUFzRTtJQUN0RCxJQUFJLEVBQUUsRUFBRTtJQUN4Qix5R0FBeUc7SUFDekYsSUFBSSxFQUFFLE9BQU87SUFDN0IscUdBQXFHO0lBQ3JGLElBQUksRUFBRSxVQUFVO0lBQ2hDLG9HQUFvRztJQUNwRixJQUFJLEVBQUUsVUFBVTtJQUNoQzs7OztPQUlHO0lBQ2EsUUFBUSxFQUFFLEVBQUU7SUFDNUIsdUdBQXVHO0lBQ3ZGLFFBQVEsRUFBRSxPQUFPO0lBQ2pDLG9HQUFvRztJQUNwRixtQkFBbUIsRUFBRSwyQkFBMkIsRUFDOUQ7SUFFSjs7O09BR0c7SUFDSCxNQUFNLENBQUMsaUJBQWlCLENBQUMsbUJBQW1CLEVBQUUsMkJBQTJCLEdBQUcsc0JBQXNCLENBV2pHO0lBRUQ7Ozs7T0FJRztJQUNILE9BQWEsY0FBYyxDQUFDLHVCQUF1QixFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLENBRzVGO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsT0FBYSxLQUFLLENBQUMsdUJBQXVCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxXQUFXLFVBQVEsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBZTdGO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxPQUFhLCtCQUErQixDQUFDLHVCQUF1QixFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLDJCQUEyQixDQUFDLENBbUNsSDtJQUVEOzs7O09BSUc7SUFDRyxjQUFjLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxjQUFjLEVBQUUsRUFBRSxtQ0F1Q2xEO0lBRUQ7Ozs7O09BS0c7SUFDRyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsRUFBRSxFQUFFLG1DQWtCdEM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0csUUFBUSxDQUFDLFdBQVcsVUFBUSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FzQnhEO0lBRUQsTUFBTSxZQU9MO0lBRUQsWUFBWSxZQVVYO0lBRUQsS0FBSywyQkFXSjtJQUVELGlCQUFpQixvQkFTaEI7SUFFRCxzQkFBc0IseUJBRXJCO0NBQ0YifQ==