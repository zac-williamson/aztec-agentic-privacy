import { MAX_CONTRACT_CLASS_LOGS_PER_TX, MAX_ENQUEUED_CALLS_PER_TX, MAX_L2_TO_L1_MSGS_PER_TX, MAX_NOTE_HASHES_PER_TX, MAX_NULLIFIERS_PER_TX, MAX_PRIVATE_LOGS_PER_TX, MAX_PROTOCOL_CONTRACTS, PRIVATE_LOG_SIZE_IN_FIELDS } from '@aztec/constants';
import { BlockNumber, SlotNumber } from '@aztec/foundation/branded-types';
import { Fr } from '@aztec/foundation/curves/bn254';
import { GrumpkinScalar, Point } from '@aztec/foundation/curves/grumpkin';
import { EthAddress } from '@aztec/foundation/eth-address';
import { assertLength, mapTuple } from '@aztec/foundation/serialize';
import { FunctionSelector } from '@aztec/stdlib/abi';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { Gas, GasFees, GasSettings } from '@aztec/stdlib/gas';
import { ClaimedLengthArray, CountedLogHash, LogHash, PrivateToPublicAccumulatedData, PrivateToRollupAccumulatedData, PublicCallRequest, ScopedCountedLogHash, ScopedLogHash } from '@aztec/stdlib/kernel';
import { PrivateLog } from '@aztec/stdlib/logs';
import { CountedL2ToL1Message, L2ToL1Message, ScopedCountedL2ToL1Message, ScopedL2ToL1Message } from '@aztec/stdlib/messaging';
import { AppendOnlyTreeSnapshot } from '@aztec/stdlib/trees';
import { BlockHeader, GlobalVariables, PartialStateReference, PrivateTxConstantData, ProtocolContracts, StateReference, TxConstantData, TxContext } from '@aztec/stdlib/tx';
/* eslint-disable camelcase */ /**
 * Maps a field to a noir field.
 * @param field - The field.
 * @returns The noir field.
 */ export function mapFieldToNoir(field) {
    return field.toString();
}
/**
 * Maps a noir field to a fr.
 * @param field - The noir field.
 * @returns The fr.
 */ export function mapFieldFromNoir(field) {
    return Fr.fromHexString(field);
}
/**
 * Maps a bigint to a noir field.
 * @param bigInt - The bigint.
 * @returns The noir field.
 */ export function mapBigIntToNoir(bigInt) {
    return new Fr(bigInt).toString();
}
/**
 * Maps a noir field to a bigint.
 * @param field - The noir field.
 * @returns The bigint.
 */ export function mapBigIntFromNoir(field) {
    return Fr.fromHexString(field).toBigInt();
}
/** Maps a field to a noir wrapped field type (ie any type implemented as struct with an inner Field). */ export function mapWrappedFieldToNoir(field) {
    return {
        inner: mapFieldToNoir(field)
    };
}
/** Maps a noir wrapped field type (ie any type implemented as struct with an inner Field) to a typescript field. */ export function mapWrappedFieldFromNoir(wrappedField) {
    return mapFieldFromNoir(wrappedField.inner);
}
export function mapU64ToNoir(u64) {
    return mapBigIntToNoir(u64);
}
export function mapU64FromNoir(u64) {
    return mapBigIntFromNoir(u64);
}
/**
 * Maps a number coming from noir.
 * @param number - The field representing the number.
 * @returns The number
 */ export function mapNumberFromNoir(number) {
    return Number(Fr.fromHexString(number).toBigInt());
}
export function mapNumberToNoir(number) {
    return new Fr(BigInt(number)).toString();
}
/**
 * Maps a point to a noir point.
 * @param point - The point.
 * @returns The noir point.
 */ export function mapPointToNoir(point) {
    return {
        x: mapFieldToNoir(point.x),
        y: mapFieldToNoir(point.y),
        is_infinite: point.isInfinite
    };
}
/**
 * Maps a noir point to a point.
 * @param point - The noir point.
 * @returns The point.
 */ export function mapPointFromNoir(point) {
    return new Point(mapFieldFromNoir(point.x), mapFieldFromNoir(point.y), point.is_infinite);
}
/**
 * Maps a GrumpkinScalar to a noir GrumpkinScalar.
 * @param privateKey - The GrumpkinScalar.
 * @returns The noir GrumpkinScalar.
 */ export function mapGrumpkinScalarToNoir(privateKey) {
    return {
        hi: mapFieldToNoir(privateKey.hi),
        lo: mapFieldToNoir(privateKey.lo)
    };
}
/**
 * Maps a noir GrumpkinScalar to a GrumpkinScalar.
 * @param privateKey - The noir GrumpkinScalar.
 * @returns The GrumpkinScalar.
 */ export function mapGrumpkinScalarFromNoir(privateKey) {
    return GrumpkinScalar.fromHighLow(mapFieldFromNoir(privateKey.hi), mapFieldFromNoir(privateKey.lo));
}
/**
 * Maps an aztec address to a noir aztec address.
 * @param address - The address.
 * @returns The noir aztec address.
 */ export function mapAztecAddressToNoir(address) {
    return {
        inner: mapFieldToNoir(address.toField())
    };
}
/**
 * Maps a noir aztec address to an aztec address.
 * @param address - The noir aztec address.
 * @returns The aztec address.
 */ export function mapAztecAddressFromNoir(address) {
    return AztecAddress.fromField(mapFieldFromNoir(address.inner));
}
/**
 * Maps an eth address to a noir eth address.
 * @param address - The address.
 * @returns The noir eth address.
 */ export function mapEthAddressToNoir(address) {
    return {
        inner: mapFieldToNoir(address.toField())
    };
}
/**
 * Maps a noir eth address to an eth address.
 * @param address - The noir eth address.
 * @returns The eth address.
 */ export function mapEthAddressFromNoir(address) {
    return EthAddress.fromField(mapFieldFromNoir(address.inner));
}
export function mapGasFromNoir(gasUsed) {
    return Gas.from({
        daGas: mapNumberFromNoir(gasUsed.da_gas),
        l2Gas: mapNumberFromNoir(gasUsed.l2_gas)
    });
}
export function mapGasToNoir(gasUsed) {
    return {
        da_gas: mapNumberToNoir(gasUsed.daGas),
        l2_gas: mapNumberToNoir(gasUsed.l2Gas)
    };
}
export function mapGasSettingsFromNoir(gasSettings) {
    return new GasSettings(mapGasFromNoir(gasSettings.gas_limits), mapGasFromNoir(gasSettings.teardown_gas_limits), mapGasFeesFromNoir(gasSettings.max_fees_per_gas), mapGasFeesFromNoir(gasSettings.max_priority_fees_per_gas));
}
export function mapGasSettingsToNoir(gasSettings) {
    return {
        gas_limits: mapGasToNoir(gasSettings.gasLimits),
        teardown_gas_limits: mapGasToNoir(gasSettings.teardownGasLimits),
        max_fees_per_gas: mapGasFeesToNoir(gasSettings.maxFeesPerGas),
        max_priority_fees_per_gas: mapGasFeesToNoir(gasSettings.maxPriorityFeesPerGas)
    };
}
export function mapGasFeesToNoir(gasFees) {
    return {
        fee_per_da_gas: mapBigIntToNoir(gasFees.feePerDaGas),
        fee_per_l2_gas: mapBigIntToNoir(gasFees.feePerL2Gas)
    };
}
export function mapGasFeesFromNoir(gasFees) {
    return new GasFees(mapBigIntFromNoir(gasFees.fee_per_da_gas), mapBigIntFromNoir(gasFees.fee_per_l2_gas));
}
export function mapPrivateLogToNoir(log) {
    return {
        fields: mapTuple(log.fields, mapFieldToNoir),
        length: mapNumberToNoir(log.emittedLength)
    };
}
export function mapPrivateLogFromNoir(log) {
    return new PrivateLog(mapTupleFromNoir(log.fields, PRIVATE_LOG_SIZE_IN_FIELDS, mapFieldFromNoir), mapNumberFromNoir(log.length));
}
/**
 * Maps an array from noir types to a tuple of parsed types.
 * @param noirArray - The noir array.
 * @param length - The length of the tuple.
 * @param mapper - The mapper function applied to each element.
 * @returns The tuple.
 */ export function mapTupleFromNoir(noirArray, length, mapper) {
    if (noirArray.length != length) {
        throw new Error(`Expected ${length} items, got ${noirArray.length}`);
    }
    return Array.from({
        length
    }, (_, idx)=>mapper(noirArray[idx]));
}
export function mapTupleToNoir(tuple, mapper) {
    return mapTuple(tuple, mapper);
}
export function mapFieldArrayToNoir(array, length = array.length) {
    return mapTupleToNoir(assertLength(array, length), mapFieldToNoir);
}
export function mapClaimedLengthArrayFromNoir(claimedLengthArray, mapper) {
    const array = mapTupleFromNoir(claimedLengthArray.array, claimedLengthArray.array.length, mapper);
    const claimedLength = mapNumberFromNoir(claimedLengthArray.length);
    return new ClaimedLengthArray(array, claimedLength);
}
export function mapClaimedLengthArrayToNoir(claimedLengthArray, mapper) {
    return {
        array: mapTupleToNoir(claimedLengthArray.array, mapper),
        length: mapNumberToNoir(claimedLengthArray.claimedLength)
    };
}
/**
 * Maps a AOT snapshot to noir.
 * @param snapshot - The stdlib AOT snapshot.
 * @returns The noir AOT snapshot.
 */ export function mapAppendOnlyTreeSnapshotFromNoir(snapshot) {
    return new AppendOnlyTreeSnapshot(mapFieldFromNoir(snapshot.root), mapNumberFromNoir(snapshot.next_available_leaf_index));
}
/**
 * Maps a AOT snapshot from noir to the stdlib type.
 * @param snapshot - The noir AOT snapshot.
 * @returns The stdlib AOT snapshot.
 */ export function mapAppendOnlyTreeSnapshotToNoir(snapshot) {
    return {
        root: mapFieldToNoir(snapshot.root),
        next_available_leaf_index: mapFieldToNoir(new Fr(snapshot.nextAvailableLeafIndex))
    };
}
/**
 * Maps a block header to Noir
 * @param header - The block header.
 * @returns BlockHeader.
 */ export function mapBlockHeaderToNoir(header) {
    return {
        last_archive: mapAppendOnlyTreeSnapshotToNoir(header.lastArchive),
        state: mapStateReferenceToNoir(header.state),
        sponge_blob_hash: mapFieldToNoir(header.spongeBlobHash),
        global_variables: mapGlobalVariablesToNoir(header.globalVariables),
        total_fees: mapFieldToNoir(header.totalFees),
        total_mana_used: mapFieldToNoir(header.totalManaUsed)
    };
}
/**
 * Maps a block header from Noir.
 * @param header - The block header.
 * @returns BlockHeader.
 */ export function mapBlockHeaderFromNoir(header) {
    return new BlockHeader(mapAppendOnlyTreeSnapshotFromNoir(header.last_archive), mapStateReferenceFromNoir(header.state), mapFieldFromNoir(header.sponge_blob_hash), mapGlobalVariablesFromNoir(header.global_variables), mapFieldFromNoir(header.total_fees), mapFieldFromNoir(header.total_mana_used));
}
/**
 * Maps a L2 to L1 message to a noir L2 to L1 message.
 * @param message - The L2 to L1 message.
 * @returns The noir L2 to L1 message.
 */ function mapL2ToL1MessageToNoir(message) {
    return {
        recipient: mapEthAddressToNoir(message.recipient),
        content: mapFieldToNoir(message.content)
    };
}
function mapL2ToL1MessageFromNoir(message) {
    return new L2ToL1Message(mapEthAddressFromNoir(message.recipient), mapFieldFromNoir(message.content));
}
export function mapCountedL2ToL1MessageToNoir(message) {
    return {
        inner: mapL2ToL1MessageToNoir(message.message),
        counter: mapNumberToNoir(message.counter)
    };
}
function mapCountedL2ToL1MessageFromNoir(message) {
    return new CountedL2ToL1Message(mapL2ToL1MessageFromNoir(message.inner), mapNumberFromNoir(message.counter));
}
export function mapScopedL2ToL1MessageToNoir(message) {
    return {
        inner: mapL2ToL1MessageToNoir(message.message),
        contract_address: mapAztecAddressToNoir(message.contractAddress)
    };
}
export function mapScopedL2ToL1MessageFromNoir(message) {
    return new ScopedL2ToL1Message(mapL2ToL1MessageFromNoir(message.inner), mapAztecAddressFromNoir(message.contract_address));
}
export function mapScopedCountedL2ToL1MessageToNoir(message) {
    return {
        inner: mapCountedL2ToL1MessageToNoir(message.inner),
        contract_address: mapAztecAddressToNoir(message.contractAddress)
    };
}
export function mapScopedCountedL2ToL1MessageFromNoir(message) {
    return new ScopedCountedL2ToL1Message(mapCountedL2ToL1MessageFromNoir(message.inner), mapAztecAddressFromNoir(message.contract_address));
}
/**
 * Maps a function selector to a noir function selector.
 * @param functionSelector - The function selector.
 * @returns The noir function selector.
 */ export function mapFunctionSelectorToNoir(functionSelector) {
    return {
        inner: mapFieldToNoir(functionSelector.toField())
    };
}
/**
 * Maps a noir function selector to a function selector.
 * @param functionSelector - The noir function selector.
 * @returns The function selector.
 */ export function mapFunctionSelectorFromNoir(functionSelector) {
    return FunctionSelector.fromField(mapFieldFromNoir(functionSelector.inner));
}
export function mapPublicCallRequestFromNoir(request) {
    return new PublicCallRequest(mapAztecAddressFromNoir(request.msg_sender), mapAztecAddressFromNoir(request.contract_address), request.is_static_call, mapFieldFromNoir(request.calldata_hash));
}
export function mapPublicCallRequestToNoir(request) {
    return {
        msg_sender: mapAztecAddressToNoir(request.msgSender),
        contract_address: mapAztecAddressToNoir(request.contractAddress),
        is_static_call: request.isStaticCall,
        calldata_hash: mapFieldToNoir(request.calldataHash)
    };
}
export function mapPublicCallRequestArrayLengthsToNoir(lengths) {
    return {
        setup_calls: mapNumberToNoir(lengths.setupCalls),
        app_logic_calls: mapNumberToNoir(lengths.appLogicCalls),
        teardown_call: lengths.teardownCall
    };
}
export function mapVerificationKeyToNoir(key, length) {
    if (key.key.length !== length) {
        throw new Error(`Expected ${length} fields, got ${key.key.length}`);
    }
    return {
        key: key.key.map(mapFieldToNoir),
        hash: mapFieldToNoir(key.hash)
    };
}
export function mapVkDataToNoir(vkData, length) {
    return {
        vk: mapVerificationKeyToNoir(vkData.vk.keyAsFields, length),
        leaf_index: mapFieldToNoir(new Fr(vkData.leafIndex)),
        sibling_path: mapTuple(vkData.siblingPath, mapFieldToNoir)
    };
}
/**
 * Maps global variables to the noir type.
 * @param globalVariables - The global variables.
 * @returns The noir global variables.
 */ export function mapGlobalVariablesToNoir(globalVariables) {
    return {
        chain_id: mapFieldToNoir(globalVariables.chainId),
        version: mapFieldToNoir(globalVariables.version),
        block_number: mapNumberToNoir(globalVariables.blockNumber),
        slot_number: mapFieldToNoir(new Fr(globalVariables.slotNumber)),
        timestamp: mapBigIntToNoir(globalVariables.timestamp),
        coinbase: mapEthAddressToNoir(globalVariables.coinbase),
        fee_recipient: mapAztecAddressToNoir(globalVariables.feeRecipient),
        gas_fees: mapGasFeesToNoir(globalVariables.gasFees)
    };
}
/**
 * Maps global variables from the noir type.
 * @param globalVariables - The noir global variables.
 * @returns The global variables.
 */ export function mapGlobalVariablesFromNoir(globalVariables) {
    return new GlobalVariables(mapFieldFromNoir(globalVariables.chain_id), mapFieldFromNoir(globalVariables.version), BlockNumber(mapNumberFromNoir(globalVariables.block_number)), SlotNumber(mapFieldFromNoir(globalVariables.slot_number).toNumber()), mapBigIntFromNoir(globalVariables.timestamp), mapEthAddressFromNoir(globalVariables.coinbase), mapAztecAddressFromNoir(globalVariables.fee_recipient), mapGasFeesFromNoir(globalVariables.gas_fees));
}
/**
 * Maps state reference to Noir.
 * @param stateReference - The state reference.
 * @returns Noir representation of state reference.
 */ export function mapStateReferenceToNoir(stateReference) {
    return {
        l1_to_l2_message_tree: mapAppendOnlyTreeSnapshotToNoir(stateReference.l1ToL2MessageTree),
        partial: mapPartialStateReferenceToNoir(stateReference.partial)
    };
}
/**
 * Maps state reference from Noir.
 * @param stateReference - The state reference.
 * @returns State reference
 */ export function mapStateReferenceFromNoir(stateReference) {
    return new StateReference(mapAppendOnlyTreeSnapshotFromNoir(stateReference.l1_to_l2_message_tree), mapPartialStateReferenceFromNoir(stateReference.partial));
}
/**
 * Maps a partial state reference to a noir partial state reference.
 * @param partialStateReference - The partial state reference.
 * @returns The noir partial state reference.
 */ export function mapPartialStateReferenceToNoir(partialStateReference) {
    return {
        note_hash_tree: mapAppendOnlyTreeSnapshotToNoir(partialStateReference.noteHashTree),
        nullifier_tree: mapAppendOnlyTreeSnapshotToNoir(partialStateReference.nullifierTree),
        public_data_tree: mapAppendOnlyTreeSnapshotToNoir(partialStateReference.publicDataTree)
    };
}
/**
 * Maps partial state reference from Noir.
 * @param partialStateReference - The state reference.
 * @returns Partial state reference
 */ export function mapPartialStateReferenceFromNoir(partialStateReference) {
    return new PartialStateReference(mapAppendOnlyTreeSnapshotFromNoir(partialStateReference.note_hash_tree), mapAppendOnlyTreeSnapshotFromNoir(partialStateReference.nullifier_tree), mapAppendOnlyTreeSnapshotFromNoir(partialStateReference.public_data_tree));
}
/**
 * Maps a nullifier leaf preimage to noir
 * @param nullifierLeafPreimage - The nullifier leaf preimage.
 * @returns The noir nullifier leaf preimage.
 */ export function mapNullifierLeafPreimageToNoir(nullifierLeafPreimage) {
    return {
        nullifier: mapFieldToNoir(nullifierLeafPreimage.leaf.nullifier),
        next_nullifier: mapFieldToNoir(nullifierLeafPreimage.nextKey),
        next_index: mapNumberToNoir(Number(nullifierLeafPreimage.nextIndex))
    };
}
/**
 * Maps a leaf preimage of the public data tree to noir.
 */ export function mapPublicDataTreePreimageToNoir(preimage) {
    return {
        slot: mapFieldToNoir(preimage.leaf.slot),
        value: mapFieldToNoir(preimage.leaf.value),
        next_slot: mapFieldToNoir(preimage.nextKey),
        next_index: mapNumberToNoir(Number(preimage.nextIndex))
    };
}
export function mapMembershipWitnessToNoir(witness) {
    const siblingPath = mapTuple(witness.siblingPath, mapFieldToNoir);
    return {
        leaf_index: witness.leafIndex.toString(),
        sibling_path: siblingPath
    };
}
/**
 * Maps a LogHash to a noir LogHash.
 * @param logHash - The LogHash.
 * @returns The noir log hash.
 */ function mapLogHashToNoir(logHash) {
    return {
        value: mapFieldToNoir(logHash.value),
        length: mapNumberToNoir(logHash.length)
    };
}
/**
 * Maps a noir LogHash to a LogHash.
 * @param logHash - The noir LogHash.
 * @returns The TS log hash.
 */ function mapLogHashFromNoir(logHash) {
    return new LogHash(mapFieldFromNoir(logHash.value), mapNumberFromNoir(logHash.length));
}
export function mapCountedLogHashToNoir(logHash) {
    return {
        inner: mapLogHashToNoir(logHash.logHash),
        counter: mapNumberToNoir(logHash.counter)
    };
}
export function mapCountedLogHashFromNoir(countedLogHash) {
    return new CountedLogHash(mapLogHashFromNoir(countedLogHash.inner), mapNumberFromNoir(countedLogHash.counter));
}
/**
 * Maps a ts ScopedLogHash to a noir ScopedLogHash.
 * @param logHash - The ts LogHash.
 * @returns The noir log hash.
 */ export function mapScopedLogHashToNoir(scopedLogHash) {
    return {
        inner: mapLogHashToNoir(scopedLogHash.logHash),
        contract_address: mapAztecAddressToNoir(scopedLogHash.contractAddress)
    };
}
export function mapScopedCountedLogHashToNoir(logHash) {
    return {
        inner: mapCountedLogHashToNoir(logHash.inner),
        contract_address: mapAztecAddressToNoir(logHash.contractAddress)
    };
}
export function mapScopedCountedLogHashFromNoir(scopedCountedLogHash) {
    return new ScopedCountedLogHash(mapCountedLogHashFromNoir(scopedCountedLogHash.inner), mapAztecAddressFromNoir(scopedCountedLogHash.contract_address));
}
/**
 * Maps a noir ScopedLogHash to a ts ScopedLogHash.
 * @param logHash - The noir LogHash.
 * @returns The TS log hash.
 */ export function mapScopedLogHashFromNoir(scopedLogHash) {
    return new ScopedLogHash(mapLogHashFromNoir(scopedLogHash.inner), mapAztecAddressFromNoir(scopedLogHash.contract_address));
}
export function mapPublicDataWriteToNoir(write) {
    return {
        leaf_slot: mapFieldToNoir(write.leafSlot),
        value: mapFieldToNoir(write.value)
    };
}
/**
 * Maps private to rollup accumulated data to noir to the parsed type.
 * @param privateToRollupAccumulatedData - The ts private to rollup accumulated data.
 * @returns The noir private to rollup accumulated data.
 */ export function mapPrivateToRollupAccumulatedDataToNoir(privateToRollupAccumulatedData) {
    return {
        note_hashes: mapTuple(privateToRollupAccumulatedData.noteHashes, mapFieldToNoir),
        nullifiers: mapTuple(privateToRollupAccumulatedData.nullifiers, mapFieldToNoir),
        l2_to_l1_msgs: mapTuple(privateToRollupAccumulatedData.l2ToL1Msgs, mapScopedL2ToL1MessageToNoir),
        private_logs: mapTuple(privateToRollupAccumulatedData.privateLogs, mapPrivateLogToNoir),
        contract_class_logs_hashes: mapTuple(privateToRollupAccumulatedData.contractClassLogsHashes, mapScopedLogHashToNoir)
    };
}
/**
 * Maps private to rollup accumulated data from noir to the parsed type.
 * @param PrivateToRollupAccumulatedData - The noir private to rollup accumulated data.
 * @returns The parsed private to rollup accumulated data.
 */ export function mapPrivateToRollupAccumulatedDataFromNoir(privateToRollupAccumulatedData) {
    return new PrivateToRollupAccumulatedData(mapTupleFromNoir(privateToRollupAccumulatedData.note_hashes, MAX_NOTE_HASHES_PER_TX, mapFieldFromNoir), mapTupleFromNoir(privateToRollupAccumulatedData.nullifiers, MAX_NULLIFIERS_PER_TX, mapFieldFromNoir), mapTupleFromNoir(privateToRollupAccumulatedData.l2_to_l1_msgs, MAX_L2_TO_L1_MSGS_PER_TX, mapScopedL2ToL1MessageFromNoir), mapTupleFromNoir(privateToRollupAccumulatedData.private_logs, MAX_PRIVATE_LOGS_PER_TX, mapPrivateLogFromNoir), mapTupleFromNoir(privateToRollupAccumulatedData.contract_class_logs_hashes, MAX_CONTRACT_CLASS_LOGS_PER_TX, mapScopedLogHashFromNoir));
}
export function mapPrivateToPublicAccumulatedDataFromNoir(data) {
    return new PrivateToPublicAccumulatedData(mapTupleFromNoir(data.note_hashes, MAX_NOTE_HASHES_PER_TX, mapFieldFromNoir), mapTupleFromNoir(data.nullifiers, MAX_NULLIFIERS_PER_TX, mapFieldFromNoir), mapTupleFromNoir(data.l2_to_l1_msgs, MAX_L2_TO_L1_MSGS_PER_TX, mapScopedL2ToL1MessageFromNoir), mapTupleFromNoir(data.private_logs, MAX_PRIVATE_LOGS_PER_TX, mapPrivateLogFromNoir), mapTupleFromNoir(data.contract_class_logs_hashes, MAX_CONTRACT_CLASS_LOGS_PER_TX, mapScopedLogHashFromNoir), mapTupleFromNoir(data.public_call_requests, MAX_ENQUEUED_CALLS_PER_TX, mapPublicCallRequestFromNoir));
}
function mapPrivateToPublicAccumulatedDataToNoir(data) {
    return {
        note_hashes: mapTuple(data.noteHashes, mapFieldToNoir),
        nullifiers: mapTuple(data.nullifiers, mapFieldToNoir),
        l2_to_l1_msgs: mapTuple(data.l2ToL1Msgs, mapScopedL2ToL1MessageToNoir),
        private_logs: mapTuple(data.privateLogs, mapPrivateLogToNoir),
        contract_class_logs_hashes: mapTuple(data.contractClassLogsHashes, mapScopedLogHashToNoir),
        public_call_requests: mapTuple(data.publicCallRequests, mapPublicCallRequestToNoir)
    };
}
/**
 * Maps a tx context to a noir tx context.
 * @param txContext - The tx context.
 * @returns The noir tx context.
 */ export function mapTxContextToNoir(txContext) {
    return {
        chain_id: mapFieldToNoir(txContext.chainId),
        version: mapFieldToNoir(txContext.version),
        gas_settings: mapGasSettingsToNoir(txContext.gasSettings)
    };
}
/**
 * Maps a noir tx context to a tx context.
 * @param txContext - The noir tx context.
 * @returns The tx context.
 */ export function mapTxContextFromNoir(txContext) {
    return new TxContext(mapFieldFromNoir(txContext.chain_id), mapFieldFromNoir(txContext.version), mapGasSettingsFromNoir(txContext.gas_settings));
}
export function mapProtocolContractsToNoir(protocolContracts) {
    return {
        derived_addresses: mapTuple(protocolContracts.derivedAddresses, mapAztecAddressToNoir)
    };
}
export function mapProtocolContractsFromNoir(protocolContracts) {
    return new ProtocolContracts(mapTupleFromNoir(protocolContracts.derived_addresses, MAX_PROTOCOL_CONTRACTS, mapAztecAddressFromNoir));
}
export function mapPrivateTxConstantDataToNoir(data) {
    return {
        anchor_block_header: mapBlockHeaderToNoir(data.anchorBlockHeader),
        tx_context: mapTxContextToNoir(data.txContext),
        vk_tree_root: mapFieldToNoir(data.vkTreeRoot),
        protocol_contracts: mapProtocolContractsToNoir(data.protocolContracts)
    };
}
export function mapPrivateTxConstantDataFromNoir(data) {
    return new PrivateTxConstantData(mapBlockHeaderFromNoir(data.anchor_block_header), mapTxContextFromNoir(data.tx_context), mapFieldFromNoir(data.vk_tree_root), mapProtocolContractsFromNoir(data.protocol_contracts));
}
export function mapTxConstantDataFromNoir(data) {
    return new TxConstantData(mapBlockHeaderFromNoir(data.anchor_block_header), mapTxContextFromNoir(data.tx_context), mapFieldFromNoir(data.vk_tree_root), mapFieldFromNoir(data.protocol_contracts_hash));
}
export function mapTxConstantDataToNoir(data) {
    return {
        anchor_block_header: mapBlockHeaderToNoir(data.anchorBlockHeader),
        tx_context: mapTxContextToNoir(data.txContext),
        vk_tree_root: mapFieldToNoir(data.vkTreeRoot),
        protocol_contracts_hash: mapFieldToNoir(data.protocolContractsHash)
    };
}
export function mapPrivateToRollupKernelCircuitPublicInputsToNoir(inputs) {
    return {
        constants: mapTxConstantDataToNoir(inputs.constants),
        end: mapPrivateToRollupAccumulatedDataToNoir(inputs.end),
        gas_used: mapGasToNoir(inputs.gasUsed),
        fee_payer: mapAztecAddressToNoir(inputs.feePayer),
        expiration_timestamp: mapU64ToNoir(inputs.expirationTimestamp)
    };
}
export function mapPrivateToPublicKernelCircuitPublicInputsToNoir(inputs) {
    return {
        constants: mapTxConstantDataToNoir(inputs.constants),
        non_revertible_accumulated_data: mapPrivateToPublicAccumulatedDataToNoir(inputs.nonRevertibleAccumulatedData),
        revertible_accumulated_data: mapPrivateToPublicAccumulatedDataToNoir(inputs.revertibleAccumulatedData),
        public_teardown_call_request: mapPublicCallRequestToNoir(inputs.publicTeardownCallRequest),
        gas_used: mapGasToNoir(inputs.gasUsed),
        fee_payer: mapAztecAddressToNoir(inputs.feePayer),
        expiration_timestamp: mapU64ToNoir(inputs.expirationTimestamp)
    };
}
