import { createConsoleLogger } from '@aztec/foundation/log';
import { codegen } from '@aztec/noir-noir_codegen';
import { pascalCase } from 'change-case';
import { promises as fs } from 'fs';
const log = createConsoleLogger('autogenerate');
const circuits = [
    'parity_base',
    'parity_root',
    'private_kernel_init',
    'private_kernel_inner',
    'private_kernel_reset',
    'private_kernel_tail',
    'private_kernel_tail_to_public',
    'hiding_kernel_to_rollup',
    'hiding_kernel_to_public',
    'chonk_verifier_public',
    'rollup_tx_base_private',
    'rollup_tx_base_public',
    'rollup_tx_merge',
    'rollup_block_root',
    'rollup_block_root_single_tx',
    'rollup_block_root_first',
    'rollup_block_root_first_single_tx',
    'rollup_block_root_first_empty_tx',
    'rollup_block_merge',
    'rollup_checkpoint_root',
    'rollup_checkpoint_root_single_block',
    'rollup_checkpoint_merge',
    'rollup_root',
    'ts_types'
];
const main = async ()=>{
    const dimensionsLists = JSON.parse(await fs.readFile('../../noir-projects/noir-protocol-circuits/private_kernel_reset_dimensions.json', 'utf8'));
    // Need any variant in the set so that the type will be rendered with generics.
    circuits.push(`private_kernel_reset_${dimensionsLists[0].join('_')}`);
    try {
        await fs.access('./src/types/');
    } catch  {
        await fs.mkdir('./src/types', {
            recursive: true
        });
    }
    const programs = [];
    // Collect all circuits
    for (const circuit of circuits){
        const rawData = await fs.readFile(`./artifacts/${circuit}.json`, 'utf-8');
        const abiObj = JSON.parse(rawData);
        programs.push([
            pascalCase(circuit),
            abiObj
        ]);
    }
    const code = codegen(programs, false, true);
    await fs.writeFile('./src/types/index.ts', code);
};
try {
    await main();
} catch (err) {
    log(`Error generating types ${err}`);
    process.exit(1);
}
