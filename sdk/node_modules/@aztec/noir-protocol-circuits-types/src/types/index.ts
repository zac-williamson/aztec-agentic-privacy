
/* Autogenerated file, do not edit! */

/* eslint-disable */

import { Noir, InputMap, type CompiledCircuit, type ForeignCallHandler } from "@aztec/noir-noir_js"

export { type ForeignCallHandler } from "@aztec/noir-noir_js"

export type FixedLengthArray<T, L extends number> = L extends 0 ? never[]: T[] & { length: L }
export type Field = string;
export type u32 = string;
export type u128 = string;
export type u64 = string;
export type u8 = string;
export type u16 = string;

export type ParityBasePrivateInputs = {
  msgs: FixedLengthArray<Field, 256>;
  vk_tree_root: Field;
}

export type ParityPublicInputs = {
  sha_root: Field;
  converted_root: Field;
  vk_tree_root: Field;
}

export type ParityRootPrivateInputs = {
  children: FixedLengthArray<ProofData<ParityPublicInputs, 449, 115>, 4>;
}

export type ProofData<A, B extends number, C extends number> = {
  public_inputs: A;
  proof: FixedLengthArray<Field, B>;
  vk_data: VkData<C>;
}

export type VkData<A extends number> = {
  vk: VerificationKey<A>;
  leaf_index: u32;
  sibling_path: FixedLengthArray<Field, 7>;
}

export type VerificationKey<A extends number> = {
  key: FixedLengthArray<Field, A>;
  hash: Field;
}

export type TxRequest = {
  origin: AztecAddress;
  args_hash: Field;
  tx_context: TxContext;
  function_data: FunctionData;
  salt: Field;
}

export type AztecAddress = {
  inner: Field;
}

export type TxContext = {
  chain_id: Field;
  version: Field;
  gas_settings: GasSettings;
}

export type FunctionData = {
  selector: FunctionSelector;
  is_private: boolean;
}

export type GasSettings = {
  gas_limits: Gas;
  teardown_gas_limits: Gas;
  max_fees_per_gas: GasFees;
  max_priority_fees_per_gas: GasFees;
}

export type FunctionSelector = {
  inner: u32;
}

export type Gas = {
  da_gas: u32;
  l2_gas: u32;
}

export type GasFees = {
  fee_per_da_gas: u128;
  fee_per_l2_gas: u128;
}

export type ProtocolContracts = {
  derived_addresses: FixedLengthArray<AztecAddress, 11>;
}

export type PrivateCallDataWithoutPublicInputs = {
  vk: VerificationKey<127>;
  verification_key_hints: PrivateVerificationKeyHints;
}

export type PrivateVerificationKeyHints = {
  salted_initialization_hash: SaltedInitializationHash;
  public_keys: PublicKeys;
  contract_class_artifact_hash: Field;
  contract_class_public_bytecode_commitment: Field;
  function_leaf_membership_witness: MembershipWitness<7>;
  updated_class_id_witness: MembershipWitness<40>;
  updated_class_id_leaf: PublicDataTreeLeafPreimage;
  updated_class_id_delayed_public_mutable_values: FixedLengthArray<Field, 3>;
}

export type SaltedInitializationHash = {
  inner: Field;
}

export type PublicKeys = {
  npk_m: NpkM;
  ivpk_m: IvpkM;
  ovpk_m: OvpkM;
  tpk_m: TpkM;
}

export type MembershipWitness<A extends number> = {
  leaf_index: Field;
  sibling_path: FixedLengthArray<Field, A>;
}

export type PublicDataTreeLeafPreimage = {
  slot: Field;
  value: Field;
  next_slot: Field;
  next_index: Field;
}

export type NpkM = {
  inner: EmbeddedCurvePoint;
}

export type IvpkM = {
  inner: EmbeddedCurvePoint;
}

export type OvpkM = {
  inner: EmbeddedCurvePoint;
}

export type TpkM = {
  inner: EmbeddedCurvePoint;
}

export type EmbeddedCurvePoint = {
  x: Field;
  y: Field;
  is_infinite: boolean;
}

export type PrivateCircuitPublicInputs = {
  call_context: CallContext;
  args_hash: Field;
  returns_hash: Field;
  anchor_block_header: BlockHeader;
  tx_context: TxContext;
  min_revertible_side_effect_counter: u32;
  is_fee_payer: boolean;
  expiration_timestamp: u64;
  start_side_effect_counter: u32;
  end_side_effect_counter: u32;
  expected_non_revertible_side_effect_counter: u32;
  expected_revertible_side_effect_counter: u32;
  note_hash_read_requests: ClaimedLengthArray<16, Scoped<Counted<Field>>>;
  nullifier_read_requests: ClaimedLengthArray<16, Scoped<Counted<Field>>>;
  key_validation_requests_and_separators: ClaimedLengthArray<16, KeyValidationRequestAndSeparator>;
  private_call_requests: ClaimedLengthArray<8, PrivateCallRequest>;
  public_call_requests: ClaimedLengthArray<32, Counted<PublicCallRequest>>;
  public_teardown_call_request: PublicCallRequest;
  note_hashes: ClaimedLengthArray<16, Counted<Field>>;
  nullifiers: ClaimedLengthArray<16, Counted<Nullifier>>;
  l2_to_l1_msgs: ClaimedLengthArray<8, Counted<L2ToL1Message>>;
  private_logs: ClaimedLengthArray<16, Counted<PrivateLogData>>;
  contract_class_logs_hashes: ClaimedLengthArray<1, Counted<LogHash>>;
}

export type CallContext = {
  msg_sender: AztecAddress;
  contract_address: AztecAddress;
  function_selector: FunctionSelector;
  is_static_call: boolean;
}

export type BlockHeader = {
  last_archive: AppendOnlyTreeSnapshot;
  state: StateReference;
  sponge_blob_hash: Field;
  global_variables: GlobalVariables;
  total_fees: Field;
  total_mana_used: Field;
}

export type ClaimedLengthArray<A extends number, B> = {
  array: FixedLengthArray<B, A>;
  length: u32;
}

export type PublicCallRequest = {
  msg_sender: AztecAddress;
  contract_address: AztecAddress;
  is_static_call: boolean;
  calldata_hash: Field;
}

export type AppendOnlyTreeSnapshot = {
  root: Field;
  next_available_leaf_index: Field;
}

export type StateReference = {
  l1_to_l2_message_tree: AppendOnlyTreeSnapshot;
  partial: PartialStateReference;
}

export type GlobalVariables = {
  chain_id: Field;
  version: Field;
  block_number: u32;
  slot_number: Field;
  timestamp: u64;
  coinbase: EthAddress;
  fee_recipient: AztecAddress;
  gas_fees: GasFees;
}

export type PartialStateReference = {
  note_hash_tree: AppendOnlyTreeSnapshot;
  nullifier_tree: AppendOnlyTreeSnapshot;
  public_data_tree: AppendOnlyTreeSnapshot;
}

export type EthAddress = {
  inner: Field;
}

export type PrivateKernelCircuitPublicInputs = {
  constants: PrivateTxConstantData;
  min_revertible_side_effect_counter: u32;
  validation_requests: PrivateValidationRequests;
  end: PrivateAccumulatedData;
  public_teardown_call_request: PublicCallRequest;
  fee_payer: AztecAddress;
  expiration_timestamp: u64;
  is_private_only: boolean;
  claimed_first_nullifier: Field;
  claimed_revertible_counter: u32;
}

export type PrivateTxConstantData = {
  anchor_block_header: BlockHeader;
  tx_context: TxContext;
  vk_tree_root: Field;
  protocol_contracts: ProtocolContracts;
}

export type PrivateValidationRequests = {
  note_hash_read_requests: ClaimedLengthArray<64, Scoped<Counted<Field>>>;
  nullifier_read_requests: ClaimedLengthArray<64, Scoped<Counted<Field>>>;
  scoped_key_validation_requests_and_separators: ClaimedLengthArray<64, Scoped<KeyValidationRequestAndSeparator>>;
}

export type PrivateAccumulatedData = {
  note_hashes: ClaimedLengthArray<64, Scoped<Counted<Field>>>;
  nullifiers: ClaimedLengthArray<64, Scoped<Counted<Nullifier>>>;
  l2_to_l1_msgs: ClaimedLengthArray<8, Scoped<Counted<L2ToL1Message>>>;
  private_logs: ClaimedLengthArray<64, Scoped<Counted<PrivateLogData>>>;
  contract_class_logs_hashes: ClaimedLengthArray<1, Scoped<Counted<LogHash>>>;
  public_call_requests: ClaimedLengthArray<32, Counted<PublicCallRequest>>;
  private_call_stack: ClaimedLengthArray<16, PrivateCallRequest>;
}

export type PrivateKernelDataWithoutPublicInputs = {
  vk_data: VkData<127>;
}

export type PaddedSideEffects = {
  note_hashes: FixedLengthArray<Field, 64>;
  nullifiers: FixedLengthArray<Field, 64>;
  private_logs: FixedLengthArray<Log, 64>;
}

export type Log = {
  fields: FixedLengthArray<Field, 16>;
  length: u32;
}

export type PrivateKernelResetHints<A extends number, B extends number, C extends number, D extends number, E extends number, F extends number> = {
  note_hash_read_request_hints: ReadRequestHints<A, B, NoteHashLeafPreimage>;
  nullifier_read_request_hints: ReadRequestHints<C, D, NullifierLeafPreimage>;
  key_validation_hints: FixedLengthArray<KeyValidationHint, E>;
  transient_data_squashing_hints: FixedLengthArray<TransientDataSquashingHint, F>;
}

export type ReadRequestHints<A extends number, B extends number, C> = {
  read_request_actions: FixedLengthArray<ReadRequestAction, 64>;
  pending_read_hints: FixedLengthArray<PendingReadHint, A>;
  settled_read_hints: FixedLengthArray<SettledReadHint<C>, B>;
}

export type KeyValidationHint = {
  sk_m: EmbeddedCurveScalar;
}

export type TransientDataSquashingHint = {
  note_hash_index: u32;
  nullifier_index: u32;
}

export type ReadRequestAction = {
  action: u8;
  hint_index: u32;
}

export type PendingReadHint = {
  read_request_index: u32;
  pending_value_index: u32;
}

export type SettledReadHint<A> = {
  read_request_index: u32;
  membership_witness: MembershipWitness<42>;
  leaf_preimage: A;
}

export type EmbeddedCurveScalar = {
  lo: Field;
  hi: Field;
}

export type PrivateToRollupKernelCircuitPublicInputs = {
  constants: TxConstantData;
  end: PrivateToRollupAccumulatedData;
  gas_used: Gas;
  fee_payer: AztecAddress;
  expiration_timestamp: u64;
}

export type TxConstantData = {
  anchor_block_header: BlockHeader;
  tx_context: TxContext;
  vk_tree_root: Field;
  protocol_contracts_hash: Field;
}

export type PrivateToRollupAccumulatedData = {
  note_hashes: FixedLengthArray<Field, 64>;
  nullifiers: FixedLengthArray<Field, 64>;
  l2_to_l1_msgs: FixedLengthArray<Scoped<L2ToL1Message>, 8>;
  private_logs: FixedLengthArray<Log, 64>;
  contract_class_logs_hashes: FixedLengthArray<Scoped<LogHash>, 1>;
}

export type Scoped<A> = {
  inner: A;
  contract_address: AztecAddress;
}

export type PaddedSideEffectAmounts = {
  non_revertible_note_hashes: u32;
  revertible_note_hashes: u32;
  non_revertible_nullifiers: u32;
  revertible_nullifiers: u32;
  non_revertible_private_logs: u32;
  revertible_private_logs: u32;
}

export type PrivateToPublicKernelCircuitPublicInputs = {
  constants: TxConstantData;
  non_revertible_accumulated_data: PrivateToPublicAccumulatedData;
  revertible_accumulated_data: PrivateToPublicAccumulatedData;
  public_teardown_call_request: PublicCallRequest;
  gas_used: Gas;
  fee_payer: AztecAddress;
  expiration_timestamp: u64;
}

export type PrivateToPublicAccumulatedData = {
  note_hashes: FixedLengthArray<Field, 64>;
  nullifiers: FixedLengthArray<Field, 64>;
  l2_to_l1_msgs: FixedLengthArray<Scoped<L2ToL1Message>, 8>;
  private_logs: FixedLengthArray<Log, 64>;
  contract_class_logs_hashes: FixedLengthArray<Scoped<LogHash>, 1>;
  public_call_requests: FixedLengthArray<PublicCallRequest, 32>;
}

export type PublicChonkVerifierPrivateInputs = {
  hiding_kernel_proof_data: ProofData<PrivateToPublicKernelCircuitPublicInputs, 1935, 127>;
  prover_id: Field;
}

export type PublicChonkVerifierPublicInputs = {
  private_tail: PrivateToPublicKernelCircuitPublicInputs;
  prover_id: Field;
}

export type PrivateTxBaseRollupPrivateInputs = {
  hiding_kernel_proof_data: ProofData<PrivateToRollupKernelCircuitPublicInputs, 1935, 127>;
  constants: BlockConstantData;
  start_tree_snapshots: PartialStateReference;
  start_sponge_blob: SpongeBlob;
  contract_class_log_fields: FixedLengthArray<FixedLengthArray<Field, 3023>, 1>;
  fee_payer_balance_leaf_preimage: PublicDataTreeLeafPreimage;
  anchor_block_archive_sibling_path: FixedLengthArray<Field, 30>;
  tree_snapshot_diff_hints: TreeSnapshotDiffHints;
}

export type BlockConstantData = {
  last_archive: AppendOnlyTreeSnapshot;
  l1_to_l2_tree_snapshot: AppendOnlyTreeSnapshot;
  vk_tree_root: Field;
  protocol_contracts_hash: Field;
  prover_id: Field;
  global_variables: GlobalVariables;
}

export type SpongeBlob = {
  sponge: Poseidon2Sponge;
  num_absorbed_fields: u32;
}

export type TreeSnapshotDiffHints = {
  note_hash_subtree_root_sibling_path: FixedLengthArray<Field, 36>;
  sorted_nullifiers: FixedLengthArray<Field, 64>;
  sorted_nullifier_indexes: FixedLengthArray<u32, 64>;
  nullifier_predecessor_preimages: FixedLengthArray<NullifierLeafPreimage, 64>;
  nullifier_predecessor_membership_witnesses: FixedLengthArray<MembershipWitness<42>, 64>;
  nullifier_subtree_root_sibling_path: FixedLengthArray<Field, 36>;
  fee_payer_balance_membership_witness: MembershipWitness<40>;
}

export type Poseidon2Sponge = {
  cache: FixedLengthArray<Field, 3>;
  state: FixedLengthArray<Field, 4>;
  cache_size: u32;
  squeeze_mode: boolean;
}

export type NullifierLeafPreimage = {
  nullifier: Field;
  next_nullifier: Field;
  next_index: Field;
}

export type TxRollupPublicInputs = {
  num_txs: u16;
  constants: BlockConstantData;
  start_tree_snapshots: PartialStateReference;
  end_tree_snapshots: PartialStateReference;
  start_sponge_blob: SpongeBlob;
  end_sponge_blob: SpongeBlob;
  out_hash: Field;
  accumulated_fees: Field;
  accumulated_mana_used: Field;
}

export type PublicTxBaseRollupPrivateInputs = {
  public_chonk_verifier_proof_data: ProofData<PublicChonkVerifierPublicInputs, 519, 115>;
  avm_proof_data: ProofDataForFixedVk;
  start_sponge_blob: SpongeBlob;
  last_archive: AppendOnlyTreeSnapshot;
  anchor_block_archive_sibling_path: FixedLengthArray<Field, 30>;
  contract_class_log_fields: FixedLengthArray<FixedLengthArray<Field, 3023>, 1>;
}

export type ProofDataForFixedVk = {
  public_inputs: AvmCircuitPublicInputs;
  proof: FixedLengthArray<Field, 16400>;
}

export type AvmCircuitPublicInputs = {
  global_variables: GlobalVariables;
  protocol_contracts: ProtocolContracts;
  start_tree_snapshots: TreeSnapshots;
  start_gas_used: Gas;
  gas_settings: GasSettings;
  effective_gas_fees: GasFees;
  fee_payer: AztecAddress;
  prover_id: Field;
  public_call_request_array_lengths: PublicCallRequestArrayLengths;
  public_setup_call_requests: FixedLengthArray<PublicCallRequest, 32>;
  public_app_logic_call_requests: FixedLengthArray<PublicCallRequest, 32>;
  public_teardown_call_request: PublicCallRequest;
  previous_non_revertible_accumulated_data_array_lengths: PrivateToAvmAccumulatedDataArrayLengths;
  previous_revertible_accumulated_data_array_lengths: PrivateToAvmAccumulatedDataArrayLengths;
  previous_non_revertible_accumulated_data: PrivateToAvmAccumulatedData;
  previous_revertible_accumulated_data: PrivateToAvmAccumulatedData;
  end_tree_snapshots: TreeSnapshots;
  end_gas_used: Gas;
  accumulated_data_array_lengths: AvmAccumulatedDataArrayLengths;
  accumulated_data: AvmAccumulatedData;
  transaction_fee: Field;
  reverted: boolean;
}

export type TreeSnapshots = {
  l1_to_l2_message_tree: AppendOnlyTreeSnapshot;
  note_hash_tree: AppendOnlyTreeSnapshot;
  nullifier_tree: AppendOnlyTreeSnapshot;
  public_data_tree: AppendOnlyTreeSnapshot;
}

export type PublicCallRequestArrayLengths = {
  setup_calls: u32;
  app_logic_calls: u32;
  teardown_call: boolean;
}

export type PrivateToAvmAccumulatedDataArrayLengths = {
  note_hashes: u32;
  nullifiers: u32;
  l2_to_l1_msgs: u32;
}

export type PrivateToAvmAccumulatedData = {
  note_hashes: FixedLengthArray<Field, 64>;
  nullifiers: FixedLengthArray<Field, 64>;
  l2_to_l1_msgs: FixedLengthArray<Scoped<L2ToL1Message>, 8>;
}

export type AvmAccumulatedDataArrayLengths = {
  note_hashes: u32;
  nullifiers: u32;
  l2_to_l1_msgs: u32;
  public_data_writes: u32;
}

export type AvmAccumulatedData = {
  note_hashes: FixedLengthArray<Field, 64>;
  nullifiers: FixedLengthArray<Field, 64>;
  l2_to_l1_msgs: FixedLengthArray<Scoped<L2ToL1Message>, 8>;
  public_logs: PublicLogs;
  public_data_writes: FixedLengthArray<PublicDataWrite, 64>;
}

export type PublicLogs = {
  length: u32;
  payload: FixedLengthArray<Field, 4096>;
}

export type PublicDataWrite = {
  leaf_slot: Field;
  value: Field;
}

export type TxMergeRollupPrivateInputs = {
  previous_rollups: FixedLengthArray<ProofData<TxRollupPublicInputs, 519, 115>, 2>;
}

export type BlockRootRollupPrivateInputs = {
  previous_rollups: FixedLengthArray<ProofData<TxRollupPublicInputs, 519, 115>, 2>;
  new_archive_sibling_path: FixedLengthArray<Field, 30>;
}

export type BlockRollupPublicInputs = {
  constants: CheckpointConstantData;
  previous_archive: AppendOnlyTreeSnapshot;
  new_archive: AppendOnlyTreeSnapshot;
  start_state: StateReference;
  end_state: StateReference;
  start_sponge_blob: SpongeBlob;
  end_sponge_blob: SpongeBlob;
  timestamp: u64;
  block_headers_hash: Field;
  in_hash: Field;
  out_hash: Field;
  accumulated_fees: Field;
  accumulated_mana_used: Field;
}

export type CheckpointConstantData = {
  chain_id: Field;
  version: Field;
  vk_tree_root: Field;
  protocol_contracts_hash: Field;
  prover_id: Field;
  slot_number: Field;
  coinbase: EthAddress;
  fee_recipient: AztecAddress;
  gas_fees: GasFees;
}

export type BlockRootSingleTxRollupPrivateInputs = {
  previous_rollup: ProofData<TxRollupPublicInputs, 519, 115>;
  new_archive_sibling_path: FixedLengthArray<Field, 30>;
}

export type BlockRootFirstRollupPrivateInputs = {
  parity_root: ProofData<ParityPublicInputs, 449, 115>;
  previous_rollups: FixedLengthArray<ProofData<TxRollupPublicInputs, 519, 115>, 2>;
  previous_l1_to_l2: AppendOnlyTreeSnapshot;
  new_l1_to_l2_message_subtree_root_sibling_path: FixedLengthArray<Field, 26>;
  new_archive_sibling_path: FixedLengthArray<Field, 30>;
}

export type BlockRootSingleTxFirstRollupPrivateInputs = {
  parity_root: ProofData<ParityPublicInputs, 449, 115>;
  previous_rollup: ProofData<TxRollupPublicInputs, 519, 115>;
  previous_l1_to_l2: AppendOnlyTreeSnapshot;
  new_l1_to_l2_message_subtree_root_sibling_path: FixedLengthArray<Field, 26>;
  new_archive_sibling_path: FixedLengthArray<Field, 30>;
}

export type BlockRootEmptyTxFirstRollupPrivateInputs = {
  parity_root: ProofData<ParityPublicInputs, 449, 115>;
  previous_archive: AppendOnlyTreeSnapshot;
  previous_state: StateReference;
  constants: CheckpointConstantData;
  timestamp: u64;
  new_l1_to_l2_message_subtree_root_sibling_path: FixedLengthArray<Field, 26>;
  new_archive_sibling_path: FixedLengthArray<Field, 30>;
}

export type BlockMergeRollupPrivateInputs = {
  previous_rollups: FixedLengthArray<ProofData<BlockRollupPublicInputs, 519, 115>, 2>;
}

export type CheckpointRootRollupPrivateInputs = {
  previous_rollups: FixedLengthArray<ProofData<BlockRollupPublicInputs, 519, 115>, 2>;
  hints: CheckpointRootRollupHints;
}

export type CheckpointRootRollupHints = {
  previous_block_header: BlockHeader;
  previous_archive_sibling_path: FixedLengthArray<Field, 30>;
  previous_out_hash: AppendOnlyTreeSnapshot;
  new_out_hash_sibling_path: FixedLengthArray<Field, 5>;
  start_blob_accumulator: BlobAccumulator;
  final_blob_challenges: FinalBlobBatchingChallenges;
  blobs_fields: FixedLengthArray<Field, 24576>;
  blob_commitments: FixedLengthArray<BLS12_381, 6>;
  blobs_hash: Field;
}

export type BlobAccumulator = {
  blob_commitments_hash_acc: Field;
  z_acc: Field;
  y_acc: BLS12_381_Fr;
  c_acc: BLS12_381;
  gamma_acc: Field;
  gamma_pow_acc: BLS12_381_Fr;
}

export type FinalBlobBatchingChallenges = {
  z: Field;
  gamma: BLS12_381_Fr;
}

export type BLS12_381 = {
  x: BLS12_381_Fq;
  y: BLS12_381_Fq;
  is_infinity: boolean;
}

export type BLS12_381_Fr = {
  limbs: FixedLengthArray<u128, 3>;
}

export type BLS12_381_Fq = {
  limbs: FixedLengthArray<u128, 4>;
}

export type CheckpointRollupPublicInputs = {
  constants: EpochConstantData;
  previous_archive: AppendOnlyTreeSnapshot;
  new_archive: AppendOnlyTreeSnapshot;
  previous_out_hash: AppendOnlyTreeSnapshot;
  new_out_hash: AppendOnlyTreeSnapshot;
  checkpoint_header_hashes: FixedLengthArray<Field, 32>;
  fees: FixedLengthArray<FeeRecipient, 32>;
  start_blob_accumulator: BlobAccumulator;
  end_blob_accumulator: BlobAccumulator;
  final_blob_challenges: FinalBlobBatchingChallenges;
}

export type EpochConstantData = {
  chain_id: Field;
  version: Field;
  vk_tree_root: Field;
  protocol_contracts_hash: Field;
  prover_id: Field;
}

export type FeeRecipient = {
  recipient: EthAddress;
  value: Field;
}

export type CheckpointRootSingleBlockRollupPrivateInputs = {
  previous_rollup: ProofData<BlockRollupPublicInputs, 519, 115>;
  hints: CheckpointRootRollupHints;
}

export type CheckpointMergeRollupPrivateInputs = {
  previous_rollups: FixedLengthArray<ProofData<CheckpointRollupPublicInputs, 519, 115>, 2>;
}

export type RootRollupPrivateInputs = {
  previous_rollups: FixedLengthArray<ProofData<CheckpointRollupPublicInputs, 519, 115>, 2>;
}

export type RootRollupPublicInputs = {
  previous_archive_root: Field;
  new_archive_root: Field;
  out_hash: Field;
  checkpoint_header_hashes: FixedLengthArray<Field, 32>;
  fees: FixedLengthArray<FeeRecipient, 32>;
  constants: EpochConstantData;
  blob_public_inputs: FinalBlobAccumulator;
}

export type FinalBlobAccumulator = {
  blob_commitments_hash: Field;
  z: Field;
  y: BLS12_381_Fr;
  c: FixedLengthArray<Field, 2>;
}

export type Nullifier = {
  value: Field;
  note_hash: Field;
}

export type PrivateLogData = {
  log: Log;
  note_hash_counter: u32;
}

export type LogHash = {
  value: Field;
  length: u32;
}

export type PrivateCallRequest = {
  call_context: CallContext;
  args_hash: Field;
  returns_hash: Field;
  start_side_effect_counter: u32;
  end_side_effect_counter: u32;
}

export type KeyValidationRequestAndSeparator = {
  request: KeyValidationRequest;
  key_type_domain_separator: Field;
}

export type KeyValidationRequest = {
  pk_m: EmbeddedCurvePoint;
  sk_app: Field;
}

export type NoteHashLeafPreimage = {
  value: Field;
}

export type L2ToL1Message = {
  recipient: EthAddress;
  content: Field;
}

export type Counted<A> = {
  inner: A;
  counter: u32;
}


export type ParityBaseInputType = {
  inputs: ParityBasePrivateInputs;
}

export type ParityBaseReturnType = ParityPublicInputs;


export async function ParityBase(inputs: ParityBasePrivateInputs, ParityBase_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<ParityPublicInputs> {
  const program = new Noir(ParityBase_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as ParityPublicInputs;
}
export type ParityRootInputType = {
  inputs: ParityRootPrivateInputs;
}

export type ParityRootReturnType = ParityPublicInputs;


export async function ParityRoot(inputs: ParityRootPrivateInputs, ParityRoot_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<ParityPublicInputs> {
  const program = new Noir(ParityRoot_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as ParityPublicInputs;
}
export type PrivateKernelInitInputType = {
  tx_request: TxRequest;
  vk_tree_root: Field;
  protocol_contracts: ProtocolContracts;
  private_call: PrivateCallDataWithoutPublicInputs;
  is_private_only: boolean;
  first_nullifier_hint: Field;
  revertible_counter_hint: u32;
  app_public_inputs: PrivateCircuitPublicInputs;
}

export type PrivateKernelInitReturnType = PrivateKernelCircuitPublicInputs;


export async function PrivateKernelInit(tx_request: TxRequest, vk_tree_root: Field, protocol_contracts: ProtocolContracts, private_call: PrivateCallDataWithoutPublicInputs, is_private_only: boolean, first_nullifier_hint: Field, revertible_counter_hint: u32, app_public_inputs: PrivateCircuitPublicInputs, PrivateKernelInit_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<PrivateKernelCircuitPublicInputs> {
  const program = new Noir(PrivateKernelInit_circuit);
  const args: InputMap = { tx_request, vk_tree_root, protocol_contracts, private_call, is_private_only, first_nullifier_hint, revertible_counter_hint, app_public_inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as PrivateKernelCircuitPublicInputs;
}
export type PrivateKernelInnerInputType = {
  previous_kernel: PrivateKernelDataWithoutPublicInputs;
  previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs;
  private_call: PrivateCallDataWithoutPublicInputs;
  app_public_inputs: PrivateCircuitPublicInputs;
}

export type PrivateKernelInnerReturnType = PrivateKernelCircuitPublicInputs;


export async function PrivateKernelInner(previous_kernel: PrivateKernelDataWithoutPublicInputs, previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs, private_call: PrivateCallDataWithoutPublicInputs, app_public_inputs: PrivateCircuitPublicInputs, PrivateKernelInner_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<PrivateKernelCircuitPublicInputs> {
  const program = new Noir(PrivateKernelInner_circuit);
  const args: InputMap = { previous_kernel, previous_kernel_public_inputs, private_call, app_public_inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as PrivateKernelCircuitPublicInputs;
}
export type PrivateKernelResetInputType = {
  previous_kernel: PrivateKernelDataWithoutPublicInputs;
  previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs;
  padded_side_effects: PaddedSideEffects;
  hints: PrivateKernelResetHints<64, 64, 64, 64, 64, 64>;
}

export type PrivateKernelResetReturnType = PrivateKernelCircuitPublicInputs;


export async function PrivateKernelReset(previous_kernel: PrivateKernelDataWithoutPublicInputs, previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs, padded_side_effects: PaddedSideEffects, hints: PrivateKernelResetHints<64, 64, 64, 64, 64, 64>, PrivateKernelReset_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<PrivateKernelCircuitPublicInputs> {
  const program = new Noir(PrivateKernelReset_circuit);
  const args: InputMap = { previous_kernel, previous_kernel_public_inputs, padded_side_effects, hints };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as PrivateKernelCircuitPublicInputs;
}
export type PrivateKernelTailInputType = {
  previous_kernel: PrivateKernelDataWithoutPublicInputs;
  previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs;
  expiration_timestamp_upper_bound: u64;
}

export type PrivateKernelTailReturnType = PrivateToRollupKernelCircuitPublicInputs;


export async function PrivateKernelTail(previous_kernel: PrivateKernelDataWithoutPublicInputs, previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs, expiration_timestamp_upper_bound: u64, PrivateKernelTail_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<PrivateToRollupKernelCircuitPublicInputs> {
  const program = new Noir(PrivateKernelTail_circuit);
  const args: InputMap = { previous_kernel, previous_kernel_public_inputs, expiration_timestamp_upper_bound };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as PrivateToRollupKernelCircuitPublicInputs;
}
export type PrivateKernelTailToPublicInputType = {
  previous_kernel: PrivateKernelDataWithoutPublicInputs;
  previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs;
  padded_side_effect_amounts: PaddedSideEffectAmounts;
  expiration_timestamp_upper_bound: u64;
}

export type PrivateKernelTailToPublicReturnType = PrivateToPublicKernelCircuitPublicInputs;


export async function PrivateKernelTailToPublic(previous_kernel: PrivateKernelDataWithoutPublicInputs, previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs, padded_side_effect_amounts: PaddedSideEffectAmounts, expiration_timestamp_upper_bound: u64, PrivateKernelTailToPublic_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<PrivateToPublicKernelCircuitPublicInputs> {
  const program = new Noir(PrivateKernelTailToPublic_circuit);
  const args: InputMap = { previous_kernel, previous_kernel_public_inputs, padded_side_effect_amounts, expiration_timestamp_upper_bound };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as PrivateToPublicKernelCircuitPublicInputs;
}
export type HidingKernelToRollupInputType = {
  previous_kernel_public_inputs: PrivateToRollupKernelCircuitPublicInputs;
  previous_kernel_vk_data: VkData<127>;
}

export type HidingKernelToRollupReturnType = PrivateToRollupKernelCircuitPublicInputs;


export async function HidingKernelToRollup(previous_kernel_public_inputs: PrivateToRollupKernelCircuitPublicInputs, previous_kernel_vk_data: VkData<127>, HidingKernelToRollup_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<PrivateToRollupKernelCircuitPublicInputs> {
  const program = new Noir(HidingKernelToRollup_circuit);
  const args: InputMap = { previous_kernel_public_inputs, previous_kernel_vk_data };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as PrivateToRollupKernelCircuitPublicInputs;
}
export type HidingKernelToPublicInputType = {
  previous_kernel_public_inputs: PrivateToPublicKernelCircuitPublicInputs;
  previous_kernel_vk_data: VkData<127>;
}

export type HidingKernelToPublicReturnType = PrivateToPublicKernelCircuitPublicInputs;


export async function HidingKernelToPublic(previous_kernel_public_inputs: PrivateToPublicKernelCircuitPublicInputs, previous_kernel_vk_data: VkData<127>, HidingKernelToPublic_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<PrivateToPublicKernelCircuitPublicInputs> {
  const program = new Noir(HidingKernelToPublic_circuit);
  const args: InputMap = { previous_kernel_public_inputs, previous_kernel_vk_data };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as PrivateToPublicKernelCircuitPublicInputs;
}
export type ChonkVerifierPublicInputType = {
  inputs: PublicChonkVerifierPrivateInputs;
}

export type ChonkVerifierPublicReturnType = PublicChonkVerifierPublicInputs;


export async function ChonkVerifierPublic(inputs: PublicChonkVerifierPrivateInputs, ChonkVerifierPublic_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<PublicChonkVerifierPublicInputs> {
  const program = new Noir(ChonkVerifierPublic_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as PublicChonkVerifierPublicInputs;
}
export type RollupTxBasePrivateInputType = {
  inputs: PrivateTxBaseRollupPrivateInputs;
}

export type RollupTxBasePrivateReturnType = TxRollupPublicInputs;


export async function RollupTxBasePrivate(inputs: PrivateTxBaseRollupPrivateInputs, RollupTxBasePrivate_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<TxRollupPublicInputs> {
  const program = new Noir(RollupTxBasePrivate_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as TxRollupPublicInputs;
}
export type RollupTxBasePublicInputType = {
  inputs: PublicTxBaseRollupPrivateInputs;
}

export type RollupTxBasePublicReturnType = TxRollupPublicInputs;


export async function RollupTxBasePublic(inputs: PublicTxBaseRollupPrivateInputs, RollupTxBasePublic_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<TxRollupPublicInputs> {
  const program = new Noir(RollupTxBasePublic_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as TxRollupPublicInputs;
}
export type RollupTxMergeInputType = {
  inputs: TxMergeRollupPrivateInputs;
}

export type RollupTxMergeReturnType = TxRollupPublicInputs;


export async function RollupTxMerge(inputs: TxMergeRollupPrivateInputs, RollupTxMerge_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<TxRollupPublicInputs> {
  const program = new Noir(RollupTxMerge_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as TxRollupPublicInputs;
}
export type RollupBlockRootInputType = {
  inputs: BlockRootRollupPrivateInputs;
}

export type RollupBlockRootReturnType = BlockRollupPublicInputs;


export async function RollupBlockRoot(inputs: BlockRootRollupPrivateInputs, RollupBlockRoot_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<BlockRollupPublicInputs> {
  const program = new Noir(RollupBlockRoot_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as BlockRollupPublicInputs;
}
export type RollupBlockRootSingleTxInputType = {
  inputs: BlockRootSingleTxRollupPrivateInputs;
}

export type RollupBlockRootSingleTxReturnType = BlockRollupPublicInputs;


export async function RollupBlockRootSingleTx(inputs: BlockRootSingleTxRollupPrivateInputs, RollupBlockRootSingleTx_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<BlockRollupPublicInputs> {
  const program = new Noir(RollupBlockRootSingleTx_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as BlockRollupPublicInputs;
}
export type RollupBlockRootFirstInputType = {
  inputs: BlockRootFirstRollupPrivateInputs;
}

export type RollupBlockRootFirstReturnType = BlockRollupPublicInputs;


export async function RollupBlockRootFirst(inputs: BlockRootFirstRollupPrivateInputs, RollupBlockRootFirst_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<BlockRollupPublicInputs> {
  const program = new Noir(RollupBlockRootFirst_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as BlockRollupPublicInputs;
}
export type RollupBlockRootFirstSingleTxInputType = {
  inputs: BlockRootSingleTxFirstRollupPrivateInputs;
}

export type RollupBlockRootFirstSingleTxReturnType = BlockRollupPublicInputs;


export async function RollupBlockRootFirstSingleTx(inputs: BlockRootSingleTxFirstRollupPrivateInputs, RollupBlockRootFirstSingleTx_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<BlockRollupPublicInputs> {
  const program = new Noir(RollupBlockRootFirstSingleTx_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as BlockRollupPublicInputs;
}
export type RollupBlockRootFirstEmptyTxInputType = {
  inputs: BlockRootEmptyTxFirstRollupPrivateInputs;
}

export type RollupBlockRootFirstEmptyTxReturnType = BlockRollupPublicInputs;


export async function RollupBlockRootFirstEmptyTx(inputs: BlockRootEmptyTxFirstRollupPrivateInputs, RollupBlockRootFirstEmptyTx_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<BlockRollupPublicInputs> {
  const program = new Noir(RollupBlockRootFirstEmptyTx_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as BlockRollupPublicInputs;
}
export type RollupBlockMergeInputType = {
  inputs: BlockMergeRollupPrivateInputs;
}

export type RollupBlockMergeReturnType = BlockRollupPublicInputs;


export async function RollupBlockMerge(inputs: BlockMergeRollupPrivateInputs, RollupBlockMerge_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<BlockRollupPublicInputs> {
  const program = new Noir(RollupBlockMerge_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as BlockRollupPublicInputs;
}
export type RollupCheckpointRootInputType = {
  inputs: CheckpointRootRollupPrivateInputs;
}

export type RollupCheckpointRootReturnType = CheckpointRollupPublicInputs;


export async function RollupCheckpointRoot(inputs: CheckpointRootRollupPrivateInputs, RollupCheckpointRoot_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<CheckpointRollupPublicInputs> {
  const program = new Noir(RollupCheckpointRoot_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as CheckpointRollupPublicInputs;
}
export type RollupCheckpointRootSingleBlockInputType = {
  inputs: CheckpointRootSingleBlockRollupPrivateInputs;
}

export type RollupCheckpointRootSingleBlockReturnType = CheckpointRollupPublicInputs;


export async function RollupCheckpointRootSingleBlock(inputs: CheckpointRootSingleBlockRollupPrivateInputs, RollupCheckpointRootSingleBlock_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<CheckpointRollupPublicInputs> {
  const program = new Noir(RollupCheckpointRootSingleBlock_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as CheckpointRollupPublicInputs;
}
export type RollupCheckpointMergeInputType = {
  inputs: CheckpointMergeRollupPrivateInputs;
}

export type RollupCheckpointMergeReturnType = CheckpointRollupPublicInputs;


export async function RollupCheckpointMerge(inputs: CheckpointMergeRollupPrivateInputs, RollupCheckpointMerge_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<CheckpointRollupPublicInputs> {
  const program = new Noir(RollupCheckpointMerge_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as CheckpointRollupPublicInputs;
}
export type RollupRootInputType = {
  inputs: RootRollupPrivateInputs;
}

export type RollupRootReturnType = RootRollupPublicInputs;


export async function RollupRoot(inputs: RootRollupPrivateInputs, RollupRoot_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<RootRollupPublicInputs> {
  const program = new Noir(RollupRoot_circuit);
  const args: InputMap = { inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as RootRollupPublicInputs;
}
export type TsTypesInputType = {
  _nullifier: Nullifier;
  _private_log_data: PrivateLogData;
  _log_hash: LogHash;
  _private_call_request: PrivateCallRequest;
  _public_call_request: PublicCallRequest;
  _key_validation_request: KeyValidationRequestAndSeparator;
  _note_hash_leaf_preimage: NoteHashLeafPreimage;
  _nullifier_leaf_preimage: NullifierLeafPreimage;
  _l2_to_l1_message: L2ToL1Message;
  _counted: Counted<u32>;
  _avm_circuit_public_inputs: AvmCircuitPublicInputs;
}



export async function TsTypes(_nullifier: Nullifier, _private_log_data: PrivateLogData, _log_hash: LogHash, _private_call_request: PrivateCallRequest, _public_call_request: PublicCallRequest, _key_validation_request: KeyValidationRequestAndSeparator, _note_hash_leaf_preimage: NoteHashLeafPreimage, _nullifier_leaf_preimage: NullifierLeafPreimage, _l2_to_l1_message: L2ToL1Message, _counted: Counted<u32>, _avm_circuit_public_inputs: AvmCircuitPublicInputs, TsTypes_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<null> {
  const program = new Noir(TsTypes_circuit);
  const args: InputMap = { _nullifier, _private_log_data, _log_hash, _private_call_request, _public_call_request, _key_validation_request, _note_hash_leaf_preimage, _nullifier_leaf_preimage, _l2_to_l1_message, _counted, _avm_circuit_public_inputs };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as null;
}
export type PrivateKernelReset_32_4_32_4_4_4_4_4_4InputType = {
  previous_kernel: PrivateKernelDataWithoutPublicInputs;
  previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs;
  padded_side_effects: PaddedSideEffects;
  hints: PrivateKernelResetHints<32, 4, 32, 4, 4, 4>;
}

export type PrivateKernelReset_32_4_32_4_4_4_4_4_4ReturnType = PrivateKernelCircuitPublicInputs;


export async function PrivateKernelReset_32_4_32_4_4_4_4_4_4(previous_kernel: PrivateKernelDataWithoutPublicInputs, previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs, padded_side_effects: PaddedSideEffects, hints: PrivateKernelResetHints<32, 4, 32, 4, 4, 4>, PrivateKernelReset_32_4_32_4_4_4_4_4_4_circuit: CompiledCircuit, foreignCallHandler?: ForeignCallHandler): Promise<PrivateKernelCircuitPublicInputs> {
  const program = new Noir(PrivateKernelReset_32_4_32_4_4_4_4_4_4_circuit);
  const args: InputMap = { previous_kernel, previous_kernel_public_inputs, padded_side_effects, hints };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as PrivateKernelCircuitPublicInputs;
}
