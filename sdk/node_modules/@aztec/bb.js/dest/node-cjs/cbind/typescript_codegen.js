"use strict";
/**
 * TypeScript Code Generator - String template based
 *
 * Philosophy:
 *   - String templates for file structure
 *   - Simple type mapping
 *   - Idiomatic TypeScript conventions
 *   - No complex abstraction
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptCodegen = void 0;
const naming_js_1 = require("./naming.js");
function toCamelCase(name) {
    const pascal = (0, naming_js_1.toPascalCase)(name);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}
class TypeScriptCodegen {
    // Type mapping: Schema type -> TypeScript type
    mapType(type) {
        switch (type.kind) {
            case 'primitive':
                switch (type.primitive) {
                    case 'bool': return 'boolean';
                    case 'u8': return 'number';
                    case 'u16': return 'number';
                    case 'u32': return 'number';
                    case 'u64': return 'number';
                    case 'f64': return 'number';
                    case 'string': return 'string';
                    case 'bytes': return 'Uint8Array';
                    case 'field2': return '[Uint8Array, Uint8Array]'; // Extension field (Fq2)
                }
                break;
            case 'vector':
                return `${this.mapType(type.element)}[]`;
            case 'array':
                return `${this.mapType(type.element)}[]`;
            case 'optional':
                return `${this.mapType(type.element)} | undefined`;
            case 'struct':
                return (0, naming_js_1.toPascalCase)(type.struct.name);
        }
        return 'unknown';
    }
    // Type mapping for msgpack interfaces (uses Msgpack* prefix for structs)
    mapMsgpackType(type) {
        switch (type.kind) {
            case 'primitive':
                switch (type.primitive) {
                    case 'bool': return 'boolean';
                    case 'u8': return 'number';
                    case 'u16': return 'number';
                    case 'u32': return 'number';
                    case 'u64': return 'number';
                    case 'f64': return 'number';
                    case 'string': return 'string';
                    case 'bytes': return 'Uint8Array';
                    case 'field2': return '[Uint8Array, Uint8Array]';
                }
                break;
            case 'vector':
                return `${this.mapMsgpackType(type.element)}[]`;
            case 'array':
                return `${this.mapMsgpackType(type.element)}[]`;
            case 'optional':
                return `${this.mapMsgpackType(type.element)} | undefined`;
            case 'struct':
                return `Msgpack${(0, naming_js_1.toPascalCase)(type.struct.name)}`;
        }
        return 'unknown';
    }
    // Check if type needs conversion (has nested structs)
    needsConversion(type) {
        switch (type.kind) {
            case 'primitive':
                return false;
            case 'vector':
            case 'array':
            case 'optional':
                return this.needsConversion(type.element);
            case 'struct':
                return true;
        }
        return false;
    }
    // Generate field
    generateField(field) {
        const tsName = toCamelCase(field.name);
        const tsType = this.mapType(field.type);
        return `  ${tsName}: ${tsType};`;
    }
    // Generate msgpack field (original names, uses Msgpack* types for structs)
    generateMsgpackField(field) {
        const tsType = this.mapMsgpackType(field.type);
        return `  ${field.name}: ${tsType};`;
    }
    // Generate public interface
    generateInterface(struct) {
        const tsName = (0, naming_js_1.toPascalCase)(struct.name);
        const fields = struct.fields.map(f => this.generateField(f)).join('\n');
        return `export interface ${tsName} {
${fields}
}`;
    }
    // Generate msgpack interface (internal)
    generateMsgpackInterface(struct) {
        const tsName = (0, naming_js_1.toPascalCase)(struct.name);
        const fields = struct.fields.map(f => this.generateMsgpackField(f)).join('\n');
        return `interface Msgpack${tsName} {
${fields}
}`;
    }
    // Generate to* conversion function
    generateToFunction(struct) {
        const tsName = (0, naming_js_1.toPascalCase)(struct.name);
        if (struct.fields.length === 0) {
            return `function to${tsName}(o: Msgpack${tsName}): ${tsName} {
  return {};
}`;
        }
        const checks = struct.fields
            .map(f => `  if (o.${f.name} === undefined) { throw new Error("Expected ${f.name} in ${tsName} deserialization"); }`)
            .join('\n');
        const conversions = struct.fields
            .map(f => {
            const tsFieldName = toCamelCase(f.name);
            const converter = this.generateToConverter(f.type, `o.${f.name}`);
            return `    ${tsFieldName}: ${converter},`;
        })
            .join('\n');
        return `function to${tsName}(o: Msgpack${tsName}): ${tsName} {
${checks};
  return {
${conversions}
  };
}`;
    }
    // Generate from* conversion function
    generateFromFunction(struct) {
        const tsName = (0, naming_js_1.toPascalCase)(struct.name);
        if (struct.fields.length === 0) {
            return `function from${tsName}(o: ${tsName}): Msgpack${tsName} {
  return {};
}`;
        }
        const checks = struct.fields
            .map(f => {
            const tsFieldName = toCamelCase(f.name);
            return `  if (o.${tsFieldName} === undefined) { throw new Error("Expected ${tsFieldName} in ${tsName} serialization"); }`;
        })
            .join('\n');
        const conversions = struct.fields
            .map(f => {
            const tsFieldName = toCamelCase(f.name);
            const converter = this.generateFromConverter(f.type, `o.${tsFieldName}`);
            return `  ${f.name}: ${converter},`;
        })
            .join('\n');
        return `function from${tsName}(o: ${tsName}): Msgpack${tsName} {
${checks};
  return {
${conversions}
  };
}`;
    }
    // Generate converter for to* function
    generateToConverter(type, value) {
        if (!this.needsConversion(type)) {
            return value;
        }
        switch (type.kind) {
            case 'vector':
            case 'array':
                if (this.needsConversion(type.element)) {
                    return `${value}.map((v: any) => ${this.generateToConverter(type.element, 'v')})`;
                }
                return value;
            case 'optional':
                if (this.needsConversion(type.element)) {
                    return `${value} !== undefined ? ${this.generateToConverter(type.element, value)} : undefined`;
                }
                return value;
            case 'struct':
                return `to${(0, naming_js_1.toPascalCase)(type.struct.name)}(${value})`;
        }
        return value;
    }
    // Generate converter for from* function
    generateFromConverter(type, value) {
        if (!this.needsConversion(type)) {
            return value;
        }
        switch (type.kind) {
            case 'vector':
            case 'array':
                if (this.needsConversion(type.element)) {
                    return `${value}.map((v: any) => ${this.generateFromConverter(type.element, 'v')})`;
                }
                return value;
            case 'optional':
                if (this.needsConversion(type.element)) {
                    return `${value} !== undefined ? ${this.generateFromConverter(type.element, value)} : undefined`;
                }
                return value;
            case 'struct':
                return `from${(0, naming_js_1.toPascalCase)(type.struct.name)}(${value})`;
        }
        return value;
    }
    // Generate types file (api_types.ts)
    generateTypes(schema) {
        const allStructs = [...schema.structs.values(), ...schema.responses.values()];
        // Public interfaces
        const publicInterfaces = allStructs
            .map(s => this.generateInterface(s))
            .join('\n\n');
        // Msgpack interfaces
        const msgpackInterfaces = allStructs
            .map(s => this.generateMsgpackInterface(s))
            .join('\n\n');
        // Conversion functions
        const toFunctions = allStructs
            .map(s => 'export ' + this.generateToFunction(s))
            .join('\n\n');
        const fromFunctions = allStructs
            .map(s => 'export ' + this.generateFromFunction(s))
            .join('\n\n');
        // BbApiBase interface
        const apiMethods = schema.commands
            .map(c => `  ${toCamelCase(c.name)}(command: ${(0, naming_js_1.toPascalCase)(c.name)}): Promise<${(0, naming_js_1.toPascalCase)(c.responseType)}>;`)
            .join('\n');
        return `// AUTOGENERATED FILE - DO NOT EDIT

// Type aliases for primitive types
export type Field2 = [Uint8Array, Uint8Array];

// Public interfaces (exported)
${publicInterfaces}

// Private Msgpack interfaces (not exported)
${msgpackInterfaces}

// Conversion functions (exported)
${toFunctions}

${fromFunctions}

// Base API interface
export interface BbApiBase {
${apiMethods}
  destroy(): Promise<void>;
}
`;
    }
    // Generate API method
    generateAsyncApiMethod(command) {
        const methodName = toCamelCase(command.name);
        const cmdType = (0, naming_js_1.toPascalCase)(command.name);
        const respType = (0, naming_js_1.toPascalCase)(command.responseType);
        return `  ${methodName}(command: ${cmdType}): Promise<${respType}> {
    const msgpackCommand = from${cmdType}(command);
    return msgpackCall(this.backend, [["${command.name}", msgpackCommand]]).then(([variantName, result]: [string, any]) => {
      if (variantName === 'ErrorResponse') {
        throw new BBApiException(result.message || 'Unknown error from barretenberg');
      }
      if (variantName !== '${command.responseType}') {
        throw new BBApiException(\`Expected variant name '${command.responseType}' but got '\${variantName}'\`);
      }
      return to${respType}(result);
    });
  }`;
    }
    generateSyncApiMethod(command) {
        const methodName = toCamelCase(command.name);
        const cmdType = (0, naming_js_1.toPascalCase)(command.name);
        const respType = (0, naming_js_1.toPascalCase)(command.responseType);
        return `  ${methodName}(command: ${cmdType}): ${respType} {
    const msgpackCommand = from${cmdType}(command);
    const [variantName, result] = msgpackCall(this.backend, [["${command.name}", msgpackCommand]]);
    if (variantName === 'ErrorResponse') {
      throw new BBApiException(result.message || 'Unknown error from barretenberg');
    }
    if (variantName !== '${command.responseType}') {
      throw new BBApiException(\`Expected variant name '${command.responseType}' but got '\${variantName}'\`);
    }
    return to${respType}(result);
  }`;
    }
    // Generate async API file
    generateAsyncApi(schema) {
        const imports = this.generateApiImports(schema);
        const methods = schema.commands
            .map(c => this.generateAsyncApiMethod(c))
            .join('\n\n');
        return `// AUTOGENERATED FILE - DO NOT EDIT

import { IMsgpackBackendAsync } from '../../bb_backends/interface.js';
import { Decoder, Encoder } from 'msgpackr';
import { BBApiException } from '../../bbapi_exception.js';
${imports}

async function msgpackCall(backend: IMsgpackBackendAsync, input: any[]) {
  const inputBuffer = new Encoder({ useRecords: false }).pack(input);
  const encodedResult = await backend.call(inputBuffer);
  return new Decoder({ useRecords: false }).unpack(encodedResult);
}

export class AsyncApi implements BbApiBase {
  constructor(protected backend: IMsgpackBackendAsync) {}

${methods}

  destroy(): Promise<void> {
    return this.backend.destroy ? this.backend.destroy() : Promise.resolve();
  }
}
`;
    }
    // Generate sync API file
    generateSyncApi(schema) {
        const imports = this.generateApiImports(schema);
        const methods = schema.commands
            .map(c => this.generateSyncApiMethod(c))
            .join('\n\n');
        return `// AUTOGENERATED FILE - DO NOT EDIT

import { IMsgpackBackendSync } from '../../bb_backends/interface.js';
import { Decoder, Encoder } from 'msgpackr';
import { BBApiException } from '../../bbapi_exception.js';
${imports}

function msgpackCall(backend: IMsgpackBackendSync, input: any[]) {
  const inputBuffer = new Encoder({ useRecords: false }).pack(input);
  const encodedResult = backend.call(inputBuffer);
  return new Decoder({ useRecords: false }).unpack(encodedResult);
}

export class SyncApi {
  constructor(protected backend: IMsgpackBackendSync) {}

${methods}

  destroy(): void {
    if (this.backend.destroy) this.backend.destroy();
  }
}
`;
    }
    // Generate import statement for API files
    generateApiImports(schema) {
        const types = new Set();
        // Add command types and their conversion functions
        for (const cmd of schema.commands) {
            const cmdType = (0, naming_js_1.toPascalCase)(cmd.name);
            const respType = (0, naming_js_1.toPascalCase)(cmd.responseType);
            types.add(cmdType);
            types.add(respType);
            types.add(`from${cmdType}`);
            types.add(`to${respType}`);
        }
        // Add BbApiBase
        types.add('BbApiBase');
        const sortedTypes = Array.from(types).sort();
        return `import { ${sortedTypes.join(', ')} } from './api_types.js';`;
    }
}
exports.TypeScriptCodegen = TypeScriptCodegen;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXNjcmlwdF9jb2RlZ2VuLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NiaW5kL3R5cGVzY3JpcHRfY29kZWdlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7O0dBUUc7OztBQUdILDJDQUEyQztBQUUzQyxTQUFTLFdBQVcsQ0FBQyxJQUFZLEVBQVU7SUFDekMsTUFBTSxNQUFNLEdBQUcsSUFBQSx3QkFBWSxFQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xDLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQUEsQ0FDekQ7QUFFRDtJQUNFLCtDQUErQztJQUN2QyxPQUFPLENBQUMsSUFBVSxFQUFVO1FBQ2xDLFFBQVEsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ2xCLEtBQUssV0FBVztnQkFDZCxRQUFRLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztvQkFDdkIsS0FBSyxNQUFNLEVBQUUsT0FBTyxTQUFTLENBQUM7b0JBQzlCLEtBQUssSUFBSSxFQUFFLE9BQU8sUUFBUSxDQUFDO29CQUMzQixLQUFLLEtBQUssRUFBRSxPQUFPLFFBQVEsQ0FBQztvQkFDNUIsS0FBSyxLQUFLLEVBQUUsT0FBTyxRQUFRLENBQUM7b0JBQzVCLEtBQUssS0FBSyxFQUFFLE9BQU8sUUFBUSxDQUFDO29CQUM1QixLQUFLLEtBQUssRUFBRSxPQUFPLFFBQVEsQ0FBQztvQkFDNUIsS0FBSyxRQUFRLEVBQUUsT0FBTyxRQUFRLENBQUM7b0JBQy9CLEtBQUssT0FBTyxFQUFFLE9BQU8sWUFBWSxDQUFDO29CQUNsQyxLQUFLLFFBQVEsRUFBRSxPQUFPLDBCQUEwQixDQUFDLENBQUUsd0JBQXdCO2dCQUM3RSxDQUFDO2dCQUNELE1BQU07WUFFUixLQUFLLFFBQVE7Z0JBQ1gsT0FBTyxHQUFHLElBQUksQ0FB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