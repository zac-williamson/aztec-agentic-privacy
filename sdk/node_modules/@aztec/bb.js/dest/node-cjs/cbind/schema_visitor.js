"use strict";
/**
 * Schema Visitor - Minimal abstraction over raw msgpack schema
 *
 * Philosophy:
 *   - Keep raw schema structure
 *   - Resolve type references into a graph
 *   - No normalization - languages handle their own conventions
 *   - Output is "compiled schema" with resolved types
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaVisitor = void 0;
/**
 * SchemaVisitor - Walks raw msgpack schema and resolves references
 */
class SchemaVisitor {
    structs = new Map();
    responses = new Map();
    visit(commandsSchema, responsesSchema) {
        // Reset state
        this.structs.clear();
        this.responses.clear();
        const commands = [];
        // Schema format: ["named_union", [[name, schema], ...]]
        const commandPairs = commandsSchema[1];
        const responsePairs = responsesSchema[1];
        // First, visit all response types (including ErrorResponse)
        for (const [respName, respSchema] of responsePairs) {
            if (typeof respSchema !== 'string') {
                const respStruct = this.visitStruct(respName, respSchema);
                this.responses.set(respName, respStruct);
            }
        }
        // Visit all commands and pair with responses
        for (let i = 0; i < commandPairs.length; i++) {
            const [cmdName, cmdSchema] = commandPairs[i];
            // Find matching response (skip ErrorResponse which is always last)
            const normalResponses = responsePairs.filter(([name]) => name !== 'ErrorResponse');
            const [respName] = normalResponses[i];
            // Discover command structure
            const cmdStruct = this.visitStruct(cmdName, cmdSchema);
            this.structs.set(cmdName, cmdStruct);
            // Create command mapping
            commands.push({
                name: cmdName,
                fields: cmdStruct.fields,
                responseType: respName,
            });
        }
        return {
            structs: this.structs,
            commands,
            responses: this.responses,
        };
    }
    visitStruct(name, schema) {
        const fields = [];
        // Schema is an object with __typename and fields
        for (const [key, value] of Object.entries(schema)) {
            if (key === '__typename')
                continue;
            fields.push({
                name: key,
                type: this.visitType(value),
            });
        }
        return { name, fields };
    }
    visitType(schema) {
        // Primitive string type
        if (typeof schema === 'string') {
            return this.resolvePrimitive(schema);
        }
        // Array type descriptor: ['vector', [elementType]]
        if (Array.isArray(schema)) {
            const [kind, args] = schema;
            switch (kind) {
                case 'vector': {
                    const [elemType] = args;
                    // Special case: vector<unsigned char> = bytes
                    if (elemType === 'unsigned char') {
                        return { kind: 'primitive', primitive: 'bytes' };
                    }
                    return {
                        kind: 'vector',
                        element: this.visitType(elemType),
                    };
                }
                case 'array': {
                    const [elemType, size] = args;
                    // Special case: array<unsigned char, N> = bytes
                    if (elemType === 'unsigned char') {
                        return { kind: 'primitive', primitive: 'bytes' };
                    }
                    return {
                        kind: 'array',
                        element: this.visitType(elemType),
                        size,
                    };
                }
                case 'optional': {
                    const [elemType] = args;
                    return {
                        kind: 'optional',
                        element: this.visitType(elemType),
                    };
                }
                case 'shared_ptr': {
                    // Dereference shared_ptr - just use inner type
                    const [innerType] = args;
                    return this.visitType(innerType);
                }
                case 'alias': {
                    // Alias types (like uint256_t) are treated as bytes
                    return { kind: 'primitive', primitive: 'bytes' };
                }
                default:
                    throw new Error(`Unknown type kind: ${kind}`);
            }
        }
        // Inline struct definition
        if (typeof schema === 'object' && schema.__typename) {
            const structName = schema.__typename;
            // Check if already visited
            if (!this.structs.has(structName)) {
                const struct = this.visitStruct(structName, schema);
                this.structs.set(structName, struct);
            }
            return {
                kind: 'struct',
                struct: this.structs.get(structName),
            };
        }
        throw new Error(`Cannot resolve type: ${JSON.stringify(schema)}`);
    }
    resolvePrimitive(name) {
        const primitiveMap = {
            'bool': 'bool',
            'int': 'u32',
            'unsigned int': 'u32',
            'unsigned short': 'u16',
            'unsigned long': 'u64',
            'unsigned char': 'u8',
            'double': 'f64',
            'string': 'string',
            'bin32': 'bytes',
            'field2': 'field2', // Extension field (Fq2) - pair of field elements
        };
        const primitive = primitiveMap[name];
        if (primitive) {
            return { kind: 'primitive', primitive };
        }
        // Unknown primitive - treat as struct reference
        // This will be resolved later if it's a real struct
        return {
            kind: 'struct',
            struct: { name, fields: [] }, // Placeholder
        };
    }
}
exports.SchemaVisitor = SchemaVisitor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hX3Zpc2l0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY2JpbmQvc2NoZW1hX3Zpc2l0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7OztHQVFHOzs7QUF1Q0g7O0dBRUc7QUFDSDtJQUNVLE9BQU8sR0FBRyxJQUFJLEdBQUcsRUFBa0IsQ0FBQztJQUNwQyxTQUFTLEdBQUcsSUFBSSxHQUFHLEVBQWtCLENBQUM7SUFFOUMsS0FBSyxDQUFDLGNBQW1CLEVBQUUsZUFBb0IsRUFBa0I7UUFDL0QsY0FBYztRQUNkLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUV2QixNQUFNLFFBQVEsR0FBYyxFQUFFLENBQUM7UUFFL0Isd0RBQXdEO1FBQ3hELE1BQU0sWUFBWSxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQXlCLENBQUM7UUFDL0QsTUFBTSxhQUFhLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBeUIsQ0FBQztRQUVqRSw0REFBNEQ7UUFDNUQsS0FBSyxNQUFNLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxJQUFJLGFBQWEsRUFBRSxDQUFDO1lBQ25ELElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxFQUFFLENBQUM7Z0JBQ25DLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO2dCQUMxRCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7WUFDM0MsQ0FBQztRQUNILENBQUM7UUFFRCw2Q0FBNkM7UUFDN0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUM3QyxNQUFNLENBQUMsT0FBTyxFQUFFLFNB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