"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BarretenbergNativeShmSyncBackend = void 0;
const module_1 = require("module");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const platform_js_1 = require("./platform.js");
const worker_threads_1 = require("worker_threads");
let instanceCounter = 0;
/**
 * Synchronous shared memory backend that communicates with bb binary via shared memory.
 * Uses NAPI module to interface with shared memory IPC.
 *
 * Architecture: bb acts as the SERVER, TypeScript is the CLIENT
 * - bb creates the shared memory region
 * - TypeScript connects via NAPI wrapper
 *
 * Protocol:
 * - Handled internally by IpcClient (no manual length prefixes needed)
 */
class BarretenbergNativeShmSyncBackend {
    process;
    client; // NAPI MsgpackClient instance
    logFd; // File descriptor for logs
    constructor(process, client, logFd) {
        this.process = process;
        this.client = client;
        this.logFd = logFd;
    }
    /**
     * Create and initialize a shared memory backend.
     * @param bbBinaryPath Path to bb binary
     * @param napiPath Path to NAPI binary
     * @param threads Optional number of threads
     */
    static async new(bbBinaryPath, napiPath, threads, logger) {
        // Import the NAPI module
        // The addon is built to the nodejs_module directory
        const addonPath = (0, platform_js_1.findNapiBinary)(napiPath);
        // Try loading
        let addon = null;
        try {
            const require = (0, module_1.createRequire)((0, platform_js_1.findPackageRoot)());
            addon = require(addonPath);
        }
        catch (err) {
            // Addon not built yet or not available
            throw new Error('Shared memory sync NAPI not available.');
        }
        // Create a unique shared memory name
        const shmName = `bb-sync-${process.pid}-${worker_threads_1.threadId}-${instanceCounter++}`;
        // If threads not set use 1 thread. We're not expected to do long lived work on sync backends.
        const hwc = threads ? threads.toString() : '1';
        const env = { ...process.env, HARDWARE_CONCURRENCY: hwc };
        // Set up file logging if logger is provided.
        // Direct file redirection bypasses Node event loop - logs are written even if process hangs.
        let logFd;
        let logPath;
        if (logger) {
            logPath = `/tmp/${shmName}.log`;
            logFd = (0, fs_1.openSync)(logPath, 'w');
            logger(`BB process logs redirected to: ${logPath}`);
        }
        // Clean up any stale shared memory files from previous runs
        // This handles the case where a previous process crashed without cleanup
        const shmRequestPath = `/dev/shm/${shmName}_request`;
        const shmResponsePath = `/dev/shm/${shmName}_response`;
        try {
            (0, fs_1.unlinkSync)(shmRequestPath);
        }
        catch (err) {
            const isNotFound = err && typeof err === 'object' && 'code' in err && err.code === 'ENOENT';
            if (!isNotFound) {
                throw new Error(`Failed to clean up stale shared memory file ${shmRequestPath}: ${err}`);
            }
        }
        try {
            (0, fs_1.unlinkSync)(shmResponsePath);
        }
        catch (err) {
            const isNotFound = err && typeof err === 'object' && 'code' in err && err.code === 'ENOENT';
            if (!isNotFound) {
                throw new Error(`Failed to clean up stale shared memory file ${shmResponsePath}: ${err}`);
            }
        }
        // Spawn bb process with shared memory mode (SPSC-only, no max-clients needed)
        const args = ['msgpack', 'run', '--input', `${shmName}.shm`, '--request-ring-size', `${1024 * 1024 * 4}`];
        const bbProcess = (0, child_process_1.spawn)(bbBinaryPath, args, {
            stdio: ['ignore', logFd ?? 'ignore', logFd ?? 'ignore'],
            env,
        });
        // Disconnect from event loop so process can exit without waiting for bb
        // The bb process has parent death monitoring (prctl on Linux, kqueue on macOS)
        // so it will automatically exit when Node.js exits
        bbProcess.unref();
        // Track if process has exited
        let processExited = false;
        let exitError = null;
        bbProcess.on('error', err => {
            processExited = true;
            exitError = new Error(`Native backend process error: ${err.message}`);
        });
        bbProcess.on('exit', (code, signal) => {
            processExited = true;
            if (code !== null && code !== 0) {
                exitError = new Error(`Native backend process exited with code ${code}`);
            }
            else if (signal && signal !== 'SIGTERM') {
                exitError = new Error(`Native backend process killed with signal ${signal}`);
            }
        });
        // Wait for bb to create shared memory
        // Retry connection every 100ms for up to 3 seconds
        const retryInterval = 100; // ms
        const timeout = 3000; // ms
        const maxAttempts = Math.floor(timeout / retryInterval);
        let client = null;
        try {
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                // Check if bb process has exited before attempting connection
                if (processExited) {
                    throw exitError || new Error('Native backend process exited unexpectedly during startup');
                }
                // Wait before attempting connection (except first attempt)
                if (attempt > 0) {
                    await new Promise(resolve => setTimeout(resolve, retryInterval));
                }
                try {
                    // Create NAPI client (SPSC-only, no max_clients needed)
                    client = new addon.MsgpackClient(shmName);
                    break; // Success!
                }
                catch (err) {
                    // Connection failed, will retry
                    if (attempt === maxAttempts - 1) {
                        // Last attempt failed - check one more time if process exited
                        if (processExited && exitError) {
                            throw exitError;
                        }
                        throw new Error(`Failed to connect to shared memory after ${timeout}ms: ${err.message}`);
                    }
                }
            }
            if (!client) {
                throw new Error('Failed to create client connection');
            }
            return new BarretenbergNativeShmSyncBackend(bbProcess, client, logFd);
        }
        finally {
            // If we failed to connect, ensure the process is killed and log file closed
            // kill() returns false if process already exited, but doesn't throw
            if (!client) {
                bbProcess.kill('SIGKILL');
                if (logFd !== undefined) {
                    try {
                        (0, fs_1.closeSync)(logFd);
                    }
                    catch (e) {
                        // Ignore errors during cleanup
                    }
                }
            }
        }
    }
    call(inputBuffer) {
        try {
            const responseBuffer = this.client.call(Buffer.from(inputBuffer));
            return new Uint8Array(responseBuffer);
        }
        catch (err) {
            throw new Error(`Shared memory call failed: ${err.message}`);
        }
    }
    cleanup() {
        if (this.client) {
            try {
                this.client.close();
            }
            catch (e) {
                // Ignore errors during cleanup
            }
        }
        if (this.logFd !== undefined) {
            try {
                (0, fs_1.closeSync)(this.logFd);
            }
            catch (e) {
                // Ignore errors during cleanup
            }
        }
    }
    destroy() {
        this.cleanup();
        this.process.kill('SIGTERM');
        // Remove process event listeners to prevent hanging
        this.process.removeAllListeners();
    }
}
exports.BarretenbergNativeShmSyncBackend = BarretenbergNativeShmSyncBackend;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF0aXZlX3NobS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iYl9iYWNrZW5kcy9ub2RlL25hdGl2ZV9zaG0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQXVDO0FBQ3ZDLGlEQUFvRDtBQUNwRCwyQkFBcUQ7QUFFckQsK0NBQWdFO0FBQ2hFLG1EQUEwQztBQUUxQyxJQUFJLGVBQWUsR0FBRyxDQUFDLENBQUM7QUFFeEI7Ozs7Ozs7Ozs7R0FVRztBQUNIO0lBQ1UsT0FBTyxDQUFlO0lBQ3RCLE1BQU0sQ0FBTSxDQUFDLDhCQUE4QjtJQUMzQyxLQUFLLENBQVUsQ0FBQywyQkFBMkI7SUFFbkQsWUFBb0IsT0FBcUIsRUFBRSxNQUFXLEVBQUUsS0FBYyxFQUFFO1FBQ3RFLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQUEsQ0FDcEI7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUNkLFlBQW9CLEVBQ3BCLFFBQWdCLEVBQ2hCLE9BQWdCLEVBQ2hCLE1BQThCLEVBQ2E7UUFDM0MseUJBQXlCO1FBQ3pCLG9EQUFvRDtRQUNwRCxNQUFNLFNBQVMsR0FBRyxJQUFBLDRCQUFjLEVBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0MsY0FBYztRQUNkLElBQUksS0FBSyxHQUFRLElBQUksQ0FBQztRQUN0QixJQUFJLENBQUM7WUFDSCxNQUFNLE9BQU8sR0FBRyxJQUFBLHNCQUFhLEVBQUMsSUFBQSw2QkFBZSxHQUFHLENBQUMsQ0FBQztZQUNsRCxLQUFLLEdBQUcsT0FBTyxDQUFDLFNBQVUsQ0FBQyxDQUFDO1FBQzlCLENBQUM7UUFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2IsdUNBQXVDO1lBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQztRQUM1RCxDQUFDO1FBRUQscUNBQXFDO1FBQ3JDLE1BQU0sT0FBTyxHQUFHLFdBQVcsT0FBTyxDQUFDLEdBQUcsSUFBSSx5QkFBUSxJQUFJLGVBQWUsRUFBRSxFQUFFLENBQUM7UUFFMUUsOEZBQThGO1FBQzlGLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDL0MsTUFBTSxHQUFHLEdBQUcsRUFBRSxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFFMUQsNkNBQTZDO1FBQzdDLDZGQUE2RjtRQUM3RixJQUFJLEtBQXlCLENBQUM7UUFDOUIsSUFBSSxPQUEyQixDQUFDO1FBQ2hDLElBQUksTUFBTSxFQUFFLENBQUM7WUFDWCxPQUFPLEdBQUcsUUFBUSxPQUFPLE1BQU0sQ0FBQztZQUNoQyxLQUFLLEdBQUcsSUFBQSxhQUFRLEVBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxrQ0FBa0MsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUN0RCxDQUFDO1FBRUQsNERBQTREO1FBQzVELHlFQUF5RTtRQUN6RSxNQUFNLGNBQWMsR0FBRyxZQUFZLE9BQU8sVUFBVSxDQUFDO1FBQ3JELE1BQU0sZUFBZSxHQUFHLFlBQVksT0FBTyxXQUFXLENBQUM7UUFDdkQsSUFBSSxDQUFDO1lBQ0gsSUFBQSxlQUFVLEVBQUMsY0FBYyxDQUFDLENBQUM7UUFDN0IsQ0FBQztRQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7WUFDYixNQUFNLFVBQVUsR0FBRyxHQUFHLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxJQUFJLE1BQU0sSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxRQUFRLENBQUM7WUFDNUYsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxjQUFjLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQztZQUMzRixDQUFDO1FBQ0gsQ0FBQztRQUVELElBQUksQ0FBQztZQUNILElBQUEsZUFBVSxFQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzlCLENBQUM7UUFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2IsTUFBTSxVQUFVLEdBQUcsR0FBRyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsSUFBSSxNQUFNLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDO1lBQzVGLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztnQkFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQywrQ0FBK0MsZUFBZSxLQUFLLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDNUYsQ0FBQztRQUNILENBQUM7UUFFRCw4RUFBOEU7UUFDOUUsTUFBTSxJQUFJLEdBQUcsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxHQUFHLE9BQU8sTUFBTSxFQUFFLHFCQUFxQixFQUFFLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzFHLE1BQU0sU0FBUyxHQUFHLElBQUEscUJBQUssRUFBQyxZQUFZLEVBQUUsSUFBSSxFQUFFO1lBQzFDLEtBQUssRUFBRSxDQUFDLFFBQVEsRUFBRSxLQUFLLElBQUksUUFBUSxFQUFFLEtBQUssSUFBSSxRQUFRLENBQUM7WUFDdkQsR0FBRztTQUNKLENBQUMsQ0FBQztRQUVILHdFQUF3RTtRQUN4RSwrRUFBK0U7UUFDL0UsbURBQW1EO1FBQ25ELFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUVsQiw4QkFBOEI7UUFDOUIsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBQzFCLElBQUksU0FBUyxHQUFpQixJQUFJLENBQUM7UUFFbkMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUMzQixhQUFhLEdBQUcsSUFBSSxDQUFDO1lBQ3JCLFNBQVMsR0FBRyxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFBQSxDQUN2RSxDQUFDLENBQUM7UUFFSCxTQUFTLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDO1lBQ3JDLGFBQWEsR0FBRyxJQUFJLENBQUM7WUFDckIsSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDaEMsU0FBUyxHQUFHLElBQUksS0FBSyxDQUFDLDJDQUEyQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQzNFLENBQUM7aUJBQU0sSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRSxDQUFDO2dCQUMxQyxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMsNkNBQTZDLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDL0UsQ0FBQztRQUFBLENBQ0YsQ0FBQyxDQUFDO1FBRUgsc0NBQXNDO1FBQ3RDLG1EQUFtRDtRQUNuRCxNQUFNLGFBQWEsR0FBRyxHQUFHLENBQUMsQ0FBQyxLQUFLO1FBQ2hDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLEtBQUs7UUFDM0IsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDLENBQUM7UUFDeEQsSUFBSSxNQUFNLEdBQVEsSUFBSSxDQUFDO1FBRXZCLElBQUksQ0FBQztZQUNILEtBQUssSUFBSSxPQUFPLEdBQUcsQ0FBQyxFQUFFLE9BQU8sR0FBRyxXQUFXLEVBQUUsT0FBTyxFQUFFLEVBQUUsQ0FBQztnQkFDdkQsOERBQThEO2dCQUM5RCxJQUFJLGFBQWEsRUFBRSxDQUFDO29CQUNsQixNQUFNLFNBQVMsSUFBSSxJQUFJLEtBQUssQ0FBQywyREFBMkQsQ0FBQyxDQUFDO2dCQUM1RixDQUFDO2dCQUVELDJEQUEyRDtnQkFDM0QsSUFBSSxPQUFPLEdBQUcsQ0FBQyxFQUFFLENBQUM7b0JBQ2hCLE1BQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUM7Z0JBQ25FLENBQUM7Z0JBRUQsSUFBSSxDQUFDO29CQUNILHdEQUF3RDtvQkFDeEQsTUFBTSxHQUFHLElBQUksS0FBSyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDMUMsTUFBTSxDQUFDLFdBQVc7Z0JBQ3BCLENBQUM7Z0JBQUMsT0FBTyxHQUFRLEVBQUUsQ0FBQztvQkFDbEIsZ0NBQWdDO29CQUNoQyxJQUFJLE9BQU8sS0FBSyxXQUFXLEdBQUcsQ0FBQyxFQUFFLENBQUM7d0JBQ2hDLDhEQUE4RDt3QkFDOUQsSUFBSSxhQUFhLElBQUksU0FBUyxFQUFFLENBQUM7NEJBQy9CLE1BQU0sU0FBUyxDQUFDO3dCQUNsQixDQUFDO3dCQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsNENBQTRDLE9BQU8sT0FBTyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztvQkFDM0YsQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQztZQUVELElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDWixNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxDQUFDLENBQUM7WUFDeEQsQ0FBQztZQUVELE9BQU8sSUFBSSxnQ0FBZ0MsQ0FBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3hFLENBQUM7Z0JBQVMsQ0FBQztZQUNULDRFQUE0RTtZQUM1RSxvRUFBb0U7WUFDcEUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNaLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQzFCLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRSxDQUFDO29CQUN4QixJQUFJLENBQUM7d0JBQ0gsSUFBQSxjQUFTLEVBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ25CLENBQUM7b0JBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQzt3QkFDWCwrQkFBK0I7b0JBQ2pDLENBQUM7Z0JBQ0gsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO0lBQUEsQ0FDRjtJQUVELElBQUksQ0FBQyxXQUF1QixFQUFjO1FBQ3hDLElBQUksQ0FBQztZQUNILE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUNsRSxPQUFPLElBQUksVUFBVSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3hDLENBQUM7UUFBQyxPQUFPLEdBQVEsRUFBRSxDQUFDO1lBQ2xCLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQy9ELENBQUM7SUFBQSxDQUNGO0lBRU8sT0FBTyxHQUFTO1FBQ3RCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2hCLElBQUksQ0FBQztnQkFDSCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3RCLENBQUM7WUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO2dCQUNYLCtCQUErQjtZQUNqQyxDQUFDO1FBQ0gsQ0FBQztRQUNELElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUUsQ0FBQztZQUM3QixJQUFJLENBQUM7Z0JBQ0gsSUFBQSxjQUFTLEVBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3hCLENBQUM7WUFBQyxPQUFPLENBQUMsRUFBRSxDQUFDO2dCQUNYLCtCQUErQjtZQUNqQyxDQUFDO1FBQ0gsQ0FBQztJQUFBLENBQ0Y7SUFFRCxPQUFPLEdBQVM7UUFDZCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDZixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM3QixvREFBb0Q7UUFDcEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0lBQUEsQ0FDbkM7Q0FDRiJ9