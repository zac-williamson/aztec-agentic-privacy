import { IMsgpackBackendAsync } from '../interface.js';
/**
 * Asynchronous shared memory backend that communicates with bb binary via shared memory.
 * Uses NAPI module with background thread polling for async operations.
 * Supports request pipelining - multiple requests can be in flight simultaneously.
 *
 * Architecture (matches socket backend pattern):
 * - bb acts as the SERVER, TypeScript is the CLIENT
 * - bb creates the shared memory region
 * - TypeScript connects via NAPI wrapper (MsgpackClientAsync)
 * - TypeScript manages promise queue (single-threaded, no mutex needed)
 * - C++ background thread polls for responses, calls JavaScript callback
 * - JavaScript callback pops queue and resolves promises in FIFO order
 */
export declare class BarretenbergNativeShmAsyncBackend implements IMsgpackBackendAsync {
    private process;
    private client;
    private logFd?;
    private pendingCallbacks;
    private constructor();
    /**
     * Handle response from C++ background thread
     * Dequeues the next pending callback and resolves it (FIFO order)
     */
    private handleResponse;
    /**
     * Create and initialize an async shared memory backend.
     * @param bbBinaryPath Path to bb binary
     * @param threads Optional number of threads (defaults to min(32, num_cpus))
     * @param logger Optional logger function for bb output
     */
    static new(bbBinaryPath: string, napiPath: string, threads?: number, logger?: (msg: string) => void): Promise<BarretenbergNativeShmAsyncBackend>;
    /**
     * Send a msgpack request asynchronously.
     * Supports pipelining - can be called multiple times before awaiting responses.
     * Use Promise.all() to send multiple requests concurrently.
     *
     * Example:
     *   const results = await Promise.all([
     *     backend.call(buf1),
     *     backend.call(buf2),
     *     backend.call(buf3)
     *   ]);
     *
     * @param inputBuffer The msgpack-encoded request
     * @returns Promise resolving to msgpack-encoded response
     */
    call(inputBuffer: Uint8Array): Promise<Uint8Array>;
    destroy(): Promise<void>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF0aXZlX3NobV9hc3luYy5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JiX2JhY2tlbmRzL25vZGUvbmF0aXZlX3NobV9hc3luYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQU12RDs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxxQkFBYSxpQ0FBa0MsWUFBVyxvQkFBb0I7SUFDNUUsT0FBTyxDQUFDLE9BQU8sQ0FBZTtJQUM5QixPQUFPLENBQUMsTUFBTSxDQUFNO0lBQ3BCLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBUztJQUl2QixPQUFPLENBQUMsZ0JBQWdCLENBR2hCO0lBRVIsT0FBTyxlQVVOO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTyxDQUFDLGNBQWM7SUFnQnRCOzs7OztPQUtHO0lBQ0gsT0FBYSxHQUFHLENBQ2QsWUFBWSxFQUFFLE1BQU0sRUFDcEIsUUFBUSxFQUFFLE1BQU0sRUFDaEIsT0FBTyxDQUFDLEVBQUUsTUFBTSxFQUNoQixNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxNQUFNLEtBQUssSUFBSSxHQUM3QixPQUFPLENBQUMsaUNBQWlDLENBQUMsQ0E0SDVDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7O09BY0c7SUFDRyxJQUFJLENBQUMsV0FBVyxFQUFFLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBMEJ2RDtJQUVLLE9BQU8sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBYzdCO0NBQ0YifQ==