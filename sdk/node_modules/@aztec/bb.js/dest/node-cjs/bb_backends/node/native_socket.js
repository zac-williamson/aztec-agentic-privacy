"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BarretenbergNativeSocketAsyncBackend = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const net = tslib_1.__importStar(require("net"));
const fs = tslib_1.__importStar(require("fs"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const readline_1 = tslib_1.__importDefault(require("readline"));
const worker_threads_1 = require("worker_threads");
let instanceCounter = 0;
/**
 * Asynchronous native backend that communicates with bb binary via Unix Domain Socket.
 * Uses event-based I/O with a state machine to handle partial reads.
 *
 * Architecture: bb acts as the SERVER, TypeScript is the CLIENT
 * - bb creates the socket and listens for connections
 * - TypeScript waits for socket file to exist, then connects
 *
 * Protocol:
 * - Request: 4-byte little-endian length + msgpack buffer
 * - Response: 4-byte little-endian length + msgpack buffer
 */
class BarretenbergNativeSocketAsyncBackend {
    process;
    socket = null;
    socketPath;
    connectionPromise;
    connectionTimeout = null;
    // Queue of pending callbacks for pipelined requests
    // Responses come back in FIFO order, so we match them with queued callbacks
    pendingCallbacks = [];
    // State machine for reading responses
    readingLength = true;
    lengthBuffer = Buffer.alloc(4);
    lengthBytesRead = 0;
    responseLength = 0;
    responseBuffer = null;
    responseBytesRead = 0;
    constructor(bbBinaryPath, threads, logger) {
        // Create a unique socket path in temp directory
        this.socketPath = path.join(os.tmpdir(), `bb-${process.pid}-${worker_threads_1.threadId}-${instanceCounter++}.sock`);
        // Ensure socket path doesn't already exist (cleanup from previous crashes)
        if (fs.existsSync(this.socketPath)) {
            fs.unlinkSync(this.socketPath);
        }
        let connectionResolve = null;
        let connectionReject = null;
        this.connectionPromise = new Promise((resolve, reject) => {
            connectionResolve = resolve;
            connectionReject = reject;
        });
        // If threads not set use num cpu cores, max 16.
        const hwc = threads ? threads.toString() : Math.min(16, os.cpus().length).toString();
        const env = { ...process.env, HARDWARE_CONCURRENCY: hwc };
        // Spawn bb process - it will create the socket server
        const args = ['msgpack', 'run', '--input', this.socketPath];
        this.process = (0, child_process_1.spawn)(bbBinaryPath, args, {
            stdio: ['ignore', logger ? 'pipe' : 'ignore', logger ? 'pipe' : 'ignore'],
            env,
        });
        // Disconnect from event loop so process can exit without waiting for bb
        // The bb process has parent death monitoring (prctl on Linux, kqueue on macOS)
        // so it will automatically exit when Node.js exits
        this.process.unref();
        if (logger) {
            logger("Logger attached to bb process. DON'T FORGET TO DESTROY THE BACKEND to allow Node.js to exit.");
            readline_1.default.createInterface({ input: this.process.stdout }).on('line', logger);
            readline_1.default.createInterface({ input: this.process.stderr }).on('line', logger);
        }
        this.process.on('error', err => {
            if (connectionReject) {
                connectionReject(new Error(`Native backend process error: ${err.message}`));
                connectionReject = null;
                connectionResolve = null;
            }
            // Reject all pending callbacks
            const error = new Error(`Native backend process error: ${err.message}`);
            for (const callback of this.pendingCallbacks) {
                callback.reject(error);
            }
            this.pendingCallbacks = [];
        });
        this.process.on('exit', (code, signal) => {
            const errorMsg = code !== null && code !== 0
                ? `Native backend process exited with code ${code}`
                : signal && signal !== 'SIGTERM'
                    ? `Native backend process killed with signal ${signal}`
                    : 'Native backend process exited unexpectedly';
            if (connectionReject) {
                connectionReject(new Error(errorMsg));
                connectionReject = null;
                connectionResolve = null;
            }
            // Reject all pending callbacks
            const error = new Error(errorMsg);
            for (const callback of this.pendingCallbacks) {
                callback.reject(error);
            }
            this.pendingCallbacks = [];
        });
        // Wait for bb to create socket file, then connect
        this.waitForSocketAndConnect()
            .then(() => {
            if (connectionResolve) {
                connectionResolve();
                connectionResolve = null;
                connectionReject = null;
            }
        })
            .catch(err => {
            if (connectionReject) {
                connectionReject(err);
                connectionReject = null;
                connectionResolve = null;
            }
        });
        // Set a timeout for connection
        this.connectionTimeout = setTimeout(() => {
            if (connectionReject) {
                connectionReject(new Error('Timeout waiting for bb socket connection'));
                connectionReject = null;
                connectionResolve = null;
                this.cleanup();
            }
        }, 5000);
    }
    async waitForSocketAndConnect() {
        // Poll for socket file to exist (bb is creating it)
        const startTime = Date.now();
        while (!fs.existsSync(this.socketPath)) {
            if (Date.now() - startTime > 5000) {
                throw new Error('Timeout waiting for bb to create socket file');
            }
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        // Additional check: ensure it's actually a socket
        const stats = fs.statSync(this.socketPath);
        if (!stats.isSocket()) {
            throw new Error(`Path exists but is not a socket: ${this.socketPath}`);
        }
        // Connect to bb's socket server as a client
        return new Promise((resolve, reject) => {
            this.socket = net.connect(this.socketPath);
            // Disable Nagle's algorithm for lower latency
            this.socket.setNoDelay(true);
            // Set up event handlers
            this.socket.once('connect', () => {
                // Socket starts referenced - will be unreferenced when no callbacks pending
                // Clear connection timeout on successful connection
                if (this.connectionTimeout) {
                    clearTimeout(this.connectionTimeout);
                    this.connectionTimeout = null;
                }
                resolve();
            });
            this.socket.once('error', err => {
                reject(new Error(`Failed to connect to bb socket: ${err.message}`));
            });
            // Set up data handler after connection is established
            this.socket.on('data', (chunk) => {
                this.handleData(chunk);
            });
            // Handle ongoing errors after initial connection
            this.socket.on('error', err => {
                // Reject all pending callbacks
                const error = new Error(`Socket error: ${err.message}`);
                for (const callback of this.pendingCallbacks) {
                    callback.reject(error);
                }
                this.pendingCallbacks = [];
            });
            this.socket.on('end', () => {
                // Reject all pending callbacks
                const error = new Error('Socket connection ended unexpectedly');
                for (const callback of this.pendingCallbacks) {
                    callback.reject(error);
                }
                this.pendingCallbacks = [];
            });
        });
    }
    handleData(chunk) {
        let offset = 0;
        while (offset < chunk.length) {
            if (this.readingLength) {
                // Reading 4-byte length prefix
                const bytesToCopy = Math.min(4 - this.lengthBytesRead, chunk.length - offset);
                chunk.copy(this.lengthBuffer, this.lengthBytesRead, offset, offset + bytesToCopy);
                this.lengthBytesRead += bytesToCopy;
                offset += bytesToCopy;
                if (this.lengthBytesRead === 4) {
                    // Length is complete, switch to reading data
                    this.responseLength = this.lengthBuffer.readUInt32LE(0);
                    this.responseBuffer = Buffer.alloc(this.responseLength);
                    this.responseBytesRead = 0;
                    this.readingLength = false;
                }
            }
            else {
                // Reading response data
                const bytesToCopy = Math.min(this.responseLength - this.responseBytesRead, chunk.length - offset);
                chunk.copy(this.responseBuffer, this.responseBytesRead, offset, offset + bytesToCopy);
                this.responseBytesRead += bytesToCopy;
                offset += bytesToCopy;
                if (this.responseBytesRead === this.responseLength) {
                    // Response is complete - dequeue the next pending callback (FIFO)
                    const callback = this.pendingCallbacks.shift();
                    if (callback) {
                        callback.resolve(new Uint8Array(this.responseBuffer));
                    }
                    else {
                        // This shouldn't happen - response without a pending request
                        console.warn('Received response but no pending callback');
                    }
                    // If no more pending callbacks, unref socket to allow process to exit
                    if (this.pendingCallbacks.length === 0 && this.socket) {
                        this.socket.unref();
                    }
                    // Reset state for next message
                    this.readingLength = true;
                    this.lengthBytesRead = 0;
                    this.responseLength = 0;
                    this.responseBuffer = null;
                    this.responseBytesRead = 0;
                }
            }
        }
    }
    async call(inputBuffer) {
        // Wait for connection to be established
        await this.connectionPromise;
        if (!this.socket) {
            throw new Error('Socket not connected');
        }
        return new Promise((resolve, reject) => {
            // If this is the first pending callback, ref the socket to keep event loop alive
            if (this.pendingCallbacks.length === 0) {
                this.socket.ref();
            }
            // Enqueue this promise's callbacks (FIFO order)
            this.pendingCallbacks.push({ resolve, reject });
            // Write request: 4-byte little-endian length + msgpack data
            // Socket will buffer these if needed, maintaining order
            const lengthBuf = Buffer.alloc(4);
            lengthBuf.writeUInt32LE(inputBuffer.length, 0);
            this.socket.write(lengthBuf);
            this.socket.write(inputBuffer);
        });
    }
    cleanup() {
        // Reject any remaining pending callbacks
        const error = new Error('Backend connection closed');
        for (const callback of this.pendingCallbacks) {
            callback.reject(error);
        }
        this.pendingCallbacks = [];
        try {
            // Remove all event listeners to prevent hanging
            if (this.socket) {
                this.socket.removeAllListeners();
                // Unref so socket doesn't keep event loop alive
                // this.socket.unref();
                this.socket.destroy();
            }
        }
        catch (e) {
            // Ignore errors during cleanup
        }
        // Clear connection timeout if still pending
        if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
            this.connectionTimeout = null;
        }
        // Remove process event listeners and unref to not block event loop
        this.process.removeAllListeners();
        // this.process.unref();
        // Don't try to unlink socket - bb owns it and will clean it up
    }
    async destroy() {
        this.cleanup();
        this.process.kill('SIGTERM');
        this.process.removeAllListeners();
    }
}
exports.BarretenbergNativeSocketAsyncBackend = BarretenbergNativeSocketAsyncBackend;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF0aXZlX3NvY2tldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iYl9iYWNrZW5kcy9ub2RlL25hdGl2ZV9zb2NrZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlEQUFvRDtBQUNwRCxNQUFZLEdBQUcsd0NBQVk7QUFDM0IsTUFBWSxFQUFFLHVDQUFXO0FBQ3pCLE1BQVksRUFBRSx1Q0FBVztBQUN6QixNQUFZLElBQUkseUNBQWE7QUFFN0IsZ0VBQWdDO0FBQ2hDLG1EQUEwQztBQUUxQyxJQUFJLGVBQWUsR0FBRyxDQUFDLENBQUM7QUFFeEI7Ozs7Ozs7Ozs7O0dBV0c7QUFDSDtJQUNVLE9BQU8sQ0FBZTtJQUN0QixNQUFNLEdBQXNCLElBQUksQ0FBQztJQUNqQyxVQUFVLENBQVM7SUFDbkIsaUJBQWlCLENBQWdCO0lBQ2pDLGlCQUFpQixHQUEwQixJQUFJLENBQUM7SUFFeEQsb0RBQW9EO0lBQ3BELDRFQUE0RTtJQUNwRSxnQkFBZ0IsR0FHbkIsRUFBRSxDQUFDO0lBRVIsc0NBQXNDO0lBQzlCLGFBQWEsR0FBWSxJQUFJLENBQUM7SUFDOUIsWUFBWSxHQUFXLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkMsZUFBZSxHQUFXLENBQUMsQ0FBQztJQUM1QixjQUFjLEdBQVcsQ0FBQyxDQUFDO0lBQzNCLGNBQWMsR0FBa0IsSUFBSSxDQUFDO0lBQ3JDLGlCQUFpQixHQUFXLENBQUMsQ0FBQztJQUV0QyxZQUFZLFlBQW9CLEVBQUUsT0FBZ0IsRUFBRSxNQUE4QixFQUFFO1FBQ2xGLGdEQUFnRDtRQUNoRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLE1BQU0sT0FBTyxDQUFDLEdBQUcsSUFBSSx5QkFBUSxJQUFJLGVBQWUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVwRywyRUFBMkU7UUFDM0UsSUFBSSxF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