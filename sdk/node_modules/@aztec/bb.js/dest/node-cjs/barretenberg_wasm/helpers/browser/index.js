"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ready = void 0;
exports.getSharedMemoryAvailable = getSharedMemoryAvailable;
exports.getRemoteBarretenbergWasm = getRemoteBarretenbergWasm;
exports.getNumCpu = getNumCpu;
exports.threadLogger = threadLogger;
exports.killSelf = killSelf;
exports.getAvailableThreads = getAvailableThreads;
exports.readinessListener = readinessListener;
const comlink_1 = require("comlink");
function getSharedMemoryAvailable() {
    const globalScope = typeof window !== 'undefined' ? window : globalThis;
    return typeof SharedArrayBuffer !== 'undefined' && globalScope.crossOriginIsolated;
}
function getRemoteBarretenbergWasm(worker) {
    return (0, comlink_1.wrap)(worker);
}
function getNumCpu() {
    return navigator.hardwareConcurrency;
}
function threadLogger(useCustomLogger) {
    if (useCustomLogger) {
        // Post log messages back to main thread for routing through user-provided logger
        return (msg) => {
            postMessage({ type: 'log', msg });
        };
    }
    // Use console.log directly when no custom logger is provided
    return console.log;
}
function killSelf() {
    self.close();
}
function getAvailableThreads(logger) {
    if (typeof navigator !== 'undefined' && navigator.hardwareConcurrency) {
        return navigator.hardwareConcurrency;
    }
    else {
        logger(`Could not detect environment to query number of threads. Falling back to one thread.`);
        return 1;
    }
}
// Solution to async initialization of workers, taken from
// https://github.com/GoogleChromeLabs/comlink/issues/635#issuecomment-1598913044
/** The message expected by the `readinessListener`. */
exports.Ready = { ready: true };
/** Listen for the readiness message from the Worker and call the `callback` once. */
function readinessListener(worker, callback) {
    worker.addEventListener('message', function ready(event) {
        if (!!event.data && event.data.ready === true) {
            worker.removeEventListener('message', ready);
            callback();
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vaGVscGVycy9icm93c2VyL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxxQ0FBK0I7QUFFL0Isb0NBQTJDO0lBQ3pDLE1BQU0sV0FBVyxHQUFHLE9BQU8sTUFBTSxLQUFLLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7SUFDeEUsT0FBTyxPQUFPLGlCQUFpQixLQUFLLFdBQVcsSUFBSSxXQUFXLENBQUMsbUJBQW1CLENBQUM7QUFBQSxDQUNwRjtBQUVELG1DQUE2QyxNQUFjLEVBQUU7SUFDM0QsT0FBTyxJQUFBLGNBQUksRUFBSSxNQUFNLENBQUMsQ0FBQztBQUFBLENBQ3hCO0FBRUQscUJBQTRCO0lBQzFCLE9BQU8sU0FBUyxDQUFDLG1CQUFtQixDQUFDO0FBQUEsQ0FDdEM7QUFFRCxzQkFBNkIsZUFBd0IsRUFBdUM7SUFDMUYsSUFBSSxlQUFlLEVBQUUsQ0FBQztRQUNwQixpRkFBaUY7UUFDakYsT0FBTyxDQUFDLEdBQVcsRUFBRSxFQUFFLENBQUM7WUFDdEIsV0FBVyxDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQUEsQ0FDbkMsQ0FBQztJQUNKLENBQUM7SUFDRCw2REFBNkQ7SUFDN0QsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDO0FBQUEsQ0FDcEI7QUFFRCxvQkFBMkI7SUFDekIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQUEsQ0FDZDtBQUVELDZCQUFvQyxNQUE2QixFQUFVO0lBQ3pFLElBQUksT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1FBQ3RFLE9BQU8sU0FBUyxDQUFDLG1CQUFtQixDQUFDO0lBQ3ZDLENBQUM7U0FBTSxDQUFDO1FBQ04sTUFBTSxDQUFDLHNGQUFzRixDQUFDLENBQUM7UUFDL0YsT0FBTyxDQUFDLENBQUM7SUFDWCxDQUFDO0FBQUEsQ0FDRjtBQUVELDBEQUEwRDtBQUMxRCxpRkFBaUY7QUFFakYsdURBQXVEO0FBQzFDLFFBQUEsS0FBSyxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDO0FBRXJDLHFGQUFxRjtBQUNyRiwyQkFBa0MsTUFBYyxFQUFFLFFBQW9CLEVBQUU7SUFDdEUsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxTQUFTLEtBQUssQ0FBQyxLQUFpQyxFQUFFO1FBQ25GLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxFQUFFLENBQUM7WUFDOUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUM3QyxRQUFRLEVBQUUsQ0FBQztRQUNiLENBQUM7SUFBQSxDQUNGLENBQUMsQ0FBQztBQUFBLENBQ0oifQ==