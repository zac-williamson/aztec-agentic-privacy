"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
exports.getSharedMemoryAvailable = getSharedMemoryAvailable;
exports.getRemoteBarretenbergWasm = getRemoteBarretenbergWasm;
exports.getNumCpu = getNumCpu;
exports.threadLogger = threadLogger;
exports.killSelf = killSelf;
exports.getAvailableThreads = getAvailableThreads;
const worker_threads_1 = require("worker_threads");
const os_1 = tslib_1.__importDefault(require("os"));
const comlink_1 = require("comlink");
const node_endpoint_js_1 = require("./node_endpoint.js");
const fs_1 = require("fs");
function getSharedMemoryAvailable() {
    return true;
}
/**
 * Comlink allows you to produce a Proxy to the worker, enabling you to call methods as if it were a normal class.
 * Note we give it the type information it needs so the returned Proxy object looks like that type.
 * Node has a different implementation, needing this nodeEndpoint wrapper, hence this function exists here.
 */
function getRemoteBarretenbergWasm(worker) {
    return (0, comlink_1.wrap)((0, node_endpoint_js_1.nodeEndpoint)(worker));
}
/**
 * Returns number of cpus as reported by the system, unless overriden by HARDWARE_CONCURRENCY env var.
 */
function getNumCpu() {
    return +process.env.HARDWARE_CONCURRENCY || os_1.default.cpus().length;
}
/**
 * Returns a logger function for worker threads.
 * When a custom logger is provided, posts messages back to the main thread.
 * Otherwise, writes directly to stdout.
 */
function threadLogger(useCustomLogger) {
    if (useCustomLogger) {
        return (msg) => {
            if (worker_threads_1.parentPort) {
                worker_threads_1.parentPort.postMessage({ type: 'log', msg });
            }
        };
    }
    // Write directly to stdout when no custom logger is provided
    return (msg) => {
        (0, fs_1.writeSync)(1, msg + '\n');
    };
}
function killSelf() {
    // Extordinarily hard process termination. Due to how parent threads block on child threads etc, even process.exit
    // doesn't seem to be able to abort the process. The following does.
    process.kill(process.pid);
    throw new Error();
}
function getAvailableThreads(logger) {
    try {
        return os_1.default.cpus().length;
    }
    catch (e) {
        logger(`Could not detect environment to query number of threads. Falling back to one thread. Error: ${e.message ?? e}`);
        return 1;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vaGVscGVycy9ub2RlL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLG1EQUFvRDtBQUNwRCxvREFBb0I7QUFDcEIscUNBQStCO0FBQy9CLHlEQUFrRDtBQUNsRCwyQkFBK0I7QUFFL0Isb0NBQTJDO0lBQ3pDLE9BQU8sSUFBSSxDQUFDO0FBQUEsQ0FDYjtBQUVEOzs7O0dBSUc7QUFDSCxtQ0FBNkMsTUFBYyxFQUFFO0lBQzNELE9BQU8sSUFBQSxjQUFJLEVBQUksSUFBQSwrQkFBWSxFQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFBQSxDQUN0QztBQUVEOztHQUVHO0FBQ0gscUJBQTRCO0lBQzFCLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLG9CQUFxQixJQUFJLFlBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUM7QUFBQSxDQUMvRDtBQUVEOzs7O0dBSUc7QUFDSCxzQkFBNkIsZUFBd0IsRUFBdUM7SUFDMUYsSUFBSSxlQUFlLEVBQUUsQ0FBQztRQUNwQixPQUFPLENBQUMsR0FBVyxFQUFFLEVBQUUsQ0FBQztZQUN0QixJQUFJLDJCQUFVLEVBQUUsQ0FBQztnQkFDZiwyQkFBVSxDQUFDLFdBQVcsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUMvQyxDQUFDO1FBQUEsQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUNELDZEQUE2RDtJQUM3RCxPQUFPLENBQUMsR0FBVyxFQUFFLEVBQUUsQ0FBQztRQUN0QixJQUFBLGNBQVMsRUFBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQUEsQ0FDMUIsQ0FBQztBQUFBLENBQ0g7QUFFRCxvQkFBa0M7SUFDaEMsa0hBQWtIO0lBQ2xILG9FQUFvRTtJQUNwRSxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMxQixNQUFNLElBQUksS0FBSyxFQUFFLENBQUM7QUFBQSxDQUNuQjtBQUVELDZCQUFvQyxNQUE2QixFQUFVO0lBQ3pFLElBQUksQ0FBQztRQUNILE9BQU8sWUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQztJQUMxQixDQUFDO0lBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztRQUNoQixNQUFNLENBQ0osK0ZBQStGLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQ2hILENBQUM7UUFDRixPQUFPLENBQUMsQ0FBQztJQUNYLENBQUM7QUFBQSxDQUNGIn0=