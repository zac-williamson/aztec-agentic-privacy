"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeapAllocator = void 0;
/**
 * Keeps track of heap allocations so they can be easily freed.
 * The WASM memory layout has 1024 bytes of unused "scratch" space at the start (addresses 0-1023).
 * We can leverage this for IO rather than making expensive bb_malloc bb_free calls.
 * Heap allocations will be created for input/output args that don't fit into the scratch space.
 * Input scratch grows UP from 0, output scratch grows DOWN from 1024, meeting in the middle.
 * This maximizes space utilization while preventing overlap.
 */
class HeapAllocator {
    wasm;
    allocs = [];
    inScratchPtr = 0; // Next input starts here, grows UP
    outScratchPtr = 1024; // Next output ends here, grows DOWN
    constructor(wasm) {
        this.wasm = wasm;
    }
    getInputs(buffers) {
        return buffers.map(bufOrNum => {
            if (typeof bufOrNum === 'object') {
                const size = bufOrNum.length;
                // Check if there's room in scratch space (inputs grow up, outputs grow down)
                if (this.inScratchPtr + size <= this.outScratchPtr) {
                    const ptr = this.inScratchPtr;
                    this.inScratchPtr += size; // Grow UP
                    this.wasm.writeMemory(ptr, bufOrNum);
                    return ptr;
                }
                else {
                    // Fall back to heap allocation
                    const ptr = this.wasm.call('bbmalloc', size);
                    this.wasm.writeMemory(ptr, bufOrNum);
                    this.allocs.push(ptr);
                    return ptr;
                }
            }
            else {
                return bufOrNum;
            }
        });
    }
    getOutputPtrs(outLens) {
        return outLens.map(len => {
            // If the obj is variable length, we need a 4 byte ptr to write the serialized data address to.
            // WARNING: 4 only works with WASM as it has 32 bit memory.
            const size = len || 4;
            // Check if there's room in scratch space (inputs grow up, outputs grow down)
            if (this.inScratchPtr + size <= this.outScratchPtr) {
                this.outScratchPtr -= size; // Grow DOWN
                return this.outScratchPtr;
            }
            else {
                // Fall back to heap allocation
                const ptr = this.wasm.call('bbmalloc', size);
                this.allocs.push(ptr);
                return ptr;
            }
        });
    }
    addOutputPtr(ptr) {
        // Only add to dealloc list if it's a heap allocation (not in scratch space 0-1023)
        if (ptr >= 1024) {
            this.allocs.push(ptr);
        }
    }
    freeAll() {
        for (const ptr of this.allocs) {
            this.wasm.call('bbfree', ptr);
        }
    }
}
exports.HeapAllocator = HeapAllocator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVhcF9hbGxvY2F0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vYmFycmV0ZW5iZXJnX3dhc21fbWFpbi9oZWFwX2FsbG9jYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQTs7Ozs7OztHQU9HO0FBQ0g7SUFLc0IsSUFBSTtJQUpoQixNQUFNLEdBQWEsRUFBRSxDQUFDO0lBQ3RCLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBQyxtQ0FBbUM7SUFDckQsYUFBYSxHQUFHLElBQUksQ0FBQyxDQUFDLG9DQUFvQztJQUVsRSxZQUFvQixJQUEwQixFQUFFO29CQUE1QixJQUFJO0lBQXlCLENBQUM7SUFFbEQsU0FBUyxDQUFDLE9BQWdDLEVBQUU7UUFDMUMsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFDN0IsSUFBSSxPQUFPLFFBQVEsS0FBSyxRQUFRLEVBQUUsQ0FBQztnQkFDakMsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztnQkFDN0IsNkVBQTZFO2dCQUM3RSxJQUFJLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztvQkFDbkQsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztvQkFDOUIsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsQ0FBQyxVQUFVO29CQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7b0JBQ3JDLE9BQU8sR0FBRyxDQUFDO2dCQUNiLENBQUM7cUJBQU0sQ0FBQztvQkFDTiwrQkFBK0I7b0JBQy9CLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO29CQUNyQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDdEIsT0FBTyxHQUFHLENBQUM7Z0JBQ2IsQ0FBQztZQUNILENBQUM7aUJBQU0sQ0FBQztnQkFDTixPQUFPLFFBQVEsQ0FBQztZQUNsQixDQUFDO1FBQUEsQ0FDRixDQUFDLENBQUM7SUFBQSxDQUNKO0lBRUQsYUFBYSxDQUFDLE9BQStCLEVBQUU7UUFDN0MsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDeEIsK0ZBQStGO1lBQy9GLDJEQUEyRDtZQUMzRCxNQUFNLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDO1lBRXRCLDZFQUE2RTtZQUM3RSxJQUFJLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztnQkFDbkQsSUFBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsQ0FBQyxZQUFZO2dCQUN4QyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7WUFDNUIsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLCtCQUErQjtnQkFDL0IsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUM3QyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDdEIsT0FBTyxHQUFHLENBQUM7WUFDYixDQUFDO1FBQUEsQ0FDRixDQUFDLENBQUM7SUFBQSxDQUNKO0lBRUQsWUFBWSxDQUFDLEdBQVcsRUFBRTtRQUN4QixtRkFBbUY7UUFDbkYsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7WUFDaEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEIsQ0FBQztJQUFBLENBQ0Y7SUFFRCxPQUFPLEdBQUc7UUFDUixLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDaEMsQ0FBQztJQUFBLENBQ0Y7Q0FDRiJ9