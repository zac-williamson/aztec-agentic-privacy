"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AztecClientBackend = exports.UltraHonkBackend = exports.UltraHonkVerifierBackend = exports.AztecClientBackendError = void 0;
exports.fieldToString = fieldToString;
exports.fieldsToStrings = fieldsToStrings;
const index_js_1 = require("../proof/index.js");
const api_types_js_1 = require("../cbind/generated/api_types.js");
const pako_1 = require("pako");
const msgpackr_1 = require("msgpackr");
class AztecClientBackendError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.AztecClientBackendError = AztecClientBackendError;
function getProofSettingsFromOptions(options) {
    // Check for conflicting options - verifierTarget should not be combined with legacy options
    if (options?.verifierTarget) {
        const legacyOptions = [options.keccak, options.keccakZK, options.starknet, options.starknetZK].filter(Boolean);
        if (legacyOptions.length > 0) {
            throw new Error('Cannot use verifierTarget with legacy options (keccak, keccakZK, starknet, starknetZK). ' +
                'Use verifierTarget alone.');
        }
        switch (options.verifierTarget) {
            case 'evm':
                return { ipaAccumulation: false, oracleHashType: 'keccak', disableZk: false, optimizedSolidityVerifier: false };
            case 'evm-no-zk':
                return { ipaAccumulation: false, oracleHashType: 'keccak', disableZk: true, optimizedSolidityVerifier: false };
            case 'noir-recursive':
                return {
                    ipaAccumulation: false,
                    oracleHashType: 'poseidon2',
                    disableZk: false,
                    optimizedSolidityVerifier: false,
                };
            case 'noir-recursive-no-zk':
                return {
                    ipaAccumulation: false,
                    oracleHashType: 'poseidon2',
                    disableZk: true,
                    optimizedSolidityVerifier: false,
                };
            case 'noir-rollup':
                return {
                    ipaAccumulation: true,
                    oracleHashType: 'poseidon2',
                    disableZk: false,
                    optimizedSolidityVerifier: false,
                };
            case 'noir-rollup-no-zk':
                return {
                    ipaAccumulation: true,
                    oracleHashType: 'poseidon2',
                    disableZk: true,
                    optimizedSolidityVerifier: false,
                };
            case 'starknet':
                return {
                    ipaAccumulation: false,
                    oracleHashType: 'starknet',
                    disableZk: false,
                    optimizedSolidityVerifier: false,
                };
            case 'starknet-no-zk':
                return {
                    ipaAccumulation: false,
                    oracleHashType: 'starknet',
                    disableZk: true,
                    optimizedSolidityVerifier: false,
                };
        }
    }
    // Legacy options support (deprecated)
    return {
        ipaAccumulation: false,
        oracleHashType: options?.keccak || options?.keccakZK
            ? 'keccak'
            : options?.starknet || options?.starknetZK
                ? 'starknet'
                : 'poseidon2',
        disableZk: options?.keccak || options?.starknet ? true : false,
        optimizedSolidityVerifier: false,
    };
}
class UltraHonkVerifierBackend {
    api;
    constructor(api) {
        this.api = api;
    }
    async verifyProof(proofData, options) {
        const proofFrs = [];
        for (let i = 0; i < proofData.proof.length; i += 32) {
            proofFrs.push(proofData.proof.slice(i, i + 32));
        }
        const { verified } = await this.api.circuitVerify({
            verificationKey: proofData.verificationKey,
            publicInputs: proofData.publicInputs.map(index_js_1.hexToUint8Array),
            proof: proofFrs,
            settings: getProofSettingsFromOptions(options),
        });
        return verified;
    }
}
exports.UltraHonkVerifierBackend = UltraHonkVerifierBackend;
class UltraHonkBackend {
    api;
    // These type assertions are used so that we don't
    // have to initialize `api` in the constructor.
    // These are initialized asynchronously in the `init` function,
    // constructors cannot be asynchronous which is why we do this.
    acirUncompressedBytecode;
    constructor(acirBytecode, api) {
        this.api = api;
        this.acirUncompressedBytecode = acirToUint8Array(acirBytecode);
    }
    async generateProof(compressedWitness, options) {
        const witness = (0, pako_1.ungzip)(compressedWitness);
        const { proof, publicInputs } = await this.api.circuitProve({
            witness,
            circuit: {
                name: 'circuit',
                bytecode: this.acirUncompressedBytecode,
                verificationKey: new Uint8Array(0), // Empty VK - lower performance.
            },
            settings: getProofSettingsFromOptions(options),
        });
        console.log(`Generated proof for circuit with ${publicInputs.length} public inputs and ${proof.length} fields.`);
        // We return ProofData as a flat buffer and an array of strings to match the current ProofData class.
        const flatProof = new Uint8Array(proof.length * 32);
        proof.forEach((fr, i) => {
            flatProof.set(fr, i * 32);
        });
        return { proof: flatProof, publicInputs: publicInputs.map(index_js_1.uint8ArrayToHex) };
    }
    async verifyProof(proofData, options) {
        const proofFrs = [];
        for (let i = 0; i < proofData.proof.length; i += 32) {
            proofFrs.push(proofData.proof.slice(i, i + 32));
        }
        // TODO reconsider API - computing the VK at this point is not optimal
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: this.acirUncompressedBytecode,
            },
            settings: getProofSettingsFromOptions(options),
        });
        const { verified } = await this.api.circuitVerify({
            verificationKey: vkResult.bytes,
            publicInputs: proofData.publicInputs.map(index_js_1.hexToUint8Array),
            proof: proofFrs,
            settings: getProofSettingsFromOptions(options),
        });
        return verified;
    }
    async getVerificationKey(options) {
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: this.acirUncompressedBytecode,
            },
            settings: getProofSettingsFromOptions(options),
        });
        return vkResult.bytes;
    }
    /** @description Returns a solidity verifier */
    async getSolidityVerifier(vk, options) {
        const result = await this.api.circuitWriteSolidityVerifier({
            verificationKey: vk,
            settings: getProofSettingsFromOptions(options),
        });
        return result.solidityCode;
    }
    // TODO(https://github.com/noir-lang/noir/issues/5661): Update this to handle Honk recursive aggregation in the browser once it is ready in the backend itself
    async generateRecursiveProofArtifacts(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _proof, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _numOfPublicInputs, options) {
        // TODO(https://github.com/noir-lang/noir/issues/5661): This needs to be updated to handle recursive aggregation.
        // There is still a proofAsFields method but we could consider getting rid of it as the proof itself
        // is a list of field elements.
        // UltraHonk also does not have public inputs directly prepended to the proof and they are still instead
        // inserted at an offset.
        // const proof = reconstructProofWithPublicInputs(proofData);
        // const proofAsFields = (await this.api.acirProofAsFieldsUltraHonk(proof)).slice(numOfPublicInputs);
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: this.acirUncompressedBytecode,
            },
            settings: getProofSettingsFromOptions(options),
        });
        // Convert VK bytes to field elements (32-byte chunks)
        const vkAsFields = [];
        for (let i = 0; i < vkResult.bytes.length; i += 32) {
            const chunk = vkResult.bytes.slice(i, i + 32);
            vkAsFields.push((0, index_js_1.uint8ArrayToHex)(chunk));
        }
        return {
            // TODO(https://github.com/noir-lang/noir/issues/5661)
            proofAsFields: [],
            vkAsFields,
            // We use an empty string for the vk hash here as it is unneeded as part of the recursive artifacts
            // The user can be expected to hash the vk inside their circuit to check whether the vk is the circuit
            // they expect
            vkHash: (0, index_js_1.uint8ArrayToHex)(vkResult.hash),
        };
    }
}
exports.UltraHonkBackend = UltraHonkBackend;
class AztecClientBackend {
    acirBuf;
    api;
    circuitNames;
    // These type assertions are used so that we don't
    // have to initialize `api` in the constructor.
    // These are initialized asynchronously in the `init` function,
    // constructors cannot be asynchronous which is why we do this.
    constructor(acirBuf, api, circuitNames = []) {
        this.acirBuf = acirBuf;
        this.api = api;
        this.circuitNames = circuitNames;
    }
    async prove(witnessBuf, vksBuf = []) {
        if (vksBuf.length !== 0 && this.acirBuf.length !== witnessBuf.length) {
            throw new AztecClientBackendError('Witness and bytecodes must have the same stack depth!');
        }
        if (vksBuf.length !== 0 && vksBuf.length !== witnessBuf.length) {
            // NOTE: we allow 0 as an explicit 'I have no VKs'. This is a deprecated feature.
            throw new AztecClientBackendError('Witness and VKs must have the same stack depth!');
        }
        // Queue IVC start with the number of circuits
        this.api.chonkStart({ numCircuits: this.acirBuf.length });
        // Queue load and accumulate for each circuit
        for (let i = 0; i < this.acirBuf.length; i++) {
            const bytecode = this.acirBuf[i];
            const witness = witnessBuf[i] || new Uint8Array(0);
            const vk = vksBuf[i] || new Uint8Array(0);
            const functionName = this.circuitNames[i] || `circuit_${i}`;
            // Load the circuit
            this.api.chonkLoad({
                circuit: {
                    name: functionName,
                    bytecode: bytecode,
                    verificationKey: vk,
                },
            });
            // Accumulate with witness
            this.api.chonkAccumulate({
                witness,
            });
        }
        // Generate the proof (and wait for all previous steps to finish)
        const proveResult = await this.api.chonkProve({});
        // The API currently expects a msgpack-encoded API.
        const proof = new msgpackr_1.Encoder({ useRecords: false }).encode((0, api_types_js_1.fromChonkProof)(proveResult.proof));
        // Generate the VK
        const lastIdx = this.acirBuf.length - 1;
        const vkResult = await this.api.chonkComputeVk({
            circuit: {
                name: this.circuitNames[lastIdx] || 'circuit',
                bytecode: this.acirBuf[lastIdx],
            },
        });
        const proofFields = [
            proveResult.proof.megaProof,
            proveResult.proof.goblinProof.mergeProof,
            proveResult.proof.goblinProof.eccvmProof,
            proveResult.proof.goblinProof.ipaProof,
            proveResult.proof.goblinProof.translatorProof,
        ].flat();
        // Verify using native proof directly to avoid redundant encode/decode cycle
        if (!(await this.verifyNative(proveResult.proof, vkResult.bytes))) {
            throw new AztecClientBackendError('Failed to verify the private (Chonk) transaction proof!');
        }
        return [proofFields, proof, vkResult.bytes];
    }
    async verify(proof, vk) {
        const result = await this.api.chonkVerify({
            proof: (0, api_types_js_1.toChonkProof)(new msgpackr_1.Decoder({ useRecords: false }).decode(proof)),
            vk,
        });
        return result.valid;
    }
    /**
     * Internal verification using native ChonkProof type.
     * Avoids encode/decode cycle when called from prove().
     */
    async verifyNative(proof, vk) {
        const result = await this.api.chonkVerify({
            proof,
            vk,
        });
        return result.valid;
    }
    async gates() {
        const circuitSizes = [];
        for (let i = 0; i < this.acirBuf.length; i++) {
            const gates = await this.api.chonkStats({
                circuit: {
                    name: this.circuitNames[i] || `circuit_${i}`,
                    bytecode: this.acirBuf[i],
                },
                includeGatesPerOpcode: false,
            });
            circuitSizes.push(gates.circuitSize);
        }
        return circuitSizes;
    }
}
exports.AztecClientBackend = AztecClientBackend;
// Converts bytecode from a base64 string to a Uint8Array
function acirToUint8Array(base64EncodedBytecode) {
    const compressedByteCode = base64Decode(base64EncodedBytecode);
    return (0, pako_1.ungzip)(compressedByteCode);
}
// Base64 decode using atob (works in both browser and Node.js 18+)
function base64Decode(input) {
    if (typeof atob === 'function') {
        return Uint8Array.from(atob(input), c => c.charCodeAt(0));
    }
    else {
        throw new Error('atob is not available. Node.js 18+ or browser required.');
    }
}
/**
 * Convert a field element (32-byte Uint8Array) to a string.
 *
 * @param field - A 32-byte field element
 * @param radix - The radix for string conversion (2-36), defaults to 10 (decimal)
 * @returns The field value as a string in the specified radix
 *
 * @example
 * const decimal = fieldToString(field);        // "12345678"
 * const hex = fieldToString(field, 16);        // "bc614e"
 */
function fieldToString(field, radix = 10) {
    let result = 0n;
    for (const byte of field) {
        result <<= 8n;
        result += BigInt(byte);
    }
    return result.toString(radix);
}
/**
 * Convert an array of field elements to an array of strings.
 * Useful for passing VK fields to Noir circuits.
 *
 * @param fields - Array of 32-byte field elements
 * @param radix - The radix for string conversion (2-36), defaults to 10 (decimal)
 * @returns Array of strings in the specified radix
 *
 * @example
 * const vkAsFields = await barretenbergAPI.vkAsFields({ verificationKey: vk });
 * const vkDecimalStrings = fieldsToStrings(vkAsFields.fields);      // ["12345678", "87654321", ...]
 * const vkHexStrings = fieldsToStrings(vkAsFields.fields, 16);      // ["bc614e", "5397fb1", ...]
 */
function fieldsToStrings(fields, radix = 10) {
    return fields.map(field => fieldToString(field, radix));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9iYXJyZXRlbmJlcmcvYmFja2VuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLGdEQUFnRjtBQUNoRixrRUFBMkY7QUFDM0YsK0JBQThCO0FBQzlCLHVDQUE0QztBQUU1Qyw2QkFBcUMsU0FBUSxLQUFLO0lBQ2hELFlBQVksT0FBZSxFQUFFO1FBQzNCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUFBLENBQ2hCO0NBQ0Y7O0FBNkNELFNBQVMsMkJBQTJCLENBQUMsT0FBaUMsRUFLcEU7SUFDQSw0RkFBNEY7SUFDNUYsSUFBSSxPQUFPLEVBQUUsY0FBYyxFQUFFLENBQUM7UUFDNUIsTUFBTSxhQUFhLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQy9HLElBQUksYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUM3QixNQUFNLElBQUksS0FBSyxDQUNiLDBGQUEwRjtnQkFDeEYsMkJBQTJCLENBQzlCLENBQUM7UUFDSixDQUFDO1FBRUQsUUFBUSxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDL0IsS0FBSyxLQUFLO2dCQUNSLE9BQU8sRUFBRSxlQUFlLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSx5QkFBeUIsRUFBRSxLQUFLLEVBQUUsQ0FBQztZQUNsSCxLQUFLLFdBQVc7Z0JBQ2QsT0FBTyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLHlCQUF5QixFQUFFLEtBQUssRUFBRSxDQUFDO1lBQ2pILEtBQUssZ0JBQWdCO2dCQUNu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