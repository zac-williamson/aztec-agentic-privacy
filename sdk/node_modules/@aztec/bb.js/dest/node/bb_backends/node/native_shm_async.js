import { createRequire } from 'module';
import { spawn } from 'child_process';
import { openSync, closeSync } from 'fs';
import { findNapiBinary, findPackageRoot } from './platform.js';
import { threadId } from 'worker_threads';
let instanceCounter = 0;
/**
 * Asynchronous shared memory backend that communicates with bb binary via shared memory.
 * Uses NAPI module with background thread polling for async operations.
 * Supports request pipelining - multiple requests can be in flight simultaneously.
 *
 * Architecture (matches socket backend pattern):
 * - bb acts as the SERVER, TypeScript is the CLIENT
 * - bb creates the shared memory region
 * - TypeScript connects via NAPI wrapper (MsgpackClientAsync)
 * - TypeScript manages promise queue (single-threaded, no mutex needed)
 * - C++ background thread polls for responses, calls JavaScript callback
 * - JavaScript callback pops queue and resolves promises in FIFO order
 */
export class BarretenbergNativeShmAsyncBackend {
    process;
    client; // NAPI MsgpackClientAsync instance
    logFd; // File descriptor for logs
    // Queue of pending callbacks for pipelined requests
    // Responses come back in FIFO order, so we match them with queued callbacks
    pendingCallbacks = [];
    constructor(process, client, logFd) {
        this.process = process;
        this.client = client;
        this.logFd = logFd;
        // Register our response handler with the C++ client
        // This callback will be invoked from the background thread via ThreadSafeFunction
        this.client.setResponseCallback((responseBuffer) => {
            this.handleResponse(responseBuffer);
        });
    }
    /**
     * Handle response from C++ background thread
     * Dequeues the next pending callback and resolves it (FIFO order)
     */
    handleResponse(responseBuffer) {
        // Response is complete - dequeue the next pending callback (FIFO)
        const callback = this.pendingCallbacks.shift();
        if (callback) {
            callback.resolve(new Uint8Array(responseBuffer));
        }
        else {
            // This shouldn't happen - response without a pending request
            console.warn('Received response but no pending callback');
        }
        // If no more pending callbacks, release ref to allow process to exit
        if (this.pendingCallbacks.length === 0) {
            this.client.release();
        }
    }
    /**
     * Create and initialize an async shared memory backend.
     * @param bbBinaryPath Path to bb binary
     * @param threads Optional number of threads (defaults to min(32, num_cpus))
     * @param logger Optional logger function for bb output
     */
    static async new(bbBinaryPath, napiPath, threads, logger) {
        // Import the NAPI module
        // The addon is built to the nodejs_module directory
        const addonPath = findNapiBinary(napiPath);
        // Try loading
        let addon = null;
        try {
            const require = createRequire(findPackageRoot());
            addon = require(addonPath);
        }
        catch (err) {
            // Addon not built yet or not available
            throw new Error('Shared memory async NAPI not available.');
        }
        // Create a unique shared memory name
        const shmName = `bb-async-${process.pid}-${threadId}-${instanceCounter++}`;
        // If threads not set use num cpu cores, max 16 (same as socket backend)
        const hwc = threads ? threads.toString() : '16';
        const env = { ...process.env, HARDWARE_CONCURRENCY: hwc };
        // Set up file logging if logger is provided
        // Direct file redirection bypasses Node event loop - logs are written even if process hangs
        let logFd;
        let logPath;
        if (logger) {
            logPath = `/tmp/${shmName}.log`;
            logFd = openSync(logPath, 'w');
            logger(`BB process logs redirected to: ${logPath}`);
        }
        // Spawn bb process with shared memory mode
        // Use larger ring buffers for async mode to support pipelining
        const args = [
            'msgpack',
            'run',
            '--input',
            `${shmName}.shm`,
            '--request-ring-size',
            `${1024 * 1024 * 4}`,
            '--response-ring-size',
            `${1024 * 1024 * 4}`,
        ];
        const bbProcess = spawn(bbBinaryPath, args, {
            stdio: ['ignore', logFd ?? 'ignore', logFd ?? 'ignore'],
            env,
        });
        // Disconnect from event loop so process can exit without waiting for bb
        // The bb process has parent death monitoring (prctl on Linux, kqueue on macOS)
        // so it will automatically exit when Node.js exits
        bbProcess.unref();
        // Track if process has exited
        let processExited = false;
        let exitError = null;
        bbProcess.on('error', err => {
            processExited = true;
            exitError = new Error(`Native backend process error: ${err.message}`);
        });
        bbProcess.on('exit', (code, signal) => {
            processExited = true;
            if (code !== null && code !== 0) {
                exitError = new Error(`Native backend process exited with code ${code}`);
            }
            else if (signal && signal !== 'SIGTERM') {
                exitError = new Error(`Native backend process killed with signal ${signal}`);
            }
        });
        // Wait for bb to create shared memory
        // Retry connection every 100ms for up to 5 seconds (longer than sync for thread startup)
        const retryInterval = 100; // ms
        const timeout = 5000; // ms
        const maxAttempts = Math.floor(timeout / retryInterval);
        let client = null;
        try {
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                // Check if bb process has exited before attempting connection
                if (processExited) {
                    throw exitError || new Error('Native backend process exited unexpectedly during startup');
                }
                // Wait before attempting connection (except first attempt)
                if (attempt > 0) {
                    await new Promise(resolve => setTimeout(resolve, retryInterval));
                }
                try {
                    // Create NAPI async client
                    client = new addon.MsgpackClientAsync(shmName);
                    break; // Success!
                }
                catch (err) {
                    // Connection failed, will retry
                    if (attempt === maxAttempts - 1) {
                        // Last attempt failed - check one more time if process exited
                        if (processExited && exitError) {
                            throw exitError;
                        }
                        throw new Error(`Failed to connect to shared memory after ${timeout}ms: ${err.message}`);
                    }
                }
            }
            if (!client) {
                throw new Error('Failed to create client connection');
            }
            return new BarretenbergNativeShmAsyncBackend(bbProcess, client, logFd);
        }
        finally {
            // If we failed to connect, ensure the process is killed and log file closed
            if (!client) {
                bbProcess.kill('SIGKILL');
                if (logFd !== undefined) {
                    try {
                        closeSync(logFd);
                    }
                    catch (e) {
                        // Ignore errors during cleanup
                    }
                }
            }
        }
    }
    /**
     * Send a msgpack request asynchronously.
     * Supports pipelining - can be called multiple times before awaiting responses.
     * Use Promise.all() to send multiple requests concurrently.
     *
     * Example:
     *   const results = await Promise.all([
     *     backend.call(buf1),
     *     backend.call(buf2),
     *     backend.call(buf3)
     *   ]);
     *
     * @param inputBuffer The msgpack-encoded request
     * @returns Promise resolving to msgpack-encoded response
     */
    async call(inputBuffer) {
        return new Promise((resolve, reject) => {
            // If this is the first pending callback, acquire ref to keep event loop alive
            if (this.pendingCallbacks.length === 0) {
                this.client.acquire();
            }
            // Enqueue this promise's callbacks (FIFO order)
            this.pendingCallbacks.push({ resolve, reject });
            try {
                // Send request to shared memory (synchronous write)
                // C++ call() no longer returns a promise - we manage them here
                this.client.call(Buffer.from(inputBuffer));
            }
            catch (err) {
                // Send failed - dequeue the callback we just added and reject
                this.pendingCallbacks.pop();
                // If queue is now empty, release ref to allow exit
                if (this.pendingCallbacks.length === 0) {
                    this.client.release();
                }
                reject(new Error(`Shared memory async call failed: ${err.message}`));
            }
        });
    }
    async destroy() {
        // Kill the bb process
        // Background thread and callbacks will be cleaned up by OS on process exit
        this.process.kill('SIGTERM');
        this.process.removeAllListeners();
        // Close log file if open
        if (this.logFd !== undefined) {
            try {
                closeSync(this.logFd);
            }
            catch (e) {
                // Ignore errors during cleanup
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF0aXZlX3NobV9hc3luYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iYl9iYWNrZW5kcy9ub2RlL25hdGl2ZV9zaG1fYXN5bmMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUN2QyxPQUFPLEVBQUUsS0FBSyxFQUFnQixNQUFNLGVBQWUsQ0FBQztBQUNwRCxPQUFPLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLElBQUksQ0FBQztBQUV6QyxPQUFPLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFMUMsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO0FBRXhCOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILE1BQU0sT0FBTyxpQ0FBaUM7SUFDcEMsT0FBTyxDQUFlO0lBQ3RCLE1BQU0sQ0FBTSxDQUFDLG1DQUFtQztJQUNoRCxLQUFLLENBQVUsQ0FBQywyQkFBMkI7SUFFbkQsb0RBQW9EO0lBQ3BELDRFQUE0RTtJQUNwRSxnQkFBZ0IsR0FHbkIsRUFBRSxDQUFDO0lBRVIsWUFBb0IsT0FBcUIsRUFBRSxNQUFXLEVBQUUsS0FBYyxFQUFFO1FBQ3RFLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBRW5CLG9EQUFvRDtRQUNwRCxrRkFBa0Y7UUFDbEYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLGNBQXNCLEVBQUUsRUFBRSxDQUFDO1lBQzFELElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLENBQUM7UUFBQSxDQUNyQyxDQUFDLENBQUM7SUFBQSxDQUNKO0lBRUQ7OztPQUdH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