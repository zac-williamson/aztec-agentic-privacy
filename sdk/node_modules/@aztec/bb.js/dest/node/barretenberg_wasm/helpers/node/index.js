import { parentPort } from 'worker_threads';
import os from 'os';
import { wrap } from 'comlink';
import { nodeEndpoint } from './node_endpoint.js';
import { writeSync } from 'fs';
export function getSharedMemoryAvailable() {
    return true;
}
/**
 * Comlink allows you to produce a Proxy to the worker, enabling you to call methods as if it were a normal class.
 * Note we give it the type information it needs so the returned Proxy object looks like that type.
 * Node has a different implementation, needing this nodeEndpoint wrapper, hence this function exists here.
 */
export function getRemoteBarretenbergWasm(worker) {
    return wrap(nodeEndpoint(worker));
}
/**
 * Returns number of cpus as reported by the system, unless overriden by HARDWARE_CONCURRENCY env var.
 */
export function getNumCpu() {
    return +process.env.HARDWARE_CONCURRENCY || os.cpus().length;
}
/**
 * Returns a logger function for worker threads.
 * When a custom logger is provided, posts messages back to the main thread.
 * Otherwise, writes directly to stdout.
 */
export function threadLogger(useCustomLogger) {
    if (useCustomLogger) {
        return (msg) => {
            if (parentPort) {
                parentPort.postMessage({ type: 'log', msg });
            }
        };
    }
    // Write directly to stdout when no custom logger is provided
    return (msg) => {
        writeSync(1, msg + '\n');
    };
}
export function killSelf() {
    // Extordinarily hard process termination. Due to how parent threads block on child threads etc, even process.exit
    // doesn't seem to be able to abort the process. The following does.
    process.kill(process.pid);
    throw new Error();
}
export function getAvailableThreads(logger) {
    try {
        return os.cpus().length;
    }
    catch (e) {
        logger(`Could not detect environment to query number of threads. Falling back to one thread. Error: ${e.message ?? e}`);
        return 1;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYmFycmV0ZW5iZXJnX3dhc20vaGVscGVycy9ub2RlL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBVSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDcEIsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUMvQixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDbEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLElBQUksQ0FBQztBQUUvQixNQUFNLFVBQVUsd0JBQXdCLEdBQUc7SUFDekMsT0FBTyxJQUFJLENBQUM7QUFBQSxDQUNiO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSx5QkFBeUIsQ0FBSSxNQUFjLEVBQUU7SUFDM0QsT0FBTyxJQUFJLENBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFBQSxDQUN0QztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLFNBQVMsR0FBRztJQUMxQixPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBcUIsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDO0FBQUEsQ0FDL0Q7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLFlBQVksQ0FBQyxlQUF3QixFQUF1QztJQUMxRixJQUFJLGVBQWUsRUFBRSxDQUFDO1FBQ3BCLE9BQU8sQ0FBQyxHQUFXLEVBQUUsRUFBRSxDQUFDO1lBQ3RCLElBQUksVUFBVSxFQUFFLENBQUM7Z0JBQ2YsVUFBVSxDQUFDLFdBQVcsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUMvQyxDQUFDO1FBQUEsQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUNELDZEQUE2RDtJQUM3RCxPQUFPLENBQUMsR0FBVyxFQUFFLEVBQUUsQ0FBQztRQUN0QixTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUFBLENBQzFCLENBQUM7QUFBQSxDQUNIO0FBRUQsTUFBTSxVQUFVLFFBQVEsR0FBVTtJQUNoQyxrSEFBa0g7SUFDbEgsb0VBQW9FO0lBQ3BFLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBQztBQUFBLENBQ25CO0FBRUQsTUFBTSxVQUFVLG1CQUFtQixDQUFDLE1BQTZCLEVBQVU7SUFDekUsSUFBSSxDQUFDO1FBQ0gsT0FBTyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDO0lBQzFCLENBQUM7SUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO1FBQ2hCLE1BQU0sQ0FDSiwrRkFBK0YsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FDaEgsQ0FBQztRQUNGLE9BQU8sQ0FBQyxDQUFDO0lBQ1gsQ0FBQztBQUFBLENBQ0YifQ==