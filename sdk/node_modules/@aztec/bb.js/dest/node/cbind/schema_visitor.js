/**
 * Schema Visitor - Minimal abstraction over raw msgpack schema
 *
 * Philosophy:
 *   - Keep raw schema structure
 *   - Resolve type references into a graph
 *   - No normalization - languages handle their own conventions
 *   - Output is "compiled schema" with resolved types
 */
/**
 * SchemaVisitor - Walks raw msgpack schema and resolves references
 */
export class SchemaVisitor {
    structs = new Map();
    responses = new Map();
    visit(commandsSchema, responsesSchema) {
        // Reset state
        this.structs.clear();
        this.responses.clear();
        const commands = [];
        // Schema format: ["named_union", [[name, schema], ...]]
        const commandPairs = commandsSchema[1];
        const responsePairs = responsesSchema[1];
        // First, visit all response types (including ErrorResponse)
        for (const [respName, respSchema] of responsePairs) {
            if (typeof respSchema !== 'string') {
                const respStruct = this.visitStruct(respName, respSchema);
                this.responses.set(respName, respStruct);
            }
        }
        // Visit all commands and pair with responses
        for (let i = 0; i < commandPairs.length; i++) {
            const [cmdName, cmdSchema] = commandPairs[i];
            // Find matching response (skip ErrorResponse which is always last)
            const normalResponses = responsePairs.filter(([name]) => name !== 'ErrorResponse');
            const [respName] = normalResponses[i];
            // Discover command structure
            const cmdStruct = this.visitStruct(cmdName, cmdSchema);
            this.structs.set(cmdName, cmdStruct);
            // Create command mapping
            commands.push({
                name: cmdName,
                fields: cmdStruct.fields,
                responseType: respName,
            });
        }
        return {
            structs: this.structs,
            commands,
            responses: this.responses,
        };
    }
    visitStruct(name, schema) {
        const fields = [];
        // Schema is an object with __typename and fields
        for (const [key, value] of Object.entries(schema)) {
            if (key === '__typename')
                continue;
            fields.push({
                name: key,
                type: this.visitType(value),
            });
        }
        return { name, fields };
    }
    visitType(schema) {
        // Primitive string type
        if (typeof schema === 'string') {
            return this.resolvePrimitive(schema);
        }
        // Array type descriptor: ['vector', [elementType]]
        if (Array.isArray(schema)) {
            const [kind, args] = schema;
            switch (kind) {
                case 'vector': {
                    const [elemType] = args;
                    // Special case: vector<unsigned char> = bytes
                    if (elemType === 'unsigned char') {
                        return { kind: 'primitive', primitive: 'bytes' };
                    }
                    return {
                        kind: 'vector',
                        element: this.visitType(elemType),
                    };
                }
                case 'array': {
                    const [elemType, size] = args;
                    // Special case: array<unsigned char, N> = bytes
                    if (elemType === 'unsigned char') {
                        return { kind: 'primitive', primitive: 'bytes' };
                    }
                    return {
                        kind: 'array',
                        element: this.visitType(elemType),
                        size,
                    };
                }
                case 'optional': {
                    const [elemType] = args;
                    return {
                        kind: 'optional',
                        element: this.visitType(elemType),
                    };
                }
                case 'shared_ptr': {
                    // Dereference shared_ptr - just use inner type
                    const [innerType] = args;
                    return this.visitType(innerType);
                }
                case 'alias': {
                    // Alias types (like uint256_t) are treated as bytes
                    return { kind: 'primitive', primitive: 'bytes' };
                }
                default:
                    throw new Error(`Unknown type kind: ${kind}`);
            }
        }
        // Inline struct definition
        if (typeof schema === 'object' && schema.__typename) {
            const structName = schema.__typename;
            // Check if already visited
            if (!this.structs.has(structName)) {
                const struct = this.visitStruct(structName, schema);
                this.structs.set(structName, struct);
            }
            return {
                kind: 'struct',
                struct: this.structs.get(structName),
            };
        }
        throw new Error(`Cannot resolve type: ${JSON.stringify(schema)}`);
    }
    resolvePrimitive(name) {
        const primitiveMap = {
            'bool': 'bool',
            'int': 'u32',
            'unsigned int': 'u32',
            'unsigned short': 'u16',
            'unsigned long': 'u64',
            'unsigned char': 'u8',
            'double': 'f64',
            'string': 'string',
            'bin32': 'bytes',
            'field2': 'field2', // Extension field (Fq2) - pair of field elements
        };
        const primitive = primitiveMap[name];
        if (primitive) {
            return { kind: 'primitive', primitive };
        }
        // Unknown primitive - treat as struct reference
        // This will be resolved later if it's a real struct
        return {
            kind: 'struct',
            struct: { name, fields: [] }, // Placeholder
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hX3Zpc2l0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY2JpbmQvc2NoZW1hX3Zpc2l0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUF1Q0g7O0dBRUc7QUFDSCxNQUFNLE9BQU8sYUFBYTtJQUNoQixPQUFPLEdBQUcsSUFBSSxHQUFHLEVBQWtCLENBQUM7SUFDcEMsU0FBUyxHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO0lBRTlDLEtBQUssQ0FBQyxjQUFtQixFQUFFLGVBQW9CLEVBQWtCO1FBQy9ELGNBQWM7UUFDZCxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFdkIsTUFBTSxRQUFRLEdBQWMsRUFBRSxDQUFDO1FBRS9CLHdEQUF3RDtRQUN4RCxNQUFNLFlBQVksR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUF5QixDQUFDO1FBQy9ELE1BQU0sYUFBYSxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQXlCLENBQUM7UUFFakUsNERBQTREO1FBQzVELEtBQUssTUFBTSxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsSUFBSSxhQUFhLEVBQUUsQ0FBQztZQUNuRCxJQUFJLE9BQU8sVUFBVSxLQUFLLFFBQVEsRUFBRSxDQUFDO2dCQUNuQyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDMUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQzNDLENBQUM7UUFDSCxDQUFDO1FBRUQsNkNBQTZDO1FBQzdDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDN0MsTUFBTSxDQUFD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