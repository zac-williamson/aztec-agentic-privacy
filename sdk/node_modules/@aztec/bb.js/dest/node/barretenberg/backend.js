import { uint8ArrayToHex, hexToUint8Array } from '../proof/index.js';
import { fromChonkProof, toChonkProof } from '../cbind/generated/api_types.js';
import { ungzip } from 'pako';
import { Decoder, Encoder } from 'msgpackr';
export class AztecClientBackendError extends Error {
    constructor(message) {
        super(message);
    }
}
function getProofSettingsFromOptions(options) {
    // Check for conflicting options - verifierTarget should not be combined with legacy options
    if (options?.verifierTarget) {
        const legacyOptions = [options.keccak, options.keccakZK, options.starknet, options.starknetZK].filter(Boolean);
        if (legacyOptions.length > 0) {
            throw new Error('Cannot use verifierTarget with legacy options (keccak, keccakZK, starknet, starknetZK). ' +
                'Use verifierTarget alone.');
        }
        switch (options.verifierTarget) {
            case 'evm':
                return { ipaAccumulation: false, oracleHashType: 'keccak', disableZk: false, optimizedSolidityVerifier: false };
            case 'evm-no-zk':
                return { ipaAccumulation: false, oracleHashType: 'keccak', disableZk: true, optimizedSolidityVerifier: false };
            case 'noir-recursive':
                return {
                    ipaAccumulation: false,
                    oracleHashType: 'poseidon2',
                    disableZk: false,
                    optimizedSolidityVerifier: false,
                };
            case 'noir-recursive-no-zk':
                return {
                    ipaAccumulation: false,
                    oracleHashType: 'poseidon2',
                    disableZk: true,
                    optimizedSolidityVerifier: false,
                };
            case 'noir-rollup':
                return {
                    ipaAccumulation: true,
                    oracleHashType: 'poseidon2',
                    disableZk: false,
                    optimizedSolidityVerifier: false,
                };
            case 'noir-rollup-no-zk':
                return {
                    ipaAccumulation: true,
                    oracleHashType: 'poseidon2',
                    disableZk: true,
                    optimizedSolidityVerifier: false,
                };
            case 'starknet':
                return {
                    ipaAccumulation: false,
                    oracleHashType: 'starknet',
                    disableZk: false,
                    optimizedSolidityVerifier: false,
                };
            case 'starknet-no-zk':
                return {
                    ipaAccumulation: false,
                    oracleHashType: 'starknet',
                    disableZk: true,
                    optimizedSolidityVerifier: false,
                };
        }
    }
    // Legacy options support (deprecated)
    return {
        ipaAccumulation: false,
        oracleHashType: options?.keccak || options?.keccakZK
            ? 'keccak'
            : options?.starknet || options?.starknetZK
                ? 'starknet'
                : 'poseidon2',
        disableZk: options?.keccak || options?.starknet ? true : false,
        optimizedSolidityVerifier: false,
    };
}
export class UltraHonkVerifierBackend {
    api;
    constructor(api) {
        this.api = api;
    }
    async verifyProof(proofData, options) {
        const proofFrs = [];
        for (let i = 0; i < proofData.proof.length; i += 32) {
            proofFrs.push(proofData.proof.slice(i, i + 32));
        }
        const { verified } = await this.api.circuitVerify({
            verificationKey: proofData.verificationKey,
            publicInputs: proofData.publicInputs.map(hexToUint8Array),
            proof: proofFrs,
            settings: getProofSettingsFromOptions(options),
        });
        return verified;
    }
}
export class UltraHonkBackend {
    api;
    // These type assertions are used so that we don't
    // have to initialize `api` in the constructor.
    // These are initialized asynchronously in the `init` function,
    // constructors cannot be asynchronous which is why we do this.
    acirUncompressedBytecode;
    constructor(acirBytecode, api) {
        this.api = api;
        this.acirUncompressedBytecode = acirToUint8Array(acirBytecode);
    }
    async generateProof(compressedWitness, options) {
        const witness = ungzip(compressedWitness);
        const { proof, publicInputs } = await this.api.circuitProve({
            witness,
            circuit: {
                name: 'circuit',
                bytecode: this.acirUncompressedBytecode,
                verificationKey: new Uint8Array(0), // Empty VK - lower performance.
            },
            settings: getProofSettingsFromOptions(options),
        });
        console.log(`Generated proof for circuit with ${publicInputs.length} public inputs and ${proof.length} fields.`);
        // We return ProofData as a flat buffer and an array of strings to match the current ProofData class.
        const flatProof = new Uint8Array(proof.length * 32);
        proof.forEach((fr, i) => {
            flatProof.set(fr, i * 32);
        });
        return { proof: flatProof, publicInputs: publicInputs.map(uint8ArrayToHex) };
    }
    async verifyProof(proofData, options) {
        const proofFrs = [];
        for (let i = 0; i < proofData.proof.length; i += 32) {
            proofFrs.push(proofData.proof.slice(i, i + 32));
        }
        // TODO reconsider API - computing the VK at this point is not optimal
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: this.acirUncompressedBytecode,
            },
            settings: getProofSettingsFromOptions(options),
        });
        const { verified } = await this.api.circuitVerify({
            verificationKey: vkResult.bytes,
            publicInputs: proofData.publicInputs.map(hexToUint8Array),
            proof: proofFrs,
            settings: getProofSettingsFromOptions(options),
        });
        return verified;
    }
    async getVerificationKey(options) {
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: this.acirUncompressedBytecode,
            },
            settings: getProofSettingsFromOptions(options),
        });
        return vkResult.bytes;
    }
    /** @description Returns a solidity verifier */
    async getSolidityVerifier(vk, options) {
        const result = await this.api.circuitWriteSolidityVerifier({
            verificationKey: vk,
            settings: getProofSettingsFromOptions(options),
        });
        return result.solidityCode;
    }
    // TODO(https://github.com/noir-lang/noir/issues/5661): Update this to handle Honk recursive aggregation in the browser once it is ready in the backend itself
    async generateRecursiveProofArtifacts(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _proof, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _numOfPublicInputs, options) {
        // TODO(https://github.com/noir-lang/noir/issues/5661): This needs to be updated to handle recursive aggregation.
        // There is still a proofAsFields method but we could consider getting rid of it as the proof itself
        // is a list of field elements.
        // UltraHonk also does not have public inputs directly prepended to the proof and they are still instead
        // inserted at an offset.
        // const proof = reconstructProofWithPublicInputs(proofData);
        // const proofAsFields = (await this.api.acirProofAsFieldsUltraHonk(proof)).slice(numOfPublicInputs);
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: this.acirUncompressedBytecode,
            },
            settings: getProofSettingsFromOptions(options),
        });
        // Convert VK bytes to field elements (32-byte chunks)
        const vkAsFields = [];
        for (let i = 0; i < vkResult.bytes.length; i += 32) {
            const chunk = vkResult.bytes.slice(i, i + 32);
            vkAsFields.push(uint8ArrayToHex(chunk));
        }
        return {
            // TODO(https://github.com/noir-lang/noir/issues/5661)
            proofAsFields: [],
            vkAsFields,
            // We use an empty string for the vk hash here as it is unneeded as part of the recursive artifacts
            // The user can be expected to hash the vk inside their circuit to check whether the vk is the circuit
            // they expect
            vkHash: uint8ArrayToHex(vkResult.hash),
        };
    }
}
export class AztecClientBackend {
    acirBuf;
    api;
    circuitNames;
    // These type assertions are used so that we don't
    // have to initialize `api` in the constructor.
    // These are initialized asynchronously in the `init` function,
    // constructors cannot be asynchronous which is why we do this.
    constructor(acirBuf, api, circuitNames = []) {
        this.acirBuf = acirBuf;
        this.api = api;
        this.circuitNames = circuitNames;
    }
    async prove(witnessBuf, vksBuf = []) {
        if (vksBuf.length !== 0 && this.acirBuf.length !== witnessBuf.length) {
            throw new AztecClientBackendError('Witness and bytecodes must have the same stack depth!');
        }
        if (vksBuf.length !== 0 && vksBuf.length !== witnessBuf.length) {
            // NOTE: we allow 0 as an explicit 'I have no VKs'. This is a deprecated feature.
            throw new AztecClientBackendError('Witness and VKs must have the same stack depth!');
        }
        // Queue IVC start with the number of circuits
        this.api.chonkStart({ numCircuits: this.acirBuf.length });
        // Queue load and accumulate for each circuit
        for (let i = 0; i < this.acirBuf.length; i++) {
            const bytecode = this.acirBuf[i];
            const witness = witnessBuf[i] || new Uint8Array(0);
            const vk = vksBuf[i] || new Uint8Array(0);
            const functionName = this.circuitNames[i] || `circuit_${i}`;
            // Load the circuit
            this.api.chonkLoad({
                circuit: {
                    name: functionName,
                    bytecode: bytecode,
                    verificationKey: vk,
                },
            });
            // Accumulate with witness
            this.api.chonkAccumulate({
                witness,
            });
        }
        // Generate the proof (and wait for all previous steps to finish)
        const proveResult = await this.api.chonkProve({});
        // The API currently expects a msgpack-encoded API.
        const proof = new Encoder({ useRecords: false }).encode(fromChonkProof(proveResult.proof));
        // Generate the VK
        const lastIdx = this.acirBuf.length - 1;
        const vkResult = await this.api.chonkComputeVk({
            circuit: {
                name: this.circuitNames[lastIdx] || 'circuit',
                bytecode: this.acirBuf[lastIdx],
            },
        });
        const proofFields = [
            proveResult.proof.megaProof,
            proveResult.proof.goblinProof.mergeProof,
            proveResult.proof.goblinProof.eccvmProof,
            proveResult.proof.goblinProof.ipaProof,
            proveResult.proof.goblinProof.translatorProof,
        ].flat();
        // Verify using native proof directly to avoid redundant encode/decode cycle
        if (!(await this.verifyNative(proveResult.proof, vkResult.bytes))) {
            throw new AztecClientBackendError('Failed to verify the private (Chonk) transaction proof!');
        }
        return [proofFields, proof, vkResult.bytes];
    }
    async verify(proof, vk) {
        const result = await this.api.chonkVerify({
            proof: toChonkProof(new Decoder({ useRecords: false }).decode(proof)),
            vk,
        });
        return result.valid;
    }
    /**
     * Internal verification using native ChonkProof type.
     * Avoids encode/decode cycle when called from prove().
     */
    async verifyNative(proof, vk) {
        const result = await this.api.chonkVerify({
            proof,
            vk,
        });
        return result.valid;
    }
    async gates() {
        const circuitSizes = [];
        for (let i = 0; i < this.acirBuf.length; i++) {
            const gates = await this.api.chonkStats({
                circuit: {
                    name: this.circuitNames[i] || `circuit_${i}`,
                    bytecode: this.acirBuf[i],
                },
                includeGatesPerOpcode: false,
            });
            circuitSizes.push(gates.circuitSize);
        }
        return circuitSizes;
    }
}
// Converts bytecode from a base64 string to a Uint8Array
function acirToUint8Array(base64EncodedBytecode) {
    const compressedByteCode = base64Decode(base64EncodedBytecode);
    return ungzip(compressedByteCode);
}
// Base64 decode using atob (works in both browser and Node.js 18+)
function base64Decode(input) {
    if (typeof atob === 'function') {
        return Uint8Array.from(atob(input), c => c.charCodeAt(0));
    }
    else {
        throw new Error('atob is not available. Node.js 18+ or browser required.');
    }
}
/**
 * Convert a field element (32-byte Uint8Array) to a string.
 *
 * @param field - A 32-byte field element
 * @param radix - The radix for string conversion (2-36), defaults to 10 (decimal)
 * @returns The field value as a string in the specified radix
 *
 * @example
 * const decimal = fieldToString(field);        // "12345678"
 * const hex = fieldToString(field, 16);        // "bc614e"
 */
export function fieldToString(field, radix = 10) {
    let result = 0n;
    for (const byte of field) {
        result <<= 8n;
        result += BigInt(byte);
    }
    return result.toString(radix);
}
/**
 * Convert an array of field elements to an array of strings.
 * Useful for passing VK fields to Noir circuits.
 *
 * @param fields - Array of 32-byte field elements
 * @param radix - The radix for string conversion (2-36), defaults to 10 (decimal)
 * @returns Array of strings in the specified radix
 *
 * @example
 * const vkAsFields = await barretenbergAPI.vkAsFields({ verificationKey: vk });
 * const vkDecimalStrings = fieldsToStrings(vkAsFields.fields);      // ["12345678", "87654321", ...]
 * const vkHexStrings = fieldsToStrings(vkAsFields.fields, 16);      // ["bc614e", "5397fb1", ...]
 */
export function fieldsToStrings(fields, radix = 10) {
    return fields.map(field => fieldToString(field, radix));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9iYXJyZXRlbmJlcmcvYmFja2VuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQWEsZUFBZSxFQUFFLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2hGLE9BQU8sRUFBRSxjQUFjLEVBQUUsWUFBWSxFQUFjLE1BQU0saUNBQWlDLENBQUM7QUFDM0YsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM5QixPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUU1QyxNQUFNLE9BQU8sdUJBQXdCLFNBQVEsS0FBSztJQUNoRCxZQUFZLE9BQWUsRUFBRTtRQUMzQixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUNoQjtDQUNGO0FBNkNELFNBQVMsMkJBQTJCLENBQUMsT0FBaUMsRUFLcEU7SUFDQSw0RkFBNEY7SUFDNUYsSUFBSSxPQUFPLEVBQUUsY0FBYyxFQUFFLENBQUM7UUFDNUIsTUFBTSxhQUFhLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQy9HLElBQUksYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUM3QixNQUFNLElBQUksS0FBSyxDQUNiLDBGQUEwRjtnQkFDeEYsMkJBQTJCLENBQzlCLENBQUM7UUFDSixDQUFDO1FBRUQsUUFBUSxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDL0IsS0FBSyxLQUFLO2dCQUNSLE9BQU8sRUFBRSxlQUFlLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSx5QkFBeUIsRUFBRSxLQUFLLEVB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