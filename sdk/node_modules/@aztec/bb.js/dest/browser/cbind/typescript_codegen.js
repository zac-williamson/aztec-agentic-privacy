/**
 * TypeScript Code Generator - String template based
 *
 * Philosophy:
 *   - String templates for file structure
 *   - Simple type mapping
 *   - Idiomatic TypeScript conventions
 *   - No complex abstraction
 */
import { toPascalCase } from './naming.js';
function toCamelCase(name) {
    const pascal = toPascalCase(name);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}
export class TypeScriptCodegen {
    // Type mapping: Schema type -> TypeScript type
    mapType(type) {
        switch (type.kind) {
            case 'primitive':
                switch (type.primitive) {
                    case 'bool': return 'boolean';
                    case 'u8': return 'number';
                    case 'u16': return 'number';
                    case 'u32': return 'number';
                    case 'u64': return 'number';
                    case 'f64': return 'number';
                    case 'string': return 'string';
                    case 'bytes': return 'Uint8Array';
                    case 'field2': return '[Uint8Array, Uint8Array]'; // Extension field (Fq2)
                }
                break;
            case 'vector':
                return `${this.mapType(type.element)}[]`;
            case 'array':
                return `${this.mapType(type.element)}[]`;
            case 'optional':
                return `${this.mapType(type.element)} | undefined`;
            case 'struct':
                return toPascalCase(type.struct.name);
        }
        return 'unknown';
    }
    // Type mapping for msgpack interfaces (uses Msgpack* prefix for structs)
    mapMsgpackType(type) {
        switch (type.kind) {
            case 'primitive':
                switch (type.primitive) {
                    case 'bool': return 'boolean';
                    case 'u8': return 'number';
                    case 'u16': return 'number';
                    case 'u32': return 'number';
                    case 'u64': return 'number';
                    case 'f64': return 'number';
                    case 'string': return 'string';
                    case 'bytes': return 'Uint8Array';
                    case 'field2': return '[Uint8Array, Uint8Array]';
                }
                break;
            case 'vector':
                return `${this.mapMsgpackType(type.element)}[]`;
            case 'array':
                return `${this.mapMsgpackType(type.element)}[]`;
            case 'optional':
                return `${this.mapMsgpackType(type.element)} | undefined`;
            case 'struct':
                return `Msgpack${toPascalCase(type.struct.name)}`;
        }
        return 'unknown';
    }
    // Check if type needs conversion (has nested structs)
    needsConversion(type) {
        switch (type.kind) {
            case 'primitive':
                return false;
            case 'vector':
            case 'array':
            case 'optional':
                return this.needsConversion(type.element);
            case 'struct':
                return true;
        }
        return false;
    }
    // Generate field
    generateField(field) {
        const tsName = toCamelCase(field.name);
        const tsType = this.mapType(field.type);
        return `  ${tsName}: ${tsType};`;
    }
    // Generate msgpack field (original names, uses Msgpack* types for structs)
    generateMsgpackField(field) {
        const tsType = this.mapMsgpackType(field.type);
        return `  ${field.name}: ${tsType};`;
    }
    // Generate public interface
    generateInterface(struct) {
        const tsName = toPascalCase(struct.name);
        const fields = struct.fields.map(f => this.generateField(f)).join('\n');
        return `export interface ${tsName} {
${fields}
}`;
    }
    // Generate msgpack interface (internal)
    generateMsgpackInterface(struct) {
        const tsName = toPascalCase(struct.name);
        const fields = struct.fields.map(f => this.generateMsgpackField(f)).join('\n');
        return `interface Msgpack${tsName} {
${fields}
}`;
    }
    // Generate to* conversion function
    generateToFunction(struct) {
        const tsName = toPascalCase(struct.name);
        if (struct.fields.length === 0) {
            return `function to${tsName}(o: Msgpack${tsName}): ${tsName} {
  return {};
}`;
        }
        const checks = struct.fields
            .map(f => `  if (o.${f.name} === undefined) { throw new Error("Expected ${f.name} in ${tsName} deserialization"); }`)
            .join('\n');
        const conversions = struct.fields
            .map(f => {
            const tsFieldName = toCamelCase(f.name);
            const converter = this.generateToConverter(f.type, `o.${f.name}`);
            return `    ${tsFieldName}: ${converter},`;
        })
            .join('\n');
        return `function to${tsName}(o: Msgpack${tsName}): ${tsName} {
${checks};
  return {
${conversions}
  };
}`;
    }
    // Generate from* conversion function
    generateFromFunction(struct) {
        const tsName = toPascalCase(struct.name);
        if (struct.fields.length === 0) {
            return `function from${tsName}(o: ${tsName}): Msgpack${tsName} {
  return {};
}`;
        }
        const checks = struct.fields
            .map(f => {
            const tsFieldName = toCamelCase(f.name);
            return `  if (o.${tsFieldName} === undefined) { throw new Error("Expected ${tsFieldName} in ${tsName} serialization"); }`;
        })
            .join('\n');
        const conversions = struct.fields
            .map(f => {
            const tsFieldName = toCamelCase(f.name);
            const converter = this.generateFromConverter(f.type, `o.${tsFieldName}`);
            return `  ${f.name}: ${converter},`;
        })
            .join('\n');
        return `function from${tsName}(o: ${tsName}): Msgpack${tsName} {
${checks};
  return {
${conversions}
  };
}`;
    }
    // Generate converter for to* function
    generateToConverter(type, value) {
        if (!this.needsConversion(type)) {
            return value;
        }
        switch (type.kind) {
            case 'vector':
            case 'array':
                if (this.needsConversion(type.element)) {
                    return `${value}.map((v: any) => ${this.generateToConverter(type.element, 'v')})`;
                }
                return value;
            case 'optional':
                if (this.needsConversion(type.element)) {
                    return `${value} !== undefined ? ${this.generateToConverter(type.element, value)} : undefined`;
                }
                return value;
            case 'struct':
                return `to${toPascalCase(type.struct.name)}(${value})`;
        }
        return value;
    }
    // Generate converter for from* function
    generateFromConverter(type, value) {
        if (!this.needsConversion(type)) {
            return value;
        }
        switch (type.kind) {
            case 'vector':
            case 'array':
                if (this.needsConversion(type.element)) {
                    return `${value}.map((v: any) => ${this.generateFromConverter(type.element, 'v')})`;
                }
                return value;
            case 'optional':
                if (this.needsConversion(type.element)) {
                    return `${value} !== undefined ? ${this.generateFromConverter(type.element, value)} : undefined`;
                }
                return value;
            case 'struct':
                return `from${toPascalCase(type.struct.name)}(${value})`;
        }
        return value;
    }
    // Generate types file (api_types.ts)
    generateTypes(schema) {
        const allStructs = [...schema.structs.values(), ...schema.responses.values()];
        // Public interfaces
        const publicInterfaces = allStructs
            .map(s => this.generateInterface(s))
            .join('\n\n');
        // Msgpack interfaces
        const msgpackInterfaces = allStructs
            .map(s => this.generateMsgpackInterface(s))
            .join('\n\n');
        // Conversion functions
        const toFunctions = allStructs
            .map(s => 'export ' + this.generateToFunction(s))
            .join('\n\n');
        const fromFunctions = allStructs
            .map(s => 'export ' + this.generateFromFunction(s))
            .join('\n\n');
        // BbApiBase interface
        const apiMethods = schema.commands
            .map(c => `  ${toCamelCase(c.name)}(command: ${toPascalCase(c.name)}): Promise<${toPascalCase(c.responseType)}>;`)
            .join('\n');
        return `// AUTOGENERATED FILE - DO NOT EDIT

// Type aliases for primitive types
export type Field2 = [Uint8Array, Uint8Array];

// Public interfaces (exported)
${publicInterfaces}

// Private Msgpack interfaces (not exported)
${msgpackInterfaces}

// Conversion functions (exported)
${toFunctions}

${fromFunctions}

// Base API interface
export interface BbApiBase {
${apiMethods}
  destroy(): Promise<void>;
}
`;
    }
    // Generate API method
    generateAsyncApiMethod(command) {
        const methodName = toCamelCase(command.name);
        const cmdType = toPascalCase(command.name);
        const respType = toPascalCase(command.responseType);
        return `  ${methodName}(command: ${cmdType}): Promise<${respType}> {
    const msgpackCommand = from${cmdType}(command);
    return msgpackCall(this.backend, [["${command.name}", msgpackCommand]]).then(([variantName, result]: [string, any]) => {
      if (variantName === 'ErrorResponse') {
        throw new BBApiException(result.message || 'Unknown error from barretenberg');
      }
      if (variantName !== '${command.responseType}') {
        throw new BBApiException(\`Expected variant name '${command.responseType}' but got '\${variantName}'\`);
      }
      return to${respType}(result);
    });
  }`;
    }
    generateSyncApiMethod(command) {
        const methodName = toCamelCase(command.name);
        const cmdType = toPascalCase(command.name);
        const respType = toPascalCase(command.responseType);
        return `  ${methodName}(command: ${cmdType}): ${respType} {
    const msgpackCommand = from${cmdType}(command);
    const [variantName, result] = msgpackCall(this.backend, [["${command.name}", msgpackCommand]]);
    if (variantName === 'ErrorResponse') {
      throw new BBApiException(result.message || 'Unknown error from barretenberg');
    }
    if (variantName !== '${command.responseType}') {
      throw new BBApiException(\`Expected variant name '${command.responseType}' but got '\${variantName}'\`);
    }
    return to${respType}(result);
  }`;
    }
    // Generate async API file
    generateAsyncApi(schema) {
        const imports = this.generateApiImports(schema);
        const methods = schema.commands
            .map(c => this.generateAsyncApiMethod(c))
            .join('\n\n');
        return `// AUTOGENERATED FILE - DO NOT EDIT

import { IMsgpackBackendAsync } from '../../bb_backends/interface.js';
import { Decoder, Encoder } from 'msgpackr';
import { BBApiException } from '../../bbapi_exception.js';
${imports}

async function msgpackCall(backend: IMsgpackBackendAsync, input: any[]) {
  const inputBuffer = new Encoder({ useRecords: false }).pack(input);
  const encodedResult = await backend.call(inputBuffer);
  return new Decoder({ useRecords: false }).unpack(encodedResult);
}

export class AsyncApi implements BbApiBase {
  constructor(protected backend: IMsgpackBackendAsync) {}

${methods}

  destroy(): Promise<void> {
    return this.backend.destroy ? this.backend.destroy() : Promise.resolve();
  }
}
`;
    }
    // Generate sync API file
    generateSyncApi(schema) {
        const imports = this.generateApiImports(schema);
        const methods = schema.commands
            .map(c => this.generateSyncApiMethod(c))
            .join('\n\n');
        return `// AUTOGENERATED FILE - DO NOT EDIT

import { IMsgpackBackendSync } from '../../bb_backends/interface.js';
import { Decoder, Encoder } from 'msgpackr';
import { BBApiException } from '../../bbapi_exception.js';
${imports}

function msgpackCall(backend: IMsgpackBackendSync, input: any[]) {
  const inputBuffer = new Encoder({ useRecords: false }).pack(input);
  const encodedResult = backend.call(inputBuffer);
  return new Decoder({ useRecords: false }).unpack(encodedResult);
}

export class SyncApi {
  constructor(protected backend: IMsgpackBackendSync) {}

${methods}

  destroy(): void {
    if (this.backend.destroy) this.backend.destroy();
  }
}
`;
    }
    // Generate import statement for API files
    generateApiImports(schema) {
        const types = new Set();
        // Add command types and their conversion functions
        for (const cmd of schema.commands) {
            const cmdType = toPascalCase(cmd.name);
            const respType = toPascalCase(cmd.responseType);
            types.add(cmdType);
            types.add(respType);
            types.add(`from${cmdType}`);
            types.add(`to${respType}`);
        }
        // Add BbApiBase
        types.add('BbApiBase');
        const sortedTypes = Array.from(types).sort();
        return `import { ${sortedTypes.join(', ')} } from './api_types.js';`;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXNjcmlwdF9jb2RlZ2VuLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NiaW5kL3R5cGVzY3JpcHRfY29kZWdlbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUdILE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFM0MsU0FBUyxXQUFXLENBQUMsSUFBWSxFQUFVO0lBQ3pDLE1BQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNsQyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUFBLENBQ3pEO0FBRUQsTUFBTSxPQUFPLGlCQUFpQjtJQUM1QiwrQ0FBK0M7SUFDdkMsT0FBTyxDQUFDLElBQVUsRUFBVTtRQUNsQyxRQUFRLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNsQixLQUFLLFdBQVc7Z0JBQ2QsUUFBUSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7b0JBQ3ZCLEtBQUssTUFBTSxFQUFFLE9BQU8sU0FBUyxDQUFDO29CQUM5QixLQUFLLElBQUksRUFBRSxPQUFPLFFBQVEsQ0FBQztvQkFDM0IsS0FBSyxLQUFLLEVBQUUsT0FBTyxRQUFRLENBQUM7b0JBQzVCLEtBQUssS0FBSyxFQUFFLE9BQU8sUUFBUSxDQUFDO29CQUM1QixLQUFLLEtBQUssRUFBRSxPQUFPLFFBQVEsQ0FBQztvQkFDNUIsS0FBSyxLQUFLLEVBQUUsT0FBTyxRQUFRLENBQUM7b0JBQzVCLEtBQUssUUFBUSxFQUFFLE9BQU8sUUFBUSxDQUFDO29CQUMvQixLQUFLLE9BQU8sRUFBRSxPQUFPLFlBQVksQ0FBQztvQkFDbEMsS0FBSyxRQUFRLEVBQUUsT0FBTywwQkFBMEIsQ0FBQyxDQUFFLHdCQUF3QjtnQkFDN0UsQ0FBQztnQkFDRCxNQUFNO1lB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