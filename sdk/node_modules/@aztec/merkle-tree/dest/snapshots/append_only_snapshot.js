import { serializeToBuffer } from '@aztec/foundation/serialize';
import { SiblingPath } from '@aztec/foundation/trees';
// stores the last block that modified this node
const nodeModifiedAtBlockKey = (level, index)=>`node:${level}:${index}:modifiedAtBlock`;
// stores the value of the node at the above block
const historicalNodeKey = (level, index)=>`node:${level}:${index}:value`;
/**
 * A more space-efficient way of storing snapshots of AppendOnlyTrees that trades space need for slower
 * sibling path reads.
 *
 * Complexity:
 *
 * N - count of non-zero nodes in tree
 * M - count of snapshots
 * H - tree height
 *
 * Space complexity: O(N + M) (N nodes - stores the last snapshot for each node and M - ints, for each snapshot stores up to which leaf its written to)
 * Sibling path access:
 *  Best case: O(H) database reads + O(1) hashes
 *  Worst case: O(H) database reads + O(H) hashes
 */ export class AppendOnlySnapshotBuilder {
    db;
    tree;
    hasher;
    deserializer;
    #nodeValue;
    #nodeLastModifiedByBlock;
    #snapshotMetadata;
    constructor(db, tree, hasher, deserializer){
        this.db = db;
        this.tree = tree;
        this.hasher = hasher;
        this.deserializer = deserializer;
        const treeName = tree.getName();
        this.#nodeValue = db.openMap(`append_only_snapshot:${treeName}:node`);
        this.#nodeLastModifiedByBlock = db.openMap(`append_ony_snapshot:${treeName}:block`);
        this.#snapshotMetadata = db.openMap(`append_only_snapshot:${treeName}:snapshot_metadata`);
    }
    getSnapshot(block) {
        const meta = this.#getSnapshotMeta(block);
        if (typeof meta === 'undefined') {
            return Promise.reject(new Error(`Snapshot for tree ${this.tree.getName()} at block ${block} does not exist`));
        }
        return Promise.resolve(new AppendOnlySnapshot(this.#nodeValue, this.#nodeLastModifiedByBlock, block, meta.numLeaves, meta.root, this.tree, this.hasher, this.deserializer));
    }
    snapshot(block) {
        return this.db.transaction(()=>{
            const meta = this.#getSnapshotMeta(block);
            if (typeof meta !== 'undefined') {
                // no-op, we already have a snapshot
                return new AppendOnlySnapshot(this.#nodeValue, this.#nodeLastModifiedByBlock, block, meta.numLeaves, meta.root, this.tree, this.hasher, this.deserializer);
            }
            const root = this.tree.getRoot(false);
            const depth = this.tree.getDepth();
            const queue = [
                [
                    root,
                    0,
                    0n
                ]
            ];
            // walk the tree in BF and store latest nodes
            while(queue.length > 0){
                const [node, level, index] = queue.shift();
                const historicalValue = this.#nodeValue.get(historicalNodeKey(level, index));
                if (!historicalValue || !node.equals(historicalValue)) {
                    // we've never seen this node before or it's different than before
                    // update the historical tree and tag it with the block that modified it
                    void this.#nodeLastModifiedByBlock.set(nodeModifiedAtBlockKey(level, index), block);
                    void this.#nodeValue.set(historicalNodeKey(level, index), node);
                } else {
                    continue;
                }
                if (level + 1 > depth) {
                    continue;
                }
                // these could be undefined because zero hashes aren't stored in the tree
                const [lhs, rhs] = [
                    this.tree.getNode(level + 1, 2n * index),
                    this.tree.getNode(level + 1, 2n * index + 1n)
                ];
                if (lhs) {
                    queue.push([
                        lhs,
                        level + 1,
                        2n * index
                    ]);
                }
                if (rhs) {
                    queue.push([
                        rhs,
                        level + 1,
                        2n * index + 1n
                    ]);
                }
            }
            const numLeaves = this.tree.getNumLeaves(false);
            void this.#snapshotMetadata.set(block, {
                numLeaves,
                root
            });
            return new AppendOnlySnapshot(this.#nodeValue, this.#nodeLastModifiedByBlock, block, numLeaves, root, this.tree, this.hasher, this.deserializer);
        });
    }
    #getSnapshotMeta(block) {
        return this.#snapshotMetadata.get(block);
    }
}
/**
 * a
 */ class AppendOnlySnapshot {
    nodes;
    nodeHistory;
    block;
    leafCount;
    historicalRoot;
    tree;
    hasher;
    deserializer;
    constructor(nodes, nodeHistory, block, leafCount, historicalRoot, tree, hasher, deserializer){
        this.nodes = nodes;
        this.nodeHistory = nodeHistory;
        this.block = block;
        this.leafCount = leafCount;
        this.historicalRoot = historicalRoot;
        this.tree = tree;
        this.hasher = hasher;
        this.deserializer = deserializer;
    }
    getSiblingPath(index) {
        const path = [];
        const depth = this.tree.getDepth();
        let level = depth;
        while(level > 0){
            const isRight = index & 0x01n;
            const siblingIndex = isRight ? index - 1n : index + 1n;
            const sibling = this.#getHistoricalNodeValue(level, siblingIndex);
            path.push(sibling);
            level -= 1;
            index >>= 1n;
        }
        return new SiblingPath(depth, path);
    }
    getDepth() {
        return this.tree.getDepth();
    }
    getNumLeaves() {
        return this.leafCount;
    }
    getRoot() {
        // we could recompute it, but it's way cheaper to just store the root
        return this.historicalRoot;
    }
    getLeafValue(index) {
        const leafLevel = this.getDepth();
        const blockNumber = this.#getBlockNumberThatModifiedNode(leafLevel, index);
        // leaf hasn't been set yet
        if (typeof blockNumber === 'undefined') {
            return undefined;
        }
        // leaf was set some time in the past
        if (blockNumber <= this.block) {
            const val = this.nodes.get(historicalNodeKey(leafLevel, index));
            return val ? this.deserializer.fromBuffer(val) : undefined;
        }
        // leaf has been set but in a block in the future
        return undefined;
    }
    #getHistoricalNodeValue(level, index) {
        const blockNumber = this.#getBlockNumberThatModifiedNode(level, index);
        // node has never been set
        if (typeof blockNumber === 'undefined') {
            return this.tree.getZeroHash(level);
        }
        // node was set some time in the past
        if (blockNumber <= this.block) {
            return this.nodes.get(historicalNodeKey(level, index));
        }
        // the node has been modified since this snapshot was taken
        // because we're working with an AppendOnly tree, historical leaves never change
        // so what we do instead is rebuild this Merkle path up using zero hashes as needed
        // worst case this will do O(H) hashes
        //
        // we first check if this subtree was touched by the block
        // compare how many leaves this block added to the leaf interval of this subtree
        // if they don't intersect then the whole subtree was a hash of zero
        // if they do then we need to rebuild the merkle tree
        const depth = this.tree.getDepth();
        const leafStart = index * 2n ** BigInt(depth - level);
        if (leafStart >= this.leafCount) {
            return this.tree.getZeroHash(level);
        }
        const [lhs, rhs] = [
            this.#getHistoricalNodeValue(level + 1, 2n * index),
            this.#getHistoricalNodeValue(level + 1, 2n * index + 1n)
        ];
        return this.hasher.hash(lhs, rhs);
    }
    #getBlockNumberThatModifiedNode(level, index) {
        return this.nodeHistory.get(nodeModifiedAtBlockKey(level, index));
    }
    findLeafIndex(value) {
        return this.findLeafIndexAfter(value, 0n);
    }
    findLeafIndexAfter(value, startIndex) {
        const valueBuffer = serializeToBuffer(value);
        const numLeaves = this.getNumLeaves();
        for(let i = startIndex; i < numLeaves; i++){
            const currentValue = this.getLeafValue(i);
            if (currentValue && serializeToBuffer(currentValue).equals(valueBuffer)) {
                return i;
            }
        }
        return undefined;
    }
}
