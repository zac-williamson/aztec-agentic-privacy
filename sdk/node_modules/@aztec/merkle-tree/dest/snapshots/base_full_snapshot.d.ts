import type { BlockNumber } from '@aztec/foundation/branded-types';
import { type Bufferable, type FromBuffer } from '@aztec/foundation/serialize';
import { SiblingPath } from '@aztec/foundation/trees';
import type { AztecKVStore, AztecMap } from '@aztec/kv-store';
import type { TreeBase } from '../tree_base.js';
import type { TreeSnapshot, TreeSnapshotBuilder } from './snapshot_builder.js';
/**
 * Metadata for a snapshot, per block
 */
type SnapshotMetadata = {
    /** The tree root at the time */
    root: Buffer;
    /** The number of filled leaves */
    numLeaves: bigint;
};
/**
 * Builds a full snapshot of a tree. This implementation works for any Merkle tree and stores
 * it in a database in a similar way to how a tree is stored in memory, using pointers.
 *
 * Sharing the same database between versions and trees is recommended as the trees would share
 * structure.
 *
 * Implement the protected method `handleLeaf` to store any additional data you need for each leaf.
 *
 * Complexity:
 * N - count of non-zero nodes in tree
 * M - count of snapshots
 * H - tree height
 * Worst case space complexity: O(N * M)
 * Sibling path access: O(H) database reads
 */
export declare abstract class BaseFullTreeSnapshotBuilder<T extends TreeBase<Bufferable>, S extends TreeSnapshot<Bufferable>> implements TreeSnapshotBuilder<S> {
    #private;
    protected db: AztecKVStore;
    protected tree: T;
    protected nodes: AztecMap<string, [Buffer, Buffer]>;
    protected snapshotMetadata: AztecMap<BlockNumber, SnapshotMetadata>;
    constructor(db: AztecKVStore, tree: T);
    snapshot(block: BlockNumber): Promise<S>;
    protected handleLeaf(_index: bigint, _node: Buffer): void;
    getSnapshot(version: BlockNumber): Promise<S>;
    protected abstract openSnapshot(root: Buffer, numLeaves: bigint): S;
}
/**
 * A source of sibling paths from a snapshot tree
 */
export declare class BaseFullTreeSnapshot<T extends Bufferable> implements TreeSnapshot<T> {
    #private;
    protected db: AztecMap<string, [Buffer, Buffer]>;
    protected historicRoot: Buffer;
    protected numLeaves: bigint;
    protected tree: TreeBase<T>;
    protected deserializer: FromBuffer<T>;
    constructor(db: AztecMap<string, [Buffer, Buffer]>, historicRoot: Buffer, numLeaves: bigint, tree: TreeBase<T>, deserializer: FromBuffer<T>);
    getSiblingPath<N extends number>(index: bigint): SiblingPath<N>;
    getLeafValue(index: bigint): T | undefined;
    getDepth(): number;
    getRoot(): Buffer;
    getNumLeaves(): bigint;
    protected pathFromRootToLeaf(leafIndex: bigint): Generator<Buffer<ArrayBufferLike>[], void, unknown>;
    findLeafIndex(value: T): bigint | undefined;
    findLeafIndexAfter(value: T, startIndex: bigint): bigint | undefined;
}
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9mdWxsX3NuYXBzaG90LmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc25hcHNob3RzL2Jhc2VfZnVsbF9zbmFwc2hvdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNuRSxPQUFPLEVBQUUsS0FBSyxVQUFVLEVBQUUsS0FBSyxVQUFVLEVBQXFCLE1BQU0sNkJBQTZCLENBQUM7QUFDbEcsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3RELE9BQU8sS0FBSyxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUU5RCxPQUFPLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRCxPQUFPLEtBQUssRUFBRSxZQUFZLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUUvRTs7R0FFRztBQUNILEtBQUssZ0JBQWdCLEdBQUc7SUFDdEIsZ0NBQWdDO0lBQ2hDLElBQUksRUFBRSxNQUFNLENBQUM7SUFDYixrQ0FBa0M7SUFDbEMsU0FBUyxFQUFFLE1BQU0sQ0FBQztDQUNuQixDQUFDO0FBRUY7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsOEJBQXNCLDJCQUEyQixDQUFDLENBQUMsU0FBUyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxTQUFTLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FDbEgsWUFBVyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7O0lBTS9CLFNBQVMsQ0FBQyxFQUFFLEVBQUUsWUFBWTtJQUMxQixTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7SUFMbkIsU0FBUyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDcEQsU0FBUyxDQUFDLGdCQUFnQixFQUFFLFFBQVEsQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUVwRSxZQUNZLEVBQUUsRUFBRSxZQUFZLEVBQ2hCLElBQUksRUFBRSxDQUFDLEVBSWxCO0lBRUQsUUFBUSxDQUFDLEtBQUssRUFBRSxXQUFXLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQXNEdkM7SUFFRCxTQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sR0FBRyxJQUFJLENBQUc7SUFFNUQsV0FBVyxDQUFDLE9BQU8sRUFBRSxXQUFXLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQVE1QztJQUVELFNBQVMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sR0FBRyxDQUFDLENBQUM7Q0FLckU7QUFFRDs7R0FFRztBQUNILHFCQUFhLG9CQUFvQixDQUFDLENBQUMsU0FBUyxVQUFVLENBQUUsWUFBVyxZQUFZLENBQUMsQ0FBQyxDQUFDOztJQUU5RSxTQUFTLENBQUMsRUFBRSxFQUFFLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDaEQsU0FBUyxDQUFDLFlBQVksRUFBRSxNQUFNO0lBQzlCLFNBQVMsQ0FBQyxTQUFTLEVBQUUsTUFBTTtJQUMzQixTQUFTLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDM0IsU0FBUyxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBTHZDLFlBQ1ksRUFBRSxFQUFFLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUMsRUFDdEMsWUFBWSxFQUFFLE1BQU0sRUFDcEIsU0FBUyxFQUFFLE1BQU0sRUFDakIsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFDakIsWUFBWSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFDbkM7SUFFSixjQUFjLENBQUMsQ0FBQyxTQUFTLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FZOUQ7SUFFRCxZQUFZLENBQUMsS0FBSyxFQUFFLE1BQU0sR0FBRyxDQUFDLEdBQUcsU0FBUyxDQU96QztJQUVELFFBQVEsSUFBSSxNQUFNLENBRWpCO0lBRUQsT0FBTyxJQUFJLE1BQU0sQ0FFaEI7SUFFRCxZQUFZLElBQUksTUFBTSxDQUVyQjtJQUVELFNBQVMsQ0FBRSxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsTUFBTSx1REFrQjlDO0lBc0JELGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLE1BQU0sR0FBRyxTQUFTLENBRTFDO0lBRU0sa0JBQWtCLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxHQUFHLE1BQU0sR0FBRyxTQUFTLENBVTFFO0NBQ0YifQ==