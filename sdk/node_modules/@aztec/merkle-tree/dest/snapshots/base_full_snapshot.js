import { serializeToBuffer } from '@aztec/foundation/serialize';
import { SiblingPath } from '@aztec/foundation/trees';
/**
 * Builds a full snapshot of a tree. This implementation works for any Merkle tree and stores
 * it in a database in a similar way to how a tree is stored in memory, using pointers.
 *
 * Sharing the same database between versions and trees is recommended as the trees would share
 * structure.
 *
 * Implement the protected method `handleLeaf` to store any additional data you need for each leaf.
 *
 * Complexity:
 * N - count of non-zero nodes in tree
 * M - count of snapshots
 * H - tree height
 * Worst case space complexity: O(N * M)
 * Sibling path access: O(H) database reads
 */ export class BaseFullTreeSnapshotBuilder {
    db;
    tree;
    nodes;
    snapshotMetadata;
    constructor(db, tree){
        this.db = db;
        this.tree = tree;
        this.nodes = db.openMap(`full_snapshot:${tree.getName()}:node`);
        this.snapshotMetadata = db.openMap(`full_snapshot:${tree.getName()}:metadata`);
    }
    snapshot(block) {
        return this.db.transaction(()=>{
            const snapshotMetadata = this.#getSnapshotMeta(block);
            if (snapshotMetadata) {
                return this.openSnapshot(snapshotMetadata.root, snapshotMetadata.numLeaves);
            }
            const root = this.tree.getRoot(false);
            const numLeaves = this.tree.getNumLeaves(false);
            const depth = this.tree.getDepth();
            const queue = [
                [
                    root,
                    0,
                    0n
                ]
            ];
            // walk the tree breadth-first and store each of its nodes in the database
            // for each node we save two keys
            //   <node hash>:0 -> <left child's hash>
            //   <node hash>:1 -> <right child's hash>
            while(queue.length > 0){
                const [node, level, i] = queue.shift();
                const nodeKey = node.toString('hex');
                // check if the database already has a child for this tree
                // if it does, then we know we've seen the whole subtree below it before
                // and we don't have to traverse it anymore
                // we use the left child here, but it could be anything that shows we've stored the node before
                if (this.nodes.has(nodeKey)) {
                    continue;
                }
                if (level + 1 > depth) {
                    // short circuit if we've reached the leaf level
                    // otherwise getNode might throw if we ask for the children of a leaf
                    this.handleLeaf(i, node);
                    continue;
                }
                const [lhs, rhs] = [
                    this.tree.getNode(level + 1, 2n * i),
                    this.tree.getNode(level + 1, 2n * i + 1n)
                ];
                // we want the zero hash at the children's level, not the node's level
                const zeroHash = this.tree.getZeroHash(level + 1);
                void this.nodes.set(nodeKey, [
                    lhs ?? zeroHash,
                    rhs ?? zeroHash
                ]);
                // enqueue the children only if they're not zero hashes
                if (lhs) {
                    queue.push([
                        lhs,
                        level + 1,
                        2n * i
                    ]);
                }
                if (rhs) {
                    queue.push([
                        rhs,
                        level + 1,
                        2n * i + 1n
                    ]);
                }
            }
            void this.snapshotMetadata.set(block, {
                root,
                numLeaves
            });
            return this.openSnapshot(root, numLeaves);
        });
    }
    handleLeaf(_index, _node) {}
    getSnapshot(version) {
        const snapshotMetadata = this.#getSnapshotMeta(version);
        if (!snapshotMetadata) {
            return Promise.reject(new Error(`Version ${version} does not exist for tree ${this.tree.getName()}`));
        }
        return Promise.resolve(this.openSnapshot(snapshotMetadata.root, snapshotMetadata.numLeaves));
    }
    #getSnapshotMeta(block) {
        return this.snapshotMetadata.get(block);
    }
}
/**
 * A source of sibling paths from a snapshot tree
 */ export class BaseFullTreeSnapshot {
    db;
    historicRoot;
    numLeaves;
    tree;
    deserializer;
    constructor(db, historicRoot, numLeaves, tree, deserializer){
        this.db = db;
        this.historicRoot = historicRoot;
        this.numLeaves = numLeaves;
        this.tree = tree;
        this.deserializer = deserializer;
    }
    getSiblingPath(index) {
        const siblings = [];
        for (const [_node, sibling] of this.pathFromRootToLeaf(index)){
            siblings.push(sibling);
        }
        // we got the siblings we were looking for, but they are in root-leaf order
        // reverse them here so we have leaf-root (what SiblingPath expects)
        siblings.reverse();
        return new SiblingPath(this.tree.getDepth(), siblings);
    }
    getLeafValue(index) {
        let leafNode = undefined;
        for (const [node, _sibling] of this.pathFromRootToLeaf(index)){
            leafNode = node;
        }
        return leafNode ? this.deserializer.fromBuffer(leafNode) : undefined;
    }
    getDepth() {
        return this.tree.getDepth();
    }
    getRoot() {
        return this.historicRoot;
    }
    getNumLeaves() {
        return this.numLeaves;
    }
    *pathFromRootToLeaf(leafIndex) {
        const root = this.historicRoot;
        const pathFromRoot = this.#getPathFromRoot(leafIndex);
        let node = root;
        for(let i = 0; i < pathFromRoot.length; i++){
            // get both children. We'll need both anyway (one to keep track of, the other to walk down to)
            const children = this.db.get(node.toString('hex')) ?? [
                this.tree.getZeroHash(i + 1),
                this.tree.getZeroHash(i + 1)
            ];
            const next = children[pathFromRoot[i]];
            const sibling = children[(pathFromRoot[i] + 1) % 2];
            yield [
                next,
                sibling
            ];
            node = next;
        }
    }
    /**
   * Calculates the path from the root to the target leaf. Returns an array of 0s and 1s,
   * each 0 represents walking down a left child and each 1 walking down to the child on the right.
   *
   * @param leafIndex - The target leaf
   * @returns An array of 0s and 1s
   */ #getPathFromRoot(leafIndex) {
        const path = [];
        let level = this.tree.getDepth();
        while(level > 0){
            path.push(leafIndex & 0x01n ? 1 : 0);
            leafIndex >>= 1n;
            level--;
        }
        path.reverse();
        return path;
    }
    findLeafIndex(value) {
        return this.findLeafIndexAfter(value, 0n);
    }
    findLeafIndexAfter(value, startIndex) {
        const numLeaves = this.getNumLeaves();
        const buffer = serializeToBuffer(value);
        for(let i = startIndex; i < numLeaves; i++){
            const currentValue = this.getLeafValue(i);
            if (currentValue && serializeToBuffer(currentValue).equals(buffer)) {
                return i;
            }
        }
        return undefined;
    }
}
