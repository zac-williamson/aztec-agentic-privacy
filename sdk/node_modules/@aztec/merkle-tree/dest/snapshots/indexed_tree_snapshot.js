import { BaseFullTreeSnapshot, BaseFullTreeSnapshotBuilder } from './base_full_snapshot.js';
const snapshotLeafValue = (node, index)=>'snapshot:leaf:' + node.toString('hex') + ':' + index;
/** a */ export class IndexedTreeSnapshotBuilder extends BaseFullTreeSnapshotBuilder {
    leafPreimageBuilder;
    leaves;
    constructor(store, tree, leafPreimageBuilder){
        super(store, tree), this.leafPreimageBuilder = leafPreimageBuilder;
        this.leaves = store.openMap('indexed_tree_snapshot:' + tree.getName());
    }
    openSnapshot(root, numLeaves) {
        return new IndexedTreeSnapshotImpl(this.nodes, this.leaves, root, numLeaves, this.tree, this.leafPreimageBuilder);
    }
    handleLeaf(index, node) {
        const leafPreimage = this.tree.getLatestLeafPreimageCopy(index, false);
        if (leafPreimage) {
            void this.leaves.set(snapshotLeafValue(node, index), leafPreimage.toBuffer());
        }
    }
}
/** A snapshot of an indexed tree at a particular point in time */ class IndexedTreeSnapshotImpl extends BaseFullTreeSnapshot {
    leaves;
    leafPreimageBuilder;
    constructor(db, leaves, historicRoot, numLeaves, tree, leafPreimageBuilder){
        super(db, historicRoot, numLeaves, tree, {
            fromBuffer: (buf)=>buf
        }), this.leaves = leaves, this.leafPreimageBuilder = leafPreimageBuilder;
    }
    getLeafValue(index) {
        const leafPreimage = this.getLatestLeafPreimageCopy(index);
        return leafPreimage?.toBuffer();
    }
    getLatestLeafPreimageCopy(index) {
        const leafNode = super.getLeafValue(index);
        const leafValue = this.leaves.get(snapshotLeafValue(leafNode, index));
        if (leafValue) {
            return this.leafPreimageBuilder.fromBuffer(leafValue);
        } else {
            return undefined;
        }
    }
    findIndexOfPreviousKey(newValue) {
        const numLeaves = this.getNumLeaves();
        const diff = [];
        for(let i = 0; i < numLeaves; i++){
            // this is very inefficient
            const storedLeaf = this.getLatestLeafPreimageCopy(BigInt(i));
            // The stored leaf can be undefined if it addresses an empty leaf
            // If the leaf is empty we do the same as if the leaf was larger
            if (storedLeaf === undefined) {
                diff.push(newValue);
            } else if (storedLeaf.getKey() > newValue) {
                diff.push(newValue);
            } else if (storedLeaf.getKey() === newValue) {
                return {
                    index: BigInt(i),
                    alreadyPresent: true
                };
            } else {
                diff.push(newValue - storedLeaf.getKey());
            }
        }
        let minIndex = 0;
        for(let i = 1; i < diff.length; i++){
            if (diff[i] < diff[minIndex]) {
                minIndex = i;
            }
        }
        return {
            index: BigInt(minIndex),
            alreadyPresent: false
        };
    }
    findLeafIndex(value) {
        const index = this.tree.findLeafIndex(value, false);
        if (index !== undefined && index < this.getNumLeaves()) {
            return index;
        }
    }
}
