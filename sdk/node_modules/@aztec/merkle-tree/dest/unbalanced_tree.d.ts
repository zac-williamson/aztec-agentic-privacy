import { type Bufferable, type FromBuffer } from '@aztec/foundation/serialize';
import { SiblingPath } from '@aztec/foundation/trees';
import type { Hasher } from '@aztec/foundation/trees';
import { HasherWithStats } from './hasher_with_stats.js';
import type { MerkleTree } from './interfaces/merkle_tree.js';
/**
 * An ephemeral unbalanced Merkle tree implementation.
 * Follows the rollup implementation which greedily hashes pairs of nodes up the tree.
 * Remaining rightmost nodes are shifted up until they can be paired.
 */
export declare class UnbalancedTree<T extends Bufferable = Buffer> implements MerkleTree<T> {
    private name;
    private maxDepth;
    protected deserializer: FromBuffer<T>;
    private cache;
    private valueCache;
    protected size: bigint;
    protected readonly maxIndex: bigint;
    protected hasher: HasherWithStats;
    root: Buffer;
    constructor(hasher: Hasher, name: string, maxDepth: number | undefined, deserializer: FromBuffer<T>);
    /**
     * Returns the root of the tree.
     * @returns The root of the tree.
     */
    getRoot(): Buffer;
    /**
     * Returns the number of leaves in the tree.
     * @returns The number of leaves in the tree.
     */
    getNumLeaves(): bigint;
    /**
     * Returns the max depth of the tree.
     * @returns The max depth of the tree.
     */
    getDepth(): number;
    /**
     * @remark A wonky tree is (currently) only ever ephemeral, so we don't use any db to commit to.
     * The fn must exist to implement MerkleTree however.
     */
    commit(): Promise<void>;
    /**
     * Rolls back the not-yet-committed changes.
     * @returns Empty promise.
     */
    rollback(): Promise<void>;
    /**
     * Clears the cache.
     */
    private clearCache;
    /**
     * @remark A wonky tree can validly have duplicate indices:
     * e.g. 001 (index 1 at level 3) and 01 (index 1 at level 2)
     * So this function cannot reliably give the expected leaf value.
     * We cannot add level as an input as its based on the MerkleTree class's function.
     */
    getLeafValue(_index: bigint): undefined;
    /**
     * Returns the index of a leaf given its value, or undefined if no leaf with that value is found.
     * @param leaf - The leaf value to look for.
     * @returns The index of the first leaf found with a given value (undefined if not found).
     * @remark This is NOT the index as inserted, but the index which will be used to calculate path structure.
     */
    findLeafIndex(value: T): bigint | undefined;
    /**
     * Returns the first index containing a leaf value after `startIndex`.
     * @param value - The leaf value to look for.
     * @param startIndex - The index to start searching from.
     * @returns The index of the first leaf found with a given value (undefined if not found).
     * @remark This is not really used for a wonky tree, but required to implement MerkleTree.
     */
    findLeafIndexAfter(value: T, startIndex: bigint): bigint | undefined;
    /**
     * Returns the node at the given level and index
     * @param level - The level of the element (root is at level 0).
     * @param index - The index of the element.
     * @returns Leaf or node value, or undefined.
     */
    getNode(level: number, index: bigint): Buffer | undefined;
    /**
     * Returns a sibling path for the element at the given index.
     * @param value - The value of the element.
     * @returns A sibling path for the element.
     * Note: The sibling path is an array of sibling hashes, with the lowest hash (leaf hash) first, and the highest hash last.
     */
    getSiblingPath<N extends number>(value: bigint): Promise<SiblingPath<N>>;
    /**
     * Appends the given leaves to the tree.
     * @param leaves - The leaves to append.
     * @returns Empty promise.
     */
    appendLeaves(leaves: T[]): Promise<void>;
    /**
     * Calculates root while adding leaves and nodes to the cache.
     * @param leaves - The leaves to append.
     * @returns Resulting root of the tree.
     */
    private batchInsert;
    /**
     * Stores the given node in the cache.
     * @param value - The value to store.
     * @param depth - The depth of the node in the full tree.
     * @param index - The index of the node at the given depth.
     */
    private storeNode;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5iYWxhbmNlZF90cmVlLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdW5iYWxhbmNlZF90cmVlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxLQUFLLFVBQVUsRUFBRSxLQUFLLFVBQVUsRUFBcUIsTUFBTSw2QkFBNkIsQ0FBQztBQUNsRyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDdEQsT0FBTyxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFdEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pELE9BQU8sS0FBSyxFQUFFLFVBQVUsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBSTlEOzs7O0dBSUc7QUFDSCxxQkFBYSxjQUFjLENBQUMsQ0FBQyxTQUFTLFVBQVUsR0FBRyxNQUFNLENBQUUsWUFBVyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBYS9FLE9BQU8sQ0FBQyxJQUFJO0lBQ1osT0FBTyxDQUFDLFFBQVE7SUFDaEIsU0FBUyxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBYnZDLE9BQU8sQ0FBQyxLQUFLLENBQWlDO0lBRTlDLE9BQU8sQ0FBQyxVQUFVLENBQWlDO0lBQ25ELFNBQVMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFNO0lBQzVCLFNBQVMsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQztJQUVwQyxTQUFTLENBQUMsTUFBTSxFQUFFLGVBQWUsQ0FBQztJQUNsQyxJQUFJLEVBQUUsTUFBTSxDQUFvQjtJQUVoQyxZQUNFLE1BQU0sRUFBRSxNQUFNLEVBQ04sSUFBSSxFQUFFLE1BQU0sRUFDWixRQUFRLG9CQUFZLEVBQ2xCLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBSXRDO0lBRUQ7OztPQUdHO0lBQ0ksT0FBTyxJQUFJLE1BQU0sQ0FFdkI7SUFFRDs7O09BR0c7SUFDSSxZQUFZLFdBRWxCO0lBRUQ7OztPQUdHO0lBQ0ksUUFBUSxJQUFJLE1BQU0sQ0FFeEI7SUFFRDs7O09BR0c7SUFDSSxNQUFNLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUc3QjtJQUVEOzs7T0FHRztJQUNJLFFBQVEsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBRy9CO0lBRUQ7O09BRUc7SUFDSCxPQUFPLENBQUMsVUFBVTtJQUtsQjs7Ozs7T0FLRztJQUNJLFlBQVksQ0FBQyxNQUFNLEVBQUUsTUFBTSxHQUFHLFNBQVMsQ0FFN0M7SUFFRDs7Ozs7T0FLRztJQUNJLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLE1BQU0sR0FBRyxTQUFTLENBSWpEO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksa0JBQWtCLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxHQUFHLE1BQU0sR0FBRyxTQUFTLENBTTFFO0lBRUQ7Ozs7O09BS0c7SUFDSSxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxHQUFHLE1BQU0sR0FBRyxTQUFTLENBVS9EO0lBRUQ7Ozs7O09BS0c7SUFDSSxjQUFjLENBQUMsQ0FBQyxTQUFTLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FjOUU7SUFFRDs7OztPQUlHO0lBQ0ksWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBWTlDO0lBRUQ7Ozs7T0FJRztJQUNILE9BQU8sQ0FBQyxXQUFXO0lBeUNuQjs7Ozs7T0FLRztJQUNILE9BQU8sQ0FBQyxTQUFTO0NBS2xCIn0=