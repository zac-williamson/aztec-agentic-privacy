import { type Logger } from '@aztec/foundation/log';
import { type Bufferable, type FromBuffer } from '@aztec/foundation/serialize';
import { type Hasher, SiblingPath } from '@aztec/foundation/trees';
import type { AztecKVStore } from '@aztec/kv-store';
import { HasherWithStats } from './hasher_with_stats.js';
import type { MerkleTree } from './interfaces/merkle_tree.js';
export declare const getTreeMeta: (store: AztecKVStore, treeName: string) => {
    root: Buffer<ArrayBufferLike>;
    depth: number;
    size: bigint;
};
export declare const INITIAL_LEAF: Buffer<ArrayBuffer>;
/**
 * A Merkle tree implementation that uses a LevelDB database to store the tree.
 */
export declare abstract class TreeBase<T extends Bufferable> implements MerkleTree<T> {
    protected store: AztecKVStore;
    private name;
    private depth;
    protected size: bigint;
    protected deserializer: FromBuffer<T>;
    protected readonly maxIndex: bigint;
    protected cachedSize?: bigint;
    private root;
    private zeroHashes;
    private cache;
    protected log: Logger;
    protected hasher: HasherWithStats;
    private nodes;
    private meta;
    constructor(store: AztecKVStore, hasher: Hasher, name: string, depth: number, size: bigint | undefined, deserializer: FromBuffer<T>, root?: Buffer);
    /**
     * Returns the root of the tree.
     * @param includeUncommitted - If true, root incorporating uncommitted changes is returned.
     * @returns The root of the tree.
     */
    getRoot(includeUncommitted: boolean): Buffer;
    /**
     * Returns the number of leaves in the tree.
     * @param includeUncommitted - If true, the returned number of leaves includes uncommitted changes.
     * @returns The number of leaves in the tree.
     */
    getNumLeaves(includeUncommitted: boolean): bigint;
    /**
     * Returns the name of the tree.
     * @returns The name of the tree.
     */
    getName(): string;
    /**
     * Returns the depth of the tree.
     * @returns The depth of the tree.
     */
    getDepth(): number;
    /**
     * Returns a sibling path for the element at the given index.
     * @param index - The index of the element.
     * @param includeUncommitted - Indicates whether to get a sibling path incorporating uncommitted changes.
     * @returns A sibling path for the element at the given index.
     * Note: The sibling path is an array of sibling hashes, with the lowest hash (leaf hash) first, and the highest hash last.
     */
    getSiblingPath<N extends number>(index: bigint, includeUncommitted: boolean): Promise<SiblingPath<N>>;
    /**
     * Commits the changes to the database.
     * @returns Empty promise.
     */
    commit(): Promise<void>;
    /**
     * Rolls back the not-yet-committed changes.
     * @returns Empty promise.
     */
    rollback(): Promise<void>;
    /**
     * Gets the value at the given index.
     * @param index - The index of the leaf.
     * @param includeUncommitted - Indicates whether to include uncommitted changes.
     * @returns Leaf value at the given index or undefined.
     */
    getLeafValue(index: bigint, includeUncommitted: boolean): T | undefined;
    /**
     * Gets the value at the given index.
     * @param index - The index of the leaf.
     * @param includeUncommitted - Indicates whether to include uncommitted changes.
     * @returns Leaf value at the given index or undefined.
     */
    getLeafBuffer(index: bigint, includeUncommitted: boolean): Buffer | undefined;
    getNode(level: number, index: bigint): Buffer | undefined;
    getZeroHash(level: number): Buffer;
    /**
     * Clears the cache.
     */
    private clearCache;
    /**
     * Adds a leaf and all the hashes above it to the cache.
     * @param leaf - Leaf to add to cache.
     * @param index - Index of the leaf (used to derive the cache key).
     */
    protected addLeafToCacheAndHashToRoot(leaf: Buffer, index: bigint): void;
    /**
     * Returns the latest value at the given index.
     * @param level - The level of the tree.
     * @param index - The index of the element.
     * @param includeUncommitted - Indicates, whether to get include uncommitted changes.
     * @returns The latest value at the given index.
     * Note: If the value is not in the cache, it will be fetched from the database.
     */
    private getLatestValueAtIndex;
    /**
     * Gets a value from db by key.
     * @param key - The key to by which to get the value.
     * @returns A value from the db based on the key.
     */
    private dbGet;
    /**
     * Initializes the tree.
     * @param prefilledSize - A number of leaves that are prefilled with values.
     * @returns Empty promise.
     */
    init(prefilledSize: number): Promise<void>;
    /**
     * Writes meta data to the provided batch.
     * @param batch - The batch to which to write the meta data.
     */
    protected writeMeta(): Promise<boolean>;
    /**
     * Appends the given leaves to the tree.
     * @param leaves - The leaves to append.
     * @returns Empty promise.
     *
     * @remarks The batch insertion algorithm works as follows:
     *          1. Insert all the leaves,
     *          2. start iterating over levels from the bottom up,
     *          3. on each level iterate over all the affected nodes (i.e. nodes whose preimages have changed),
     *          4. fetch the preimage, hash it and insert the updated value.
     * @remarks This algorithm is optimal when it comes to the number of hashing operations. It might not be optimal when
     *          it comes to the number of database reads, but that should be irrelevant given that most of the time
     *          `getLatestValueAtIndex` will return a value from cache (because at least one of the 2 children was
     *          touched in previous iteration).
     */
    protected appendLeaves(leaves: T[]): void;
    /**
     * Returns the index of a leaf given its value, or undefined if no leaf with that value is found.
     * @param value - The leaf value to look for.
     * @param includeUncommitted - Indicates whether to include uncommitted data.
     * @returns The index of the first leaf found with a given value (undefined if not found).
     */
    abstract findLeafIndex(value: T, includeUncommitted: boolean): bigint | undefined;
    /**
     * Returns the first index containing a leaf value after `startIndex`.
     * @param leaf - The leaf value to look for.
     * @param startIndex - The index to start searching from (used when skipping nullified messages)
     * @param includeUncommitted - Indicates whether to include uncommitted data.
     * @returns The index of the first leaf found with a given value (undefined if not found).
     */
    abstract findLeafIndexAfter(leaf: T, startIndex: bigint, includeUncommitted: boolean): bigint | undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZV9iYXNlLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdHJlZV9iYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxLQUFLLE1BQU0sRUFBZ0IsTUFBTSx1QkFBdUIsQ0FBQztBQUNsRSxPQUFPLEVBQUUsS0FBSyxVQUFVLEVBQUUsS0FBSyxVQUFVLEVBQXFCLE1BQU0sNkJBQTZCLENBQUM7QUFDbEcsT0FBTyxFQUFFLEtBQUssTUFBTSxFQUFFLFdBQVcsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ25FLE9BQU8sS0FBSyxFQUFFLFlBQVksRUFBNEIsTUFBTSxpQkFBaUIsQ0FBQztBQUU5RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDekQsT0FBTyxLQUFLLEVBQUUsVUFBVSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUF5QjlELGVBQU8sTUFBTSxXQUFXOzs7O0NBT3ZCLENBQUM7QUFFRixlQUFPLE1BQU0sWUFBWSxxQkFBeUYsQ0FBQztBQUVuSDs7R0FFRztBQUNILDhCQUFzQixRQUFRLENBQUMsQ0FBQyxTQUFTLFVBQVUsQ0FBRSxZQUFXLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFhekUsU0FBUyxDQUFDLEtBQUssRUFBRSxZQUFZO0lBRTdCLE9BQU8sQ0FBQyxJQUFJO0lBQ1osT0FBTyxDQUFDLEtBQUs7SUFDYixTQUFTLENBQUMsSUFBSSxFQUFFLE1BQU07SUFDdEIsU0FBUyxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBakJ2QyxTQUFTLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUM7SUFDcEMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxFQUFFLE1BQU0sQ0FBQztJQUM5QixPQUFPLENBQUMsSUFBSSxDQUFVO0lBQ3RCLE9BQU8sQ0FBQyxVQUFVLENBQWdCO0lBQ2xDLE9BQU8sQ0FBQyxLQUFLLENBQWlDO0lBQzlDLFNBQVMsQ0FBQyxH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