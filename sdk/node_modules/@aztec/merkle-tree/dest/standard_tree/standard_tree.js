import { serializeToBuffer } from '@aztec/foundation/serialize';
import { Timer } from '@aztec/foundation/timer';
import { AppendOnlySnapshotBuilder } from '../snapshots/append_only_snapshot.js';
import { TreeBase } from '../tree_base.js';
/**
 * A Merkle tree implementation that uses a LevelDB database to store the tree.
 */ export class StandardTree extends TreeBase {
    #snapshotBuilder = new AppendOnlySnapshotBuilder(this.store, this, this.hasher, this.deserializer);
    /**
   * Appends the given leaves to the tree.
   * @param leaves - The leaves to append.
   * @returns Empty promise.
   */ appendLeaves(leaves) {
        this.hasher.reset();
        const timer = new Timer();
        super.appendLeaves(leaves);
        this.log.debug(`Inserted ${leaves.length} leaves into ${this.getName()} tree`, {
            eventName: 'tree-insertion',
            duration: timer.ms(),
            batchSize: leaves.length,
            treeName: this.getName(),
            treeDepth: this.getDepth(),
            treeType: 'append-only',
            ...this.hasher.stats()
        });
    }
    snapshot(blockNumber) {
        return this.#snapshotBuilder.snapshot(blockNumber);
    }
    getSnapshot(blockNumber) {
        return this.#snapshotBuilder.getSnapshot(blockNumber);
    }
    findLeafIndex(value, includeUncommitted) {
        return this.findLeafIndexAfter(value, 0n, includeUncommitted);
    }
    findLeafIndexAfter(value, startIndex, includeUncommitted) {
        const buffer = serializeToBuffer(value);
        for(let i = startIndex; i < this.getNumLeaves(includeUncommitted); i++){
            const currentValue = this.getLeafValue(i, includeUncommitted);
            if (currentValue && serializeToBuffer(currentValue).equals(buffer)) {
                return i;
            }
        }
        return undefined;
    }
}
