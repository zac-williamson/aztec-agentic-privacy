import type { BlockNumber } from '@aztec/foundation/branded-types';
import type { FromBuffer } from '@aztec/foundation/serialize';
import { SiblingPath } from '@aztec/foundation/trees';
import type { Hasher, IndexedTreeLeaf, IndexedTreeLeafPreimage } from '@aztec/foundation/trees';
import type { AztecKVStore, AztecMap } from '@aztec/kv-store';
import type { BatchInsertionResult } from '@aztec/stdlib/trees';
import type { IndexedTree, PreimageFactory } from '../interfaces/indexed_tree.js';
import type { IndexedTreeSnapshot } from '../snapshots/snapshot_builder.js';
import { TreeBase } from '../tree_base.js';
export declare const buildDbKeyForPreimage: (name: string, index: bigint) => `${string}:leaf_by_index:${string}`;
export declare const buildDbKeyForLeafIndex: (name: string, key: bigint) => `${string}:leaf_index_by_leaf_key:${string}`;
/**
 * Factory for creating leaves.
 */
export interface LeafFactory {
    /**
     * Creates a new leaf from a buffer.
     * @param key - Key of the leaf.
     */
    buildDummy(key: bigint): IndexedTreeLeaf;
    /**
     * Creates a new leaf from a buffer.
     * @param buffer - Buffer to create a leaf from.
     */
    fromBuffer(buffer: Buffer): IndexedTreeLeaf;
}
export declare const noopDeserializer: FromBuffer<Buffer>;
/**
 * Standard implementation of an indexed tree.
 */
export declare class StandardIndexedTree extends TreeBase<Buffer> implements IndexedTree {
    #private;
    protected leafPreimageFactory: PreimageFactory;
    protected leafFactory: LeafFactory;
    protected cachedLeafPreimages: {
        [key: string]: IndexedTreeLeafPreimage;
    };
    protected leaves: AztecMap<ReturnType<typeof buildDbKeyForPreimage>, Buffer>;
    protected leafIndex: AztecMap<ReturnType<typeof buildDbKeyForLeafIndex>, bigint>;
    constructor(store: AztecKVStore, hasher: Hasher, name: string, depth: number, size: bigint | undefined, leafPreimageFactory: PreimageFactory, leafFactory: LeafFactory, root?: Buffer);
    /**
     * Appends the given leaves to the tree.
     * @param _leaves - The leaves to append.
     * @returns Empty promise.
     * @remarks Use batchInsert method instead.
     */
    appendLeaves(_leaves: Buffer[]): void;
    /**
     * Commits the changes to the database.
     * @returns Empty promise.
     */
    commit(): Promise<void>;
    /**
     * Rolls back the not-yet-committed changes.
     * @returns Empty promise.
     */
    rollback(): Promise<void>;
    /**
     * Gets the value of the leaf at the given index.
     * @param index - Index of the leaf of which to obtain the value.
     * @param includeUncommitted - Indicates whether to include uncommitted leaves in the computation.
     * @returns The value of the leaf at the given index or undefined if the leaf is empty.
     */
    getLeafValue(index: bigint, includeUncommitted: boolean): Buffer | undefined;
    /**
     * Finds the index of the largest leaf whose value is less than or equal to the provided value.
     * @param newKey - The new key to be inserted into the tree.
     * @param includeUncommitted - If true, the uncommitted changes are included in the search.
     * @returns The found leaf index and a flag indicating if the corresponding leaf's value is equal to `newValue`.
     */
    findIndexOfPreviousKey(newKey: bigint, includeUncommitted: boolean): {
        /**
         * The index of the found leaf.
         */
        index: bigint;
        /**
         * A flag indicating if the corresponding leaf's value is equal to `newValue`.
         */
        alreadyPresent: boolean;
    } | undefined;
    private getCachedLowLeafIndex;
    private getCachedLeafIndex;
    private getDbLowLeafIndex;
    private getDbPreimage;
    private getCachedPreimage;
    /**
     * Gets the latest LeafPreimage copy.
     * @param index - Index of the leaf of which to obtain the LeafPreimage copy.
     * @param includeUncommitted - If true, the uncommitted changes are included in the search.
     * @returns A copy of the leaf preimage at the given index or undefined if the leaf was not found.
     */
    getLatestLeafPreimageCopy(index: bigint, includeUncommitted: boolean): IndexedTreeLeafPreimage | undefined;
    /**
     * Returns the index of a leaf given its value, or undefined if no leaf with that value is found.
     * @param value - The leaf value to look for.
     * @param includeUncommitted - Indicates whether to include uncommitted data.
     * @returns The index of the first leaf found with a given value (undefined if not found).
     */
    findLeafIndex(value: Buffer, includeUncommitted: boolean): bigint | undefined;
    findLeafIndexAfter(_leaf: Buffer, _startIndex: bigint, _includeUncommitted: boolean): bigint | undefined;
    /**
     * Initializes the tree.
     * @param prefilledSize - A number of leaves that are prefilled with values.
     * @returns Empty promise.
     *
     * @remarks Explanation of pre-filling:
     *    There needs to be an initial (0,0,0) leaf in the tree, so that when we insert the first 'proper' leaf, we can
     *    prove that any value greater than 0 doesn't exist in the tree yet. We prefill/pad the tree with "the number of
     *    leaves that are added by one block" so that the first 'proper' block can insert a full subtree.
     *
     *    Without this padding, there would be a leaf (0,0,0) at leaf index 0, making it really difficult to insert e.g.
     *    1024 leaves for the first block, because there's only neat space for 1023 leaves after 0. By padding with 1023
     *    more leaves, we can then insert the first block of 1024 leaves into indices 1024:2047.
     */
    init(prefilledSize: number): Promise<void>;
    /**
     * Commits all the leaves to the database and removes them from a cache.
     */
    private commitLeaves;
    /**
     * Clears the cache.
     */
    private clearCachedLeaves;
    /**
     * Updates a leaf in the tree.
     * @param preimage - New contents of the leaf.
     * @param index - Index of the leaf to be updated.
     */
    protected updateLeaf(preimage: IndexedTreeLeafPreimage, index: bigint): void;
    /**
     *
     * Each base rollup needs to provide non membership / inclusion proofs for each of the nullifier.
     * This method will return membership proofs and perform partial node updates that will
     * allow the circuit to incrementally update the tree and perform a batch insertion.
     *
     * This offers massive circuit performance savings over doing incremental insertions.
     *
     * WARNING: This function has side effects, it will insert values into the tree.
     *
     * Assumptions:
     * 1. There are 8 nullifiers provided and they are either unique or empty. (denoted as 0)
     * 2. If kc 0 has 1 nullifier, and kc 1 has 3 nullifiers the layout will assume to be the sparse
     *   nullifier layout: [kc0-0, 0, 0, 0, kc1-0, kc1-1, kc1-2, 0]
     *
     * Algorithm overview
     *
     * In general, if we want to batch insert items, we first need to update their low nullifier to point to them,
     * then batch insert all of the values at once in the final step.
     * To update a low nullifier, we provide an insertion proof that the low nullifier currently exists to the
     * circuit, then update the low nullifier.
     * Updating this low nullifier will in turn change the root of the tree. Therefore future low nullifier insertion proofs
     * must be given against this new root.
     * As a result, each low nullifier membership proof will be provided against an intermediate tree state, each with differing
     * roots.
     *
     * This become tricky when two items that are being batch inserted need to update the same low nullifier, or need to use
     * a value that is part of the same batch insertion as their low nullifier. What we do to avoid this case is to
     * update the existing leaves in the tree with the nullifiers in high to low order, ensuring that this case never occurs.
     * The circuit has to sort the nullifiers (or take a hint of the sorted nullifiers and prove that it's a valid permutation).
     * Then we just batch insert the new nullifiers in the original order.
     *
     * The following example will illustrate attempting to insert 2,3,20,19 into a tree already containing 0,5,10,15
     *
     * The example will explore two cases. In each case the values low nullifier will exist within the batch insertion,
     * One where the low nullifier comes before the item in the set (2,3), and one where it comes after (20,19).
     *
     * First, we sort the nullifiers high to low, that's 20,19,3,2
     *
     * The original tree:                       Pending insertion subtree
     *
     *  index     0       1       2       3         -       -       -       -
     *  -------------------------------------      ----------------------------
     *  val       0       5      10      15         -       -       -       -
     *  nextIdx   1       2       3       0         -       -       -       -
     *  nextVal   5      10      15       0         -       -       -       -
     *
     *
     * Inserting 20:
     * 1. Find the low nullifier (3) - provide inclusion proof
     * 2. Update its pointers
     * 3. Insert 20 into the pending subtree
     *
     *  index     0       1       2       3         -       -       6       -
     *  -------------------------------------      ----------------------------
     *  val       0       5      10      15         -       -      20       -
     *  nextIdx   1       2       3       6         -       -       0       -
     *  nextVal   5      10      15      20         -       -       0       -
     *
     * Inserting 19:
     * 1. Find the low nullifier (3) - provide inclusion proof
     * 2. Update its pointers
     * 3. Insert 19 into the pending subtree
     *
     *  index     0       1       2       3         -       -       6       7
     *  -------------------------------------      ----------------------------
     *  val       0       5      10      15         -       -      20      19
     *  nextIdx   1       2       3       7         -       -       0       6
     *  nextVal   5      10      15      19         -       -       0      20
     *
     * Inserting 3:
     * 1. Find the low nullifier (0) - provide inclusion proof
     * 2. Update its pointers
     * 3. Insert 3 into the pending subtree
     *
     *  index     0       1       2       3         -       5       6       7
     *  -------------------------------------      ----------------------------
     *  val       0       5      10      15         -       3      20      19
     *  nextIdx   5       2       3       7         -       1       0       6
     *  nextVal   3      10      15      19         -       5       0      20
     *
     * Inserting 2:
     * 1. Find the low nullifier (0) - provide inclusion proof
     * 2. Update its pointers
     * 3. Insert 2 into the pending subtree
     *
     *  index     0       1       2       3         4       5       6       7
     *  -------------------------------------      ----------------------------
     *  val       0       5      10      15         2       3      20      19
     *  nextIdx   4       2       3       7         5       1       0       6
     *  nextVal   2      10      15      19         3       5       0      20
     *
     * Perform subtree insertion
     *
     *  index     0       1       2       3       4       5       6       7
     *  ---------------------------------------------------------------------
     *  val       0       5      10      15       2       3      20      19
     *  nextIdx   4       2       3       7       5       1       0       6
     *  nextVal   2      10      15      19       3       5       0      20
     *
     * For leaves that allow updating the process is exactly the same. When a leaf is inserted that is already present,
     * the low leaf will be the leaf that is being updated, and it'll get updated and an empty leaf will be inserted instead.
     * For example:
     *
     * Initial state:
     *
     *  index     0       1       2       3        4       5       6       7
     *  ---------------------------------------------------------------------
     *  slot      0       0       0       0        0       0       0       0
     *  value     0       0       0       0        0       0       0       0
     *  nextIdx   0       0       0       0        0       0       0       0
     *  nextSlot  0       0       0       0        0       0       0       0.
     *
     *
     *  Add new value 30:5:
     *
     *  index     0       1       2       3        4       5       6       7
     *  ---------------------------------------------------------------------
     *  slot      0       30      0       0        0       0       0       0
     *  value     0       5       0       0        0       0       0       0
     *  nextIdx   1       0       0       0        0       0       0       0
     *  nextSlot  30      0       0       0        0       0       0       0.
     *
     *
     *  Update the value of 30 to 10 (insert 30:10):
     *
     *  index     0       1       2       3        4       5       6       7
     *  ---------------------------------------------------------------------
     *  slot      0       30      0       0        0       0       0       0
     *  value     0       10      0       0        0       0       0       0
     *  nextIdx   1       0       0       0        0       0       0       0
     *  nextSlot  30      0       0       0        0       0       0       0.
     *
     *  The low leaf is 30, so we update it to 10, and insert an empty leaf at index 2.
     *
     * @param leaves - Values to insert into the tree.
     * @param subtreeHeight - Height of the subtree.
     * @returns The data for the leaves to be updated when inserting the new ones.
     */
    batchInsert<TreeHeight extends number, SubtreeHeight extends number, SubtreeSiblingPathHeight extends number>(leaves: Buffer[], subtreeHeight: SubtreeHeight): Promise<BatchInsertionResult<TreeHeight, SubtreeSiblingPathHeight>>;
    getSubtreeSiblingPath<SubtreeHeight extends number, SubtreeSiblingPathHeight extends number>(subtreeHeight: SubtreeHeight, includeUncommitted: boolean): Promise<SiblingPath<SubtreeSiblingPathHeight>>;
    snapshot(blockNumber: BlockNumber): Promise<IndexedTreeSnapshot>;
    getSnapshot(blockNumber: BlockNumber): Promise<IndexedTreeSnapshot>;
    /**
     * Encodes leaves and appends them to a tree.
     * @param preimages - Leaves to encode.
     * @param hash0Leaf - Indicates whether 0 value leaf should be hashed. See {@link encodeLeaf}.
     * @returns Empty promise
     */
    private encodeAndAppendLeaves;
    /**
     * Encode a leaf into a buffer.
     * @param leaf - Leaf to encode.
     * @param hash0Leaf - Indicates whether 0 value leaf should be hashed. Not hashing 0 value can represent a forced
     *                    null leaf insertion. Detecting this case by checking for 0 value is safe as in the case of
     *                    nullifier it is improbable that a valid nullifier would be 0.
     * @returns Leaf encoded in a buffer.
     */
    private encodeLeaf;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhbmRhcmRfaW5kZXhlZF90cmVlLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc3RhbmRhcmRfaW5kZXhlZF90cmVlL3N0YW5kYXJkX2luZGV4ZWRfdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNuRSxPQUFPLEtBQUssRUFBRSxVQUFVLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUU5RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDdEQsT0FBTyxLQUFLLEVBQUUsTUFBTSxFQUFFLGVBQWUsRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ2hHLE9BQU8sS0FBSyxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUU5RCxPQUFPLEtBQUssRUFBRSxvQkFBb0IsRUFBeUIsTUFBTSxxQkFBcUIsQ0FBQztBQUV2RixPQUFPLEtBQUssRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFbEYsT0FBTyxLQUFLLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUM1RSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFM0MsZUFBTyxNQUFNLHFCQUFxQixzRUFFakMsQ0FBQztBQUVGLGVBQU8sTUFBTSxzQkFBc0IsNkVBRWxDLENBQUM7QUFFRjs7R0FFRztBQUNILE1BQU0sV0FBVyxXQUFXO0lBQzFCOzs7T0FHRztJQUNILFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxHQUFHLGVBQWUsQ0FBQztJQUN6Qzs7O09BR0c7SUFDSCxVQUFVLENBQUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxlQUFlLENBQUM7Q0FDN0M7QUFrQkQsZUFBTyxNQUFNLGdCQUFnQixFQUFFLFVBQVUsQ0FBQyxNQUFNLENBRS9DLENB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