var _computedKey;
import { FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH, PUBLIC_LOG_HEADER_LENGTH } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, FieldReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
function totalSizeInFields(logs) {
    return logs.reduce((acc, log)=>acc + log.sizeInFields(), 0);
}
// This class represents logs in the same format as noir does, with a bounded maximum length.
export class FlatPublicLogs {
    length;
    payload;
    // We don't use tuple here because FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH is too large
    constructor(length, payload){
        this.length = length;
        this.payload = payload;
        if (payload.length !== FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH) {
            throw new Error('Invalid payload given to FlatPublicLogs');
        }
        if (length > payload.length) {
            throw new Error('Invalid length given to FlatPublicLogs');
        }
    }
    static fromUnpaddedPayload(payload) {
        const length = payload.length;
        return new FlatPublicLogs(length, [
            ...payload,
            ...Array(FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH - length).fill(Fr.ZERO)
        ]);
    }
    // In blobs, the actual nonempty length of the logs is encoded with the prefix, and then we have the non-padded payload.
    static fromBlobFields(length, fields) {
        const reader = FieldReader.asReader(fields);
        const payload = reader.readFieldArray(length);
        return this.fromUnpaddedPayload(payload);
    }
    toBlobFields() {
        return this.payload.slice(0, this.length);
    }
    static fromLogs(logs) {
        return this.fromUnpaddedPayload(logs.flatMap((log)=>log.toFields()));
    }
    toLogs() {
        const reader = FieldReader.asReader(this.payload);
        const logs = [];
        while(totalSizeInFields(logs) < this.length){
            logs.push(PublicLog.fromFields(reader));
        }
        if (totalSizeInFields(logs) !== this.length) {
            throw new Error('Wrong length in FlatPublicLogs');
        }
        return logs;
    }
    static get schema() {
        return z.object({
            length: z.number(),
            payload: z.array(schemas.Fr).min(FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH).max(FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH)
        }).transform(({ length, payload })=>new FlatPublicLogs(length, payload));
    }
    toBuffer() {
        return serializeToBuffer(this.length, this.payload.slice(0, this.length));
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const length = reader.readNumber();
        return this.fromUnpaddedPayload(reader.readArray(length, Fr));
    }
    // ToFields and fromFields expect the noir style representation, with constant length payload.
    toFields() {
        return [
            new Fr(this.length),
            ...this.payload
        ];
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        // We need to do this because field reader returns tuples, which break the type system on these sizes.
        const length = reader.readU32();
        const payload = [];
        for(let i = 0; i < FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH; ++i){
            payload.push(reader.readField());
        }
        return new FlatPublicLogs(length, payload);
    }
    static empty() {
        return new FlatPublicLogs(0, Array(FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH).fill(Fr.ZERO));
    }
    /**
   * Creates a FlatPublicLogs instance from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing FlatPublicLogs fields
   * @returns A FlatPublicLogs instance
   */ static fromPlainObject(obj) {
        return new FlatPublicLogs(obj.length, obj.payload.map((p)=>Fr.fromPlainObject(p)));
    }
    isEmpty() {
        return this.length === 0;
    }
}
_computedKey = inspect.custom;
export class PublicLog {
    contractAddress;
    fields;
    constructor(contractAddress, fields){
        this.contractAddress = contractAddress;
        this.fields = fields;
    }
    static from(fields) {
        return new PublicLog(...PublicLog.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.contractAddress,
            fields.fields
        ];
    }
    toFields() {
        return [
            new Fr(this.fields.length),
            this.contractAddress.toField(),
            ...this.fields
        ];
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        const fieldsLength = reader.readU32();
        return new PublicLog(reader.readObject(AztecAddress), reader.readFieldArray(fieldsLength));
    }
    sizeInFields() {
        return this.fields.length + PUBLIC_LOG_HEADER_LENGTH;
    }
    getEmittedFields() {
        return this.fields.slice(0);
    }
    getEmittedFieldsWithoutTag() {
        return this.fields.slice(1);
    }
    isEmpty() {
        return this.contractAddress.isZero() && this.fields.length === 0;
    }
    static empty() {
        return new PublicLog(AztecAddress.ZERO, []);
    }
    toBuffer() {
        return serializeToBuffer(this.fields.length, this.contractAddress, this.fields);
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const fieldsLength = reader.readNumber();
        return new PublicLog(reader.readObject(AztecAddress), reader.readArray(fieldsLength, Fr));
    }
    static fromPlainObject(obj) {
        return new PublicLog(AztecAddress.fromPlainObject(obj.contractAddress), obj.fields.map((f)=>Fr.fromPlainObject(f)));
    }
    static async random() {
        return new PublicLog(await AztecAddress.random(), Array.from({
            length: 10
        }, ()=>Fr.random()));
    }
    equals(other) {
        return this.fields.length === other.fields.length && this.contractAddress.equals(other.contractAddress) && this.fields.every((field, i)=>field.equals(other.fields[i]));
    }
    toHumanReadable() {
        return `PublicLog: (contractAddress: ${this.contractAddress} fields: ${this.fields})`;
    }
    static get schema() {
        return z.object({
            contractAddress: AztecAddress.schema,
            fields: z.array(schemas.Fr)
        }).transform(({ contractAddress, fields })=>PublicLog.from({
                contractAddress,
                fields
            }));
    }
    [_computedKey]() {
        return `PublicLog {
      contractAddress: ${inspect(this.contractAddress)},
      fields: [${this.fields.map((x)=>inspect(x)).join(', ')}],
    }`;
    }
}
