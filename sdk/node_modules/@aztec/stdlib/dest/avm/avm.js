import { DEFAULT_MAX_DEBUG_LOG_MEMORY_READS } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { jsonParseWithSchema, jsonStringify } from '@aztec/foundation/json-rpc';
import { z } from 'zod';
import { FunctionSelector } from '../abi/index.js';
import { AztecAddress } from '../aztec-address/index.js';
import { AllContractDeploymentData, ContractDeploymentData } from '../contract/index.js';
import { SimulationError } from '../errors/simulation_error.js';
import { computeEffectiveGasFees } from '../fees/transaction_fee.js';
import { Gas } from '../gas/gas.js';
import { GasFees } from '../gas/gas_fees.js';
import { GasSettings } from '../gas/gas_settings.js';
import { GasUsed } from '../gas/gas_used.js';
import { PublicKeys } from '../keys/public_keys.js';
import { DebugLog } from '../logs/debug_log.js';
import { PublicLog } from '../logs/public_log.js';
import { ScopedL2ToL1Message } from '../messaging/l2_to_l1_message.js';
import { NullishToUndefined, schemas } from '../schemas/schemas.js';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { MerkleTreeId } from '../trees/merkle_tree_id.js';
import { NullifierLeaf, NullifierLeafPreimage } from '../trees/nullifier_leaf.js';
import { PublicDataTreeLeaf, PublicDataTreeLeafPreimage } from '../trees/public_data_leaf.js';
import { GlobalVariables, NestedProcessReturnValues, ProtocolContracts, PublicCallRequestWithCalldata, TreeSnapshots } from '../tx/index.js';
import { TxExecutionPhase } from '../tx/processed_tx.js';
import { WorldStateRevision } from '../world-state/world_state_revision.js';
import { AvmCircuitPublicInputs } from './avm_circuit_public_inputs.js';
import { serializeWithMessagePack } from './message_pack.js';
import { PublicDataWrite } from './public_data_write.js';
import { RevertCode } from './revert_code.js';
////////////////////////////////////////////////////////////////////////////
// Hints (contracts)
////////////////////////////////////////////////////////////////////////////
export class AvmContractClassHint {
    hintKey;
    classId;
    artifactHash;
    privateFunctionsRoot;
    packedBytecode;
    constructor(hintKey, classId, artifactHash, privateFunctionsRoot, packedBytecode){
        this.hintKey = hintKey;
        this.classId = classId;
        this.artifactHash = artifactHash;
        this.privateFunctionsRoot = privateFunctionsRoot;
        this.packedBytecode = packedBytecode;
    }
    static get schema() {
        return z.object({
            hintKey: z.number().int().nonnegative(),
            classId: schemas.Fr,
            artifactHash: schemas.Fr,
            privateFunctionsRoot: schemas.Fr,
            packedBytecode: schemas.Buffer
        }).transform(({ hintKey, classId, artifactHash, privateFunctionsRoot, packedBytecode })=>new AvmContractClassHint(hintKey, classId, artifactHash, privateFunctionsRoot, packedBytecode));
    }
    /**
   * Creates an AvmContractClassHint from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmContractClassHint fields
   * @returns An AvmContractClassHint instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmContractClassHint) {
            return obj;
        }
        return new AvmContractClassHint(obj.hintKey, Fr.fromPlainObject(obj.classId), Fr.fromPlainObject(obj.artifactHash), Fr.fromPlainObject(obj.privateFunctionsRoot), obj.packedBytecode instanceof Buffer ? obj.packedBytecode : Buffer.from(obj.packedBytecode));
    }
}
export class AvmBytecodeCommitmentHint {
    hintKey;
    classId;
    commitment;
    constructor(hintKey, classId, commitment){
        this.hintKey = hintKey;
        this.classId = classId;
        this.commitment = commitment;
    }
    static get schema() {
        return z.object({
            hintKey: z.number().int().nonnegative(),
            classId: schemas.Fr,
            commitment: schemas.Fr
        }).transform(({ hintKey, classId, commitment })=>new AvmBytecodeCommitmentHint(hintKey, classId, commitment));
    }
    /**
   * Creates an AvmBytecodeCommitmentHint from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmBytecodeCommitmentHint fields
   * @returns An AvmBytecodeCommitmentHint instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmBytecodeCommitmentHint) {
            return obj;
        }
        return new AvmBytecodeCommitmentHint(obj.hintKey, Fr.fromPlainObject(obj.classId), Fr.fromPlainObject(obj.commitment));
    }
}
export class AvmContractInstanceHint {
    hintKey;
    address;
    salt;
    deployer;
    currentContractClassId;
    originalContractClassId;
    initializationHash;
    publicKeys;
    constructor(hintKey, address, salt, deployer, currentContractClassId, originalContractClassId, initializationHash, publicKeys){
        this.hintKey = hintKey;
        this.address = address;
        this.salt = salt;
        this.deployer = deployer;
        this.currentContractClassId = currentContractClassId;
        this.originalContractClassId = originalContractClassId;
        this.initializationHash = initializationHash;
        this.publicKeys = publicKeys;
    }
    static get schema() {
        return z.object({
            hintKey: z.number().int().nonnegative(),
            address: AztecAddress.schema,
            salt: schemas.Fr,
            deployer: AztecAddress.schema,
            currentContractClassId: schemas.Fr,
            originalContractClassId: schemas.Fr,
            initializationHash: schemas.Fr,
            publicKeys: PublicKeys.schema
        }).transform(({ hintKey, address, salt, deployer, currentContractClassId, originalContractClassId, initializationHash, publicKeys })=>new AvmContractInstanceHint(hintKey, address, salt, deployer, currentContractClassId, originalContractClassId, initializationHash, publicKeys));
    }
    /**
   * Creates an AvmContractInstanceHint from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmContractInstanceHint fields
   * @returns An AvmContractInstanceHint instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmContractInstanceHint) {
            return obj;
        }
        return new AvmContractInstanceHint(obj.hintKey, AztecAddress.fromPlainObject(obj.address), Fr.fromPlainObject(obj.salt), AztecAddress.fromPlainObject(obj.deployer), Fr.fromPlainObject(obj.currentContractClassId), Fr.fromPlainObject(obj.originalContractClassId), Fr.fromPlainObject(obj.initializationHash), PublicKeys.fromPlainObject(obj.publicKeys));
    }
}
export class AvmDebugFunctionNameHint {
    address;
    selector;
    name;
    constructor(address, selector, name){
        this.address = address;
        this.selector = selector;
        this.name = name;
    }
    static get schema() {
        return z.object({
            address: AztecAddress.schema,
            selector: schemas.Fr,
            name: z.string()
        }).transform(({ address, selector, name })=>new AvmDebugFunctionNameHint(address, selector, name));
    }
    /**
   * Creates an AvmDebugFunctionNameHint from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmDebugFunctionNameHint fields
   * @returns An AvmDebugFunctionNameHint instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmDebugFunctionNameHint) {
            return obj;
        }
        return new AvmDebugFunctionNameHint(AztecAddress.fromPlainObject(obj.address), Fr.fromPlainObject(obj.selector), obj.name);
    }
}
////////////////////////////////////////////////////////////////////////////
// Hints (merkle db)
////////////////////////////////////////////////////////////////////////////
// Hint for MerkleTreeDB.getSiblingPath.
export class AvmGetSiblingPathHint {
    hintKey;
    treeId;
    index;
    path;
    constructor(hintKey, // params
    treeId, index, // return
    path){
        this.hintKey = hintKey;
        this.treeId = treeId;
        this.index = index;
        this.path = path;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            index: schemas.BigInt,
            path: schemas.Fr.array()
        }).transform(({ hintKey, treeId, index, path })=>new AvmGetSiblingPathHint(hintKey, treeId, index, path));
    }
    /**
   * Creates an AvmGetSiblingPathHint from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmGetSiblingPathHint fields
   * @returns An AvmGetSiblingPathHint instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmGetSiblingPathHint) {
            return obj;
        }
        return new AvmGetSiblingPathHint(AppendOnlyTreeSnapshot.fromPlainObject(obj.hintKey), obj.treeId, typeof obj.index === 'bigint' ? obj.index : BigInt(obj.index), obj.path.map((p)=>Fr.fromPlainObject(p)));
    }
}
// Hint for MerkleTreeDB.getPreviousValueIndex.
export class AvmGetPreviousValueIndexHint {
    hintKey;
    treeId;
    value;
    index;
    alreadyPresent;
    constructor(hintKey, // params
    treeId, value, // return
    index, alreadyPresent){
        this.hintKey = hintKey;
        this.treeId = treeId;
        this.value = value;
        this.index = index;
        this.alreadyPresent = alreadyPresent;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            value: schemas.Fr,
            index: schemas.BigInt,
            alreadyPresent: z.boolean()
        }).transform(({ hintKey, treeId, value, index, alreadyPresent })=>new AvmGetPreviousValueIndexHint(hintKey, treeId, value, index, alreadyPresent));
    }
    /**
   * Creates an AvmGetPreviousValueIndexHint from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmGetPreviousValueIndexHint fields
   * @returns An AvmGetPreviousValueIndexHint instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmGetPreviousValueIndexHint) {
            return obj;
        }
        return new AvmGetPreviousValueIndexHint(AppendOnlyTreeSnapshot.fromPlainObject(obj.hintKey), obj.treeId, Fr.fromPlainObject(obj.value), typeof obj.index === 'bigint' ? obj.index : BigInt(obj.index), obj.alreadyPresent);
    }
}
// Hint for MerkleTreeDB.getLeafPreimage.
// NOTE: I need this factory because in order to get hold of the schema, I need an actual instance of the class,
// having the type doesn't suffice since TS does type erasure in the end.
function AvmGetLeafPreimageHintFactory(klass) {
    return class {
        hintKey;
        index;
        leafPreimage;
        constructor(hintKey, // params (tree id will be implicit)
        index, // return
        leafPreimage){
            this.hintKey = hintKey;
            this.index = index;
            this.leafPreimage = leafPreimage;
        }
        static get schema() {
            return z.object({
                hintKey: AppendOnlyTreeSnapshot.schema,
                index: schemas.BigInt,
                leafPreimage: klass.schema
            }).transform(({ hintKey, index, leafPreimage })=>new this(hintKey, index, leafPreimage));
        }
        /**
     * Creates an instance from a plain object without Zod validation.
     * This method is optimized for performance and skips validation, making it suitable
     * for deserializing trusted data (e.g., from C++ via MessagePack).
     * @param obj - Plain object containing hint fields
     * @returns An instance
     */ static fromPlainObject(obj) {
            if (obj instanceof this) {
                return obj;
            }
            return new this(AppendOnlyTreeSnapshot.fromPlainObject(obj.hintKey), typeof obj.index === 'bigint' ? obj.index : BigInt(obj.index), klass.fromPlainObject(obj.leafPreimage));
        }
    };
}
// Note: only supported for PUBLIC_DATA_TREE and NULLIFIER_TREE.
export class AvmGetLeafPreimageHintPublicDataTree extends AvmGetLeafPreimageHintFactory(PublicDataTreeLeafPreimage) {
}
export class AvmGetLeafPreimageHintNullifierTree extends AvmGetLeafPreimageHintFactory(NullifierLeafPreimage) {
}
// Hint for MerkleTreeDB.getLeafValue.
// Note: only supported for NOTE_HASH_TREE and L1_TO_L2_MESSAGE_TREE.
export class AvmGetLeafValueHint {
    hintKey;
    treeId;
    index;
    value;
    constructor(hintKey, // params
    treeId, index, // return
    value){
        this.hintKey = hintKey;
        this.treeId = treeId;
        this.index = index;
        this.value = value;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            index: schemas.BigInt,
            value: schemas.Fr
        }).transform(({ hintKey, treeId, index, value })=>new AvmGetLeafValueHint(hintKey, treeId, index, value));
    }
    /**
   * Creates an AvmGetLeafValueHint from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmGetLeafValueHint fields
   * @returns An AvmGetLeafValueHint instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmGetLeafValueHint) {
            return obj;
        }
        return new AvmGetLeafValueHint(AppendOnlyTreeSnapshot.fromPlainObject(obj.hintKey), obj.treeId, typeof obj.index === 'bigint' ? obj.index : BigInt(obj.index), Fr.fromPlainObject(obj.value));
    }
}
// Hint for MerkleTreeDB.sequentialInsert.
// NOTE: I need this factory because in order to get hold of the schema, I need an actual instance of the class,
// having the type doesn't suffice since TS does type erasure in the end.
function AvmSequentialInsertHintFactory(klass) {
    return class {
        hintKey;
        stateAfter;
        treeId;
        leaf;
        lowLeavesWitnessData;
        insertionWitnessData;
        constructor(hintKey, stateAfter, // params
        treeId, leaf, // return
        lowLeavesWitnessData, insertionWitnessData){
            this.hintKey = hintKey;
            this.stateAfter = stateAfter;
            this.treeId = treeId;
            this.leaf = leaf;
            this.lowLeavesWitnessData = lowLeavesWitnessData;
            this.insertionWitnessData = insertionWitnessData;
        }
        static get schema() {
            return z.object({
                hintKey: AppendOnlyTreeSnapshot.schema,
                stateAfter: AppendOnlyTreeSnapshot.schema,
                treeId: z.number().int().nonnegative(),
                leaf: klass.leafSchema,
                lowLeavesWitnessData: z.object({
                    leaf: klass.schema,
                    index: schemas.BigInt,
                    path: schemas.Fr.array()
                }),
                insertionWitnessData: z.object({
                    leaf: klass.schema,
                    index: schemas.BigInt,
                    path: schemas.Fr.array()
                })
            }).transform(({ hintKey, stateAfter, treeId, leaf, lowLeavesWitnessData, insertionWitnessData })=>new this(hintKey, stateAfter, treeId, leaf, lowLeavesWitnessData, insertionWitnessData));
        }
        /**
     * Creates an instance from a plain object without Zod validation.
     * This method is optimized for performance and skips validation, making it suitable
     * for deserializing trusted data (e.g., from C++ via MessagePack).
     * @param obj - Plain object containing hint fields
     * @returns An instance
     */ static fromPlainObject(obj) {
            if (obj instanceof this) {
                return obj;
            }
            // Determine the leaf class based on the klass parameter
            const LeafClass = klass === PublicDataTreeLeafPreimage ? PublicDataTreeLeaf : NullifierLeaf;
            return new this(AppendOnlyTreeSnapshot.fromPlainObject(obj.hintKey), AppendOnlyTreeSnapshot.fromPlainObject(obj.stateAfter), obj.treeId, LeafClass.fromPlainObject(obj.leaf), {
                leaf: klass.fromPlainObject(obj.lowLeavesWitnessData.leaf),
                index: typeof obj.lowLeavesWitnessData.index === 'bigint' ? obj.lowLeavesWitnessData.index : BigInt(obj.lowLeavesWitnessData.index),
                path: obj.lowLeavesWitnessData.path.map((p)=>Fr.fromPlainObject(p))
            }, {
                leaf: klass.fromPlainObject(obj.insertionWitnessData.leaf),
                index: typeof obj.insertionWitnessData.index === 'bigint' ? obj.insertionWitnessData.index : BigInt(obj.insertionWitnessData.index),
                path: obj.insertionWitnessData.path.map((p)=>Fr.fromPlainObject(p))
            });
        }
    };
}
// Note: only supported for PUBLIC_DATA_TREE and NULLIFIER_TREE.
export class AvmSequentialInsertHintPublicDataTree extends AvmSequentialInsertHintFactory(PublicDataTreeLeafPreimage) {
}
export class AvmSequentialInsertHintNullifierTree extends AvmSequentialInsertHintFactory(NullifierLeafPreimage) {
}
// Hint for MerkleTreeDB.appendLeaves.
// Note: only supported for NOTE_HASH_TREE and L1_TO_L2_MESSAGE_TREE.
export class AvmAppendLeavesHint {
    hintKey;
    stateAfter;
    treeId;
    leaves;
    constructor(hintKey, stateAfter, // params
    treeId, leaves){
        this.hintKey = hintKey;
        this.stateAfter = stateAfter;
        this.treeId = treeId;
        this.leaves = leaves;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            stateAfter: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            leaves: schemas.Fr.array()
        }).transform(({ hintKey, stateAfter, treeId, leaves })=>new AvmAppendLeavesHint(hintKey, stateAfter, treeId, leaves));
    }
    /**
   * Creates an AvmAppendLeavesHint from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmAppendLeavesHint fields
   * @returns An AvmAppendLeavesHint instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmAppendLeavesHint) {
            return obj;
        }
        return new AvmAppendLeavesHint(AppendOnlyTreeSnapshot.fromPlainObject(obj.hintKey), AppendOnlyTreeSnapshot.fromPlainObject(obj.stateAfter), obj.treeId, obj.leaves.map((l)=>Fr.fromPlainObject(l)));
    }
}
// Hint for checkpoint actions that don't change the state.
class AvmCheckpointActionNoStateChangeHint {
    actionCounter;
    oldCheckpointId;
    newCheckpointId;
    constructor(// key
    actionCounter, // current checkpoint evolution
    oldCheckpointId, newCheckpointId){
        this.actionCounter = actionCounter;
        this.oldCheckpointId = oldCheckpointId;
        this.newCheckpointId = newCheckpointId;
    }
    static get schema() {
        return z.object({
            actionCounter: z.number().int().nonnegative(),
            oldCheckpointId: z.number().int().nonnegative(),
            newCheckpointId: z.number().int().nonnegative()
        }).transform(({ actionCounter, oldCheckpointId, newCheckpointId })=>new this(actionCounter, oldCheckpointId, newCheckpointId));
    }
    /**
   * Creates an instance from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing hint fields
   * @returns An instance
   */ static fromPlainObject(obj) {
        if (obj instanceof this) {
            return obj;
        }
        return new this(obj.actionCounter, obj.oldCheckpointId, obj.newCheckpointId);
    }
}
// Hint for MerkleTreeDB.createCheckpoint.
export class AvmCreateCheckpointHint extends AvmCheckpointActionNoStateChangeHint {
}
// Hint for MerkleTreeDB.commitCheckpoint.
export class AvmCommitCheckpointHint extends AvmCheckpointActionNoStateChangeHint {
}
// Hint for MerkleTreeDB.revertCheckpoint.
export class AvmRevertCheckpointHint {
    actionCounter;
    oldCheckpointId;
    newCheckpointId;
    stateBefore;
    stateAfter;
    // We use explicit fields for MessagePack.
    constructor(// key
    actionCounter, // current checkpoint evolution
    oldCheckpointId, newCheckpointId, // state evolution
    stateBefore, stateAfter){
        this.actionCounter = actionCounter;
        this.oldCheckpointId = oldCheckpointId;
        this.newCheckpointId = newCheckpointId;
        this.stateBefore = stateBefore;
        this.stateAfter = stateAfter;
    }
    static create(actionCounter, oldCheckpointId, newCheckpointId, stateBefore, stateAfter) {
        return new AvmRevertCheckpointHint(actionCounter, oldCheckpointId, newCheckpointId, new TreeSnapshots(stateBefore[MerkleTreeId.L1_TO_L2_MESSAGE_TREE], stateBefore[MerkleTreeId.NOTE_HASH_TREE], stateBefore[MerkleTreeId.NULLIFIER_TREE], stateBefore[MerkleTreeId.PUBLIC_DATA_TREE]), new TreeSnapshots(stateAfter[MerkleTreeId.L1_TO_L2_MESSAGE_TREE], stateAfter[MerkleTreeId.NOTE_HASH_TREE], stateAfter[MerkleTreeId.NULLIFIER_TREE], stateAfter[MerkleTreeId.PUBLIC_DATA_TREE]));
    }
    static get schema() {
        return z.object({
            actionCounter: z.number().int().nonnegative(),
            oldCheckpointId: z.number().int().nonnegative(),
            newCheckpointId: z.number().int().nonnegative(),
            stateBefore: TreeSnapshots.schema,
            stateAfter: TreeSnapshots.schema
        }).transform(({ actionCounter, oldCheckpointId, newCheckpointId, stateBefore, stateAfter })=>new AvmRevertCheckpointHint(actionCounter, oldCheckpointId, newCheckpointId, stateBefore, stateAfter));
    }
    /**
   * Creates an AvmRevertCheckpointHint from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmRevertCheckpointHint fields
   * @returns An AvmRevertCheckpointHint instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmRevertCheckpointHint) {
            return obj;
        }
        return new AvmRevertCheckpointHint(obj.actionCounter, obj.oldCheckpointId, obj.newCheckpointId, TreeSnapshots.fromPlainObject(obj.stateBefore), TreeSnapshots.fromPlainObject(obj.stateAfter));
    }
}
export class AvmContractDbCreateCheckpointHint extends AvmCheckpointActionNoStateChangeHint {
}
export class AvmContractDbCommitCheckpointHint extends AvmCheckpointActionNoStateChangeHint {
}
export class AvmContractDbRevertCheckpointHint extends AvmCheckpointActionNoStateChangeHint {
}
////////////////////////////////////////////////////////////////////////////
// Hints (other)
////////////////////////////////////////////////////////////////////////////
export class AvmTxHint {
    hash;
    gasSettings;
    effectiveGasFees;
    nonRevertibleContractDeploymentData;
    revertibleContractDeploymentData;
    nonRevertibleAccumulatedData;
    revertibleAccumulatedData;
    setupEnqueuedCalls;
    appLogicEnqueuedCalls;
    teardownEnqueuedCall;
    gasUsedByPrivate;
    feePayer;
    constructor(hash, gasSettings, effectiveGasFees, nonRevertibleContractDeploymentData, revertibleContractDeploymentData, nonRevertibleAccumulatedData, revertibleAccumulatedData, setupEnqueuedCalls, appLogicEnqueuedCalls, // We need this to be null and not undefined because that's what
    // MessagePack expects for an std::optional.
    teardownEnqueuedCall, gasUsedByPrivate, feePayer){
        this.hash = hash;
        this.gasSettings = gasSettings;
        this.effectiveGasFees = effectiveGasFees;
        this.nonRevertibleContractDeploymentData = nonRevertibleContractDeploymentData;
        this.revertibleContractDeploymentData = revertibleContractDeploymentData;
        this.nonRevertibleAccumulatedData = nonRevertibleAccumulatedData;
        this.revertibleAccumulatedData = revertibleAccumulatedData;
        this.setupEnqueuedCalls = setupEnqueuedCalls;
        this.appLogicEnqueuedCalls = appLogicEnqueuedCalls;
        this.teardownEnqueuedCall = teardownEnqueuedCall;
        this.gasUsedByPrivate = gasUsedByPrivate;
        this.feePayer = feePayer;
    }
    static fromTx(tx, gasFees) {
        const setupCallRequests = tx.getNonRevertiblePublicCallRequestsWithCalldata();
        const appLogicCallRequests = tx.getRevertiblePublicCallRequestsWithCalldata();
        const teardownCallRequest = tx.getTeardownPublicCallRequestWithCalldata();
        const gasSettings = tx.data.constants.txContext.gasSettings;
        const effectiveGasFees = computeEffectiveGasFees(gasFees, gasSettings);
        const allContractDeploymentData = AllContractDeploymentData.fromTx(tx);
        // For informational purposes. Assumed quick because it should be cached.
        const txHash = tx.getTxHash();
        return new AvmTxHint(txHash.hash.toString(), gasSettings, effectiveGasFees, allContractDeploymentData.getNonRevertibleContractDeploymentData(), allContractDeploymentData.getRevertibleContractDeploymentData(), {
            noteHashes: tx.data.forPublic.nonRevertibleAccumulatedData.noteHashes.filter((x)=>!x.isZero()),
            nullifiers: tx.data.forPublic.nonRevertibleAccumulatedData.nullifiers.filter((x)=>!x.isZero()),
            l2ToL1Messages: tx.data.forPublic.nonRevertibleAccumulatedData.l2ToL1Msgs.filter((x)=>!x.isEmpty())
        }, {
            noteHashes: tx.data.forPublic.revertibleAccumulatedData.noteHashes.filter((x)=>!x.isZero()),
            nullifiers: tx.data.forPublic.revertibleAccumulatedData.nullifiers.filter((x)=>!x.isZero()),
            l2ToL1Messages: tx.data.forPublic.revertibleAccumulatedData.l2ToL1Msgs.filter((x)=>!x.isEmpty())
        }, setupCallRequests, appLogicCallRequests, teardownCallRequest ?? null, tx.data.gasUsed, tx.data.feePayer);
    }
    static empty() {
        return new AvmTxHint('', GasSettings.empty(), GasFees.empty(), ContractDeploymentData.empty(), ContractDeploymentData.empty(), {
            noteHashes: [],
            nullifiers: [],
            l2ToL1Messages: []
        }, {
            noteHashes: [],
            nullifiers: [],
            l2ToL1Messages: []
        }, [], [], null, Gas.empty(), AztecAddress.zero());
    }
    /**
   * Creates an AvmTxHint from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmTxHint fields
   * @returns An AvmTxHint instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmTxHint) {
            return obj;
        }
        return new AvmTxHint(obj.hash, GasSettings.fromPlainObject(obj.gasSettings), GasFees.fromPlainObject(obj.effectiveGasFees), ContractDeploymentData.fromPlainObject(obj.nonRevertibleContractDeploymentData), ContractDeploymentData.fromPlainObject(obj.revertibleContractDeploymentData), {
            noteHashes: obj.nonRevertibleAccumulatedData.noteHashes.map((h)=>Fr.fromPlainObject(h)),
            nullifiers: obj.nonRevertibleAccumulatedData.nullifiers.map((n)=>Fr.fromPlainObject(n)),
            l2ToL1Messages: obj.nonRevertibleAccumulatedData.l2ToL1Messages.map((m)=>ScopedL2ToL1Message.fromPlainObject(m))
        }, {
            noteHashes: obj.revertibleAccumulatedData.noteHashes.map((h)=>Fr.fromPlainObject(h)),
            nullifiers: obj.revertibleAccumulatedData.nullifiers.map((n)=>Fr.fromPlainObject(n)),
            l2ToL1Messages: obj.revertibleAccumulatedData.l2ToL1Messages.map((m)=>ScopedL2ToL1Message.fromPlainObject(m))
        }, obj.setupEnqueuedCalls.map((c)=>PublicCallRequestWithCalldata.fromPlainObject(c)), obj.appLogicEnqueuedCalls.map((c)=>PublicCallRequestWithCalldata.fromPlainObject(c)), obj.teardownEnqueuedCall ? PublicCallRequestWithCalldata.fromPlainObject(obj.teardownEnqueuedCall) : null, Gas.fromPlainObject(obj.gasUsedByPrivate), AztecAddress.fromPlainObject(obj.feePayer));
    }
    static get schema() {
        return z.object({
            hash: z.string(),
            gasSettings: GasSettings.schema,
            effectiveGasFees: GasFees.schema,
            nonRevertibleContractDeploymentData: ContractDeploymentData.schema,
            revertibleContractDeploymentData: ContractDeploymentData.schema,
            nonRevertibleAccumulatedData: z.object({
                noteHashes: schemas.Fr.array(),
                nullifiers: schemas.Fr.array(),
                l2ToL1Messages: ScopedL2ToL1Message.schema.array()
            }),
            revertibleAccumulatedData: z.object({
                noteHashes: schemas.Fr.array(),
                nullifiers: schemas.Fr.array(),
                l2ToL1Messages: ScopedL2ToL1Message.schema.array()
            }),
            setupEnqueuedCalls: PublicCallRequestWithCalldata.schema.array(),
            appLogicEnqueuedCalls: PublicCallRequestWithCalldata.schema.array(),
            teardownEnqueuedCall: PublicCallRequestWithCalldata.schema.nullable(),
            gasUsedByPrivate: Gas.schema,
            feePayer: AztecAddress.schema
        }).transform(({ hash, gasSettings, effectiveGasFees, nonRevertibleContractDeploymentData, revertibleContractDeploymentData, nonRevertibleAccumulatedData, revertibleAccumulatedData, setupEnqueuedCalls, appLogicEnqueuedCalls, teardownEnqueuedCall, gasUsedByPrivate, feePayer })=>new AvmTxHint(hash, gasSettings, effectiveGasFees, nonRevertibleContractDeploymentData, revertibleContractDeploymentData, nonRevertibleAccumulatedData, revertibleAccumulatedData, setupEnqueuedCalls, appLogicEnqueuedCalls, teardownEnqueuedCall, gasUsedByPrivate, feePayer));
    }
}
export class AvmExecutionHints {
    globalVariables;
    tx;
    protocolContracts;
    contractInstances;
    contractClasses;
    bytecodeCommitments;
    debugFunctionNames;
    contractDbCreateCheckpointHints;
    contractDbCommitCheckpointHints;
    contractDbRevertCheckpointHints;
    startingTreeRoots;
    getSiblingPathHints;
    getPreviousValueIndexHints;
    getLeafPreimageHintsPublicDataTree;
    getLeafPreimageHintsNullifierTree;
    getLeafValueHints;
    sequentialInsertHintsPublicDataTree;
    sequentialInsertHintsNullifierTree;
    appendLeavesHints;
    createCheckpointHints;
    commitCheckpointHints;
    revertCheckpointHints;
    constructor(globalVariables, tx, // Protocol contracts.
    protocolContracts, // Contract hints.
    contractInstances = [], contractClasses = [], bytecodeCommitments = [], debugFunctionNames = [], contractDbCreateCheckpointHints = [], contractDbCommitCheckpointHints = [], contractDbRevertCheckpointHints = [], // Merkle DB hints.
    startingTreeRoots = TreeSnapshots.empty(), getSiblingPathHints = [], getPreviousValueIndexHints = [], getLeafPreimageHintsPublicDataTree = [], getLeafPreimageHintsNullifierTree = [], getLeafValueHints = [], sequentialInsertHintsPublicDataTree = [], sequentialInsertHintsNullifierTree = [], appendLeavesHints = [], createCheckpointHints = [], commitCheckpointHints = [], revertCheckpointHints = []){
        this.globalVariables = globalVariables;
        this.tx = tx;
        this.protocolContracts = protocolContracts;
        this.contractInstances = contractInstances;
        this.contractClasses = contractClasses;
        this.bytecodeCommitments = bytecodeCommitments;
        this.debugFunctionNames = debugFunctionNames;
        this.contractDbCreateCheckpointHints = contractDbCreateCheckpointHints;
        this.contractDbCommitCheckpointHints = contractDbCommitCheckpointHints;
        this.contractDbRevertCheckpointHints = contractDbRevertCheckpointHints;
        this.startingTreeRoots = startingTreeRoots;
        this.getSiblingPathHints = getSiblingPathHints;
        this.getPreviousValueIndexHints = getPreviousValueIndexHints;
        this.getLeafPreimageHintsPublicDataTree = getLeafPreimageHintsPublicDataTree;
        this.getLeafPreimageHintsNullifierTree = getLeafPreimageHintsNullifierTree;
        this.getLeafValueHints = getLeafValueHints;
        this.sequentialInsertHintsPublicDataTree = sequentialInsertHintsPublicDataTree;
        this.sequentialInsertHintsNullifierTree = sequentialInsertHintsNullifierTree;
        this.appendLeavesHints = appendLeavesHints;
        this.createCheckpointHints = createCheckpointHints;
        this.commitCheckpointHints = commitCheckpointHints;
        this.revertCheckpointHints = revertCheckpointHints;
    }
    /**
   * Creates an AvmExecutionHints from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing AvmExecutionHints fields
   * @returns An AvmExecutionHints instance
   */ static fromPlainObject(obj) {
        if (obj instanceof AvmExecutionHints) {
            return obj;
        }
        return new AvmExecutionHints(GlobalVariables.fromPlainObject(obj.globalVariables), AvmTxHint.fromPlainObject(obj.tx), ProtocolContracts.fromPlainObject(obj.protocolContracts), obj.contractInstances?.map((i)=>AvmContractInstanceHint.fromPlainObject(i)) || [], obj.contractClasses?.map((c)=>AvmContractClassHint.fromPlainObject(c)) || [], obj.bytecodeCommitments?.map((b)=>AvmBytecodeCommitmentHint.fromPlainObject(b)) || [], obj.debugFunctionNames?.map((d)=>AvmDebugFunctionNameHint.fromPlainObject(d)) || [], obj.contractDbCreateCheckpointHints?.map((h)=>AvmContractDbCreateCheckpointHint.fromPlainObject(h)) || [], obj.contractDbCommitCheckpointHints?.map((h)=>AvmContractDbCommitCheckpointHint.fromPlainObject(h)) || [], obj.contractDbRevertCheckpointHints?.map((h)=>AvmContractDbRevertCheckpointHint.fromPlainObject(h)) || [], obj.startingTreeRoots ? TreeSnapshots.fromPlainObject(obj.startingTreeRoots) : TreeSnapshots.empty(), obj.getSiblingPathHints?.map((h)=>AvmGetSiblingPathHint.fromPlainObject(h)) || [], obj.getPreviousValueIndexHints?.map((h)=>AvmGetPreviousValueIndexHint.fromPlainObject(h)) || [], obj.getLeafPreimageHintsPublicDataTree?.map((h)=>AvmGetLeafPreimageHintPublicDataTree.fromPlainObject(h)) || [], obj.getLeafPreimageHintsNullifierTree?.map((h)=>AvmGetLeafPreimageHintNullifierTree.fromPlainObject(h)) || [], obj.getLeafValueHints?.map((h)=>AvmGetLeafValueHint.fromPlainObject(h)) || [], obj.sequentialInsertHintsPublicDataTree?.map((h)=>AvmSequentialInsertHintPublicDataTree.fromPlainObject(h)) || [], obj.sequentialInsertHintsNullifierTree?.map((h)=>AvmSequentialInsertHintNullifierTree.fromPlainObject(h)) || [], obj.appendLeavesHints?.map((h)=>AvmAppendLeavesHint.fromPlainObject(h)) || [], obj.createCheckpointHints?.map((h)=>AvmCreateCheckpointHint.fromPlainObject(h)) || [], obj.commitCheckpointHints?.map((h)=>AvmCommitCheckpointHint.fromPlainObject(h)) || [], obj.revertCheckpointHints?.map((h)=>AvmRevertCheckpointHint.fromPlainObject(h)) || []);
    }
    static empty() {
        return new AvmExecutionHints(GlobalVariables.empty(), AvmTxHint.empty(), ProtocolContracts.empty());
    }
    static get schema() {
        return z.object({
            globalVariables: GlobalVariables.schema,
            tx: AvmTxHint.schema,
            protocolContracts: ProtocolContracts.schema,
            contractInstances: AvmContractInstanceHint.schema.array(),
            contractClasses: AvmContractClassHint.schema.array(),
            bytecodeCommitments: AvmBytecodeCommitmentHint.schema.array(),
            debugFunctionNames: AvmDebugFunctionNameHint.schema.array(),
            contractDbCreateCheckpointHints: AvmContractDbCreateCheckpointHint.schema.array(),
            contractDbCommitCheckpointHints: AvmContractDbCommitCheckpointHint.schema.array(),
            contractDbRevertCheckpointHints: AvmContractDbRevertCheckpointHint.schema.array(),
            startingTreeRoots: TreeSnapshots.schema,
            getSiblingPathHints: AvmGetSiblingPathHint.schema.array(),
            getPreviousValueIndexHints: AvmGetPreviousValueIndexHint.schema.array(),
            getLeafPreimageHintsPublicDataTree: AvmGetLeafPreimageHintPublicDataTree.schema.array(),
            getLeafPreimageHintsNullifierTree: AvmGetLeafPreimageHintNullifierTree.schema.array(),
            getLeafValueHints: AvmGetLeafValueHint.schema.array(),
            sequentialInsertHintsPublicDataTree: AvmSequentialInsertHintPublicDataTree.schema.array(),
            sequentialInsertHintsNullifierTree: AvmSequentialInsertHintNullifierTree.schema.array(),
            appendLeavesHints: AvmAppendLeavesHint.schema.array(),
            createCheckpointHints: AvmCreateCheckpointHint.schema.array(),
            commitCheckpointHints: AvmCommitCheckpointHint.schema.array(),
            revertCheckpointHints: AvmRevertCheckpointHint.schema.array()
        }).transform(({ globalVariables, tx, protocolContracts, contractInstances, contractClasses, bytecodeCommitments, debugFunctionNames, contractDbCreateCheckpointHints, contractDbCommitCheckpointHints, contractDbRevertCheckpointHints, startingTreeRoots, getSiblingPathHints, getPreviousValueIndexHints, getLeafPreimageHintsPublicDataTree, getLeafPreimageHintsNullifierTree, getLeafValueHints, sequentialInsertHintsPublicDataTree, sequentialInsertHintsNullifierTree, appendLeavesHints, createCheckpointHints, commitCheckpointHints, revertCheckpointHints })=>new AvmExecutionHints(globalVariables, tx, protocolContracts, contractInstances, contractClasses, bytecodeCommitments, debugFunctionNames, contractDbCreateCheckpointHints, contractDbCommitCheckpointHints, contractDbRevertCheckpointHints, startingTreeRoots, getSiblingPathHints, getPreviousValueIndexHints, getLeafPreimageHintsPublicDataTree, getLeafPreimageHintsNullifierTree, getLeafValueHints, sequentialInsertHintsPublicDataTree, sequentialInsertHintsNullifierTree, appendLeavesHints, createCheckpointHints, commitCheckpointHints, revertCheckpointHints));
    }
}
export class AvmCircuitInputs {
    hints;
    publicInputs;
    constructor(hints, publicInputs){
        this.hints = hints;
        this.publicInputs = publicInputs;
    }
    static empty() {
        return new AvmCircuitInputs(AvmExecutionHints.empty(), AvmCircuitPublicInputs.empty());
    }
    static fromPlainObject(obj) {
        return new AvmCircuitInputs(AvmExecutionHints.fromPlainObject(obj.hints), AvmCircuitPublicInputs.fromPlainObject(obj.publicInputs));
    }
    static get schema() {
        return z.object({
            hints: AvmExecutionHints.schema,
            publicInputs: AvmCircuitPublicInputs.schema
        }).transform(({ hints, publicInputs })=>new AvmCircuitInputs(hints, publicInputs));
    }
    serializeWithMessagePack() {
        return serializeWithMessagePack(this);
    }
    // These are used by the prover to generate an id, and also gcs_proof_store.ts.
    toBuffer() {
        return Buffer.from(jsonStringify(this));
    }
    static fromBuffer(buf) {
        return jsonParseWithSchema(buf.toString(), this.schema);
    }
}
// Metadata about a given (enqueued or external) call.
export class CallStackMetadata {
    phase;
    contractAddress;
    callerPc;
    calldata;
    isStaticCall;
    gasLimit;
    output;
    internalCallStackAtExit;
    haltingMessage;
    reverted;
    nested;
    numNestedCalls;
    constructor(phase, contractAddress, callerPc, calldata, isStaticCall, gasLimit, output, internalCallStackAtExit, haltingMessage, reverted, nested, numNestedCalls){
        this.phase = phase;
        this.contractAddress = contractAddress;
        this.callerPc = callerPc;
        this.calldata = calldata;
        this.isStaticCall = isStaticCall;
        this.gasLimit = gasLimit;
        this.output = output;
        this.internalCallStackAtExit = internalCallStackAtExit;
        this.haltingMessage = haltingMessage;
        this.reverted = reverted;
        this.nested = nested;
        this.numNestedCalls = numNestedCalls;
    }
    static get schema() {
        return z.object({
            phase: z.nativeEnum(TxExecutionPhase),
            contractAddress: Fr.schema,
            callerPc: z.number(),
            calldata: Fr.schema.array(),
            isStaticCall: z.boolean(),
            gasLimit: Gas.schema,
            output: Fr.schema.array(),
            internalCallStackAtExit: z.number().array(),
            haltingMessage: NullishToUndefined(z.string()),
            reverted: z.boolean(),
            nested: CallStackMetadata.schema.array(),
            numNestedCalls: z.number()
        }).transform(({ phase, contractAddress, callerPc, calldata, isStaticCall, gasLimit, output, internalCallStackAtExit, haltingMessage, reverted, nested, numNestedCalls })=>new CallStackMetadata(phase, contractAddress, callerPc, calldata, isStaticCall, gasLimit, output, internalCallStackAtExit, haltingMessage, reverted, nested, numNestedCalls));
    }
    /**
   * Creates a CallStackMetadata from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing CallStackMetadata fields
   * @returns A CallStackMetadata instance
   */ static fromPlainObject(obj) {
        if (obj instanceof CallStackMetadata) {
            return obj;
        }
        return new CallStackMetadata(obj.phase, Fr.fromPlainObject(obj.contractAddress), obj.callerPc, obj.calldata.map((f)=>Fr.fromPlainObject(f)), obj.isStaticCall, Gas.fromPlainObject(obj.gasLimit), obj.output.map((f)=>Fr.fromPlainObject(f)), obj.internalCallStackAtExit.map((p)=>Number(p)), obj.haltingMessage, obj.reverted, obj.nested.map((n)=>CallStackMetadata.fromPlainObject(n)), obj.numNestedCalls);
    }
    getRevertReason() {
        const failingCall = this.findDeepestRevert([
            this
        ]);
        if (!failingCall) {
            return undefined;
        }
        const { stack, leaf } = failingCall;
        const aztecCallStack = stack.map((call)=>({
                contractAddress: AztecAddress.fromField(call.contractAddress),
                functionSelector: call.calldata.length > 0 ? FunctionSelector.fromFieldOrUndefined(call.calldata[0]) : undefined
            }));
        // The Noir call stack is the internal call stack at exit of the failing call
        const noirCallStack = leaf.internalCallStackAtExit.map((pc)=>`0.${pc}`);
        return new SimulationError(leaf.haltingMessage ?? 'Transaction reverted', aztecCallStack, leaf.output, noirCallStack);
    }
    /**
   * Finds the "rightmost deepest" revert in the call tree.
   *
   * At each level, we select the LAST (rightmost) reverted call, then recurse into its
   * nested calls to find the deepest reverted leaf along that path. The chain stops
   * when we encounter a non-reverted call (since you can choose not to rethrow).
   *
   * Examples (X = reverted, O = passed):
   *
   * 1. [X, X, X] at depth 1 -> returns the last X (rightmost)
   *
   * 2. [X(depth2), X, X] where first X has a nested revert -> returns the last X at depth 1,
   *    NOT the deeper revert in the first X (rightmost takes priority over depth)
   *
   * 3. X -> X -> X -> O -> O -> X (nested chain)
   *    Returns the 3rd X, because the O's break the reverted chain (they didn't rethrow)
   *
   * @param calls - Array of call metadata at the current level
   * @param parentStack - Accumulated stack of parent calls (for building the result)
   * @returns The deepest reverted call along the rightmost reverted path, or undefined if none
   */ findDeepestRevert(calls, parentStack = []) {
        const lastReverted = calls.findLast((call)=>call.reverted);
        if (!lastReverted) {
            return undefined;
        }
        const currentStack = [
            ...parentStack,
            lastReverted
        ];
        return this.findDeepestRevert(lastReverted.nested, currentStack) || {
            stack: currentStack,
            leaf: lastReverted
        };
    }
}
export class PublicTxEffect {
    transactionFee;
    noteHashes;
    nullifiers;
    l2ToL1Msgs;
    publicLogs;
    publicDataWrites;
    constructor(transactionFee, noteHashes, nullifiers, l2ToL1Msgs, publicLogs, publicDataWrites){
        this.transactionFee = transactionFee;
        this.noteHashes = noteHashes;
        this.nullifiers = nullifiers;
        this.l2ToL1Msgs = l2ToL1Msgs;
        this.publicLogs = publicLogs;
        this.publicDataWrites = publicDataWrites;
    }
    static empty() {
        return new PublicTxEffect(Fr.ZERO, [], [], [], [], []);
    }
    static get schema() {
        return z.object({
            transactionFee: Fr.schema,
            noteHashes: Fr.schema.array(),
            nullifiers: Fr.schema.array(),
            l2ToL1Msgs: ScopedL2ToL1Message.schema.array(),
            publicLogs: PublicLog.schema.array(),
            publicDataWrites: PublicDataWrite.schema.array()
        }).transform(PublicTxEffect.from);
    }
    static from(obj) {
        return new PublicTxEffect(obj.transactionFee, obj.noteHashes, obj.nullifiers, obj.l2ToL1Msgs, obj.publicLogs, obj.publicDataWrites);
    }
    static fromPlainObject(obj) {
        return new PublicTxEffect(Fr.fromPlainObject(obj.transactionFee), obj.noteHashes.map((h)=>Fr.fromPlainObject(h)), obj.nullifiers.map((n)=>Fr.fromPlainObject(n)), obj.l2ToL1Msgs.map((m)=>ScopedL2ToL1Message.fromPlainObject(m)), obj.publicLogs.map((l)=>PublicLog.fromPlainObject(l)), obj.publicDataWrites.map((w)=>PublicDataWrite.fromPlainObject(w)));
    }
    equals(other) {
        return this.transactionFee.equals(other.transactionFee) && this.noteHashes.length === other.noteHashes.length && this.noteHashes.every((h, i)=>h.equals(other.noteHashes[i])) && this.nullifiers.length === other.nullifiers.length && this.nullifiers.every((h, i)=>h.equals(other.nullifiers[i])) && this.l2ToL1Msgs.length === other.l2ToL1Msgs.length && this.l2ToL1Msgs.every((m, i)=>m.equals(other.l2ToL1Msgs[i])) && this.publicLogs.length === other.publicLogs.length && this.publicLogs.every((l, i)=>l.equals(other.publicLogs[i])) && this.publicDataWrites.length === other.publicDataWrites.length && this.publicDataWrites.every((w, i)=>w.equals(other.publicDataWrites[i]));
    }
}
export class PublicTxResult {
    gasUsed;
    revertCode;
    publicTxEffect;
    callStackMetadata;
    logs;
    hints;
    publicInputs;
    constructor(// Simulation result.
    gasUsed, revertCode, publicTxEffect, // These are only guaranteed to be present if the simulator is configured to collect them.
    // TODO(fcarreiro): Remove NestedProcessReturnValues[] once we migrate to the C++ simulator.
    callStackMetadata, logs, // For the proving request.
    hints, publicInputs){
        this.gasUsed = gasUsed;
        this.revertCode = revertCode;
        this.publicTxEffect = publicTxEffect;
        this.callStackMetadata = callStackMetadata;
        this.logs = logs;
        this.hints = hints;
        this.publicInputs = publicInputs;
    }
    static empty() {
        return new PublicTxResult({
            totalGas: Gas.empty(),
            teardownGas: Gas.empty(),
            publicGas: Gas.empty(),
            billedGas: Gas.empty()
        }, RevertCode.OK, PublicTxEffect.empty(), /*callStackMetadata=*/ [], /*logs=*/ [], /*hints=*/ AvmExecutionHints.empty(), /*publicInputs=*/ AvmCircuitPublicInputs.empty());
    }
    static get schema() {
        return z.object({
            gasUsed: schemas.GasUsed,
            revertCode: RevertCode.schema,
            revertReason: NullishToUndefined(SimulationError.schema),
            publicTxEffect: PublicTxEffect.schema,
            callStackMetadata: z.union([
                CallStackMetadata.schema.array(),
                NestedProcessReturnValues.schema.array()
            ]),
            logs: NullishToUndefined(DebugLog.schema.array()),
            // For the proving request.
            publicInputs: NullishToUndefined(AvmCircuitPublicInputs.schema),
            hints: NullishToUndefined(AvmExecutionHints.schema)
        }).transform(({ gasUsed, revertCode, publicTxEffect, callStackMetadata, logs, hints, publicInputs })=>new PublicTxResult(gasUsed, revertCode, publicTxEffect, callStackMetadata, logs, hints, publicInputs));
    }
    /**
   * Creates a PublicTxResult from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing PublicTxResult fields
   * @returns A PublicTxResult instance
   */ static fromPlainObject(obj) {
        return new PublicTxResult(GasUsed.fromPlainObject(obj.gasUsed), RevertCode.fromPlainObject(obj.revertCode), PublicTxEffect.fromPlainObject(obj.publicTxEffect), obj.callStackMetadata.map(CallStackMetadata.fromPlainObject), obj.logs?.map(DebugLog.fromPlainObject), obj.hints ? AvmExecutionHints.fromPlainObject(obj.hints) : undefined, obj.publicInputs ? AvmCircuitPublicInputs.fromPlainObject(obj.publicInputs) : undefined);
    }
    /** Returns one level of return values for the app logic phase, one per enqueued call. */ getAppLogicReturnValues() {
        if (this.callStackMetadata.every((metadata)=>metadata instanceof CallStackMetadata)) {
            return this.callStackMetadata.filter((metadata)=>metadata.phase === TxExecutionPhase.APP_LOGIC).map((metadata)=>new NestedProcessReturnValues(metadata.output));
        } else {
            return this.callStackMetadata.map((metadata)=>new NestedProcessReturnValues(metadata.values, metadata.nested));
        }
    }
    findRevertReason() {
        if (this.revertCode.isOK()) {
            return undefined;
        }
        const callStackMetadata = this.callStackMetadata;
        // TODO(fcarreiro): Remove this after migration to the C++ simulator.
        // If the "stack" comes from TS, it will have this field.
        if (callStackMetadata.revertReason !== undefined) {
            return callStackMetadata.revertReason;
        }
        // Handle CallStackMetadata[].
        let revertReason = undefined;
        for (const call of callStackMetadata){
            revertReason = call.getRevertReason();
            if (revertReason) {
                break;
            }
        }
        return revertReason;
    }
}
export class CollectionLimitsConfig {
    maxDebugLogMemoryReads;
    maxCalldataSizeInFields;
    maxReturndataSizeInFields;
    maxCallStackDepth;
    maxCallStackItems;
    constructor(maxDebugLogMemoryReads, maxCalldataSizeInFields, maxReturndataSizeInFields, maxCallStackDepth, maxCallStackItems){
        this.maxDebugLogMemoryReads = maxDebugLogMemoryReads;
        this.maxCalldataSizeInFields = maxCalldataSizeInFields;
        this.maxReturndataSizeInFields = maxReturndataSizeInFields;
        this.maxCallStackDepth = maxCallStackDepth;
        this.maxCallStackItems = maxCallStackItems;
    }
    static from(obj) {
        return new CollectionLimitsConfig(obj.maxDebugLogMemoryReads ?? DEFAULT_MAX_DEBUG_LOG_MEMORY_READS, obj.maxCalldataSizeInFields ?? 300, obj.maxReturndataSizeInFields ?? 300, obj.maxCallStackDepth ?? 5, obj.maxCallStackItems ?? 100);
    }
    static empty() {
        return CollectionLimitsConfig.from({});
    }
    static get schema() {
        return z.object({
            maxDebugLogMemoryReads: z.number(),
            maxCalldataSizeInFields: z.number(),
            maxReturndataSizeInFields: z.number(),
            maxCallStackDepth: z.number(),
            maxCallStackItems: z.number()
        }).transform(({ maxDebugLogMemoryReads, maxCalldataSizeInFields, maxReturndataSizeInFields, maxCallStackDepth, maxCallStackItems })=>new CollectionLimitsConfig(maxDebugLogMemoryReads, maxCalldataSizeInFields, maxReturndataSizeInFields, maxCallStackDepth, maxCallStackItems));
    }
}
export class PublicSimulatorConfig {
    proverId;
    skipFeeEnforcement;
    collectCallMetadata;
    collectHints;
    collectPublicInputs;
    collectDebugLogs;
    collectStatistics;
    collectionLimits;
    constructor(proverId, skipFeeEnforcement, collectCallMetadata, collectHints, collectPublicInputs, collectDebugLogs, collectStatistics, collectionLimits){
        this.proverId = proverId;
        this.skipFeeEnforcement = skipFeeEnforcement;
        this.collectCallMetadata = collectCallMetadata;
        this.collectHints = collectHints;
        this.collectPublicInputs = collectPublicInputs;
        this.collectDebugLogs = collectDebugLogs;
        this.collectStatistics = collectStatistics;
        this.collectionLimits = collectionLimits;
    }
    static from(obj) {
        return new PublicSimulatorConfig(obj.proverId ?? Fr.ZERO, obj.skipFeeEnforcement ?? false, obj.collectCallMetadata ?? false, obj.collectHints ?? false, obj.collectPublicInputs ?? false, obj.collectDebugLogs ?? false, obj.collectStatistics ?? false, obj.collectionLimits ?? CollectionLimitsConfig.empty());
    }
    static empty() {
        return PublicSimulatorConfig.from({});
    }
    static get schema() {
        return z.object({
            proverId: Fr.schema,
            skipFeeEnforcement: z.boolean(),
            collectCallMetadata: z.boolean(),
            collectHints: z.boolean(),
            collectPublicInputs: z.boolean(),
            collectDebugLogs: z.boolean(),
            collectStatistics: z.boolean(),
            collectionLimits: CollectionLimitsConfig.schema
        }).transform(PublicSimulatorConfig.from);
    }
}
export class AvmFastSimulationInputs {
    wsRevision;
    config;
    tx;
    globalVariables;
    protocolContracts;
    constructor(wsRevision, config, tx, globalVariables, protocolContracts){
        this.wsRevision = wsRevision;
        this.config = config;
        this.tx = tx;
        this.globalVariables = globalVariables;
        this.protocolContracts = protocolContracts;
    }
    static empty() {
        return new AvmFastSimulationInputs(WorldStateRevision.empty(), PublicSimulatorConfig.empty(), AvmTxHint.empty(), GlobalVariables.empty(), ProtocolContracts.empty());
    }
    static get schema() {
        return z.object({
            wsRevision: WorldStateRevision.schema,
            config: PublicSimulatorConfig.schema,
            tx: AvmTxHint.schema,
            globalVariables: GlobalVariables.schema,
            protocolContracts: ProtocolContracts.schema
        }).transform(({ wsRevision, config, tx, globalVariables, protocolContracts })=>new AvmFastSimulationInputs(wsRevision, config, tx, globalVariables, protocolContracts));
    }
    serializeWithMessagePack() {
        return serializeWithMessagePack(this);
    }
}
