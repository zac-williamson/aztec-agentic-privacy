import { MAX_L2_TO_L1_MSGS_PER_TX, MAX_NOTE_HASHES_PER_TX, MAX_NULLIFIERS_PER_TX, MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX } from '@aztec/constants';
import { type FieldsOf } from '@aztec/foundation/array';
import { Fr } from '@aztec/foundation/curves/bn254';
import { BufferReader, FieldReader, type Tuple } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
import { FlatPublicLogs } from '../logs/public_log.js';
import { ScopedL2ToL1Message } from '../messaging/l2_to_l1_message.js';
import { PublicDataWrite } from './public_data_write.js';
export declare class AvmAccumulatedData {
    /**
     * The note hashes from private combining with those made in the AVM execution.
     */
    noteHashes: Tuple<Fr, typeof MAX_NOTE_HASHES_PER_TX>;
    /**
     * The nullifiers from private combining with those made in the AVM execution.
     */
    nullifiers: Tuple<Fr, typeof MAX_NULLIFIERS_PER_TX>;
    /**
     * The L2 to L1 messages from private combining with those made in the AVM execution.
     */
    l2ToL1Msgs: Tuple<ScopedL2ToL1Message, typeof MAX_L2_TO_L1_MSGS_PER_TX>;
    /**
     * The public logs emitted from the AVM execution.
     */
    publicLogs: FlatPublicLogs;
    /**
     * The public data writes made in the AVM execution.
     */
    publicDataWrites: Tuple<PublicDataWrite, typeof MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX>;
    constructor(
    /**
     * The note hashes from private combining with those made in the AVM execution.
     */
    noteHashes: Tuple<Fr, typeof MAX_NOTE_HASHES_PER_TX>, 
    /**
     * The nullifiers from private combining with those made in the AVM execution.
     */
    nullifiers: Tuple<Fr, typeof MAX_NULLIFIERS_PER_TX>, 
    /**
     * The L2 to L1 messages from private combining with those made in the AVM execution.
     */
    l2ToL1Msgs: Tuple<ScopedL2ToL1Message, typeof MAX_L2_TO_L1_MSGS_PER_TX>, 
    /**
     * The public logs emitted from the AVM execution.
     */
    publicLogs: FlatPublicLogs, 
    /**
     * The public data writes made in the AVM execution.
     */
    publicDataWrites: Tuple<PublicDataWrite, typeof MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX>);
    static get schema(): z.ZodEffects<z.ZodObject<{
        noteHashes: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        nullifiers: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        l2ToL1Msgs: z.ZodArray<z.ZodEffects<z.ZodObject<{
            message: z.ZodEffects<z.ZodObject<{
                recipient: z.ZodType<import("@aztec/foundation/eth-address").EthAddress, any, string>;
                content: z.ZodType<Fr, any, string>;
            }, "strip", z.ZodTypeAny, {
                recipient: import("@aztec/foundation/eth-address").EthAddress;
                content: Fr;
            }, {
                recipient: string;
                content: string;
            }>, import("../messaging/l2_to_l1_message.js").L2ToL1Message, {
                recipient: string;
                content: string;
            }>;
            contractAddress: import("@aztec/foundation/schemas").ZodFor<import("../aztec-address/index.js").AztecAddress>;
        }, "strip", z.ZodTypeAny, {
            message: import("../messaging/l2_to_l1_message.js").L2ToL1Message;
            contractAddress: import("../aztec-address/index.js").AztecAddress;
        }, {
            message: {
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }>, ScopedL2ToL1Message, {
            message: {
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }>, "many">;
        publicLogs: import("@aztec/foundation/schemas").ZodFor<FlatPublicLogs>;
        publicDataWrites: z.ZodArray<z.ZodEffects<z.ZodObject<{
            leafSlot: z.ZodType<Fr, any, string>;
            value: z.ZodType<Fr, any, string>;
        }, "strip", z.ZodTypeAny, {
            leafSlot: Fr;
            value: Fr;
        }, {
            leafSlot: string;
            value: string;
        }>, PublicDataWrite, {
            leafSlot: string;
            value: string;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        noteHashes: Fr[];
        nullifiers: Fr[];
        l2ToL1Msgs: ScopedL2ToL1Message[];
        publicLogs: FlatPublicLogs;
        publicDataWrites: PublicDataWrite[];
    }, {
        noteHashes: string[];
        nullifiers: string[];
        l2ToL1Msgs: {
            message: {
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }[];
        publicLogs?: any;
        publicDataWrites: {
            leafSlot: string;
            value: string;
        }[];
    }>, AvmAccumulatedData, {
        noteHashes: string[];
        nullifiers: string[];
        l2ToL1Msgs: {
            message: {
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }[];
        publicLogs?: any;
        publicDataWrites: {
            leafSlot: string;
            value: string;
        }[];
    }>;
    getSize(): number;
    static fromBuffer(buffer: Buffer | BufferReader): AvmAccumulatedData;
    toBuffer(): Buffer<ArrayBufferLike>;
    static getFields(fields: FieldsOf<AvmAccumulatedData>): readonly [[Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], [ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message], FlatPublicLogs, [PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite]];
    static fromFields(fields: Fr[] | FieldReader): AvmAccumulatedData;
    toFields(): Fr[];
    static fromString(str: string): AvmAccumulatedData;
    toString(): `0x${string}`;
    static empty(): AvmAccumulatedData;
    /**
     * Creates an AvmAccumulatedData instance from a plain object without Zod validation.
     * This method is optimized for performance and skips validation, making it suitable
     * for deserializing trusted data (e.g., from C++ via MessagePack).
     * @param obj - Plain object containing AvmAccumulatedData fields
     * @returns An AvmAccumulatedData instance
     */
    static fromPlainObject(obj: any): AvmAccumulatedData;
    isEmpty(): boolean;
    [inspect.custom](): string;
    getArrayLengths(): AvmAccumulatedDataArrayLengths;
}
/**
 * Represents the lengths of arrays in AVM accumulated data
 */
export declare class AvmAccumulatedDataArrayLengths {
    /**
     * Number of note hashes
     */
    noteHashes: number;
    /**
     * Number of nullifiers
     */
    nullifiers: number;
    /**
     * Number of L2 to L1 messages
     */
    l2ToL1Msgs: number;
    /**
     * Number of public data writes
     */
    publicDataWrites: number;
    constructor(
    /**
     * Number of note hashes
     */
    noteHashes: number, 
    /**
     * Number of nullifiers
     */
    nullifiers: number, 
    /**
     * Number of L2 to L1 messages
     */
    l2ToL1Msgs: number, 
    /**
     * Number of public data writes
     */
    publicDataWrites: number);
    static get schema(): z.ZodEffects<z.ZodObject<{
        noteHashes: z.ZodNumber;
        nullifiers: z.ZodNumber;
        l2ToL1Msgs: z.ZodNumber;
        publicDataWrites: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        noteHashes: number;
        nullifiers: number;
        l2ToL1Msgs: number;
        publicDataWrites: number;
    }, {
        noteHashes: number;
        nullifiers: number;
        l2ToL1Msgs: number;
        publicDataWrites: number;
    }>, AvmAccumulatedDataArrayLengths, {
        noteHashes: number;
        nullifiers: number;
        l2ToL1Msgs: number;
        publicDataWrites: number;
    }>;
    static fromBuffer(buffer: Buffer | BufferReader): AvmAccumulatedDataArrayLengths;
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromFields(fields: Fr[] | FieldReader): AvmAccumulatedDataArrayLengths;
    toFields(): Fr[];
    static empty(): AvmAccumulatedDataArrayLengths;
    /**
     * Creates an AvmAccumulatedDataArrayLengths instance from a plain object without Zod validation.
     * This method is optimized for performance and skips validation, making it suitable
     * for deserializing trusted data (e.g., from C++ via MessagePack).
     * @param obj - Plain object containing AvmAccumulatedDataArrayLengths fields
     * @returns An AvmAccumulatedDataArrayLengths instance
     */
    static fromPlainObject(obj: any): AvmAccumulatedDataArrayLengths;
    [inspect.custom](): string;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZtX2FjY3VtdWxhdGVkX2RhdGEuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hdm0vYXZtX2FjY3VtdWxhdGVkX2RhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLHdCQUF3QixFQUN4QixzQkFBc0IsRUFDdEIscUJBQXFCLEVBQ3JCLDRDQUE0QyxFQUM3QyxNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFBRSxLQUFLLFFBQVEsRUFBYSxNQUFNLHlCQUF5QixDQUFDO0FBRW5FLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUVwRCxPQUFPLEVBQ0wsWUFBWSxFQUNaLFdBQVcsRUFDWCxLQUFLLEtBQUssRUFJWCxNQUFNLDZCQUE2QixDQUFDO0FBR3JDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLENBQUMsRUFBRSxNQUFNLEtBQUssQ0FBQztBQUd4QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdkQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDdkUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRXpELHFCQUFhLGtCQUFrQjtJQUUzQjs7T0FFRztJQUNJLFVBQVUsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLE9BQU8sc0JBQXNCLENBQUM7SUFDM0Q7O09BRUc7SUFDSSxVQUFVLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxPQUFPLHFCQUFxQixDQUFDO0lBQzFEOztPQUVHO0lBQ0ksVUFBVSxFQUFFLEtBQUssQ0FBQyxtQkFBbUIsRUFBRSxPQUFPLHdCQUF3QixDQUFDO0lBQzlFOztPQUVHO0lBQ0ksVUFBVSxFQUFFLGNBQWM7SUFDakM7O09BRUc7SUFDSSxnQkFBZ0IsRUFBRSxLQUFLLENBQUMsZUFBZSxFQUFFLE9BQU8sNENBQTRD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