import type { BlockNumber, CheckpointNumber, SlotNumber } from '@aztec/foundation/branded-types';
import type { SecretValue } from '@aztec/foundation/config';
import { Fr } from '@aztec/foundation/curves/bn254';
import type { EthAddress } from '@aztec/foundation/eth-address';
import type { Signature } from '@aztec/foundation/eth-signature';
import type { SequencerConfig, SlasherConfig } from '@aztec/stdlib/interfaces/server';
import type { BlockProposal, BlockProposalOptions, CheckpointAttestation, CheckpointLastBlockData, CheckpointProposal, CheckpointProposalOptions } from '@aztec/stdlib/p2p';
import type { CheckpointHeader } from '@aztec/stdlib/rollup';
import type { BlockHeader, Tx } from '@aztec/stdlib/tx';
import { type ValidatorHASignerConfig } from '@aztec/validator-ha-signer/config';
import type { PeerId } from '@libp2p/interface';
import { z } from 'zod';
import type { CommitteeAttestationsAndSigners } from '../block/index.js';
/**
 * Validator client configuration
 */
export type ValidatorClientConfig = ValidatorHASignerConfig & {
    /** The private keys of the validators participating in attestation duties */
    validatorPrivateKeys?: SecretValue<`0x${string}`[]>;
    /** The addresses of the validators to use with remote signers */
    validatorAddresses?: EthAddress[];
    /** Do not run the validator */
    disableValidator: boolean;
    /** Temporarily disable these specific validator addresses */
    disabledValidators: EthAddress[];
    /** Interval between polling for new attestations from peers */
    attestationPollingIntervalMs: number;
    /** Whether to re-execute transactions in a block proposal before attesting */
    validatorReexecute: boolean;
    /** Whether to always reexecute block proposals, even for non-validator nodes or when out of the currnet committee */
    alwaysReexecuteBlockProposals?: boolean;
    /** Whether to run in fisherman mode: validates all proposals and attestations but does not broadcast attestations or participate in consensus */
    fishermanMode?: boolean;
    /** Skip checkpoint proposal validation and always attest (default: false) */
    skipCheckpointProposalValidation?: boolean;
    /** Skip pushing re-executed blocks to archiver (default: false) */
    skipPushProposedBlocksToArchiver?: boolean;
    /** Agree to attest to equivocated checkpoint proposals (for testing purposes only) */
    attestToEquivocatedProposals?: boolean;
};
export type ValidatorClientFullConfig = ValidatorClientConfig & Pick<SequencerConfig, 'txPublicSetupAllowList' | 'broadcastInvalidBlockProposal'> & Pick<SlasherConfig, 'slashBroadcastedInvalidBlockPenalty' | 'slashDuplicateProposalPenalty' | 'slashDuplicateAttestationPenalty'> & {
    /**
     * Whether transactions are disabled for this node
     * @remarks This should match the property in P2PConfig. It's not picked from there to avoid circular dependencies.
     */
    disableTransactions?: boolean;
};
export declare const ValidatorClientConfigSchema: z.ZodObject<{
    haSigningEnabled: z.ZodBoolean;
    l1Contracts: z.ZodObject<{
        rollupAddress: z.ZodType<EthAddress, z.ZodTypeDef, EthAddress>;
    }, "strip", z.ZodTypeAny, {
        rollupAddress: EthAddress;
    }, {
        rollupAddress: EthAddress;
    }>;
    nodeId: z.ZodString;
    pollingIntervalMs: z.ZodNumber;
    signingTimeoutMs: z.ZodNumber;
    maxStuckDutiesAgeMs: z.ZodOptional<z.ZodNumber>;
    cleanupOldDutiesAfterHours: z.ZodOptional<z.ZodNumber>;
    databaseUrl: z.ZodOptional<z.ZodString>;
    poolMaxCount: z.ZodOptional<z.ZodNumber>;
    poolMinCount: z.ZodOptional<z.ZodNumber>;
    poolIdleTimeoutMs: z.ZodOptional<z.ZodNumber>;
    poolConnectionTimeoutMs: z.ZodOptional<z.ZodNumber>;
} & {
    validatorAddresses: z.ZodOptional<z.ZodArray<z.ZodType<EthAddress, any, string>, "many">>;
    disableValidator: z.ZodBoolean;
    disabledValidators: z.ZodArray<z.ZodType<EthAddress, any, string>, "many">;
    attestationPollingIntervalMs: z.ZodNumber;
    validatorReexecute: z.ZodBoolean;
    alwaysReexecuteBlockProposals: z.ZodOptional<z.ZodBoolean>;
    fishermanMode: z.ZodOptional<z.ZodBoolean>;
    skipCheckpointProposalValidation: z.ZodOptional<z.ZodBoolean>;
    skipPushProposedBlocksToArchiver: z.ZodOptional<z.ZodBoolean>;
    attestToEquivocatedProposals: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    haSigningEnabled: boolean;
    l1Contracts: {
        rollupAddress: EthAddress;
    };
    nodeId: string;
    pollingIntervalMs: number;
    signingTimeoutMs: number;
    maxStuckDutiesAgeMs?: number | undefined;
    cleanupOldDutiesAfterHours?: number | undefined;
    databaseUrl?: string | undefined;
    poolMaxCount?: number | undefined;
    poolMinCount?: number | undefined;
    poolIdleTimeoutMs?: number | undefined;
    poolConnectionTimeoutMs?: number | undefined;
    validatorAddresses?: EthAddress[] | undefined;
    disableValidator: boolean;
    disabledValidators: EthAddress[];
    attestationPollingIntervalMs: number;
    validatorReexecute: boolean;
    alwaysReexecuteBlockProposals?: boolean | undefined;
    fishermanMode?: boolean | undefined;
    skipCheckpointProposalValidation?: boolean | undefined;
    skipPushProposedBlocksToArchiver?: boolean | undefined;
    attestToEquivocatedProposals?: boolean | undefined;
}, {
    haSigningEnabled: boolean;
    l1Contracts: {
        rollupAddress: EthAddress;
    };
    nodeId: string;
    pollingIntervalMs: number;
    signingTimeoutMs: number;
    maxStuckDutiesAgeMs?: number | undefined;
    cleanupOldDutiesAfterHours?: number | undefined;
    databaseUrl?: string | undefined;
    poolMaxCount?: number | undefined;
    poolMinCount?: number | undefined;
    poolIdleTimeoutMs?: number | undefined;
    poolConnectionTimeoutMs?: number | undefined;
    validatorAddresses?: string[] | undefined;
    disableValidator: boolean;
    disabledValidators: string[];
    attestationPollingIntervalMs: number;
    validatorReexecute: boolean;
    alwaysReexecuteBlockProposals?: boolean | undefined;
    fishermanMode?: boolean | undefined;
    skipCheckpointProposalValidation?: boolean | undefined;
    skipPushProposedBlocksToArchiver?: boolean | undefined;
    attestToEquivocatedProposals?: boolean | undefined;
}>;
export declare const ValidatorClientFullConfigSchema: z.ZodObject<{
    haSigningEnabled: z.ZodBoolean;
    l1Contracts: z.ZodObject<{
        rollupAddress: z.ZodType<EthAddress, z.ZodTypeDef, EthAddress>;
    }, "strip", z.ZodTypeAny, {
        rollupAddress: EthAddress;
    }, {
        rollupAddress: EthAddress;
    }>;
    nodeId: z.ZodString;
    pollingIntervalMs: z.ZodNumber;
    signingTimeoutMs: z.ZodNumber;
    maxStuckDutiesAgeMs: z.ZodOptional<z.ZodNumber>;
    cleanupOldDutiesAfterHours: z.ZodOptional<z.ZodNumber>;
    databaseUrl: z.ZodOptional<z.ZodString>;
    poolMaxCount: z.ZodOptional<z.ZodNumber>;
    poolMinCount: z.ZodOptional<z.ZodNumber>;
    poolIdleTimeoutMs: z.ZodOptional<z.ZodNumber>;
    poolConnectionTimeoutMs: z.ZodOptional<z.ZodNumber>;
} & {
    validatorAddresses: z.ZodOptional<z.ZodArray<z.ZodType<EthAddress, any, string>, "many">>;
    disableValidator: z.ZodBoolean;
    disabledValidators: z.ZodArray<z.ZodType<EthAddress, any, string>, "many">;
    attestationPollingIntervalMs: z.ZodNumber;
    validatorReexecute: z.ZodBoolean;
    alwaysReexecuteBlockProposals: z.ZodOptional<z.ZodBoolean>;
    fishermanMode: z.ZodOptional<z.ZodBoolean>;
    skipCheckpointProposalValidation: z.ZodOptional<z.ZodBoolean>;
    skipPushProposedBlocksToArchiver: z.ZodOptional<z.ZodBoolean>;
    attestToEquivocatedProposals: z.ZodOptional<z.ZodBoolean>;
} & {
    txPublicSetupAllowList: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodObject<{
        address: import("@aztec/foundation/schemas").ZodFor<import("../aztec-address/index.js").AztecAddress>;
        selector: import("@aztec/foundation/schemas").ZodFor<import("../abi/function_selector.js").FunctionSelector>;
    }, "strip", z.ZodTypeAny, {
        address: import("../aztec-address/index.js").AztecAddress;
        selector: import("../abi/function_selector.js").FunctionSelector;
    }, {
        address?: any;
        selector?: any;
    }>, z.ZodObject<{
        address: import("@aztec/foundation/schemas").ZodFor<import("../aztec-address/index.js").AztecAddress>;
    }, "strip", z.ZodTypeAny, {
        address: import("../aztec-address/index.js").AztecAddress;
    }, {
        address?: any;
    }>, z.ZodObject<{
        classId: import("@aztec/foundation/schemas").ZodFor<Fr>;
        selector: import("@aztec/foundation/schemas").ZodFor<import("../abi/function_selector.js").FunctionSelector>;
    }, "strip", z.ZodTypeAny, {
        classId: Fr;
        selector: import("../abi/function_selector.js").FunctionSelector;
    }, {
        classId?: any;
        selector?: any;
    }>, z.ZodObject<{
        classId: import("@aztec/foundation/schemas").ZodFor<Fr>;
    }, "strip", z.ZodTypeAny, {
        classId: Fr;
    }, {
        classId?: any;
    }>]>, "many">>;
    broadcastInvalidBlockProposal: z.ZodOptional<z.ZodBoolean>;
    slashBroadcastedInvalidBlockPenalty: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
    slashDuplicateProposalPenalty: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
    slashDuplicateAttestationPenalty: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
    disableTransactions: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    haSigningEnabled: boolean;
    l1Contracts: {
        rollupAddress: EthAddress;
    };
    nodeId: string;
    pollingIntervalMs: number;
    signingTimeoutMs: number;
    maxStuckDutiesAgeMs?: number | undefined;
    cleanupOldDutiesAfterHours?: number | undefined;
    databaseUrl?: string | undefined;
    poolMaxCount?: number | undefined;
    poolMinCount?: number | undefined;
    poolIdleTimeoutMs?: number | undefined;
    poolConnectionTimeoutMs?: number | undefined;
    validatorAddresses?: EthAddress[] | undefined;
    disableValidator: boolean;
    disabledValidators: EthAddress[];
    attestationPollingIntervalMs: number;
    validatorReexecute: boolean;
    alwaysReexecuteBlockProposals?: boolean | undefined;
    fishermanMode?: boolean | undefined;
    skipCheckpointProposalValidation?: boolean | undefined;
    skipPushProposedBlocksToArchiver?: boolean | undefined;
    attestToEquivocatedProposals?: boolean | undefined;
    txPublicSetupAllowList?: ({
        address: import("../aztec-address/index.js").AztecAddress;
        selector: import("../abi/function_selector.js").FunctionSelector;
    } | {
        address: import("../aztec-address/index.js").AztecAddress;
    } | {
        classId: Fr;
        selector: import("../abi/function_selector.js").FunctionSelector;
    } | {
        classId: Fr;
    })[] | undefined;
    broadcastInvalidBlockProposal?: boolean | undefined;
    slashBroadcastedInvalidBlockPenalty: bigint;
    slashDuplicateProposalPenalty: bigint;
    slashDuplicateAttestationPenalty: bigint;
    disableTransactions?: boolean | undefined;
}, {
    haSigningEnabled: boolean;
    l1Contracts: {
        rollupAddress: EthAddress;
    };
    nodeId: string;
    pollingIntervalMs: number;
    signingTimeoutMs: number;
    maxStuckDutiesAgeMs?: number | undefined;
    cleanupOldDutiesAfterHours?: number | undefined;
    databaseUrl?: string | undefined;
    poolMaxCount?: number | undefined;
    poolMinCount?: number | undefined;
    poolIdleTimeoutMs?: number | undefined;
    poolConnectionTimeoutMs?: number | undefined;
    validatorAddresses?: string[] | undefined;
    disableValidator: boolean;
    disabledValidators: string[];
    attestationPollingIntervalMs: number;
    validatorReexecute: boolean;
    alwaysReexecuteBlockProposals?: boolean | undefined;
    fishermanMode?: boolean | undefined;
    skipCheckpointProposalValidation?: boolean | undefined;
    skipPushProposedBlocksToArchiver?: boolean | undefined;
    attestToEquivocatedProposals?: boolean | undefined;
    txPublicSetupAllowList?: ({
        address?: any;
        selector?: any;
    } | {
        address?: any;
    } | {
        classId?: any;
        selector?: any;
    } | {
        classId?: any;
    })[] | undefined;
    broadcastInvalidBlockProposal?: boolean | undefined;
    slashBroadcastedInvalidBlockPenalty: string | number | bigint;
    slashDuplicateProposalPenalty: string | number | bigint;
    slashDuplicateAttestationPenalty: string | number | bigint;
    disableTransactions?: boolean | undefined;
}>;
export type CreateCheckpointProposalLastBlockData = Omit<CheckpointLastBlockData, 'txHashes'> & {
    txs: Tx[];
};
export interface Validator {
    start(): Promise<void>;
    updateConfig(config: Partial<ValidatorClientFullConfig>): void;
    createBlockProposal(blockHeader: BlockHeader, indexWithinCheckpoint: number, inHash: Fr, archive: Fr, txs: Tx[], proposerAddress: EthAddress | undefined, options: BlockProposalOptions): Promise<BlockProposal | undefined>;
    /** Creates a checkpoint proposal for the last block in a checkpoint */
    createCheckpointProposal(checkpointHeader: CheckpointHeader, archive: Fr, feeAssetPriceModifier: bigint, lastBlockInfo: CreateCheckpointProposalLastBlockData | undefined, proposerAddress: EthAddress | undefined, options: CheckpointProposalOptions): Promise<CheckpointProposal>;
    /**
     * Validate a block proposal from a peer.
     * Note: Validators do NOT attest to individual blocks - attestations are only for checkpoint proposals.
     * @returns true if the proposal is valid, false otherwise
     */
    validateBlockProposal(proposal: BlockProposal, sender: PeerId): Promise<boolean>;
    /**
     * Validate and attest to a checkpoint proposal from a peer.
     * @returns Checkpoint attestations if valid, undefined otherwise
     */
    attestToCheckpointProposal(proposal: CheckpointProposal, sender: PeerId): Promise<CheckpointAttestation[] | undefined>;
    broadcastBlockProposal(proposal: BlockProposal): Promise<void>;
    /** Collect own attestations for a checkpoint proposal (used when skipping p2p attestation collection) */
    collectOwnAttestations(proposal: CheckpointProposal): Promise<CheckpointAttestation[]>;
    /** Collect attestations from the p2p network for a checkpoint proposal */
    collectAttestations(proposal: CheckpointProposal, required: number, deadline: Date): Promise<CheckpointAttestation[]>;
    signAttestationsAndSigners(attestationsAndSigners: CommitteeAttestationsAndSigners, proposer: EthAddress, slot: SlotNumber, blockNumber: BlockNumber | CheckpointNumber): Promise<Signature>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9yLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW50ZXJmYWNlcy92YWxpZGF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFLFVBQVUsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQ2pHLE9BQU8sS0FBSyxFQUFFLFdBQVcsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzVELE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNwRCxPQUFPLEtBQUssRUFBRSxVQUFVLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNoRSxPQUFPLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUVqRSxPQUFPLEtBQUssRUFBRSxlQUFlLEVBQUUsYUFBYSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDdEYsT0FBTyxLQUFLLEVBQ1YsYUFBYSxFQUNiLG9CQUFvQixFQUNwQixxQkFBcUIsRUFDckIsdUJBQXVCLEVBQ3ZCLGtCQUFrQixFQUNsQix5QkFBeUIsRUFDMUIsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEtBQUssRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQzdELE9BQU8sS0FBSyxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsS0FBSyx1QkFBdUIsRUFBaUMsTUFBTSxtQ0FBbUMsQ0FBQztBQUVoSCxPQUFPLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNoRCxPQUFPLEVBQUUsQ0FBQyxFQUFFLE1BQU0sS0FBSyxDQUFDO0FBRXhCLE9BQU8sS0FBSyxFQUFFLCtCQUErQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFHekU7O0dBRUc7QUFDSCxNQUFNLE1BQU0scUJBQXFCLEdBQUcsdUJBQXVCLEdBQUc7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