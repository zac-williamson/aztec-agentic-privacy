import { AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED, NESTED_RECURSIVE_PROOF_LENGTH, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, RECURSIVE_PROOF_LENGTH } from '@aztec/constants';
import { EpochNumber, EpochNumberSchema } from '@aztec/foundation/branded-types';
import { z } from 'zod';
import { AvmCircuitInputs } from '../avm/avm.js';
import { AvmProvingRequestSchema } from '../avm/avm_proving_request.js';
import { ParityBasePrivateInputs } from '../parity/parity_base_private_inputs.js';
import { ParityPublicInputs } from '../parity/parity_public_inputs.js';
import { ParityRootPrivateInputs } from '../parity/parity_root_private_inputs.js';
import { ProvingRequestType } from '../proofs/proving_request_type.js';
import { RecursiveProof } from '../proofs/recursive_proof.js';
import { BlockMergeRollupPrivateInputs } from '../rollup/block_merge_rollup_private_inputs.js';
import { BlockRollupPublicInputs } from '../rollup/block_rollup_public_inputs.js';
import { BlockRootEmptyTxFirstRollupPrivateInputs, BlockRootFirstRollupPrivateInputs, BlockRootRollupPrivateInputs, BlockRootSingleTxFirstRollupPrivateInputs, BlockRootSingleTxRollupPrivateInputs } from '../rollup/block_root_rollup_private_inputs.js';
import { CheckpointMergeRollupPrivateInputs } from '../rollup/checkpoint_merge_rollup_private_inputs.js';
import { CheckpointRollupPublicInputs } from '../rollup/checkpoint_rollup_public_inputs.js';
import { CheckpointPaddingRollupPrivateInputs, CheckpointRootRollupPrivateInputs, CheckpointRootSingleBlockRollupPrivateInputs } from '../rollup/checkpoint_root_rollup_private_inputs.js';
import { PrivateTxBaseRollupPrivateInputs } from '../rollup/private_tx_base_rollup_private_inputs.js';
import { PublicChonkVerifierPrivateInputs } from '../rollup/public_chonk_verifier_private_inputs.js';
import { PublicChonkVerifierPublicInputs } from '../rollup/public_chonk_verifier_public_inputs.js';
import { PublicTxBaseRollupPrivateInputs } from '../rollup/public_tx_base_rollup_private_inputs.js';
import { RootRollupPrivateInputs } from '../rollup/root_rollup_private_inputs.js';
import { RootRollupPublicInputs } from '../rollup/root_rollup_public_inputs.js';
import { TxMergeRollupPrivateInputs } from '../rollup/tx_merge_rollup_private_inputs.js';
import { TxRollupPublicInputs } from '../rollup/tx_rollup_public_inputs.js';
import { VerificationKeyData } from '../vks/verification_key.js';
export function makeProofAndVerificationKey(proof, verificationKey) {
    return {
        proof,
        verificationKey
    };
}
function schemaForPublicInputsAndRecursiveProof(inputs, proofSize) {
    return z.object({
        inputs,
        proof: RecursiveProof.schemaFor(proofSize),
        verificationKey: VerificationKeyData.schema
    });
}
export function makePublicInputsAndRecursiveProof(inputs, proof, verificationKey) {
    return {
        inputs,
        proof,
        verificationKey
    };
}
export const ProvingJobInputs = z.discriminatedUnion('type', [
    AvmProvingRequestSchema,
    z.object({
        type: z.literal(ProvingRequestType.PARITY_BASE),
        inputs: ParityBasePrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.PARITY_ROOT),
        inputs: ParityRootPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.PUBLIC_CHONK_VERIFIER),
        inputs: PublicChonkVerifierPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.PRIVATE_TX_BASE_ROLLUP),
        inputs: PrivateTxBaseRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.PUBLIC_TX_BASE_ROLLUP),
        inputs: PublicTxBaseRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.TX_MERGE_ROLLUP),
        inputs: TxMergeRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_FIRST_ROLLUP),
        inputs: BlockRootFirstRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_SINGLE_TX_FIRST_ROLLUP),
        inputs: BlockRootSingleTxFirstRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_EMPTY_TX_FIRST_ROLLUP),
        inputs: BlockRootEmptyTxFirstRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_ROLLUP),
        inputs: BlockRootRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_SINGLE_TX_ROLLUP),
        inputs: BlockRootSingleTxRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_MERGE_ROLLUP),
        inputs: BlockMergeRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.CHECKPOINT_ROOT_ROLLUP),
        inputs: CheckpointRootRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.CHECKPOINT_ROOT_SINGLE_BLOCK_ROLLUP),
        inputs: CheckpointRootSingleBlockRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.CHECKPOINT_PADDING_ROLLUP),
        inputs: CheckpointPaddingRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.CHECKPOINT_MERGE_ROLLUP),
        inputs: CheckpointMergeRollupPrivateInputs.schema
    }),
    z.object({
        type: z.literal(ProvingRequestType.ROOT_ROLLUP),
        inputs: RootRollupPrivateInputs.schema
    })
]);
export function getProvingJobInputClassFor(type) {
    switch(type){
        case ProvingRequestType.PUBLIC_VM:
            return AvmCircuitInputs;
        case ProvingRequestType.PUBLIC_CHONK_VERIFIER:
            return PublicChonkVerifierPrivateInputs;
        case ProvingRequestType.PRIVATE_TX_BASE_ROLLUP:
            return PrivateTxBaseRollupPrivateInputs;
        case ProvingRequestType.PUBLIC_TX_BASE_ROLLUP:
            return PublicTxBaseRollupPrivateInputs;
        case ProvingRequestType.TX_MERGE_ROLLUP:
            return TxMergeRollupPrivateInputs;
        case ProvingRequestType.BLOCK_ROOT_FIRST_ROLLUP:
            return BlockRootFirstRollupPrivateInputs;
        case ProvingRequestType.BLOCK_ROOT_SINGLE_TX_FIRST_ROLLUP:
            return BlockRootSingleTxFirstRollupPrivateInputs;
        case ProvingRequestType.BLOCK_ROOT_EMPTY_TX_FIRST_ROLLUP:
            return BlockRootEmptyTxFirstRollupPrivateInputs;
        case ProvingRequestType.BLOCK_ROOT_ROLLUP:
            return BlockRootRollupPrivateInputs;
        case ProvingRequestType.BLOCK_ROOT_SINGLE_TX_ROLLUP:
            return BlockRootSingleTxRollupPrivateInputs;
        case ProvingRequestType.BLOCK_MERGE_ROLLUP:
            return BlockMergeRollupPrivateInputs;
        case ProvingRequestType.CHECKPOINT_ROOT_ROLLUP:
            return CheckpointRootRollupPrivateInputs;
        case ProvingRequestType.CHECKPOINT_ROOT_SINGLE_BLOCK_ROLLUP:
            return CheckpointRootSingleBlockRollupPrivateInputs;
        case ProvingRequestType.CHECKPOINT_PADDING_ROLLUP:
            return CheckpointPaddingRollupPrivateInputs;
        case ProvingRequestType.CHECKPOINT_MERGE_ROLLUP:
            return CheckpointMergeRollupPrivateInputs;
        case ProvingRequestType.ROOT_ROLLUP:
            return RootRollupPrivateInputs;
        case ProvingRequestType.PARITY_BASE:
            return ParityBasePrivateInputs;
        case ProvingRequestType.PARITY_ROOT:
            return ParityRootPrivateInputs;
        default:
            {
                const _exhaustive = type;
                throw new Error(`Cannot find circuit inputs class for proving type ${type}`);
            }
    }
}
export const ProvingJobResult = z.discriminatedUnion('type', [
    z.object({
        type: z.literal(ProvingRequestType.PUBLIC_VM),
        result: RecursiveProof.schemaFor(AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED)
    }),
    z.object({
        type: z.literal(ProvingRequestType.PUBLIC_CHONK_VERIFIER),
        result: schemaForPublicInputsAndRecursiveProof(PublicChonkVerifierPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.PRIVATE_TX_BASE_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(TxRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.PUBLIC_TX_BASE_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(TxRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.TX_MERGE_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(TxRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_FIRST_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BlockRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_SINGLE_TX_FIRST_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BlockRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_EMPTY_TX_FIRST_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BlockRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BlockRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_ROOT_SINGLE_TX_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BlockRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.BLOCK_MERGE_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(BlockRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.CHECKPOINT_ROOT_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(CheckpointRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.CHECKPOINT_ROOT_SINGLE_BLOCK_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(CheckpointRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.CHECKPOINT_PADDING_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(CheckpointRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.CHECKPOINT_MERGE_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(CheckpointRollupPublicInputs.schema, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.ROOT_ROLLUP),
        result: schemaForPublicInputsAndRecursiveProof(RootRollupPublicInputs.schema, NESTED_RECURSIVE_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.PARITY_BASE),
        result: schemaForPublicInputsAndRecursiveProof(ParityPublicInputs.schema, RECURSIVE_PROOF_LENGTH)
    }),
    z.object({
        type: z.literal(ProvingRequestType.PARITY_ROOT),
        result: schemaForPublicInputsAndRecursiveProof(ParityPublicInputs.schema, NESTED_RECURSIVE_PROOF_LENGTH)
    })
]);
export const ProvingJobId = z.string();
export const ProofUri = z.string().brand('ProvingJobUri');
export const ProvingJob = z.object({
    id: ProvingJobId,
    type: z.nativeEnum(ProvingRequestType),
    epochNumber: EpochNumberSchema,
    inputsUri: ProofUri
});
export const makeProvingJobId = (epochNumber, type, inputsHash)=>{
    return `${epochNumber}:${ProvingRequestType[type]}:${inputsHash}`;
};
export const getEpochFromProvingJobId = (id)=>{
    const components = id.split(':');
    const epochNumber = components.length < 1 ? Number.NaN : parseInt(components[0], 10);
    if (!Number.isSafeInteger(epochNumber) || epochNumber < 0) {
        throw new Error(`Proving Job ID ${id} does not contain valid epoch`);
    }
    return EpochNumber(epochNumber);
};
export function makeProvingRequestResult(type, result) {
    return {
        type,
        result
    };
}
export const ProvingJobFulfilledResult = z.object({
    status: z.literal('fulfilled'),
    value: ProofUri
});
export const ProvingJobRejectedResult = z.object({
    status: z.literal('rejected'),
    reason: z.string()
});
export const ProvingJobSettledResult = z.discriminatedUnion('status', [
    ProvingJobFulfilledResult,
    ProvingJobRejectedResult
]);
export const ProvingJobStatus = z.discriminatedUnion('status', [
    z.object({
        status: z.literal('in-queue')
    }),
    z.object({
        status: z.literal('in-progress')
    }),
    z.object({
        status: z.literal('not-found')
    }),
    ProvingJobFulfilledResult,
    ProvingJobRejectedResult
]);
