import { ARCHIVE_HEIGHT, L1_TO_L2_MSG_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT } from '@aztec/constants';
import { type L1ContractAddresses } from '@aztec/ethereum/l1-contract-addresses';
import { BlockNumber, EpochNumber, type SlotNumber } from '@aztec/foundation/branded-types';
import type { Fr } from '@aztec/foundation/curves/bn254';
import type { EthAddress } from '@aztec/foundation/eth-address';
import { MembershipWitness, SiblingPath } from '@aztec/foundation/trees';
import type { AztecAddress } from '../aztec-address/index.js';
import { BlockHash } from '../block/block_hash.js';
import { type BlockParameter } from '../block/block_parameter.js';
import { type DataInBlock } from '../block/in_block.js';
import { L2Block } from '../block/l2_block.js';
import { type L2BlockSource, type L2Tips } from '../block/l2_block_source.js';
import { type ContractClassPublic, type ContractInstanceWithAddress, type NodeInfo, type ProtocolContractAddresses } from '../contract/index.js';
import { GasFees } from '../gas/gas_fees.js';
import { SiloedTag, Tag, TxScopedL2Log } from '../logs/index.js';
import { type LogFilter } from '../logs/log_filter.js';
import { type ApiSchemaFor } from '../schemas/schemas.js';
import { MerkleTreeId } from '../trees/merkle_tree_id.js';
import { NullifierMembershipWitness } from '../trees/nullifier_membership_witness.js';
import { PublicDataWitness } from '../trees/public_data_witness.js';
import { BlockHeader, type IndexedTxEffect, PublicSimulationOutput, Tx, TxHash, TxReceipt, type TxValidationResult } from '../tx/index.js';
import type { SingleValidatorStats, ValidatorsStats } from '../validators/types.js';
import { type ComponentsVersions } from '../versioning/index.js';
import { type AllowedElement } from './allowed_element.js';
import { type GetContractClassLogsResponse, type GetPublicLogsResponse } from './get_logs_response.js';
import { type WorldStateSyncStatus } from './world_state.js';
/**
 * The aztec node.
 * We will probably implement the additional interfaces by means other than Aztec Node as it's currently a privacy leak
 */
export interface AztecNode extends Pick<L2BlockSource, 'getBlocks' | 'getCheckpoints' | 'getBlockHeader' | 'getL2Tips' | 'getCheckpointedBlocks'> {
    /**
     * Returns the tips of the L2 chain.
     */
    getL2Tips(): Promise<L2Tips>;
    /**
     * Returns the sync status of the node's world state
     */
    getWorldStateSyncStatus(): Promise<WorldStateSyncStatus>;
    /**
     * Find the indexes of the given leaves in the given tree along with a block metadata pointing to the block in which
     * the leaves were inserted.
     * @param referenceBlock - The block parameter (block number, block hash, or 'latest') at which to get the data.
     * @param treeId - The tree to search in.
     * @param leafValues - The values to search for.
     * @returns The indices of leaves and the block metadata of a block in which the leaves were inserted.
     */
    findLeavesIndexes(referenceBlock: BlockParameter, treeId: MerkleTreeId, leafValues: Fr[]): Promise<(DataInBlock<bigint> | undefined)[]>;
    /**
     * Returns a nullifier membership witness for a given nullifier at a given block.
     * @param referenceBlock - The block parameter (block number, block hash, or 'latest') at which to get the data.
     * @param nullifier - Nullifier we try to find witness for.
     * @returns The nullifier membership witness (if found).
     */
    getNullifierMembershipWitness(referenceBlock: BlockParameter, nullifier: Fr): Promise<NullifierMembershipWitness | undefined>;
    /**
     * Returns a low nullifier membership witness for a given nullifier at a given block.
     * @param referenceBlock - The block parameter (block number, block hash, or 'latest') at which to get the data.
     * @param nullifier - Nullifier we try to find the low nullifier witness for.
     * @returns The low nullifier membership witness (if found).
     * @remarks Low nullifier witness can be used to perform a nullifier non-inclusion proof by leveraging the "linked
     * list structure" of leaves and proving that a lower nullifier is pointing to a bigger next value than the nullifier
     * we are trying to prove non-inclusion for.
     */
    getLowNullifierMembershipWitness(referenceBlock: BlockParameter, nullifier: Fr): Promise<NullifierMembershipWitness | undefined>;
    /**
     * Returns a public data tree witness for a given leaf slot at a given block.
     * @param referenceBlock - The block parameter (block number, block hash, or 'latest') at which to get the data.
     * @param leafSlot - The leaf slot we try to find the witness for.
     * @returns The public data witness (if found).
     * @remarks The witness can be used to compute the current value of the public data tree leaf. If the low leaf preimage corresponds to an
     * "in range" slot, means that the slot doesn't exist and the value is 0. If the low leaf preimage corresponds to the exact slot, the current value
     * is contained in the leaf preimage.
     */
    getPublicDataWitness(referenceBlock: BlockParameter, leafSlot: Fr): Promise<PublicDataWitness | undefined>;
    /**
     * Returns a membership witness for a given block hash in the archive tree.
     *
     * Block hashes are the leaves of the archive tree. Each time a new block is added to the chain,
     * its block hash is appended as a new leaf to the archive tree. This method finds the membership
     * witness (leaf index and sibling path) for a given block hash, which can be used to prove that
     * a specific block exists in the chain's history.
     *
     * @param referenceBlock - The block parameter (block number, block hash, or 'latest') at which to get the data
     * (which contains the root of the archive tree in which we are searching for the block hash).
     * @param blockHash - The block hash to find in the archive tree.
     */
    getBlockHashMembershipWitness(referenceBlock: BlockParameter, blockHash: BlockHash): Promise<MembershipWitness<typeof ARCHIVE_HEIGHT> | undefined>;
    /**
     * Returns a membership witness for a given note hash at a given block.
     * @param referenceBlock - The block parameter (block number, block hash, or 'latest') at which to get the data.
     * @param noteHash - The note hash we try to find the witness for.
     */
    getNoteHashMembershipWitness(referenceBlock: BlockParameter, noteHash: Fr): Promise<MembershipWitness<typeof NOTE_HASH_TREE_HEIGHT> | undefined>;
    /**
     * Returns the index and a sibling path for a leaf in the committed l1 to l2 data tree.
     * @param referenceBlock - The block parameter (block number, block hash, or 'latest') at which to get the data.
     * @param l1ToL2Message - The l1ToL2Message to get the index / sibling path for.
     * @returns A tuple of the index and the sibling path of the L1ToL2Message (undefined if not found).
     */
    getL1ToL2MessageMembershipWitness(referenceBlock: BlockParameter, l1ToL2Message: Fr): Promise<[bigint, SiblingPath<typeof L1_TO_L2_MSG_TREE_HEIGHT>] | undefined>;
    /** Returns the L2 block number in which this L1 to L2 message becomes available, or undefined if not found. */
    getL1ToL2MessageBlock(l1ToL2Message: Fr): Promise<BlockNumber | undefined>;
    /**
     * Returns whether an L1 to L2 message is synced by archiver.
     * @param l1ToL2Message - The L1 to L2 message to check.
     * @returns Whether the message is synced.
     * @deprecated Use `getL1ToL2MessageBlock` instead. This method may return true even if the message is not ready to use.
     */
    isL1ToL2MessageSynced(l1ToL2Message: Fr): Promise<boolean>;
    /**
     * Returns all the L2 to L1 messages in an epoch.
     * @param epoch - The epoch at which to get the data.
     * @returns A nested array of the L2 to L1 messages in each tx of each block in each checkpoint in the epoch (empty
     * array if the epoch is not found).
     */
    getL2ToL1Messages(epoch: EpochNumber): Promise<Fr[][][][]>;
    /**
     * Get a block specified by its block number or 'latest'.
     * @param blockParameter - The block parameter (block number, block hash, or 'latest').
     * @returns The requested block.
     */
    getBlock(blockParameter: BlockParameter): Promise<L2Block | undefined>;
    /**
     * Get a block specified by its hash.
     * @param blockHash - The block hash being requested.
     * @returns The requested block.
     */
    getBlockByHash(blockHash: BlockHash): Promise<L2Block | undefined>;
    /**
     * Get a block specified by its archive root.
     * @param archive - The archive root being requested.
     * @returns The requested block.
     */
    getBlockByArchive(archive: Fr): Promise<L2Block | undefined>;
    /**
     * Method to fetch the latest block number synchronized by the node.
     * @returns The block number.
     */
    getBlockNumber(): Promise<BlockNumber>;
    /**
     * Fetches the latest proven block number.
     * @returns The block number.
     */
    getProvenBlockNumber(): Promise<BlockNumber>;
    /**
     * Fetches the latest checkpointed block number.
     * @returns The block number.
     */
    getCheckpointedBlockNumber(): Promise<BlockNumber>;
    /**
     * Method to determine if the node is ready to accept transactions.
     * @returns - Flag indicating the readiness for tx submission.
     */
    isReady(): Promise<boolean>;
    /**
     * Returns the information about the server's node. Includes current Node version, compatible Noir version,
     * L1 chain identifier, protocol version, and L1 address of the rollup contract.
     * @returns - The node information.
     */
    getNodeInfo(): Promise<NodeInfo>;
    /**
     * Method to request blocks. Will attempt to return all requested blocks but will return only those available.
     * @param from - The start of the range of blocks to return.
     * @param limit - The maximum number of blocks to return.
     * @returns The blocks requested.
     */
    getBlocks(from: BlockNumber, limit: number): Promise<L2Block[]>;
    /**
     * Method to fetch the current min fees.
     * @returns The current min fees.
     */
    getCurrentMinFees(): Promise<GasFees>;
    /**
     * Method to fetch the current max priority fee of txs in the mempool.
     * @returns The current max priority fees.
     */
    getMaxPriorityFees(): Promise<GasFees>;
    /**
     * Method to fetch the version of the package.
     * @returns The node package version
     */
    getNodeVersion(): Promise<string>;
    /**
     * Method to fetch the version of the rollup the node is connected to.
     * @returns The rollup version.
     */
    getVersion(): Promise<number>;
    /**
     * Method to fetch the chain id of the base-layer for the rollup.
     * @returns The chain id.
     */
    getChainId(): Promise<number>;
    /**
     * Method to fetch the currently deployed l1 contract addresses.
     * @returns The deployed contract addresses.
     */
    getL1ContractAddresses(): Promise<L1ContractAddresses>;
    /**
     * Method to fetch the protocol contract addresses.
     */
    getProtocolContractAddresses(): Promise<ProtocolContractAddresses>;
    /**
     * Registers contract function signatures for debugging purposes.
     * @param functionSignatures - An array of function signatures to register by selector.
     */
    registerContractFunctionSignatures(functionSignatures: string[]): Promise<void>;
    /**
     * Gets public logs based on the provided filter.
     * @param filter - The filter to apply to the logs.
     * @returns The requested logs.
     */
    getPublicLogs(filter: LogFilter): Promise<GetPublicLogsResponse>;
    /**
     * Gets contract class logs based on the provided filter.
     * @param filter - The filter to apply to the logs.
     * @returns The requested logs.
     */
    getContractClassLogs(filter: LogFilter): Promise<GetContractClassLogsResponse>;
    /**
     * Gets private logs that match any of the `tags`. For each tag, an array of matching logs is returned. An empty
     * array implies no logs match that tag.
     * @param tags - The tags to search for.
     * @param page - The page number (0-indexed) for pagination.
     * @param referenceBlock - Optional block hash used to ensure the block still exists before logs are retrieved.
     * This block is expected to represent the latest block to which the client has synced (called anchor block in PXE).
     * If specified and the block is not found, an error is thrown. This helps detect reorgs, which could result in
     * undefined behavior in the client's code.
     * @returns An array of log arrays, one per tag. Returns at most 10 logs per tag per page. If 10 logs are returned
     * for a tag, the caller should fetch the next page to check for more logs.
     */
    getPrivateLogsByTags(tags: SiloedTag[], page?: number, referenceBlock?: BlockHash): Promise<TxScopedL2Log[][]>;
    /**
     * Gets public logs that match any of the `tags` from the specified contract. For each tag, an array of matching
     * logs is returned. An empty array implies no logs match that tag.
     * @param contractAddress - The contract address to search logs for.
     * @param tags - The tags to search for.
     * @param page - The page number (0-indexed) for pagination.
     * @param referenceBlock - Optional block hash used to ensure the block still exists before logs are retrieved.
     * This block is expected to represent the latest block to which the client has synced (called anchor block in PXE).
     * If specified and the block is not found, an error is thrown. This helps detect reorgs, which could result in
     * undefined behavior in the client's code.
     * @returns An array of log arrays, one per tag. Returns at most 10 logs per tag per page. If 10 logs are returned
     * for a tag, the caller should fetch the next page to check for more logs.
     */
    getPublicLogsByTagsFromContract(contractAddress: AztecAddress, tags: Tag[], page?: number, referenceBlock?: BlockHash): Promise<TxScopedL2Log[][]>;
    /**
     * Method to submit a transaction to the p2p pool.
     * @param tx - The transaction to be submitted.
     * @returns Nothing.
     */
    sendTx(tx: Tx): Promise<void>;
    /**
     * Fetches a transaction receipt for a given transaction hash. Returns a mined receipt if it was added
     * to the chain, a pending receipt if it's still in the mempool of the connected Aztec node, or a dropped
     * receipt if not found in the connected Aztec node.
     *
     * @param txHash - The transaction hash.
     * @returns A receipt of the transaction.
     */
    getTxReceipt(txHash: TxHash): Promise<TxReceipt>;
    /**
     * Gets a tx effect.
     * @param txHash - The hash of the tx corresponding to the tx effect.
     * @returns The requested tx effect with block info (or undefined if not found).
     */
    getTxEffect(txHash: TxHash): Promise<IndexedTxEffect | undefined>;
    /**
     * Method to retrieve pending txs.
     * @returns The pending txs.
     */
    getPendingTxs(limit?: number, after?: TxHash): Promise<Tx[]>;
    /**
     * Retrieves the number of pending txs
     * @returns The number of pending txs.
     */
    getPendingTxCount(): Promise<number>;
    /**
     * Method to retrieve a single pending tx.
     * @param txHash - The transaction hash to return.
     * @returns The pending tx if it exists.
     */
    getTxByHash(txHash: TxHash): Promise<Tx | undefined>;
    /**
     * Method to retrieve multiple pending txs.
     * @param txHash - The transaction hashes to return.
     * @returns The pending txs if exist.
     */
    getTxsByHash(txHashes: TxHash[]): Promise<Tx[]>;
    /**
     * Gets the storage value at the given contract storage slot.
     *
     * @remarks The storage slot here refers to the slot as it is defined in Noir not the index in the merkle tree.
     * Aztec's version of `eth_getStorageAt`.
     *
     * @param referenceBlock - The block parameter (block number, block hash, or 'latest') at which to get the data.
     * @param contract - Address of the contract to query.
     * @param slot - Slot to query.
     * @returns Storage value at the given contract slot.
     */
    getPublicStorageAt(referenceBlock: BlockParameter, contract: AztecAddress, slot: Fr): Promise<Fr>;
    /**
     * Returns the block header for a given block number, block hash, or 'latest'.
     * @param block - The block parameter (block number, block hash, or 'latest'). Defaults to 'latest'.
     * @returns The requested block header.
     */
    getBlockHeader(block?: BlockParameter): Promise<BlockHeader | undefined>;
    /**
     * Get a block header specified by its archive root.
     * @param archive - The archive root being requested.
     * @returns The requested block header.
     */
    getBlockHeaderByArchive(archive: Fr): Promise<BlockHeader | undefined>;
    /** Returns stats for validators if enabled. */
    getValidatorsStats(): Promise<ValidatorsStats>;
    /** Returns stats for a single validator if enabled. */
    getValidatorStats(validatorAddress: EthAddress, fromSlot?: SlotNumber, toSlot?: SlotNumber): Promise<SingleValidatorStats | undefined>;
    /**
     * Simulates the public part of a transaction with the current state.
     * This currently just checks that the transaction execution succeeds.
     * @param tx - The transaction to simulate.
     **/
    simulatePublicCalls(tx: Tx, skipFeeEnforcement?: boolean): Promise<PublicSimulationOutput>;
    /**
     * Returns true if the transaction is valid for inclusion at the current state. Valid transactions can be
     * made invalid by *other* transactions if e.g. they emit the same nullifiers, or come become invalid
     * due to e.g. the expiration_timestamp property.
     * @param tx - The transaction to validate for correctness.
     * @param isSimulation - True if the transaction is a simulated one without generated proofs. (Optional)
     * @param skipFeeEnforcement - True if the validation of the fee should be skipped. Useful when the simulation is for estimating fee (Optional)
     */
    isValidTx(tx: Tx, options?: {
        isSimulation?: boolean;
        skipFeeEnforcement?: boolean;
    }): Promise<TxValidationResult>;
    /**
     * Returns a registered contract class given its id.
     * @param id - Id of the contract class.
     */
    getContractClass(id: Fr): Promise<ContractClassPublic | undefined>;
    /**
     * Returns a publicly deployed contract instance given its address.
     * @param address - Address of the deployed contract.
     */
    getContract(address: AztecAddress): Promise<ContractInstanceWithAddress | undefined>;
    /**
     * Returns the ENR of this node for peer discovery, if available.
     */
    getEncodedEnr(): Promise<string | undefined>;
    /**
     * Returns the list of allowed public setup elements configured for this node.
     * @returns The list of allowed elements.
     */
    getAllowedPublicSetup(): Promise<AllowedElement[]>;
}
export declare const AztecNodeApiSchema: ApiSchemaFor<AztecNode>;
export declare function createAztecNodeClient(url: string, versions?: Partial<ComponentsVersions>, fetch?: typeof import("@aztec/foundation/json-rpc/client").defaultFetch, batchWindowMS?: number): AztecNode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXp0ZWMtbm9kZS5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVyZmFjZXMvYXp0ZWMtbm9kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLHdCQUF3QixFQUFFLHFCQUFxQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbkcsT0FBTyxFQUFFLEtBQUssbUJBQW1CLEVBQTZCLE1BQU0sdUNBQXVDLENBQUM7QUFDNUcsT0FBTyxFQUNMLFdBQVcsRUFJWCxXQUFXLEVBRVgsS0FBSyxVQUFVLEVBQ2hCLE1BQU0saUNBQWlDLENBQUM7QUFDekMsT0FBTyxLQUFLLEVBQUUsRUFBRSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDekQsT0FBTyxLQUFLLEVBQUUsVUFBVSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFaEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBSXpFLE9BQU8sS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzlELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsS0FBSyxjQUFjLEVBQXdCLE1BQU0sNkJBQTZCLENBQUM7QUFFeEYsT0FBTyxFQUFFLEtBQUssV0FBVyxFQUF3QixNQUFNLHNCQUFzQixDQUFDO0FBQzlFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvQyxPQUFPLEVBQUUsS0FBSyxhQUFhLEVBQUUsS0FBSyxNQUFNLEVBQWdCLE1BQU0sNkJBQTZCLENBQUM7QUFFNUYsT0FBTyxFQUNMLEtBQUssbUJBQW1CLEVBRXhCLEtBQUssMkJBQTJCLEVBRWhDLEtBQUssUUFBUSxFQUViLEtBQUsseUJBQXlCLEVBRS9CLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLG9CQUFvQixD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