import type { BlockNumber } from '@aztec/foundation/branded-types';
import type { Fr } from '@aztec/foundation/curves/bn254';
import { type IndexedTreeLeafPreimage, SiblingPath } from '@aztec/foundation/trees';
import type { MerkleTreeId, TreeHeights } from '../trees/merkle_tree_id.js';
import type { NullifierLeaf } from '../trees/nullifier_leaf.js';
import type { PublicDataTreeLeaf } from '../trees/public_data_leaf.js';
import type { BlockHeader } from '../tx/block_header.js';
import type { StateReference } from '../tx/state_reference.js';
import type { WorldStateRevision, WorldStateRevisionWithHandle } from '../world-state/world_state_revision.js';
/**
 * Type alias for the nullifier tree ID.
 */
export type IndexedTreeId = MerkleTreeId.NULLIFIER_TREE | MerkleTreeId.PUBLIC_DATA_TREE;
export type FrTreeId = Exclude<MerkleTreeId, IndexedTreeId>;
/**
 * Witness data for a leaf update.
 */
export interface LeafUpdateWitnessData<N extends number> {
    /**
     * Preimage of the leaf before updating.
     */
    leafPreimage: IndexedTreeLeafPreimage;
    /**
     * Sibling path to prove membership of the leaf.
     */
    siblingPath: SiblingPath<N>;
    /**
     * The index of the leaf.
     */
    index: bigint;
}
/**
 * The result of a batch insertion in an indexed merkle tree.
 */
export interface BatchInsertionResult<TreeHeight extends number, SubtreeSiblingPathHeight extends number> {
    /**
     * Data for the leaves to be updated when inserting the new ones.
     */
    lowLeavesWitnessData?: LeafUpdateWitnessData<TreeHeight>[];
    /**
     * Sibling path "pointing to" where the new subtree should be inserted into the tree.
     */
    newSubtreeSiblingPath: SiblingPath<SubtreeSiblingPathHeight>;
    /**
     * The new leaves being inserted in high to low order. This order corresponds with the order of the low leaves witness.
     */
    sortedNewLeaves: Buffer[];
    /**
     * The indexes of the sorted new leaves to the original ones.
     */
    sortedNewLeavesIndexes: number[];
}
/**
 * The result of a sequential insertion in an indexed merkle tree.
 */
export interface SequentialInsertionResult<TreeHeight extends number> {
    /**
     * Data for the leaves to be updated when inserting the new ones.
     */
    lowLeavesWitnessData: LeafUpdateWitnessData<TreeHeight>[];
    /**
     * Data for the inserted leaves
     */
    insertionWitnessData: LeafUpdateWitnessData<TreeHeight>[];
}
/**
 *  Defines tree information.
 */
export interface TreeInfo {
    /**
     * The tree ID.
     */
    treeId: MerkleTreeId;
    /**
     * The tree root.
     */
    root: Buffer;
    /**
     * The number of leaves in the tree.
     */
    size: bigint;
    /**
     * The depth of the tree.
     */
    depth: number;
}
type LeafTypes = {
    [MerkleTreeId.NULLIFIER_TREE]: Buffer;
    [MerkleTreeId.NOTE_HASH_TREE]: Fr;
    [MerkleTreeId.PUBLIC_DATA_TREE]: Buffer;
    [MerkleTreeId.L1_TO_L2_MESSAGE_TREE]: Fr;
    [MerkleTreeId.ARCHIVE]: Fr;
};
type LeafValueTypes = {
    [MerkleTreeId.NULLIFIER_TREE]: NullifierLeaf;
    [MerkleTreeId.NOTE_HASH_TREE]: Fr;
    [MerkleTreeId.PUBLIC_DATA_TREE]: PublicDataTreeLeaf;
    [MerkleTreeId.L1_TO_L2_MESSAGE_TREE]: Fr;
    [MerkleTreeId.ARCHIVE]: Fr;
};
export type MerkleTreeLeafType<ID extends MerkleTreeId> = LeafTypes[ID];
export type MerkleTreeLeafValue<ID extends MerkleTreeId> = LeafValueTypes[ID];
/**
 * Defines the interface for operations on a set of Merkle Trees.
 */
export interface MerkleTreeReadOperations {
    /**
     * Returns information about the given tree.
     * @param treeId - The tree to be queried.
     */
    getTreeInfo(treeId: MerkleTreeId): Promise<TreeInfo>;
    /**
     * Gets the current state reference.
     */
    getStateReference(): Promise<StateReference>;
    /**
     * Gets the initial header.
     */
    getInitialHeader(): BlockHeader;
    /**
     * Gets the current revision.
     */
    getRevision(): WorldStateRevision | WorldStateRevisionWithHandle;
    /**
     * Gets sibling path for a leaf.
     * @param treeId - The tree to be queried for a sibling path.
     * @param index - The index of the leaf for which a sibling path should be returned.
     */
    getSiblingPath<ID extends MerkleTreeId>(treeId: ID, index: bigint): Promise<SiblingPath<TreeHeights[ID]>>;
    /**
     * Returns the previous index for a given value in an indexed tree.
     * @param treeId - The tree for which the previous value index is required.
     * @param value - The value to be queried.
     */
    getPreviousValueIndex<ID extends IndexedTreeId>(treeId: ID, value: bigint): Promise<{
        /** The index of the found leaf.*/
        index: bigint;
        /** A flag indicating if the corresponding leaf's value is equal to `newValue`. */
        alreadyPresent: boolean;
    } | undefined>;
    /**
     * Returns the data at a specific leaf.
     * @param treeId - The tree for which leaf data should be returned.
     * @param index - The index of the leaf required.
     */
    getLeafPreimage<ID extends IndexedTreeId>(treeId: ID, index: bigint): Promise<IndexedTreeLeafPreimage | undefined>;
    /**
     * Returns the index containing a leaf value.
     * @param treeId - The tree for which the index should be returned.
     * @param value - The value to search for in the tree.
     */
    findLeafIndices<ID extends MerkleTreeId>(treeId: ID, values: MerkleTreeLeafType<ID>[]): Promise<(bigint | undefined)[]>;
    /**
     * Returns the sibling paths for the given leaf values
     * @param treeId - The tree for which the index should be returned.
     * @param values - The values to search for in the tree.
     */
    findSiblingPaths<ID extends MerkleTreeId>(treeId: ID, values: MerkleTreeLeafType<ID>[]): Promise<({
        path: SiblingPath<TreeHeights[ID]>;
        index: bigint;
    } | undefined)[]>;
    /**
     * Returns the first index containing a leaf value after `startIndex`.
     * @param treeId - The tree for which the index should be returned.
     * @param value - The value to search for in the tree.
     * @param startIndex - The index to start searching from (used when skipping nullified messages)
     */
    findLeafIndicesAfter<ID extends MerkleTreeId>(treeId: ID, values: MerkleTreeLeafType<ID>[], startIndex: bigint): Promise<(bigint | undefined)[]>;
    /**
     * Gets the value for a leaf in the tree.
     * @param treeId - The tree for which the index should be returned.
     * @param index - The index of the leaf.
     */
    getLeafValue<ID extends MerkleTreeId>(treeId: ID, index: bigint): Promise<MerkleTreeLeafType<typeof treeId> | undefined>;
    /**
     * Get the block numbers for a set of leaf indices
     * @param treeId - The tree for which the block numbers should be returned.
     * @param leafIndices - The indices to be queried.
     */
    getBlockNumbersForLeafIndices<ID extends MerkleTreeId>(treeId: ID, leafIndices: bigint[]): Promise<(BlockNumber | undefined)[]>;
}
export interface MerkleTreeCheckpointOperations {
    /**
     * Checkpoints the current fork state
     */
    createCheckpoint(): Promise<void>;
    /**
     * Commits the current checkpoint
     */
    commitCheckpoint(): Promise<void>;
    /**
     * Reverts the current checkpoint
     */
    revertCheckpoint(): Promise<void>;
    /**
     * Commits all checkpoints
     */
    commitAllCheckpoints(): Promise<void>;
    /**
     * Reverts all checkpoints
     */
    revertAllCheckpoints(): Promise<void>;
}
export interface MerkleTreeWriteOperations extends MerkleTreeReadOperations, MerkleTreeCheckpointOperations, AsyncDisposable {
    /**
     * Appends leaves to a given tree.
     * @param treeId - The tree to be updated.
     * @param leaves - The set of leaves to be appended.
     */
    appendLeaves<ID extends MerkleTreeId>(treeId: ID, leaves: MerkleTreeLeafType<ID>[]): Promise<void>;
    /**
     * Inserts the block hash into the archive.
     * This includes all of the current roots of all of the data trees and the current blocks global vars.
     * @param header - The header to insert into the archive.
     */
    updateArchive(header: BlockHeader): Promise<void>;
    /**
     * Batch insert multiple leaves into the tree.
     * @param leaves - Leaves to insert into the tree.
     * @param treeId - The tree on which to insert.
     * @param subtreeHeight - Height of the subtree.
     * @returns The witness data for the leaves to be updated when inserting the new ones.
     */
    batchInsert<TreeHeight extends number, SubtreeSiblingPathHeight extends number, ID extends IndexedTreeId>(treeId: ID, leaves: Buffer[], subtreeHeight: number): Promise<BatchInsertionResult<TreeHeight, SubtreeSiblingPathHeight>>;
    /**
     * Inserts multiple leaves into the tree, getting witnesses at every step.
     * Note: This method doesn't support inserting empty leaves.
     * @param treeId - The tree on which to insert.
     * @param leaves - The leaves to insert.
     * @returns The witnesses for the low leaf updates and the insertions.
     */
    sequentialInsert<TreeHeight extends number, ID extends IndexedTreeId>(treeId: ID, leaves: Buffer[]): Promise<SequentialInsertionResult<TreeHeight>>;
    /**
     * Closes the database, discarding any uncommitted changes.
     */
    close(): Promise<void>;
}
/**
 * Outputs a tree leaves using for debugging purposes.
 */
export declare function inspectTree(db: MerkleTreeReadOperations, treeId: MerkleTreeId, log?: import("@aztec/foundation/log").Logger): Promise<void>;
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVya2xlX3RyZWVfb3BlcmF0aW9ucy5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVyZmFjZXMvbWVya2xlX3RyZWVfb3BlcmF0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNuRSxPQUFPLEtBQUssRUFBRSxFQUFFLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUV6RCxPQUFPLEVBQUUsS0FBSyx1QkFBdUIsRUFBRSxXQUFXLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUVwRixPQUFPLEtBQUssRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDNUUsT0FBTyxLQUFLLEVBQUUsYUFBYSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDaEUsT0FBTyxLQUFLLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUN2RSxPQUFPLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RCxPQUFPLEtBQUssRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMvRCxPQUFPLEtBQUssRUFBRSxrQkFBa0IsRUFBRSw0QkFBNEIsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBRS9HOztHQUVHO0FBQ0gsTUFBTSxNQUFNLGFBQWEsR0FBRyxZQUFZLENBQUMsY0FBYyxHQUFHLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQztBQUV4RixNQUFNLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxZQUFZLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFFNUQ7O0dBRUc7QUFDSCxNQUFNLFdBQVcscUJBQXFCLENBQUMsQ0FBQyxTQUFTLE1BQU07SUFDckQ7O09BRUc7SUFDSCxZQUFZLEVBQUUsdUJBQXVCLENBQUM7SUFDdEM7O09BRUc7SUFDSCxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVCOztPQUVHO0lBQ0gsS0FBSyxFQUFFLE1BQU0sQ0FBQztDQUNmO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFdBQVcsb0JBQW9CLENBQUMsVUFBVSxTQUFTLE1BQU0sRUFBRSx3QkFBd0IsU0FBUyxNQUFNO0lBQ3RHOztPQUVHO0lBQ0gsb0JBQW9CLENBQUMsRUFBRSxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO0lBQzNEOztPQUVHO0lBQ0gscUJBQXFCLEVBQUUsV0FBVyxDQUFDLHdCQUF3QixDQUFDLENBQUM7SUFDN0Q7O09BRUc7SUFDSCxlQUFlLEVBQUUsTUFBTSxFQUFFLENBQUM7SUFDMUI7O09BRUc7SUFDSCxzQkFBc0IsRUFBRSxNQUFNLEVBQUUsQ0FBQztDQUNsQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxXQUFXLHlCQUF5QixDQUFDLFVBQVUsU0FBUyxNQUFNO0lBQ2xFOztPQUVHO0lBQ0gsb0JBQW9CLEVBQUUscUJBQXFCLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztJQUMxRDs7T0FFRztJQUNILG9CQUFvQixFQUFFLHFCQUFxQixDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7Q0FDM0Q7QUFFRDs7R0FFRztBQUNILE1BQU0sV0FBVyxRQUFRO0lBQ3ZCOztPQUVHO0lBQ0gsTUFBTSxFQUFFLFlBQVksQ0FBQztJQUNyQjs7T0FFRztJQUNILElBQUksRUFBRSxNQUFNLENBQUM7SUFDYjs7T0FFRztJQUNILElBQUksRUFBRSxNQUFNLENBQUM7SUFFYjs7T0FFRztJQUNILEtBQUssRUFBRSxNQUFNLENBQUM7Q0FDZjtBQUVELEtBQUssU0FBUyxHQUFHO0lBQ2YsQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLEVBQUUsTUFBTSxDQUFDO0lBQ3RDLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUNsQyxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLE1BQU0sQ0FBQztJQUN4QyxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUN6QyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLENBQUM7Q0FDNUIsQ0FBQztBQUVGLEtBQUssY0FBYyxHQUFHO0lBQ3BCLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxFQUFFLGFBQWEsQ0FBQztJQUM3QyxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLENBQUM7SUFDbEMsQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxrQkFBa0IsQ0FBQztJQUNwRCxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUN6QyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLENBQUM7Q0FDNUIsQ0FBQztBQUVGLE1BQU0sTUFBTSxrQkFBa0IsQ0FBQyxFQUFFLFNBQVMsWUFBWSxJQUFJLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUV4RSxNQUFNLE1BQU0sbUJBQW1CLENBQUMsRUFBRSxTQUFTLFlBQVksSUFBSSxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7QUFFOUU7O0dBRUc7QUFDSCxNQUFNLFdBQVcsd0JBQXdCO0lBQ3ZDOzs7T0FHRztJQUNILFdBQVcsQ0FBQyxNQUFNLEVBQUUsWUFBWSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUVyRDs7T0FFRztJQUNILGlCQUFpQixJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUU3Qzs7T0FFRztJQUNILGdCQUFnQixJQUFJLFdBQVcsQ0FBQztJQUVoQzs7T0FFRztJQUNILFdBQVcsSUFBSSxrQkFBa0IsR0FBRyw0QkFBNEIsQ0FBQztJQUVqRTs7OztPQUlHO0lBQ0gsY0FBYyxDQUFDLEVBQUUsU0FBUyxZQUFZLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUxRzs7OztPQUlHO0lBQ0gscUJBQXFCLENBQUMsRUFBRSxTQUFTLGFBQWEsRUFDNUMsTUFBTSxFQUFFLEVBQUUsRUFDVixLQUFLLEVBQUUsTUFBTSxHQUNaLE9BQU8sQ0FDTjtRQUNFLGtDQUFrQztRQUNsQyxLQUFLLEVBQUUsTUFBTSxDQUFDO1FBQ2Qsa0ZBQWtGO1FBQ2xGLGNBQWMsRUFBRSxPQUFPLENBQUM7S0FDekIsR0FDRCxTQUFTLENBQ1osQ0FBQztJQUVGOzs7O09BSUc7SUFDSCxlQUFlLENBQUMsRUFBRSxTQUFTLGFBQWEsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLHVCQUF1QixHQUFHLFNBQVMsQ0FBQyxDQUFDO0lBRW5IOzs7O09BSUc7SUFDSCxlQUFlLENBQUMsRUFBRSxTQUFTLFlBQVksRUFDckMsTUFBTSxFQUFFLEVBQUUsRUFDVixNQUFNLEVBQUUsa0JBQWtCLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FDL0IsT0FBTyxDQUFDLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUVuQzs7OztPQUlHO0lBQ0gsZ0JBQWdCLENBQUMsRUFBRSxTQUFTLFlBQVksRUFDdEMsTUFBTSxFQUFFLEVBQUUsRUFDVixNQUFNLEVBQUUsa0JBQWtCLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FDL0IsT0FBTyxDQUFDLENBQUM7UUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQTtLQUFFLEdBQUcsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBRWxGOzs7OztPQUtHO0lBQ0gsb0JBQW9CLENBQUMsRUFBRSxTQUFTLFlBQVksRUFDMUMsTUFBTSxFQUFFLEVBQUUsRUFDVixNQUFNLEVBQUUsa0JBQWtCLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFDaEMsVUFBVSxFQUFFLE1BQU0sR0FDakIsT0FBTyxDQUFDLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUVuQzs7OztPQUlHO0lBQ0gsWUFBWSxDQUFDLEVBQUUsU0FBUyxZQUFZLEVBQ2xDLE1BQU0sRUFBRSxFQUFFLEVBQ1YsS0FBSyxFQUFFLE1BQU0sR0FDWixPQUFPLENBQUMsa0JBQWtCLENBQUMsT0FBTyxNQUFNLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztJQUUxRDs7OztPQUlHO0lBQ0gsNkJBQTZCLENBQUMsRUFBRSxTQUFTLFlBQVksRUFDbkQsTUFBTSxFQUFFLEVBQUUsRUFDVixXQUFXLEVBQUUsTUFBTSxFQUFFLEdBQ3BCLE9BQU8sQ0FBQyxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7Q0FDekM7QUFFRCxNQUFNLFdBQVcsOEJBQThCO0lBQzdDOztPQUVHO0lBQ0gsZ0JBQWdCLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRWxDOztPQUVHO0lBQ0gsZ0JBQWdCLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRWxDOztPQUVHO0lBQ0gsZ0JBQWdCLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRWxDOztPQUVHO0lBQ0gsb0JBQW9CLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXRDOztPQUVHO0lBQ0gsb0JBQW9CLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3ZDO0FBRUQsTUFBTSxXQUFXLHlCQUNmLFNBQVEsd0JBQXdCLEVBQzlCLDhCQUE4QixFQUM5QixlQUFlO0lBQ2pCOzs7O09BSUc7SUFDSCxZQUFZLENBQUMsRUFBRSxTQUFTLFlBQVksRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxrQkFBa0IsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUVuRzs7OztPQUlHO0lBQ0gsYUFBYSxDQUFDLE1BQU0sRUFBRSxXQUFXLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRWxEOzs7Ozs7T0FNRztJQUNILFdBQVcsQ0FBQyxVQUFVLFNBQVMsTUFBTSxFQUFFLHdCQUF3QixTQUFTLE1BQU0sRUFBRSxFQUFFLFNBQVMsYUFBYSxFQUN0RyxNQUFNLEVBQUUsRUFBRSxFQUNWLE1BQU0sRUFBRSxNQUFNLEVBQUUsRUFDaEIsYUFBYSxFQUFFLE1BQU0sR0FDcEIsT0FBTyxDQUFDLG9CQUFvQixDQUFDLFVBQVUsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDLENBQUM7SUFFdkU7Ozs7OztPQU1HO0lBQ0gsZ0JBQWdCLENBQUMsVUFBVSxTQUFTLE1BQU0sRUFBRSxFQUFFLFNBQVMsYUFBYSxFQUNsRSxNQUFNLEVBQUUsRUFBRSxFQUNWLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FDZixPQUFPLENBQUMseUJBQXlCLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUVsRDs7T0FFRztJQUNILEtBQUssSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDeEI7QUFFRDs7R0FFRztBQUNILHdCQUFzQixXQUFXLENBQy9CLEVBQUUsRUFBRSx3QkFBd0IsRUFDNUIsTUFBTSxFQUFFLFlBQVksRUFDcEIsR0FBRyx5Q0FBcUMsaUJBVXpDIn0=