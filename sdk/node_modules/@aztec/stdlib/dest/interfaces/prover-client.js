import { booleanConfigHelper, numberConfigHelper } from '@aztec/foundation/config';
import { EthAddress } from '@aztec/foundation/eth-address';
import { z } from 'zod';
import { schemas, zodFor } from '../schemas/index.js';
export const ProverConfigSchema = zodFor()(z.object({
    nodeUrl: z.string().optional(),
    realProofs: z.boolean(),
    proverId: schemas.EthAddress.optional(),
    proverTestDelayType: z.enum([
        'fixed',
        'realistic'
    ]),
    proverTestDelayMs: z.number(),
    proverTestDelayFactor: z.number(),
    proverAgentCount: z.number(),
    proofStore: z.string().optional(),
    failedProofStore: z.string().optional(),
    cancelJobsOnStop: z.boolean()
}));
export const proverConfigMappings = {
    nodeUrl: {
        env: 'AZTEC_NODE_URL',
        description: 'The URL to the Aztec node to take proving jobs from'
    },
    realProofs: {
        env: 'PROVER_REAL_PROOFS',
        description: 'Whether to construct real proofs',
        ...booleanConfigHelper(true)
    },
    proverId: {
        env: 'PROVER_ID',
        parseEnv: (val)=>parseProverId(val),
        description: 'Hex value that identifies the prover. Defaults to the address used for submitting proofs if not set.'
    },
    proverTestDelayType: {
        env: 'PROVER_TEST_DELAY_TYPE',
        description: 'The type of artificial delay to introduce'
    },
    proverTestDelayMs: {
        env: 'PROVER_TEST_DELAY_MS',
        description: 'Artificial delay to introduce to all operations to the test prover.',
        ...numberConfigHelper(0)
    },
    proverTestDelayFactor: {
        env: 'PROVER_TEST_DELAY_FACTOR',
        description: 'If using realistic delays, what percentage of realistic times to apply.',
        ...numberConfigHelper(1)
    },
    proverAgentCount: {
        env: 'PROVER_AGENT_COUNT',
        description: 'The number of prover agents to start',
        ...numberConfigHelper(1)
    },
    proofStore: {
        env: 'PROVER_PROOF_STORE',
        description: 'Optional proof input store for the prover'
    },
    failedProofStore: {
        env: 'PROVER_FAILED_PROOF_STORE',
        description: 'Store for failed proof inputs. Google cloud storage is only supported at the moment. Set this value as gs://bucket-name/path/to/store.'
    },
    cancelJobsOnStop: {
        env: 'PROVER_CANCEL_JOBS_ON_STOP',
        description: 'Whether to abort pending proving jobs when the orchestrator is cancelled. ' + 'When false (default), jobs remain in the broker queue and can be reused on restart/reorg. ' + 'When true, jobs are explicitly cancelled with the broker, which prevents reuse.',
        ...booleanConfigHelper(false)
    }
};
function parseProverId(str) {
    if (!str) {
        return undefined;
    }
    return EthAddress.fromString(str);
}
export class BlockProofError extends Error {
    txHashes;
    static #name = 'BlockProofError';
    name;
    constructor(message, txHashes){
        super(message), this.txHashes = txHashes, this.name = BlockProofError.#name;
    }
    static isBlockProofError(err) {
        return err && typeof err === 'object' && err.name === BlockProofError.#name;
    }
}
