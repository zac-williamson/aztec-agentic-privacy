import { type ConfigMappingsType } from '@aztec/foundation/config';
import { EthAddress } from '@aztec/foundation/eth-address';
import { z } from 'zod';
import type { TxHash } from '../tx/tx_hash.js';
import type { EpochProver } from './epoch-prover.js';
import type { ProvingJobConsumer } from './prover-broker.js';
export type ActualProverConfig = {
    /** Whether to construct real proofs */
    realProofs: boolean;
    /** The type of artificial delay to introduce */
    proverTestDelayType: 'fixed' | 'realistic';
    /** If using fixed delay, the time each operation takes. */
    proverTestDelayMs: number;
    /** If using realistic delays, what percentage of realistic times to apply. */
    proverTestDelayFactor: number;
    /**
     * Whether to abort pending proving jobs when the orchestrator is cancelled.
     * When false (default), jobs remain in the broker queue and can be reused on restart/reorg.
     * When true, jobs are explicitly cancelled with the broker, which prevents reuse.
     */
    cancelJobsOnStop: boolean;
};
/**
 * The prover configuration.
 */
export type ProverConfig = ActualProverConfig & {
    /** The URL to the Aztec node to take proving jobs from */
    nodeUrl?: string;
    /** Identifier of the prover */
    proverId?: EthAddress;
    /** Number of proving agents to start within the prover. */
    proverAgentCount: number;
    /** Where to store proving request. Must be accessible to both prover node and agents. If not set will inline-encode the parameters */
    proofStore?: string;
    /** Store for failed proof inputs. */
    failedProofStore?: string;
};
export declare const ProverConfigSchema: z.ZodObject<{
    nodeUrl: z.ZodOptional<z.ZodString>;
    realProofs: z.ZodBoolean;
    proverId: z.ZodOptional<import("../schemas/index.js").ZodFor<EthAddress>>;
    proverTestDelayType: z.ZodEnum<["fixed", "realistic"]>;
    proverTestDelayMs: z.ZodNumber;
    proverTestDelayFactor: z.ZodNumber;
    proverAgentCount: z.ZodNumber;
    proofStore: z.ZodOptional<z.ZodString>;
    failedProofStore: z.ZodOptional<z.ZodString>;
    cancelJobsOnStop: z.ZodBoolean;
}, "strip", z.ZodTypeAny, {
    nodeUrl?: string | undefined;
    realProofs: boolean;
    proverId?: EthAddress | undefined;
    proverTestDelayType: "fixed" | "realistic";
    proverTestDelayMs: number;
    proverTestDelayFactor: number;
    proverAgentCount: number;
    proofStore?: string | undefined;
    failedProofStore?: string | undefined;
    cancelJobsOnStop: boolean;
}, {
    nodeUrl?: string | undefined;
    realProofs: boolean;
    proverId?: any;
    proverTestDelayType: "fixed" | "realistic";
    proverTestDelayMs: number;
    proverTestDelayFactor: number;
    proverAgentCount: number;
    proofStore?: string | undefined;
    failedProofStore?: string | undefined;
    cancelJobsOnStop: boolean;
}>;
export declare const proverConfigMappings: ConfigMappingsType<ProverConfig>;
/**
 * The interface to the prover client.
 * Provides the ability to generate proofs and build rollups.
 */
export interface EpochProverManager {
    createEpochProver(): EpochProver;
    start(): Promise<void>;
    stop(): Promise<void>;
    getProvingJobSource(): ProvingJobConsumer;
    getProverId(): EthAddress;
    updateProverConfig(config: Partial<ProverConfig>): Promise<void>;
}
export declare class BlockProofError extends Error {
    #private;
    readonly txHashes: TxHash[];
    name: string;
    constructor(message: string, txHashes: TxHash[]);
    static isBlockProofError(err: any): err is BlockProofError;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdmVyLWNsaWVudC5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ludGVyZmFjZXMvcHJvdmVyLWNsaWVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsS0FBSyxrQkFBa0IsRUFBMkMsTUFBTSwwQkFBMEIsQ0FBQztBQUM1RyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFM0QsT0FBTyxFQUFFLENBQUMsRUFBRSxNQUFNLEtBQUssQ0FBQztBQUd4QixPQUFPLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUMvQyxPQUFPLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNyRCxPQUFPLEtBQUssRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRTdELE1BQU0sTUFBTSxrQkFBa0IsR0FBRztJQUMvQix1Q0FBdUM7SUFDdkMsVUFBVSxFQUFFLE9BQU8sQ0FBQztJQUNwQixnREFBZ0Q7SUFDaEQsbUJBQW1CLEVBQUUsT0FBTyxHQUFHLFdBQVcsQ0FBQztJQUMzQywyREFBMkQ7SUFDM0QsaUJBQWlCLEVBQUUsTUFBTSxDQUFDO0lBQzFCLDhFQUE4RTtJQUM5RSxxQkFBcUIsRUFBRSxNQUFNLENBQUM7SUFDOUI7Ozs7T0FJRztJQUNILGdCQUFnQixFQUFFLE9BQU8sQ0FBQztDQUMzQixDQUFDO0FBRUY7O0dBRUc7QUFDSCxNQUFNLE1BQU0sWUFBWSxHQUFHLGtCQUFrQixHQUFHO0lBQzlDLDBEQUEwRDtJQUMxRCxPQUFPLENBQUMsRUFBRSxNQUFNLENBQUM7SUFDakIsK0JBQStCO0lBQy9CLFFBQVEsQ0FBQyxFQUFFLFVBQVUsQ0FBQztJQUN0QiwyREFBMkQ7SUFDM0QsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDO0lBQ3pCLHNJQUFzSTtJQUN0SSxVQUFVLENBQUMsRUFBRSxNQUFNLENBQUM7SUFDcEIscUNBQXFDO0lBQ3JDLGdCQUFnQixDQUFDLEVBQUUsTUFBTSxDQUFDO0NBQzNCLENBQUM7QUFFRixlQUFPLE1BQU0sa0JBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFhOUIsQ0FBQztBQUVGLGVBQU8sTUFBTSxvQkFBb0IsRUFBRSxrQkFBa0IsQ0FBQyxZQUFZLENBbURqRSxDQUFDO0FBU0Y7OztHQUdHO0FBQ0gsTUFBTSxXQUFXLGtCQUFrQjtJQUNqQyxpQkFBaUIsSUFBSSxXQUFXLENBQUM7SUFFakMsS0FBSyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV2QixJQUFJLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXRCLG1CQUFtQixJQUFJLGtCQUFrQixDQUFDO0lBRTFDLFdBQVcsSUFBSSxVQUFVLENBQUM7SUFFMUIsa0JBQWtCLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxZQUFZLENBQUMsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDbEU7QUFFRCxxQkFBYSxlQUFnQixTQUFRLEtBQUs7O2FBTXRCLFFBQVEsRUFBRSxNQUFNLEVBQUU7SUFKM0IsSUFBSSxTQUF5QjtJQUV0QyxZQUNFLE9BQU8sRUFBRSxNQUFNLEVBQ0MsUUFBUSxFQUFFLE1BQU0sRUFBRSxFQUduQztJQUVELE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsSUFBSSxlQUFlLENBRXpEO0NBQ0YifQ==