import { NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP, NUM_MSGS_PER_BASE_PARITY } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { bufferSchemaFor } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
export class ParityBasePrivateInputs {
    msgs;
    vkTreeRoot;
    constructor(/** Aggregated proof of all the parity circuit iterations. */ msgs, /** Root of the VK tree */ vkTreeRoot){
        this.msgs = msgs;
        this.vkTreeRoot = vkTreeRoot;
    }
    static fromSlice(array, index, vkTreeRoot) {
        // Can't use Tuple<Fr, typeof NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP> due to length
        if (array.length !== NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP) {
            throw new Error(`Msgs array length must be NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP=${NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP}`);
        }
        const start = index * NUM_MSGS_PER_BASE_PARITY;
        const end = start + NUM_MSGS_PER_BASE_PARITY;
        const msgs = array.slice(start, end);
        return new ParityBasePrivateInputs(msgs, vkTreeRoot);
    }
    /** Serializes the inputs to a buffer. */ toBuffer() {
        return serializeToBuffer(this.msgs, this.vkTreeRoot);
    }
    /** Serializes the inputs to a hex string. */ toString() {
        return bufferToHex(this.toBuffer());
    }
    /**
   * Deserializes the inputs from a buffer.
   * @param buffer - The buffer to deserialize from.
   */ static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new ParityBasePrivateInputs(reader.readArray(NUM_MSGS_PER_BASE_PARITY, Fr), Fr.fromBuffer(reader));
    }
    /**
   * Deserializes the inputs from a hex string.
   * @param str - The hex string to deserialize from.
   * @returns - The deserialized inputs.
   */ static fromString(str) {
        return ParityBasePrivateInputs.fromBuffer(hexToBuffer(str));
    }
    /** Returns a buffer representation for JSON serialization. */ toJSON() {
        return this.toBuffer();
    }
    /** Creates an instance from a hex string. */ static get schema() {
        return bufferSchemaFor(ParityBasePrivateInputs);
    }
}
