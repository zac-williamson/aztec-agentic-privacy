import { Fq, Fr } from '@aztec/foundation/curves/bn254';
import { BufferReader } from '@aztec/foundation/serialize';
import { CircuitType } from '../types/shared.js';
/**
 * Curve data.
 */
export declare class G1AffineElement {
    /**
     * Element's x coordinate.
     */
    x: Fq;
    /**
     * Element's y coordinate.
     */
    y: Fq;
    constructor(x: Fq | bigint, y: Fq | bigint);
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer  or BufferReader to read from.
     * @returns The G1AffineElement.
     */
    static fromBuffer(buffer: Buffer | BufferReader): G1AffineElement;
}
/**
 * Used store and serialize a key-value map of commitments where key is the name of the commitment and value is
 * the commitment itself. The name can be e.g. Q_1, Q_2, SIGMA_1 etc.
 */
export declare class CommitmentMap {
    /**
     * An object used to store the commitments.
     */
    record: {
        [name: string]: G1AffineElement;
    };
    constructor(
    /**
     * An object used to store the commitments.
     */
    record: {
        [name: string]: G1AffineElement;
    });
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer or BufferReader to read from.
     * @returns The CommitmentMap.
     */
    static fromBuffer(buffer: Buffer | BufferReader): CommitmentMap;
}
export declare const CIRCUIT_SIZE_INDEX = 0;
export declare const CIRCUIT_PUBLIC_INPUTS_INDEX = 1;
/**
 * Provides a 'fields' representation of a circuit's verification key
 */
export declare class VerificationKeyAsFields {
    key: Fr[];
    hash: Fr;
    constructor(key: Fr[], hash: Fr);
    static fromKey(key: Fr[]): Promise<VerificationKeyAsFields>;
    get numPublicInputs(): number;
    get circuitSize(): number;
    static get schema(): import("zod").ZodType<VerificationKeyAsFields, any, string>;
    toJSON(): Buffer<ArrayBufferLike>;
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    toFields(): (number | Fr)[];
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer to read from.
     * @returns The VerificationKeyAsFields.
     */
    static fromBuffer(buffer: Buffer | BufferReader): VerificationKeyAsFields;
    static fromFrBuffer(vkBytes: Buffer): Promise<VerificationKeyAsFields>;
    /**
     * Builds a fake verification key that should be accepted by circuits.
     * @returns A fake verification key.
     */
    static makeFake(size: number, seed?: number): VerificationKeyAsFields;
    static makeFakeHonk(seed?: number): VerificationKeyAsFields;
    static makeFakeRollupHonk(seed?: number): VerificationKeyAsFields;
    /**
     * Builds an 'empty' verification key
     * @returns An 'empty' verification key
     */
    static makeEmpty(size: number): VerificationKeyAsFields;
}
export declare class VerificationKey {
    /**
     * For Plonk, this is equivalent to the proving system used to prove and verify.
     */
    circuitType: CircuitType;
    /**
     * The number of gates in this circuit.
     */
    circuitSize: number;
    /**
     * The number of public inputs in this circuit.
     */
    numPublicInputs: number;
    /**
     * The commitments for this circuit.
     */
    commitments: Record<string, G1AffineElement>;
    /**
     * Contains a recursive proof?
     */
    containsRecursiveProof: boolean;
    /**
     * Recursion stack.
     */
    recursiveProofPublicInputIndices: number[];
    constructor(
    /**
     * For Plonk, this is equivalent to the proving system used to prove and verify.
     */
    circuitType: CircuitType, 
    /**
     * The number of gates in this circuit.
     */
    circuitSize: number, 
    /**
     * The number of public inputs in this circuit.
     */
    numPublicInputs: number, 
    /**
     * The commitments for this circuit.
     */
    commitments: Record<string, G1AffineElement>, 
    /**
     * Contains a recursive proof?
     */
    containsRecursiveProof: boolean, 
    /**
     * Recursion stack.
     */
    recursiveProofPublicInputIndices: number[]);
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Deserializes class from a buffer.
     * @returns A VerificationKey instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): VerificationKey;
    /**
     * Builds a fake Rollup Honk verification key that should be accepted by circuits.
     * @returns A fake verification key.
     */
    static makeRollupFake(): VerificationKey;
    /**
     * Builds a fake verification key that should be accepted by circuits.
     * @returns A fake verification key.
     */
    static makeFake(): VerificationKey;
    /**
     * Builds a fake MegaHonk verification key buffer for testing.
     * Uses a real VK from a compiled contract to ensure proper format.
     *
     * @returns A valid MegaHonk VK buffer (4064 bytes)
     */
    static makeFakeMegaHonk(): Buffer;
}
export declare class VerificationKeyData {
    readonly keyAsFields: VerificationKeyAsFields;
    readonly keyAsBytes: Buffer;
    constructor(keyAsFields: VerificationKeyAsFields, keyAsBytes: Buffer);
    get numPublicInputs(): number;
    get circuitSize(): number;
    static empty(): VerificationKeyData;
    static makeFakeHonk(): VerificationKeyData;
    static makeFakeRollupHonk(): VerificationKeyData;
    static makeFake(len?: number): VerificationKeyData;
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    toString(): `0x${string}`;
    static fromBuffer(buffer: Buffer | BufferReader): VerificationKeyData;
    static fromFrBuffer(vkBytes: Buffer): Promise<VerificationKeyData>;
    static fromString(str: string): VerificationKeyData;
    clone(): VerificationKeyData;
    /** Returns a hex representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string. */
    static get schema(): import("zod").ZodType<VerificationKeyData, any, string>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyaWZpY2F0aW9uX2tleS5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Zrcy92ZXJpZmljYXRpb25fa2V5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE9BQU8sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFFeEQsT0FBTyxFQUFFLFlBQVksRUFBcUIsTUFBTSw2QkFBNkIsQ0FBQztBQUk5RSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFakQ7O0dBRUc7QUFDSCxxQkFBYSxlQUFlO0lBQzFCOztPQUVHO0lBQ0ksQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUNiOztPQUVHO0lBQ0ksQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUViLFlBQVksQ0FBQyxFQUFFLEVBQUUsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsR0FBRyxNQUFNLEVBR3pDO0lBQ0Q7OztPQUdHO0lBQ0gsUUFBUSw0QkFFUDtJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUcsWUFBWSxHQUFHLGVBQWUsQ0FHaEU7Q0FDRjtBQUVEOzs7R0FHRztBQUNILHFCQUFhLGFBQWE7SUFFdEI7O09BRUc7SUFDSSxNQUFNLEVBQUU7UUFBRSxDQUFDLElBQUksRUFBRSxNQUFNLEdBQUcsZUFBZSxDQUFBO0tBQUU7SUFKcEQ7SUFDRTs7T0FFRztJQUNJLE1BQU0sRUFBRTtRQUFFLENBQUMsSUFBSSxFQUFFLE1BQU0sR0FBRyxlQUFlLENBQUE7S0FBRSxFQUNoRDtJQUVKOzs7T0FHRztJQUNILFFBQVEsNEJBR1A7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxHQUFHLFlBQVksR0FBRyxhQUFhLENBRzlEO0NBQ0Y7QUFHRCxlQUFPLE1BQU0sa0JBQWtCLElBQUksQ0FBQztBQUNwQyxlQUFPLE1BQU0sMkJB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