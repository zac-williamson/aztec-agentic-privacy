import { z } from 'zod';
import { schemas, zodFor } from '../schemas/index.js';
export var OffenseType = /*#__PURE__*/ function(OffenseType) {
    OffenseType[OffenseType["UNKNOWN"] = 0] = "UNKNOWN";
    /** The data for proving an epoch was not publicly available, we slash its committee */ OffenseType[OffenseType["DATA_WITHHOLDING"] = 1] = "DATA_WITHHOLDING";
    /** An epoch was not successfully proven in time, we slash its committee */ OffenseType[OffenseType["VALID_EPOCH_PRUNED"] = 2] = "VALID_EPOCH_PRUNED";
    /** A proposer failed to attest or propose during an epoch according to the Sentinel */ OffenseType[OffenseType["INACTIVITY"] = 3] = "INACTIVITY";
    /** A proposer sent an invalid block proposal over the p2p network to the committee */ OffenseType[OffenseType["BROADCASTED_INVALID_BLOCK_PROPOSAL"] = 4] = "BROADCASTED_INVALID_BLOCK_PROPOSAL";
    /** A proposer pushed to L1 a block with insufficient committee attestations */ OffenseType[OffenseType["PROPOSED_INSUFFICIENT_ATTESTATIONS"] = 5] = "PROPOSED_INSUFFICIENT_ATTESTATIONS";
    /** A proposer pushed to L1 a block with incorrect committee attestations (ie signature from a non-committee member) */ OffenseType[OffenseType["PROPOSED_INCORRECT_ATTESTATIONS"] = 6] = "PROPOSED_INCORRECT_ATTESTATIONS";
    /** A committee member attested to a block that was built as a descendent of an invalid block (as in a block with invalid attestations) */ OffenseType[OffenseType["ATTESTED_DESCENDANT_OF_INVALID"] = 7] = "ATTESTED_DESCENDANT_OF_INVALID";
    /** A proposer sent duplicate proposals for the same position (slot, indexWithinCheckpoint for blocks or slot for checkpoints) */ OffenseType[OffenseType["DUPLICATE_PROPOSAL"] = 8] = "DUPLICATE_PROPOSAL";
    /** A validator signed attestations for different proposals at the same slot (equivocation) */ OffenseType[OffenseType["DUPLICATE_ATTESTATION"] = 9] = "DUPLICATE_ATTESTATION";
    return OffenseType;
}({});
export function getOffenseTypeName(offense) {
    switch(offense){
        case 0:
            return 'unknown';
        case 1:
            return 'data_withholding';
        case 2:
            return 'valid_epoch_pruned';
        case 3:
            return 'inactivity';
        case 4:
            return 'broadcasted_invalid_block_proposal';
        case 5:
            return 'proposed_insufficient_attestations';
        case 6:
            return 'proposed_incorrect_attestations';
        case 7:
            return 'attested_descendant_of_invalid';
        case 8:
            return 'duplicate_proposal';
        case 9:
            return 'duplicate_attestation';
        default:
            throw new Error(`Unknown offense type: ${offense}`);
    }
}
export const OffenseTypeSchema = z.nativeEnum(OffenseType);
export const OffenseToBigInt = {
    [0]: 0n,
    [1]: 1n,
    [2]: 2n,
    [3]: 3n,
    [4]: 4n,
    [5]: 5n,
    [6]: 6n,
    [7]: 7n,
    [8]: 8n,
    [9]: 9n
};
export function bigIntToOffense(offense) {
    switch(offense){
        case 0n:
            return 0;
        case 1n:
            return 1;
        case 2n:
            return 2;
        case 3n:
            return 3;
        case 4n:
            return 4;
        case 5n:
            return 5;
        case 6n:
            return 6;
        case 7n:
            return 7;
        case 8n:
            return 8;
        case 9n:
            return 9;
        default:
            throw new Error(`Unknown offense: ${offense}`);
    }
}
export const OffenseSchema = zodFor()(z.object({
    validator: schemas.EthAddress,
    amount: schemas.BigInt,
    offenseType: OffenseTypeSchema,
    epochOrSlot: schemas.BigInt
}));
export const SlashPayloadRoundSchema = zodFor()(z.object({
    address: schemas.EthAddress,
    timestamp: schemas.BigInt,
    votes: schemas.BigInt,
    round: schemas.BigInt,
    slashes: z.array(z.object({
        validator: schemas.EthAddress,
        amount: schemas.BigInt,
        offenses: z.array(z.object({
            offenseType: OffenseTypeSchema,
            epochOrSlot: schemas.BigInt
        }))
    }))
}));
