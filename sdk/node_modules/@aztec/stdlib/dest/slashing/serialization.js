import { times } from '@aztec/foundation/collection';
import { EthAddress } from '@aztec/foundation/eth-address';
import { BufferReader, bigintToUInt64BE, bigintToUInt128BE, serializeToBuffer } from '@aztec/foundation/serialize';
export function serializeOffense(offense) {
    return serializeToBuffer(offense.validator, bigintToUInt128BE(offense.amount), offense.offenseType, bigintToUInt64BE(offense.epochOrSlot));
}
export function deserializeOffense(buffer) {
    const reader = BufferReader.asReader(buffer);
    const validator = reader.readObject(EthAddress);
    const amount = reader.readUInt128();
    const offense = reader.readNumber();
    const epochOrSlot = reader.readUInt64();
    return {
        validator,
        amount,
        offenseType: offense,
        epochOrSlot
    };
}
function serializeValidatorSlashOffense(offense) {
    return serializeToBuffer(bigintToUInt64BE(offense.epochOrSlot), offense.offenseType);
}
function deserializeValidatorSlashOffense(buffer) {
    const reader = BufferReader.asReader(buffer);
    return {
        epochOrSlot: reader.readUInt64(),
        offenseType: reader.readNumber()
    };
}
function serializeValidatorSlash(slash) {
    return serializeToBuffer(slash.validator, bigintToUInt128BE(slash.amount), slash.offenses.length, slash.offenses.map(serializeValidatorSlashOffense));
}
function deserializeValidatorSlash(buffer) {
    const reader = BufferReader.asReader(buffer);
    const validator = reader.readObject(EthAddress);
    const amount = reader.readUInt128();
    const offensesCount = reader.readNumber();
    const offenses = times(offensesCount, ()=>deserializeValidatorSlashOffense(reader));
    return {
        validator,
        amount,
        offenses
    };
}
export function serializeSlashPayload(payload) {
    return serializeToBuffer(payload.address, payload.slashes.length, payload.slashes.map(serializeValidatorSlash), bigintToUInt64BE(payload.timestamp));
}
export function deserializeSlashPayload(buffer) {
    const reader = BufferReader.asReader(buffer);
    const address = reader.readObject(EthAddress);
    const slashesCount = reader.readNumber();
    const slashes = times(slashesCount, ()=>deserializeValidatorSlash(reader));
    const timestamp = reader.readUInt64();
    return {
        address,
        slashes,
        timestamp
    };
}
export function serializeSlashPayloadRound(payload) {
    return serializeToBuffer(payload.address, payload.slashes.length, payload.slashes.map(serializeValidatorSlash), bigintToUInt64BE(payload.timestamp), Number(payload.votes), bigintToUInt64BE(payload.round));
}
export function deserializeSlashPayloadRound(buffer) {
    const reader = BufferReader.asReader(buffer);
    const address = reader.readObject(EthAddress);
    const slashesCount = reader.readNumber();
    const slashes = times(slashesCount, ()=>deserializeValidatorSlash(reader));
    const timestamp = reader.readUInt64();
    const votes = BigInt(reader.readNumber());
    const round = reader.readUInt64();
    return {
        address,
        slashes,
        timestamp,
        votes,
        round
    };
}
