import { type L2BlockSource } from '../l2_block_source.js';
import type { L2BlockStreamEventHandler, L2BlockStreamLocalDataProvider } from './interfaces.js';
/** Maximum number of checkpoints to prefetch at once during sync. Matches MAX_RPC_CHECKPOINTS_LEN. */
export declare const CHECKPOINT_PREFETCH_LIMIT = 50;
/** Creates a stream of events for new blocks, chain tips updates, and reorgs, out of polling an archiver or a node. */
export declare class L2BlockStream {
    private l2BlockSource;
    private localData;
    private handler;
    private readonly log;
    private opts;
    private readonly runningPromise;
    private isSyncing;
    private hasStarted;
    constructor(l2BlockSource: Pick<L2BlockSource, 'getBlocks' | 'getBlockHeader' | 'getL2Tips' | 'getCheckpoints' | 'getCheckpointedBlocks'>, localData: L2BlockStreamLocalDataProvider, handler: L2BlockStreamEventHandler, log?: import("@aztec/foundation/log").Logger, opts?: {
        pollIntervalMS?: number;
        batchSize?: number;
        startingBlock?: number;
        /** Instead of downloading all blocks, only fetch the smallest subset that results in reliable reorg detection. */
        skipFinalized?: boolean;
        /** When true, checkpoint events will not be emitted. Blocks are still fetched via checkpoints but only blocks-added events are emitted. */
        ignoreCheckpoints?: boolean;
        /** Maximum number of checkpoints to prefetch at once during sync. Defaults to CHECKPOINT_PREFETCH_LIMIT (50). */
        checkpointPrefetchLimit?: number;
    });
    start(): void;
    stop(): Promise<void>;
    isRunning(): boolean;
    /**
     * Runs the synchronization process once.
     *
     * If you want to run this process continuously use `start` and `stop` instead.
     */
    sync(): Promise<void>;
    protected work(): Promise<void>;
    private areBlockHashesEqualAt;
    private getBlockHashFromSource;
    private emitEvent;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibDJfYmxvY2tfc3RyZWFtLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYmxvY2svbDJfYmxvY2tfc3RyZWFtL2wyX2Jsb2NrX3N0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNQSxPQUFPLEVBQWtCLEtBQUssYUFBYSxFQUFpQixNQUFNLHVCQUF1QixDQUFDO0FBQzFGLE9BQU8sS0FBSyxFQUFzQix5QkFBeUIsRUFBRSw4QkFBOEIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXJILHNHQUFzRztBQUN0RyxlQUFPLE1BQU0seUJBQXlCLEtBQUssQ0FBQztBQUU1Qyx1SEFBdUg7QUFDdkgscUJBQWEsYUFBYTtJQU10QixPQUFPLENBQUMsYUFBYTtJQUlyQixPQUFPLENBQUMsU0FBUztJQUNqQixPQUFPLENBQUMsT0FBTztJQUNmLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRztJQUNwQixPQUFPLENBQUMsSUFBSTtJQVpkLE9BQU8sQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFpQjtJQUNoRCxPQUFPLENBQUMsU0FBUyxDQUFTO0lBQzFCLE9BQU8sQ0FBQyxVQUFVLENBQVM7SUFFM0IsWUFDVSxhQUFhLEVBQUUsSUFBSSxDQUN6QixhQUFhLEVBQ2IsV0FBVyxHQUFHLGdCQUFnQixHQUFHLFdBQVcsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsQ0FDMUYsRUFDTyxTQUFTLEVBQUUsOEJBQThCLEVBQ3pDLE9BQU8sRUFBRSx5QkFBeUIsRUFDekIsR0FBRyx5Q0FBcUMsRUFDakQsSUFBSSxHQUFFO1FBQ1osY0FBYyxDQUFDLEVBQUUsTUFBTSxDQUFDO1FBQ3hCLFNBQVMsQ0FBQyxFQUFFLE1BQU0sQ0FBQztRQUNuQixhQUFhLENBQUMsRUFBRSxNQUFNLENBQUM7UUFDdkIsa0hBQWtIO1FBQ2xILGFBQWEsQ0FBQyxFQUFFLE9BQU8sQ0FBQztRQUN4QiwySUFBMkk7UUFDM0ksaUJBQWlCLENBQUMsRUFBRSxPQUFPLENBQUM7UUFDNUIsaUhBQWlIO1FBQ2pILHVCQUF1QixDQUFDLEVBQUUsTUFBTSxDQUFDO0tBQzdCLEVBT1A7SUFFTSxLQUFLLFNBR1g7SUFFWSxJQUFJLGtCQUVoQjtJQUVNLFNBQVMsWUFFZjtJQUVEOzs7O09BSUc7SUFDVSxJQUFJLGtCQUloQjtJQUVELFVBQWdCLElBQUksa0JBMEtuQjtZQU9hLHFCQUFxQjtJQXdCbkMsT0FBTyxDQUFDLHNCQUFzQjtZQU9oQixTQUFTO0NBU3hCIn0=