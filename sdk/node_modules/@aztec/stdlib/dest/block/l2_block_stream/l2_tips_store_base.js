import { GENESIS_BLOCK_HEADER_HASH } from '@aztec/constants';
import { BlockNumber, CheckpointNumber } from '@aztec/foundation/branded-types';
import { GENESIS_CHECKPOINT_HEADER_HASH } from '../l2_block_source.js';
/**
 * Abstract base class for L2 tips stores. Provides common event handling logic
 * while delegating storage operations to subclasses.
 */ export class L2TipsStoreBase {
    // Public interface implementation
    getL2BlockHash(number) {
        return this.getStoredBlockHash(number);
    }
    getL2Tips() {
        return this.runInTransaction(async ()=>{
            const [proposedBlockId, finalizedBlockId, provenBlockId, checkpointedBlockId] = await Promise.all([
                this.getBlockId('proposed'),
                this.getBlockId('finalized'),
                this.getBlockId('proven'),
                this.getBlockId('checkpointed')
            ]);
            const [finalizedCheckpointId, provenCheckpointId, checkpointedCheckpointId] = await Promise.all([
                this.getCheckpointId('finalized'),
                this.getCheckpointId('proven'),
                this.getCheckpointId('checkpointed')
            ]);
            return {
                proposed: proposedBlockId,
                finalized: {
                    block: finalizedBlockId,
                    checkpoint: finalizedCheckpointId
                },
                proven: {
                    block: provenBlockId,
                    checkpoint: provenCheckpointId
                },
                checkpointed: {
                    block: checkpointedBlockId,
                    checkpoint: checkpointedCheckpointId
                }
            };
        });
    }
    async handleBlockStreamEvent(event) {
        switch(event.type){
            case 'blocks-added':
                await this.handleBlocksAdded(event);
                break;
            case 'chain-checkpointed':
                await this.handleChainCheckpointed(event);
                break;
            case 'chain-pruned':
                await this.handleChainPruned(event);
                break;
            case 'chain-proven':
                await this.handleChainProven(event);
                break;
            case 'chain-finalized':
                await this.handleChainFinalized(event);
                break;
        }
    }
    // Protected helper that subclasses can override for block hash computation
    computeBlockHash(block) {
        return block.hash().then((hash)=>hash.toString());
    }
    // Private implementation
    async getBlockId(tag) {
        const blockNumber = await this.getTip(tag);
        if (blockNumber === undefined || blockNumber === 0) {
            return {
                number: BlockNumber.ZERO,
                hash: GENESIS_BLOCK_HEADER_HASH.toString()
            };
        }
        const blockHash = await this.getStoredBlockHash(blockNumber);
        if (!blockHash) {
            throw new Error(`Block hash not found for block number ${blockNumber}`);
        }
        return {
            number: blockNumber,
            hash: blockHash
        };
    }
    async getCheckpointId(tag) {
        const blockNumber = await this.getTip(tag);
        if (blockNumber === undefined || blockNumber === 0) {
            return {
                number: CheckpointNumber.ZERO,
                hash: GENESIS_CHECKPOINT_HEADER_HASH.toString()
            };
        }
        const checkpointNumber = await this.getCheckpointNumberForBlock(blockNumber);
        if (checkpointNumber === undefined) {
            // No checkpoint associated with this block yet
            return {
                number: CheckpointNumber.ZERO,
                hash: GENESIS_CHECKPOINT_HEADER_HASH.toString()
            };
        }
        const checkpoint = await this.getCheckpoint(checkpointNumber);
        if (!checkpoint) {
            throw new Error(`Checkpoint not found for checkpoint number ${checkpointNumber}`);
        }
        return {
            number: checkpointNumber,
            hash: checkpoint.checkpoint.hash().toString()
        };
    }
    async handleBlocksAdded(event) {
        if (event.type !== 'blocks-added') {
            return;
        }
        await this.runInTransaction(async ()=>{
            const blocks = event.blocks;
            for (const block of blocks){
                await this.setBlockHash(block.number, await this.computeBlockHash(block));
            }
            await this.setTip('proposed', blocks.at(-1).number);
        });
    }
    async handleChainCheckpointed(event) {
        if (event.type !== 'chain-checkpointed') {
            return;
        }
        await this.runInTransaction(async ()=>{
            await this.saveTag('checkpointed', event.block);
            await this.saveCheckpoint(event.checkpoint);
        });
    }
    async handleChainPruned(event) {
        if (event.type !== 'chain-pruned') {
            return;
        }
        await this.runInTransaction(async ()=>{
            await this.saveTag('proposed', event.block);
            await this.saveTag('checkpointed', event.block);
            const storeProven = await this.getBlockId('proven');
            if (storeProven.number > event.block.number) {
                await this.saveTag('proven', event.block);
            }
        });
    }
    async handleChainProven(event) {
        if (event.type !== 'chain-proven') {
            return;
        }
        await this.runInTransaction(async ()=>{
            await this.saveTag('proven', event.block);
        });
    }
    async handleChainFinalized(event) {
        if (event.type !== 'chain-finalized') {
            return;
        }
        await this.runInTransaction(async ()=>{
            await this.saveTag('finalized', event.block);
            const finalizedCheckpointNumber = await this.getCheckpointNumberForBlock(event.block.number);
            await this.deleteBlockHashesBefore(event.block.number);
            await this.deleteBlockToCheckpointBefore(event.block.number);
            if (finalizedCheckpointNumber !== undefined) {
                await this.deleteCheckpointsBefore(finalizedCheckpointNumber);
            }
        });
    }
    async saveTag(name, block) {
        await this.setTip(name, block.number);
        if (block.hash) {
            await this.setBlockHash(block.number, block.hash);
        }
    }
    async saveCheckpoint(publishedCheckpoint) {
        const checkpoint = publishedCheckpoint.checkpoint;
        const lastBlock = checkpoint.blocks.at(-1);
        // Only store the mapping for the last block since tips only point to checkpoint boundaries
        await Promise.all([
            this.setCheckpointNumberForBlock(lastBlock.number, checkpoint.number),
            this.saveCheckpointData(publishedCheckpoint)
        ]);
    }
}
