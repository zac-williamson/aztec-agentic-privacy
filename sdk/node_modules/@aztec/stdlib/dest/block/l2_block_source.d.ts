import { BlockNumber, CheckpointNumber, type EpochNumber, type SlotNumber } from '@aztec/foundation/branded-types';
import type { Fr } from '@aztec/foundation/curves/bn254';
import type { EthAddress } from '@aztec/foundation/eth-address';
import type { TypedEventEmitter } from '@aztec/foundation/types';
import { z } from 'zod';
import type { Checkpoint } from '../checkpoint/checkpoint.js';
import type { CheckpointData } from '../checkpoint/checkpoint_data.js';
import type { PublishedCheckpoint } from '../checkpoint/published_checkpoint.js';
import type { L1RollupConstants } from '../epoch-helpers/index.js';
import type { BlockHeader } from '../tx/block_header.js';
import type { IndexedTxEffect } from '../tx/indexed_tx_effect.js';
import type { TxHash } from '../tx/tx_hash.js';
import type { TxReceipt } from '../tx/tx_receipt.js';
import type { BlockData } from './block_data.js';
import type { BlockHash } from './block_hash.js';
import type { CheckpointedL2Block } from './checkpointed_l2_block.js';
import type { L2Block } from './l2_block.js';
import type { ValidateCheckpointNegativeResult, ValidateCheckpointResult } from './validate_block_result.js';
/**
 * Interface of classes allowing for the retrieval of L2 blocks.
 */
export interface L2BlockSource {
    /**
     * Method to fetch the rollup contract address at the base-layer.
     * @returns The rollup address.
     */
    getRollupAddress(): Promise<EthAddress>;
    /**
     * Method to fetch the registry contract address at the base-layer.
     * @returns The registry address.
     */
    getRegistryAddress(): Promise<EthAddress>;
    /**
     * Gets the number of the latest L2 block processed by the block source implementation.
     * @returns The number of the latest L2 block processed by the block source implementation.
     */
    getBlockNumber(): Promise<BlockNumber>;
    /**
     * Gets the number of the latest L2 block proven seen by the block source implementation.
     * @returns The number of the latest L2 block proven seen by the block source implementation.
     */
    getProvenBlockNumber(): Promise<BlockNumber>;
    /**
     * Gets the number of the latest L2 block checkpointed seen by the block source implementation.
     * @returns The number of the latest L2 block checkpointed seen by the block source implementation.
     */
    getCheckpointedL2BlockNumber(): Promise<BlockNumber>;
    /**
     * Computes the finalized block number based on the proven block number.
     * A block is considered finalized when it's 2 epochs behind the proven block.
     * TODO(#13569): Compute proper finalized block number based on L1 finalized block.
     * @returns The finalized block number.
     */
    getFinalizedL2BlockNumber(): Promise<BlockNumber>;
    /**
     * Gets an l2 block header.
     * @param number - The block number to return or 'latest' for the most recent one.
     * @returns The requested L2 block header.
     */
    getBlockHeader(number: BlockNumber | 'latest'): Promise<BlockHeader | undefined>;
    /**
     * Gets a checkpointed L2 block by block number.
     * Returns undefined if the block doesn't exist or hasn't been checkpointed yet.
     * @param number - The block number to retrieve.
     * @returns The requested checkpointed L2 block (or undefined if not found or not checkpointed).
     */
    getCheckpointedBlock(number: BlockNumber): Promise<CheckpointedL2Block | undefined>;
    getCheckpointedBlocks(from: BlockNumber, limit: number): Promise<CheckpointedL2Block[]>;
    /**
     * Retrieves a collection of checkpoints.
     * @param checkpointNumber The first checkpoint to be retrieved.
     * @param limit The number of checkpoints to be retrieved.
     * @returns The collection of complete checkpoints.
     */
    getCheckpoints(checkpointNumber: CheckpointNumber, limit: number): Promise<PublishedCheckpoint[]>;
    /**
     * Gets the checkpoints for a given epoch
     * @param epochNumber - Epoch for which we want checkpoint data
     */
    getCheckpointsForEpoch(epochNumber: EpochNumber): Promise<Checkpoint[]>;
    /**
     * Gets lightweight checkpoint metadata for a given epoch, without fetching full block data.
     * @param epochNumber - Epoch for which we want checkpoint data
     */
    getCheckpointsDataForEpoch(epochNumber: EpochNumber): Promise<CheckpointData[]>;
    /**
     * Gets a block header by its hash.
     * @param blockHash - The block hash to retrieve.
     * @returns The requested block header (or undefined if not found).
     */
    getBlockHeaderByHash(blockHash: BlockHash): Promise<BlockHeader | undefined>;
    /**
     * Gets a block header by its archive root.
     * @param archive - The archive root to retrieve.
     * @returns The requested block header (or undefined if not found).
     */
    getBlockHeaderByArchive(archive: Fr): Promise<BlockHeader | undefined>;
    /**
     * Gets block metadata (without tx data) by block number.
     * @param number - The block number to retrieve.
     * @returns The requested block data (or undefined if not found).
     */
    getBlockData(number: BlockNumber): Promise<BlockData | undefined>;
    /**
     * Gets block metadata (without tx data) by archive root.
     * @param archive - The archive root to retrieve.
     * @returns The requested block data (or undefined if not found).
     */
    getBlockDataByArchive(archive: Fr): Promise<BlockData | undefined>;
    /**
     * Gets an L2 block by block number.
     * @param number - The block number to return.
     * @returns The requested L2 block (or undefined if not found).
     */
    getL2Block(number: BlockNumber): Promise<L2Block | undefined>;
    /**
     * Gets an L2 block by its hash.
     * @param blockHash - The block hash to retrieve.
     * @returns The requested L2 block (or undefined if not found).
     */
    getL2BlockByHash(blockHash: BlockHash): Promise<L2Block | undefined>;
    /**
     * Gets an L2 block by its archive root.
     * @param archive - The archive root to retrieve.
     * @returns The requested L2 block (or undefined if not found).
     */
    getL2BlockByArchive(archive: Fr): Promise<L2Block | undefined>;
    /**
     * Gets a tx effect.
     * @param txHash - The hash of the tx corresponding to the tx effect.
     * @returns The requested tx effect with block info (or undefined if not found).
     */
    getTxEffect(txHash: TxHash): Promise<IndexedTxEffect | undefined>;
    /**
     * Gets a receipt of a settled tx.
     * @param txHash - The hash of a tx we try to get the receipt for.
     * @returns The requested tx receipt (or undefined if not found).
     */
    getSettledTxReceipt(txHash: TxHash): Promise<TxReceipt | undefined>;
    /**
     * Returns the current L2 slot number based on the currently synced L1 timestamp.
     */
    getL2SlotNumber(): Promise<SlotNumber | undefined>;
    /**
     * Returns the current L2 epoch number based on the currently synced L1 timestamp.
     */
    getL2EpochNumber(): Promise<EpochNumber | undefined>;
    /**
     * Returns all checkpointed block headers for a given epoch.
     * @dev Use this method only with recent epochs, since it walks the block list backwards.
     * @param epochNumber - The epoch number to return headers for.
     */
    getCheckpointedBlockHeadersForEpoch(epochNumber: EpochNumber): Promise<BlockHeader[]>;
    /**
     * Returns whether the given epoch is completed on L1, based on the current L1 and L2 block numbers.
     * @param epochNumber - The epoch number to check.
     */
    isEpochComplete(epochNumber: EpochNumber): Promise<boolean>;
    /**
     * Returns the tips of the L2 chain.
     */
    getL2Tips(): Promise<L2Tips>;
    /**
     * Returns the rollup constants for the current chain.
     */
    getL1Constants(): Promise<L1RollupConstants>;
    /** Returns values for the genesis block */
    getGenesisValues(): Promise<{
        genesisArchiveRoot: Fr;
    }>;
    /** Latest synced L1 timestamp. */
    getL1Timestamp(): Promise<bigint | undefined>;
    /**
     * Returns whether the latest block in the pending chain on L1 is invalid (ie its attestations are incorrect).
     * Note that invalid blocks do not get synced, so the latest block returned by the block source is always a valid one.
     */
    isPendingChainInvalid(): Promise<boolean>;
    /**
     * Returns the status of the pending chain validation. If the chain is invalid, reports the earliest consecutive
     * checkpoint that is invalid, along with the reason for being invalid, which can be used to trigger an invalidation.
     */
    getPendingChainValidationStatus(): Promise<ValidateCheckpointResult>;
    /** Force a sync. */
    syncImmediate(): Promise<void>;
    /**
     * Gets an l2 block. If a negative number is passed, the block returned is the most recent.
     * @param number - The block number to return (inclusive).
     * @returns The requested L2 block.
     */
    getBlock(number: BlockNumber): Promise<L2Block | undefined>;
    /**
     * Returns all checkpointed blocks for a given epoch.
     * @dev Use this method only with recent epochs, since it walks the block list backwards.
     * @param epochNumber - The epoch number to return blocks for.
     */
    getCheckpointedBlocksForEpoch(epochNumber: EpochNumber): Promise<CheckpointedL2Block[]>;
    /**
     * Returns all blocks for a given slot.
     * @dev Use this method only with recent slots, since it walks the block list backwards.
     * @param slotNumber - The slot number to return blocks for.
     */
    getBlocksForSlot(slotNumber: SlotNumber): Promise<L2Block[]>;
    /**
     * Gets a checkpointed block by its block hash.
     * @param blockHash - The block hash to retrieve.
     * @returns The requested block (or undefined if not found).
     */
    getCheckpointedBlockByHash(blockHash: BlockHash): Promise<CheckpointedL2Block | undefined>;
    /**
     * Gets a checkpointed block by its archive root.
     * @param archive - The archive root to retrieve.
     * @returns The requested block (or undefined if not found).
     */
    getCheckpointedBlockByArchive(archive: Fr): Promise<CheckpointedL2Block | undefined>;
    /**
     * Gets up to `limit` amount of L2 blocks starting from `from`.
     * @param from - Number of the first block to return (inclusive).
     * @param limit - The maximum number of blocks to return.
     * @returns The requested L2 blocks.
     */
    getBlocks(from: BlockNumber, limit: number): Promise<L2Block[]>;
}
/**
 * Interface for classes that can receive and store L2 blocks.
 */
export interface L2BlockSink {
    /**
     * Adds a block to the store.
     * @param block - The L2 block to add.
     * @throws If block number is not incremental (i.e., not exactly one more than the last stored block).
     */
    addBlock(block: L2Block): Promise<void>;
}
/**
 * L2BlockSource that emits events upon pending / proven chain changes.
 * see L2BlockSourceEvents for the events emitted.
 */
export type ArchiverEmitter = TypedEventEmitter<{
    [L2BlockSourceEvents.L2PruneUnproven]: (args: L2PruneUnprovenEvent) => void;
    [L2BlockSourceEvents.L2PruneUncheckpointed]: (args: L2PruneUncheckpointedEvent) => void;
    [L2BlockSourceEvents.L2BlockProven]: (args: L2BlockProvenEvent) => void;
    [L2BlockSourceEvents.InvalidAttestationsCheckpointDetected]: (args: InvalidCheckpointDetectedEvent) => void;
    [L2BlockSourceEvents.L2BlocksCheckpointed]: (args: L2CheckpointEvent) => void;
}>;
export interface L2BlockSourceEventEmitter extends L2BlockSource {
    events: ArchiverEmitter;
}
/**
 * Identifier for L2 block tags.
 * - proposed: Latest block proposed on L2.
 * - checkpointed: Checkpointed block on L1.
 * - proven: Proven block on L1.
 * - finalized: Proven block on a finalized L1 block (not implemented, set to proven for now).
 */
export type L2BlockTag = 'proposed' | 'checkpointed' | 'proven' | 'finalized';
/** Tips of the L2 chain. */
export type L2Tips = {
    proposed: L2BlockId;
    checkpointed: L2TipId;
    proven: L2TipId;
    finalized: L2TipId;
};
export declare const GENESIS_CHECKPOINT_HEADER_HASH: Fr;
/** Identifies a block by number and hash. */
export type L2BlockId = {
    number: BlockNumber;
    hash: string;
};
export type CheckpointId = {
    number: CheckpointNumber;
    hash: string;
};
export type L2TipId = {
    block: L2BlockId;
    checkpoint: CheckpointId;
};
/** Creates an L2 block id */
export declare function makeL2BlockId(number: BlockNumber, hash?: string): L2BlockId;
/** Creates an L2 checkpoint id */
export declare function makeL2CheckpointId(number: CheckpointNumber, hash: string): CheckpointId;
export declare const L2TipsSchema: z.ZodObject<{
    proposed: z.ZodObject<{
        number: z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodBigInt, z.ZodString]>, z.ZodNumber>, BlockNumber, string | number | bigint>;
        hash: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        number: number & {
            _branding: "BlockNumber";
        };
        hash: string;
    }, {
        number: string | number | bigint;
        hash: string;
    }>;
    checkpointed: z.ZodObject<{
        block: z.ZodObject<{
            number: z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodBigInt, z.ZodString]>, z.ZodNumber>, BlockNumber, string | number | bigint>;
            hash: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            number: number & {
                _branding: "BlockNumber";
            };
            hash: string;
        }, {
            number: string | number | bigint;
            hash: string;
        }>;
        checkpoint: z.ZodObject<{
            number: z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodBigInt, z.ZodString]>, z.ZodNumber>, CheckpointNumber, string | number | bigint>;
            hash: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            number: number & {
                _branding: "CheckpointNumber";
            };
            hash: string;
        }, {
            number: string | number | bigint;
            hash: string;
        }>;
    }, "strip", z.ZodTypeAny, {
        block: {
            number: number & {
                _branding: "BlockNumber";
            };
            hash: string;
        };
        checkpoint: {
            number: number & {
                _branding: "CheckpointNumber";
            };
            hash: string;
        };
    }, {
        block: {
            number: string | number | bigint;
            hash: string;
        };
        checkpoint: {
            number: string | number | bigint;
            hash: string;
        };
    }>;
    proven: z.ZodObject<{
        block: z.ZodObject<{
            number: z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodBigInt, z.ZodString]>, z.ZodNumber>, BlockNumber, string | number | bigint>;
            hash: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            number: number & {
                _branding: "BlockNumber";
            };
            hash: string;
        }, {
            number: string | number | bigint;
            hash: string;
        }>;
        checkpoint: z.ZodObject<{
            number: z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodBigInt, z.ZodString]>, z.ZodNumber>, CheckpointNumber, string | number | bigint>;
            hash: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            number: number & {
                _branding: "CheckpointNumber";
            };
            hash: string;
        }, {
            number: string | number | bigint;
            hash: string;
        }>;
    }, "strip", z.ZodTypeAny, {
        block: {
            number: number & {
                _branding: "BlockNumber";
            };
            hash: string;
        };
        checkpoint: {
            number: number & {
                _branding: "CheckpointNumber";
            };
            hash: string;
        };
    }, {
        block: {
            number: string | number | bigint;
            hash: string;
        };
        checkpoint: {
            number: string | number | bigint;
            hash: string;
        };
    }>;
    finalized: z.ZodObject<{
        block: z.ZodObject<{
            number: z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodBigInt, z.ZodString]>, z.ZodNumber>, BlockNumber, string | number | bigint>;
            hash: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            number: number & {
                _branding: "BlockNumber";
            };
            hash: string;
        }, {
            number: string | number | bigint;
            hash: string;
        }>;
        checkpoint: z.ZodObject<{
            number: z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodBigInt, z.ZodString]>, z.ZodNumber>, CheckpointNumber, string | number | bigint>;
            hash: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            number: number & {
                _branding: "CheckpointNumber";
            };
            hash: string;
        }, {
            number: string | number | bigint;
            hash: string;
        }>;
    }, "strip", z.ZodTypeAny, {
        block: {
            number: number & {
                _branding: "BlockNumber";
            };
            hash: string;
        };
        checkpoint: {
            number: number & {
                _branding: "CheckpointNumber";
            };
            hash: string;
        };
    }, {
        block: {
            number: string | number | bigint;
            hash: string;
        };
        checkpoint: {
            number: string | number | bigint;
            hash: string;
        };
    }>;
}, "strip", z.ZodTypeAny, {
    proposed: {
        number: number & {
            _branding: "BlockNumber";
        };
        hash: string;
    };
    checkpointed: {
        block: {
            number: number & {
                _branding: "BlockNumber";
            };
            hash: string;
        };
        checkpoint: {
            number: number & {
                _branding: "CheckpointNumber";
            };
            hash: string;
        };
    };
    proven: {
        block: {
            number: number & {
                _branding: "BlockNumber";
            };
            hash: string;
        };
        checkpoint: {
            number: number & {
                _branding: "CheckpointNumber";
            };
            hash: string;
        };
    };
    finalized: {
        block: {
            number: number & {
                _branding: "BlockNumber";
            };
            hash: string;
        };
        checkpoint: {
            number: number & {
                _branding: "CheckpointNumber";
            };
            hash: string;
        };
    };
}, {
    proposed: {
        number: string | number | bigint;
        hash: string;
    };
    checkpointed: {
        block: {
            number: string | number | bigint;
            hash: string;
        };
        checkpoint: {
            number: string | number | bigint;
            hash: string;
        };
    };
    proven: {
        block: {
            number: string | number | bigint;
            hash: string;
        };
        checkpoint: {
            number: string | number | bigint;
            hash: string;
        };
    };
    finalized: {
        block: {
            number: string | number | bigint;
            hash: string;
        };
        checkpoint: {
            number: string | number | bigint;
            hash: string;
        };
    };
}>;
export declare enum L2BlockSourceEvents {
    L2PruneUnproven = "l2PruneUnproven",
    L2PruneUncheckpointed = "l2PruneUncheckpointed",
    L2BlockProven = "l2BlockProven",
    L2BlocksCheckpointed = "l2BlocksCheckpointed",
    InvalidAttestationsCheckpointDetected = "invalidCheckpointDetected"
}
export type L2BlockProvenEvent = {
    type: 'l2BlockProven';
    blockNumber: BlockNumber;
    slotNumber: SlotNumber;
    epochNumber: EpochNumber;
};
export type L2PruneUnprovenEvent = {
    type: 'l2PruneUnproven';
    epochNumber: EpochNumber;
    blocks: L2Block[];
};
export type L2PruneUncheckpointedEvent = {
    type: 'l2PruneUncheckpointed';
    slotNumber: SlotNumber;
    blocks: L2Block[];
};
export type L2CheckpointEvent = {
    type: 'l2BlocksCheckpointed';
    checkpoint: PublishedCheckpoint;
};
export type InvalidCheckpointDetectedEvent = {
    type: 'invalidCheckpointDetected';
    validationResult: ValidateCheckpointNegativeResult;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibDJfYmxvY2tfc291cmNlLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYmxvY2svbDJfYmxvY2tfc291cmNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxXQUFXLEVBRVgsZ0JBQWdCLEVBRWhCLEtBQUssV0FBVyxFQUNoQixLQUFLLFVBQVUsRUFDaEIsTUFBTSxpQ0FBaUMsQ0FBQztBQUN6QyxPQUFPLEtBQUssRUFBRSxFQUFFLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUN6RCxPQUFPLEtBQUssRUFBRSxVQUFVLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNoRSxPQUFPLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRWpFLE9BQU8sRUFBRSxDQUFDLEVBQUUsTUFBTSxLQUFLLENBQUM7QUFFeEIsT0FBTyxLQUFLLEVBQUUsVUFBVSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDOUQsT0FBTyxLQUFLLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDdkUsT0FBTyxLQUFLLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUNqRixPQUFPLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRW5FLE9BQU8sS0FBSyxFQUFFLFdBQVcsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3pELE9BQU8sS0FBSyxFQUFFLGVBQWUsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ2xFLE9BQU8sS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQy9DLE9BQU8sS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3JELE9BQU8sS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2pELE9BQU8sS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2pELE9BQU8s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