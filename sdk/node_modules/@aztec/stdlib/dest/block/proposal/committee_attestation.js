import { EthAddress } from '@aztec/foundation/eth-address';
import { Signature } from '@aztec/foundation/eth-signature';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { z } from 'zod';
export { EthAddress, Signature };
export class CommitteeAttestation {
    address;
    signature;
    constructor(address, signature){
        this.address = address;
        this.signature = signature;
    }
    static get schema() {
        return z.object({
            address: EthAddress.schema,
            signature: Signature.schema
        }).transform(({ address, signature })=>new CommitteeAttestation(address, signature));
    }
    // Create an empty attestation for an address that has not signed
    static fromAddress(address) {
        return new CommitteeAttestation(address, Signature.empty());
    }
    // Create an attestation from an address and a signature
    static fromAddressAndSignature(address, signature) {
        return new CommitteeAttestation(address, signature);
    }
    static fromSignature(signature) {
        return new CommitteeAttestation(EthAddress.ZERO, signature);
    }
    static fromViem(viem) {
        return new CommitteeAttestation(EthAddress.fromString(viem.addr), Signature.fromViemSignature(viem.signature));
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const address = reader.readObject(EthAddress);
        const signature = reader.readObject(Signature);
        return new CommitteeAttestation(address, signature);
    }
    static random() {
        // note: will be invalid
        return new CommitteeAttestation(EthAddress.random(), Signature.random());
    }
    static empty() {
        return new CommitteeAttestation(EthAddress.ZERO, Signature.empty());
    }
    static fromPacked(packed, committeeSize) {
        const signatureIndicesBuffer = Buffer.from(packed.signatureIndices.slice(2), 'hex');
        const dataBuffer = Buffer.from(packed.signaturesOrAddresses.slice(2), 'hex');
        const attestations = [];
        let dataIndex = 0;
        for(let i = 0; i < committeeSize; i++){
            // Check if this position has a signature
            const byteIndex = Math.floor(i / 8);
            const bitIndex = 7 - i % 8;
            const hasSignature = byteIndex < signatureIndicesBuffer.length && (signatureIndicesBuffer[byteIndex] & 1 << bitIndex) !== 0;
            if (hasSignature) {
                // Extract signature: v (1 byte) + r (32 bytes) + s (32 bytes)
                if (dataIndex + 65 > dataBuffer.length) {
                    throw new Error(`Insufficient data for signature at position ${i}`);
                }
                const v = dataBuffer[dataIndex];
                const r = `0x${dataBuffer.subarray(dataIndex + 1, dataIndex + 33).toString('hex')}`;
                const s = `0x${dataBuffer.subarray(dataIndex + 33, dataIndex + 65).toString('hex')}`;
                const signature = Signature.fromViemSignature({
                    r,
                    s,
                    v
                });
                // For signed attestations, we use a zero address as the address is recovered from the signature
                attestations.push(new CommitteeAttestation(EthAddress.ZERO, signature));
                dataIndex += 65;
            } else {
                // Extract address (20 bytes)
                if (dataIndex + 20 > dataBuffer.length) {
                    throw new Error(`Insufficient data for address at position ${i}`);
                }
                const addressBytes = dataBuffer.subarray(dataIndex, dataIndex + 20);
                const address = EthAddress.fromString(`0x${addressBytes.toString('hex')}`);
                // For address-only attestations, use empty signature
                attestations.push(new CommitteeAttestation(address, Signature.empty()));
                dataIndex += 20;
            }
        }
        return attestations;
    }
    toBuffer() {
        return serializeToBuffer([
            this.address,
            this.signature
        ]);
    }
    equals(other) {
        return this.address.equals(other.address) && this.signature.equals(other.signature);
    }
    toViem() {
        return {
            addr: this.address.toString(),
            signature: this.signature.toViemSignature()
        };
    }
}
