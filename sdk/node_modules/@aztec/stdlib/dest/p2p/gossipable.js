import { BufferReader, bigintToUInt64BE, serializeToBuffer } from '@aztec/foundation/serialize';
export class P2PMessage {
    payload;
    timestamp;
    traceContext;
    constructor(payload, timestamp, traceContext){
        this.payload = payload;
        this.timestamp = timestamp;
        this.traceContext = traceContext;
    }
    static fromGossipable(message, instrumentMessages = false, traceContext) {
        if (!instrumentMessages) {
            return new P2PMessage(message.toBuffer());
        }
        return new P2PMessage(message.toBuffer(), new Date(), traceContext);
    }
    static fromMessageData(messageData, instrumentMessages = false) {
        const reader = new BufferReader(messageData);
        let timestamp;
        let traceContext;
        if (instrumentMessages) {
            timestamp = new Date(Number(reader.readUInt64()));
            traceContext = reader.readString();
        }
        const payload = reader.readBuffer();
        return new P2PMessage(payload, timestamp, traceContext);
    }
    toMessageData() {
        const arr = [];
        if (this.timestamp) {
            arr.push(bigintToUInt64BE(BigInt(this.timestamp.getTime())));
            arr.push(serializeToBuffer(this.traceContext ?? ''));
        }
        arr.push(serializeToBuffer(this.payload.length, this.payload));
        return serializeToBuffer(arr);
    }
}
/**
 * Gossipable
 *
 * Any class which extends gossipable will be able to be Gossiped over the p2p network
 */ export class Gossipable {
    cachedId;
    /** The p2p topic identifier, this determines how the message is handled */ static p2pTopic;
    /**
   * A digest of the message information **used for logging only**.
   * The identifier used for deduplication is `getMsgIdFn` as defined in `encoding.ts` which is a hash over topic and data.
   */ async p2pMessageLoggingIdentifier() {
        if (this.cachedId) {
            return this.cachedId;
        }
        this.cachedId = await this.generateP2PMessageIdentifier();
        return this.cachedId;
    }
    toMessage() {
        return this.toBuffer();
    }
}
