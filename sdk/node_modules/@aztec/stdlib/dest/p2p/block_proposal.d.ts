import { BlockNumber, IndexWithinCheckpoint, SlotNumber } from '@aztec/foundation/branded-types';
import { Buffer32 } from '@aztec/foundation/buffer';
import { Fr } from '@aztec/foundation/curves/bn254';
import type { EthAddress } from '@aztec/foundation/eth-address';
import { Signature } from '@aztec/foundation/eth-signature';
import { BufferReader } from '@aztec/foundation/serialize';
import { type SigningContext } from '@aztec/validator-ha-signer/types';
import type { L2Block } from '../block/l2_block.js';
import type { L2BlockInfo } from '../block/l2_block_info.js';
import { BlockHeader } from '../tx/block_header.js';
import { TxHash } from '../tx/index.js';
import type { Tx } from '../tx/tx.js';
import { Gossipable } from './gossipable.js';
import { SignatureDomainSeparator } from './signature_utils.js';
import { SignedTxs } from './signed_txs.js';
import { TopicType } from './topic_type.js';
export declare class BlockProposalHash extends Buffer32 {
    constructor(hash: Buffer);
}
export type BlockProposalOptions = {
    /**
     * Whether to include the tx objects along with the block proposal.
     * Dramatically increases size of the payload but eliminates failed reexecutions due to missing txs.
     */
    publishFullTxs?: boolean;
    /**
     * Whether to generate an invalid block proposal for broadcasting.
     * Use only for testing.
     */
    broadcastInvalidBlockProposal?: boolean;
};
/**
 * A block proposal is created by the leader of the chain proposing a sequence of transactions
 * to be included in a block within a checkpoint. This is used for non-last blocks in a slot.
 * The last block is sent as part of a CheckpointProposal.
 */
export declare class BlockProposal extends Gossipable {
    /** The per-block header containing block state and global variables */
    readonly blockHeader: BlockHeader;
    /** Index of this block within the checkpoint (0-indexed) */
    readonly indexWithinCheckpoint: IndexWithinCheckpoint;
    /** Hash of L1 to L2 messages for this checkpoint (constant across all blocks in checkpoint) */
    readonly inHash: Fr;
    /** Archive root after this block is applied */
    readonly archiveRoot: Fr;
    /** The sequence of transactions in the block */
    readonly txHashes: TxHash[];
    /** The proposer's signature over the block data */
    readonly signature: Signature;
    /** The signed transactions in the block (optional, for DA guarantees) */
    readonly signedTxs?: SignedTxs | undefined;
    static p2pTopic: TopicType;
    private sender;
    constructor(
    /** The per-block header containing block state and global variables */
    blockHeader: BlockHeader, 
    /** Index of this block within the checkpoint (0-indexed) */
    indexWithinCheckpoint: IndexWithinCheckpoint, 
    /** Hash of L1 to L2 messages for this checkpoint (constant across all blocks in checkpoint) */
    inHash: Fr, 
    /** Archive root after this block is applied */
    archiveRoot: Fr, 
    /** The sequence of transactions in the block */
    txHashes: TxHash[], 
    /** The proposer's signature over the block data */
    signature: Signature, 
    /** The signed transactions in the block (optional, for DA guarantees) */
    signedTxs?: SignedTxs | undefined);
    generateP2PMessageIdentifier(): Promise<Buffer32>;
    get archive(): Fr;
    get slotNumber(): SlotNumber;
    get blockNumber(): BlockNumber;
    /** Convenience getter for txs from signedTxs */
    get txs(): Tx[] | undefined;
    toBlockInfo(): Omit<L2BlockInfo, 'blockNumber'>;
    /**
     * Get the payload to sign for this block proposal.
     * The signature is over: blockHeader + indexWithinCheckpoint + inHash + archiveRoot + txHashes
     */
    getPayloadToSign(domainSeparator: SignatureDomainSeparator): Buffer;
    static createProposalFromSigner(blockHeader: BlockHeader, indexWithinCheckpoint: IndexWithinCheckpoint, inHash: Fr, archiveRoot: Fr, txHashes: TxHash[], txs: Tx[] | undefined, payloadSigner: (payload: Buffer32, context: SigningContext) => Promise<Signature>): Promise<BlockProposal>;
    /**
     * Lazily evaluate the sender of the proposal; result is cached.
     * If there's signedTxs, also verifies the signedTxs sender matches the block proposal sender.
     * @returns The sender address, or undefined if signature recovery fails or senders don't match
     */
    getSender(): EthAddress | undefined;
    getPayload(): Buffer<ArrayBufferLike>;
    toBuffer(): Buffer;
    static fromBuffer(buf: Buffer | BufferReader): BlockProposal;
    getSize(): number;
    static empty(): BlockProposal;
    static random(): BlockProposal;
    toInspect(): {
        blockHeader: {
            lastArchive: `0x${string}`;
            state: {
                l1ToL2MessageTree: `0x${string}`;
                noteHashTree: `0x${string}`;
                nullifierTree: `0x${string}`;
                publicDataTree: `0x${string}`;
            };
            spongeBlobHash: bigint;
            globalVariables: {
                chainId: number;
                version: number;
                blockNumber: BlockNumber;
                slotNumber: SlotNumber;
                timestamp: bigint;
                coinbase: `0x${string}`;
                feeRecipient: `0x${string}`;
                feePerDaGas: number;
                feePerL2Gas: number;
            };
            totalFees: bigint;
            totalManaUsed: bigint;
        };
        indexWithinCheckpoint: IndexWithinCheckpoint;
        inHash: `0x${string}`;
        archiveRoot: `0x${string}`;
        signature: `0x${string}`;
        txHashes: `0x${string}`[];
    };
    /**
     * Check if this proposal matches the given block.
     * Compares the archive root and block header.
     * @param block - The L2Block to compare against
     * @returns True if the proposal matches the block
     */
    matchesBlock(block: L2Block): boolean;
    /**
     * Returns a copy of this proposal without signedTxs.
     * Used when storing proposals in attestation pool to avoid storing full tx data.
     */
    withoutSignedTxs(): BlockProposal;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxvY2tfcHJvcG9zYWwuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wMnAvYmxvY2tfcHJvcG9zYWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFdBQVcsRUFBRSxxQkFBcUIsRUFBRSxVQUFVLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNqRyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFHcEQsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3BELE9BQU8sS0FBSyxFQUFFLFVBQVUsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUM1RCxPQUFPLEVBQUUsWUFBWSxFQUFxQixNQUFNLDZCQUE2QixDQUFDO0FBQzlFLE9BQU8sRUFBWSxLQUFLLGNBQWMsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBRWpGLE9BQU8sS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3BELE9BQU8sS0FBSyxFQUFFLFdBQVcsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRTdELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEMsT0FBTyxLQUFLLEVBQUUsRUFBRSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM3QyxPQUFPLEVBQ0wsd0JBQXdCLEVBR3pCLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUU1QyxxQkFBYSxpQkFBa0IsU0FBUSxRQUFRO0lBQzdDLFlB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