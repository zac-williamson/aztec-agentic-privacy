import { BlockNumber, IndexWithinCheckpoint, SlotNumber } from '@aztec/foundation/branded-types';
import { Buffer32 } from '@aztec/foundation/buffer';
import { Fr } from '@aztec/foundation/curves/bn254';
import type { EthAddress } from '@aztec/foundation/eth-address';
import { Signature } from '@aztec/foundation/eth-signature';
import { BufferReader } from '@aztec/foundation/serialize';
import { type SigningContext } from '@aztec/validator-ha-signer/types';
import type { L2BlockInfo } from '../block/l2_block_info.js';
import { CheckpointHeader } from '../rollup/checkpoint_header.js';
import { BlockHeader } from '../tx/block_header.js';
import { TxHash } from '../tx/index.js';
import type { Tx } from '../tx/tx.js';
import { BlockProposal } from './block_proposal.js';
import { Gossipable } from './gossipable.js';
import { SignatureDomainSeparator } from './signature_utils.js';
import { SignedTxs } from './signed_txs.js';
import { TopicType } from './topic_type.js';
export declare class CheckpointProposalHash extends Buffer32 {
    constructor(hash: Buffer);
}
export type CheckpointProposalOptions = {
    /**
     * Whether to include the tx objects along with the block proposal.
     * Dramatically increases size of the payload but eliminates failed reexecutions due to missing txs.
     */
    publishFullTxs?: boolean;
    /**
     * Whether to generate an invalid checkpoint proposal for broadcasting.
     * Use only for testing.
     */
    broadcastInvalidCheckpointProposal?: boolean;
};
/** Data for the last block included in a checkpoint proposal */
export type CheckpointLastBlockData = {
    /** The per-block header for the last block in the checkpoint */
    blockHeader: BlockHeader;
    /** Index of this block within the checkpoint (should be the last index, e.g., numBlocks - 1) */
    indexWithinCheckpoint: IndexWithinCheckpoint;
    /** The sequence of transactions in the last block */
    txHashes: TxHash[];
    /** The tx in the last block (optional, for DA guarantees) */
    txs?: Tx[];
};
/** Last block included in a checkpoint proposal */
export type CheckpointLastBlock = Omit<CheckpointLastBlockData, 'txs'> & {
    /** The proposer's signature over the block data (separate from checkpoint signature) */
    signature: Signature;
    /** The signed transactions in the last block (optional, for DA guarantees) */
    signedTxs?: SignedTxs;
};
/**
 * A checkpoint proposal is created by the leader of the chain for the last block in a checkpoint.
 * It includes the aggregated checkpoint header that validators will attest to, plus optionally
 * the last block's info for nodes to re-execute. This marks the completion of a slot's worth of blocks.
 */
export declare class CheckpointProposal extends Gossipable {
    /** The aggregated checkpoint header for consensus */
    readonly checkpointHeader: CheckpointHeader;
    /** Archive root after this checkpoint is applied */
    readonly archive: Fr;
    /** The fee asset price modifier in basis points (from oracle) */
    readonly feeAssetPriceModifier: bigint;
    /** The proposer's signature over the checkpoint payload (checkpointHeader + archive + feeAssetPriceModifier) */
    readonly signature: Signature;
    /** Optional last block info, including its own signature for BlockProposal extraction */
    readonly lastBlock?: CheckpointLastBlock | undefined;
    static p2pTopic: TopicType;
    private sender;
    constructor(
    /** The aggregated checkpoint header for consensus */
    checkpointHeader: CheckpointHeader, 
    /** Archive root after this checkpoint is applied */
    archive: Fr, 
    /** The fee asset price modifier in basis points (from oracle) */
    feeAssetPriceModifier: bigint, 
    /** The proposer's signature over the checkpoint payload (checkpointHeader + archive + feeAssetPriceModifier) */
    signature: Signature, 
    /** Optional last block info, including its own signature for BlockProposal extraction */
    lastBlock?: CheckpointLastBlock | undefined);
    generateP2PMessageIdentifier(): Promise<Buffer32>;
    get slotNumber(): SlotNumber;
    get blockNumber(): BlockNumber;
    /** Convenience getter for txHashes from lastBlock */
    get txHashes(): TxHash[];
    /** Convenience getter for txs from lastBlock */
    get txs(): Tx[] | undefined;
    /**
     * Extract a BlockProposal from the last block info.
     * Uses inHash from checkpointHeader.contentCommitment.inHash
     */
    getBlockProposal(): BlockProposal | undefined;
    toBlockInfo(): Omit<L2BlockInfo, 'blockNumber'>;
    toCheckpointInfo(): {
        slotNumber: SlotNumber;
        archive: Fr;
        lastBlockNumber: BlockNumber | undefined;
        lastBlockIndex: IndexWithinCheckpoint | undefined;
        blockHeadersHash: Fr;
    };
    /**
     * Get the payload to sign for this checkpoint proposal.
     * The signature is over the checkpoint header + archive root + feeAssetPriceModifier (for consensus).
     */
    getPayloadToSign(domainSeparator: SignatureDomainSeparator): Buffer;
    static createProposalFromSigner(checkpointHeader: CheckpointHeader, archiveRoot: Fr, feeAssetPriceModifier: bigint, lastBlockInfo: CheckpointLastBlockData | undefined, payloadSigner: (payload: Buffer32, context: SigningContext) => Promise<Signature>): Promise<CheckpointProposal>;
    /**
     * Lazily evaluate the sender of the proposal; result is cached.
     * If there's a lastBlock, also verifies the block proposal sender matches the checkpoint sender.
     * @returns The sender address, or undefined if signature recovery fails or senders don't match
     */
    getSender(): EthAddress | undefined;
    getPayload(): Buffer<ArrayBufferLike>;
    toBuffer(): Buffer;
    static fromBuffer(buf: Buffer | BufferReader): CheckpointProposal;
    getSize(): number;
    static empty(): CheckpointProposal;
    static random(): CheckpointProposal;
    toInspect(): {
        checkpointHeader: {
            lastArchive: `0x${string}`;
            blockHeadersHash: `0x${string}`;
            blobsHash: `0x${string}`;
            inHash: `0x${string}`;
            epochOutHash: `0x${string}`;
            slotNumber: SlotNumber;
            timestamp: bigint;
            coinbase: `0x${string}`;
            feeRecipient: `0x${string}`;
            gasFees: {
                feePerDaGas: bigint;
                feePerL2Gas: bigint;
            };
            totalManaUsed: bigint;
        };
        archive: `0x${string}`;
        signature: `0x${string}`;
        feeAssetPriceModifier: string;
        lastBlock: {
            blockHeader: {
                lastArchive: `0x${string}`;
                state: {
                    l1ToL2MessageTree: `0x${string}`;
                    noteHashTree: `0x${string}`;
                    nullifierTree: `0x${string}`;
                    publicDataTree: `0x${string}`;
                };
                spongeBlobHash: bigint;
                globalVariables: {
                    chainId: number;
                    version: number;
                    blockNumber: BlockNumber;
                    slotNumber: SlotNumber;
                    timestamp: bigint;
                    coinbase: `0x${string}`;
                    feeRecipient: `0x${string}`;
                    feePerDaGas: number;
                    feePerL2Gas: number;
                };
                totalFees: bigint;
                totalManaUsed: bigint;
            };
            indexWithinCheckpoint: IndexWithinCheckpoint;
            txHashes: `0x${string}`[];
            signature: `0x${string}`;
        } | undefined;
    };
    /**
     * Returns a copy of this proposal without lastBlock info, as a CheckpointProposalCore.
     * Used when the lastBlock has been extracted and stored separately.
     */
    toCore(): CheckpointProposalCore;
}
/**
 * A checkpoint proposal without the lastBlock info.
 * Used when the lastBlock has been extracted and handled separately as a BlockProposal.
 * This type makes it clear that lastBlock and getBlockProposal() are not available.
 */
export type CheckpointProposalCore = Omit<CheckpointProposal, 'lastBlock' | 'getBlockProposal' | 'toCore'>;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2twb2ludF9wcm9wb3NhbC5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3AycC9jaGVja3BvaW50X3Byb3Bvc2FsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxXQUFXLEVBQUUscUJBQXFCLEVBQUUsVUFBVSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDakcsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBR3BELE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNwRCxPQUFPLEtBQUssRUFBRSxVQUFVLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDNUQsT0FBTyxFQUFFLFlBQVksRUFBNEMsTUFBTSw2QkFBNkIsQ0FBQztBQUNyRyxPQUFPLEVBQVksS0FBSyxjQUFjLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUVqRixPQUFPLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUU3RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNsRSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDcEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hDLE9BQU8sS0FBSyxFQUFFLEVBQUUsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN0QyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzdDLE9BQU8sRUFDTCx3QkFBd0IsRUFHekIsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDNUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFN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