import { Buffer32 } from '@aztec/foundation/buffer';
import { keccak256 } from '@aztec/foundation/crypto/keccak';
import { tryRecoverAddress } from '@aztec/foundation/crypto/secp256k1-signer';
import { Signature } from '@aztec/foundation/eth-signature';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { z } from 'zod';
import { CheckpointProposal } from './checkpoint_proposal.js';
import { ConsensusPayload } from './consensus_payload.js';
import { Gossipable } from './gossipable.js';
import { SignatureDomainSeparator, getHashedSignaturePayloadEthSignedMessage } from './signature_utils.js';
import { TopicType } from './topic_type.js';
export class CheckpointAttestationHash extends Buffer32 {
    constructor(hash){
        super(hash);
    }
}
/**
 * CheckpointAttestation
 *
 * A validator that has attested to seeing all blocks in a checkpoint
 * will produce a checkpoint attestation over the checkpoint header.
 */ export class CheckpointAttestation extends Gossipable {
    payload;
    signature;
    proposerSignature;
    static p2pTopic = TopicType.checkpoint_attestation;
    sender;
    proposer;
    constructor(/** The payload of the message, and what the signature is over */ payload, /** The signature of the checkpoint attester */ signature, /** The signature from the checkpoint proposer */ proposerSignature){
        super(), this.payload = payload, this.signature = signature, this.proposerSignature = proposerSignature;
    }
    static get schema() {
        return z.object({
            payload: ConsensusPayload.schema,
            signature: Signature.schema,
            proposerSignature: Signature.schema
        }).transform((obj)=>new CheckpointAttestation(obj.payload, obj.signature, obj.proposerSignature));
    }
    generateP2PMessageIdentifier() {
        return Promise.resolve(new CheckpointAttestationHash(keccak256(this.signature.toBuffer())));
    }
    get archive() {
        return this.payload.archive;
    }
    get slotNumber() {
        return this.payload.header.slotNumber;
    }
    /**
   * Lazily evaluate and cache the signer of the attestation
   * @returns The signer of the attestation, or undefined if signature recovery fails
   */ getSender() {
        if (!this.sender) {
            // Recover the sender from the attestation
            const hashed = getHashedSignaturePayloadEthSignedMessage(this.payload, SignatureDomainSeparator.checkpointAttestation);
            // Cache the sender for later use
            this.sender = tryRecoverAddress(hashed, this.signature);
        }
        return this.sender;
    }
    /**
   * Lazily evaluate and cache the proposer of the checkpoint
   * @returns The proposer of the checkpoint
   */ getProposer() {
        if (!this.proposer) {
            // Create a temporary CheckpointProposal to recover the proposer address.
            // We need to use CheckpointProposal because it has a different getPayloadToSign()
            // implementation than ConsensusPayload (uses serializeToBuffer vs ABI encoding).
            const proposal = new CheckpointProposal(this.payload.header, this.payload.archive, this.payload.feeAssetPriceModifier, this.proposerSignature);
            // Cache the proposer for later use
            this.proposer = proposal.getSender();
        }
        return this.proposer;
    }
    getPayload() {
        return this.payload.getPayloadToSign(SignatureDomainSeparator.checkpointAttestation);
    }
    toBuffer() {
        return serializeToBuffer([
            this.payload,
            this.signature,
            this.proposerSignature
        ]);
    }
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        return new CheckpointAttestation(reader.readObject(ConsensusPayload), reader.readObject(Signature), reader.readObject(Signature));
    }
    static empty() {
        return new CheckpointAttestation(ConsensusPayload.empty(), Signature.empty(), Signature.empty());
    }
    static random() {
        return new CheckpointAttestation(ConsensusPayload.random(), Signature.random(), Signature.random());
    }
    getSize() {
        return this.payload.getSize() + this.signature.getSize() + this.proposerSignature.getSize();
    }
    toInspect() {
        return {
            payload: this.payload.toInspect(),
            signature: this.signature.toString(),
            proposerSignature: this.proposerSignature.toString()
        };
    }
}
