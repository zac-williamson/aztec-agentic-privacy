/* eslint-disable camelcase */ import { createLogger } from '@aztec/foundation/log';
import { schemas, zodFor } from '@aztec/foundation/schemas';
import { inflate } from 'pako';
import { z } from 'zod';
import { FunctionSelector } from './function_selector.js';
const logger = createLogger('aztec:foundation:abi');
export const AbiValueSchema = z.discriminatedUnion('kind', [
    z.object({
        kind: z.literal('boolean'),
        value: z.boolean()
    }),
    z.object({
        kind: z.literal('string'),
        value: z.string()
    }),
    z.object({
        kind: z.literal('array'),
        value: z.array(z.lazy(()=>AbiValueSchema))
    }),
    z.object({
        kind: z.literal('tuple'),
        fields: z.array(z.lazy(()=>AbiValueSchema))
    }),
    z.object({
        kind: z.literal('integer'),
        value: z.string(),
        sign: z.boolean()
    }),
    z.object({
        kind: z.literal('struct'),
        fields: z.array(z.object({
            name: z.string(),
            value: z.lazy(()=>AbiValueSchema)
        }))
    })
]);
/** Indicates whether a parameter is public or secret/private. */ export const ABIParameterVisibility = [
    'public',
    'private',
    'databus'
];
/** Sign for numeric types. */ const Sign = [
    'unsigned',
    'signed'
];
export const AbiTypeSchema = z.discriminatedUnion('kind', [
    z.object({
        kind: z.literal('field')
    }),
    z.object({
        kind: z.literal('boolean')
    }),
    z.object({
        kind: z.literal('integer'),
        sign: z.enum(Sign),
        width: z.number()
    }),
    z.object({
        kind: z.literal('array'),
        length: z.number(),
        type: z.lazy(()=>AbiTypeSchema)
    }),
    z.object({
        kind: z.literal('string'),
        length: z.number()
    }),
    z.object({
        kind: z.literal('struct'),
        fields: z.array(z.lazy(()=>ABIVariableSchema)),
        path: z.string()
    }),
    z.object({
        kind: z.literal('tuple'),
        fields: z.array(z.lazy(()=>AbiTypeSchema))
    })
]);
/** A named type. */ export const ABIVariableSchema = z.object({
    /** The name of the variable. */ name: z.string(),
    /** The type of the variable. */ type: AbiTypeSchema
});
/** A function parameter. */ export const ABIParameterSchema = ABIVariableSchema.and(z.object({
    /** Visibility of the parameter in the function. */ visibility: z.enum(ABIParameterVisibility)
}));
const AbiErrorTypeSchema = zodFor()(z.union([
    z.object({
        error_kind: z.literal('string'),
        string: z.string()
    }),
    z.object({
        error_kind: z.literal('fmtstring'),
        length: z.number(),
        item_types: z.array(AbiTypeSchema)
    }),
    z.object({
        error_kind: z.literal('custom')
    }).and(AbiTypeSchema)
]));
/** Aztec.nr function types. */ export var FunctionType = /*#__PURE__*/ function(FunctionType) {
    FunctionType["PRIVATE"] = "private";
    FunctionType["PUBLIC"] = "public";
    FunctionType["UTILITY"] = "utility";
    return FunctionType;
}({});
export const FunctionAbiSchema = z.object({
    name: z.string(),
    functionType: z.nativeEnum(FunctionType),
    isOnlySelf: z.boolean(),
    isStatic: z.boolean(),
    isInitializer: z.boolean(),
    parameters: z.array(z.object({
        name: z.string(),
        type: AbiTypeSchema,
        visibility: z.enum(ABIParameterVisibility)
    })),
    returnTypes: z.array(AbiTypeSchema),
    errorTypes: z.record(z.string(), AbiErrorTypeSchema.optional())
});
export const FunctionDebugMetadataSchema = z.object({
    debugSymbols: z.object({
        location_tree: z.object({
            locations: z.array(z.object({
                parent: z.number().nullable(),
                value: z.object({
                    span: z.object({
                        start: z.number(),
                        end: z.number()
                    }),
                    file: z.number()
                })
            }))
        }),
        acir_locations: z.record(z.number()),
        brillig_locations: z.record(z.record(z.number()))
    }),
    files: z.record(z.object({
        source: z.string(),
        path: z.string()
    }))
});
export const FunctionArtifactSchema = zodFor()(FunctionAbiSchema.and(z.object({
    bytecode: schemas.Buffer,
    verificationKey: z.string().optional(),
    debugSymbols: z.string(),
    debug: FunctionDebugMetadataSchema.optional()
})));
export const ContractArtifactSchema = zodFor()(z.object({
    name: z.string(),
    functions: z.array(FunctionArtifactSchema),
    nonDispatchPublicFunctions: z.array(FunctionAbiSchema),
    outputs: z.object({
        structs: z.record(z.array(AbiTypeSchema)).transform((structs)=>{
            for (const [key, value] of Object.entries(structs)){
                // We are manually ordering events and functions in the abi by path.
                // The path ordering is arbitrary, and only needed to ensure deterministic order.
                // These are the only arrays in the artifact with arbitrary order, and hence the only ones
                // we need to sort.
                if (key === 'events' || key === 'functions') {
                    structs[key] = value.sort((a, b)=>a.path > b.path ? -1 : 1);
                }
            }
            return structs;
        }),
        globals: z.record(z.array(AbiValueSchema))
    }),
    storageLayout: z.record(z.object({
        slot: schemas.Fr
    })),
    fileMap: z.record(z.coerce.number(), z.object({
        source: z.string(),
        path: z.string()
    }))
}));
export function getFunctionArtifactByName(artifact, functionName) {
    const functionArtifact = artifact.functions.find((f)=>f.name === functionName);
    if (!functionArtifact) {
        throw new Error(`Unknown function ${functionName}`);
    }
    const debugMetadata = getFunctionDebugMetadata(artifact, functionArtifact);
    return {
        ...functionArtifact,
        debug: debugMetadata
    };
}
/** Gets a function artifact including debug metadata given its name or selector. */ export async function getFunctionArtifact(artifact, functionNameOrSelector) {
    let functionArtifact;
    if (typeof functionNameOrSelector === 'string') {
        functionArtifact = artifact.functions.find((f)=>f.name === functionNameOrSelector);
    } else {
        const functionsAndSelectors = await Promise.all(artifact.functions.map(async (fn)=>({
                fn,
                selector: await FunctionSelector.fromNameAndParameters(fn.name, fn.parameters)
            })));
        functionArtifact = functionsAndSelectors.find((fnAndSelector)=>functionNameOrSelector.equals(fnAndSelector.selector))?.fn;
    }
    if (!functionArtifact) {
        throw new Error(`Unknown function ${functionNameOrSelector}`);
    }
    const debugMetadata = getFunctionDebugMetadata(artifact, functionArtifact);
    return {
        ...functionArtifact,
        debug: debugMetadata,
        contractName: artifact.name
    };
}
/** Gets all function abis */ export function getAllFunctionAbis(artifact) {
    return artifact.functions.map((f)=>f).concat(artifact.nonDispatchPublicFunctions || []);
}
export function parseDebugSymbols(debugSymbols) {
    return JSON.parse(inflate(Buffer.from(debugSymbols, 'base64'), {
        to: 'string',
        raw: true
    })).debug_infos;
}
/**
 * Gets the debug metadata of a given function from the contract artifact
 * @param artifact - The contract build artifact
 * @param functionName - The name of the function
 * @returns The debug metadata of the function
 */ export function getFunctionDebugMetadata(contractArtifact, functionArtifact) {
    try {
        if (functionArtifact.debugSymbols && contractArtifact.fileMap) {
            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/10546) investigate why debugMetadata is so big for some tests.
            const programDebugSymbols = parseDebugSymbols(functionArtifact.debugSymbols);
            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/5813)
            // We only support handling debug info for the contract function entry point.
            // So for now we simply index into the first debug info.
            return {
                debugSymbols: programDebugSymbols[0],
                files: contractArtifact.fileMap
            };
        }
    } catch (err) {
        if (err instanceof RangeError && err.message.includes('Invalid string length')) {
            logger.warn(`Caught RangeError: Invalid string length. This suggests the debug_symbols field of the contract ${contractArtifact.name} and function ${functionArtifact.name} is huge; too big to parse. We'll skip returning this info until this issue is resolved. Here's the error:\n${err.message}`);
        // We'll return undefined.
        } else {
            // Rethrow unexpected errors
            throw err;
        }
    }
    return undefined;
}
/**
 * Returns an initializer from the contract, assuming there is at least one. If there are multiple initializers,
 * it returns the one named "constructor" or "initializer"; if there is none with that name, it returns the first
 * initializer it finds, prioritizing initializers with no arguments and then private ones.
 * @param contractArtifact - The contract artifact.
 * @returns An initializer function, or none if there are no functions flagged as initializers in the contract.
 */ export function getDefaultInitializer(contractArtifact) {
    const functionAbis = getAllFunctionAbis(contractArtifact);
    const initializers = functionAbis.filter((f)=>f.isInitializer);
    return initializers.length > 1 ? initializers.find((f)=>f.name === 'constructor') ?? initializers.find((f)=>f.name === 'initializer') ?? initializers.find((f)=>f.parameters?.length === 0) ?? initializers.find((f)=>f.functionType === "private") ?? initializers[0] : initializers[0];
}
/**
 * Returns an initializer from the contract.
 * @param initializerNameOrArtifact - The name of the constructor, or the artifact of the constructor, or undefined
 * to pick the default initializer.
 */ export function getInitializer(contract, initializerNameOrArtifact) {
    if (typeof initializerNameOrArtifact === 'string') {
        const functionAbis = getAllFunctionAbis(contract);
        const found = functionAbis.find((f)=>f.name === initializerNameOrArtifact);
        if (!found) {
            throw new Error(`Constructor method ${initializerNameOrArtifact} not found in contract artifact`);
        } else if (!found.isInitializer) {
            throw new Error(`Method ${initializerNameOrArtifact} is not an initializer`);
        }
        return found;
    } else if (initializerNameOrArtifact === undefined) {
        return getDefaultInitializer(contract);
    } else {
        if (!initializerNameOrArtifact.isInitializer) {
            throw new Error(`Method ${initializerNameOrArtifact.name} is not an initializer`);
        }
        return initializerNameOrArtifact;
    }
}
export function emptyFunctionAbi() {
    return {
        name: '',
        functionType: "private",
        isOnlySelf: false,
        isStatic: false,
        parameters: [],
        returnTypes: [],
        errorTypes: {},
        isInitializer: false
    };
}
export function emptyFunctionArtifact() {
    const abi = emptyFunctionAbi();
    return {
        ...abi,
        bytecode: Buffer.from([]),
        debugSymbols: ''
    };
}
export function emptyContractArtifact() {
    return {
        name: '',
        functions: [
            emptyFunctionArtifact()
        ],
        nonDispatchPublicFunctions: [
            emptyFunctionAbi()
        ],
        outputs: {
            structs: {},
            globals: {}
        },
        storageLayout: {},
        fileMap: {}
    };
}
