import { toBigIntBE, toBufferBE } from '@aztec/foundation/bigint-buffer';
import { poseidon2Hash } from '@aztec/foundation/crypto/poseidon';
import { Fr } from '@aztec/foundation/curves/bn254';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { z } from 'zod';
/**
 * Class containing the data of a preimage of a single leaf in the public data tree.
 * Note: It's called preimage because this data gets hashed before being inserted as a node into the `IndexedTree`.
 */ export class PublicDataTreeLeafPreimage {
    leaf;
    nextKey;
    nextIndex;
    constructor(/**
     * The leaf (slot, value).
     */ leaf, /**
     * Next key (slot) inside the indexed tree's linked list.
     */ nextKey, /**
     * Index of the next leaf in the indexed tree's linked list.
     */ nextIndex){
        this.leaf = leaf;
        this.nextKey = nextKey;
        this.nextIndex = nextIndex;
    }
    static get schema() {
        return z.object({
            leaf: PublicDataTreeLeaf.schema,
            nextKey: schemas.Fr,
            nextIndex: schemas.BigInt
        }).transform(({ leaf, nextKey, nextIndex })=>new PublicDataTreeLeafPreimage(leaf, nextKey, nextIndex));
    }
    /**
   * Creates a PublicDataTreeLeafPreimage from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing PublicDataTreeLeafPreimage fields
   * @returns A PublicDataTreeLeafPreimage instance
   */ static fromPlainObject(obj) {
        if (obj instanceof PublicDataTreeLeafPreimage) {
            return obj;
        }
        return new PublicDataTreeLeafPreimage(PublicDataTreeLeaf.fromPlainObject(obj.leaf), Fr.fromPlainObject(obj.nextKey), typeof obj.nextIndex === 'bigint' ? obj.nextIndex : BigInt(obj.nextIndex));
    }
    static get leafSchema() {
        return PublicDataTreeLeaf.schema;
    }
    getKey() {
        return this.leaf.getKey();
    }
    getNextKey() {
        return this.nextKey.toBigInt();
    }
    getNextIndex() {
        return this.nextIndex;
    }
    asLeaf() {
        return this.leaf;
    }
    toBuffer() {
        return Buffer.concat(this.toHashInputs());
    }
    toHashInputs() {
        return [
            ...this.leaf.toHashInputs(),
            Buffer.from(this.nextKey.toBuffer()),
            Buffer.from(toBufferBE(this.nextIndex, 32))
        ];
    }
    hash() {
        return poseidon2Hash(this.toHashInputs());
    }
    clone() {
        return new PublicDataTreeLeafPreimage(this.leaf.clone(), this.nextKey, this.nextIndex);
    }
    static random() {
        return new PublicDataTreeLeafPreimage(PublicDataTreeLeaf.buildDummy(BigInt(Math.floor(Math.random() * 1000))), Fr.random(), BigInt(Math.floor(Math.random() * 1000)));
    }
    static empty() {
        return new PublicDataTreeLeafPreimage(PublicDataTreeLeaf.empty(), Fr.ZERO, 0n);
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PublicDataTreeLeafPreimage(PublicDataTreeLeaf.fromBuffer(reader), Fr.fromBuffer(reader), toBigIntBE(reader.readBytes(32)));
    }
    static fromLeaf(leaf, nextKey, nextIndex) {
        return new PublicDataTreeLeafPreimage(leaf, new Fr(nextKey), nextIndex);
    }
    static clone(preimage) {
        return preimage.clone();
    }
}
/**
 * A leaf in the public data indexed tree.
 */ export class PublicDataTreeLeaf {
    slot;
    value;
    constructor(/**
     * The slot the value is stored in
     */ slot, /**
     * The value stored in the slot
     */ value){
        this.slot = slot;
        this.value = value;
    }
    getKey() {
        return this.slot.toBigInt();
    }
    toBuffer() {
        return serializeToBuffer([
            this.slot,
            this.value
        ]);
    }
    clone() {
        return new PublicDataTreeLeaf(this.slot, this.value);
    }
    toHashInputs() {
        return [
            this.slot.toBuffer(),
            this.value.toBuffer()
        ];
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PublicDataTreeLeaf(Fr.fromBuffer(reader), Fr.fromBuffer(reader));
    }
    equals(another) {
        return this.slot.equals(another.slot) && this.value.equals(another.value);
    }
    toString() {
        return `PublicDataTreeLeaf(${this.slot.toString()}, ${this.value.toString()})`;
    }
    isEmpty() {
        return this.slot.isZero() && this.value.isZero();
    }
    updateTo(another) {
        if (!this.slot.equals(another.slot)) {
            throw new Error('Invalid update: slots do not match');
        }
        return new PublicDataTreeLeaf(this.slot, another.value);
    }
    static buildDummy(key) {
        return new PublicDataTreeLeaf(new Fr(key), new Fr(0));
    }
    static empty() {
        return new PublicDataTreeLeaf(Fr.ZERO, Fr.ZERO);
    }
    static get schema() {
        return z.object({
            slot: schemas.Fr,
            value: schemas.Fr
        }).transform(({ slot, value })=>new PublicDataTreeLeaf(slot, value));
    }
    /**
   * Creates a PublicDataTreeLeaf from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing PublicDataTreeLeaf fields
   * @returns A PublicDataTreeLeaf instance
   */ static fromPlainObject(obj) {
        if (obj instanceof PublicDataTreeLeaf) {
            return obj;
        }
        return new PublicDataTreeLeaf(Fr.fromPlainObject(obj.slot), Fr.fromPlainObject(obj.value));
    }
}
