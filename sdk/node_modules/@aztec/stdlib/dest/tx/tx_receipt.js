import { BlockNumberSchema } from '@aztec/foundation/branded-types';
import { z } from 'zod';
import { RevertCode } from '../avm/revert_code.js';
import { BlockHash } from '../block/block_hash.js';
import { schemas } from '../schemas/schemas.js';
import { TxHash } from './tx_hash.js';
/** Block inclusion/finalization status. */ export var TxStatus = /*#__PURE__*/ function(TxStatus) {
    TxStatus["DROPPED"] = "dropped";
    TxStatus["PENDING"] = "pending";
    TxStatus["PROPOSED"] = "proposed";
    TxStatus["CHECKPOINTED"] = "checkpointed";
    TxStatus["PROVEN"] = "proven";
    TxStatus["FINALIZED"] = "finalized";
    return TxStatus;
}({});
/** Tx status sorted by finalization progress. */ export const SortedTxStatuses = [
    "dropped",
    "pending",
    "proposed",
    "checkpointed",
    "proven",
    "finalized"
];
/** Execution result - only set when tx is in a block. */ export var TxExecutionResult = /*#__PURE__*/ function(TxExecutionResult) {
    TxExecutionResult["SUCCESS"] = "success";
    TxExecutionResult["APP_LOGIC_REVERTED"] = "app_logic_reverted";
    TxExecutionResult["TEARDOWN_REVERTED"] = "teardown_reverted";
    TxExecutionResult["BOTH_REVERTED"] = "both_reverted";
    return TxExecutionResult;
}({});
/**
 * Represents a transaction receipt in the Aztec network.
 * Contains essential information about the transaction including its status, origin, and associated addresses.
 * REFACTOR: TxReceipt should be returned only once the tx is mined, and all its fields should be required.
 * We should not be using a TxReceipt to answer a query for a pending or dropped tx.
 */ export class TxReceipt {
    txHash;
    status;
    executionResult;
    error;
    transactionFee;
    blockHash;
    blockNumber;
    constructor(/** A unique identifier for a transaction. */ txHash, /** The transaction's block finalization status. */ status, /** The execution result of the transaction, only set when tx is in a block. */ executionResult, /** Description of transaction error, if any. */ error, /** The transaction fee paid for the transaction. */ transactionFee, /** The hash of the block containing the transaction. */ blockHash, /** The block number in which the transaction was included. */ blockNumber){
        this.txHash = txHash;
        this.status = status;
        this.executionResult = executionResult;
        this.error = error;
        this.transactionFee = transactionFee;
        this.blockHash = blockHash;
        this.blockNumber = blockNumber;
    }
    /** Returns true if the transaction was executed successfully. */ hasExecutionSucceeded() {
        return this.executionResult === "success";
    }
    /** Returns true if the transaction execution reverted. */ hasExecutionReverted() {
        return this.executionResult !== undefined && this.executionResult !== "success";
    }
    /** Returns true if the transaction has been included in a block (proposed, checkpointed, proven, or finalized). */ isMined() {
        return this.status === "proposed" || this.status === "checkpointed" || this.status === "proven" || this.status === "finalized";
    }
    /** Returns true if the transaction is pending. */ isPending() {
        return this.status === "pending";
    }
    /** Returns true if the transaction was dropped. */ isDropped() {
        return this.status === "dropped";
    }
    static empty() {
        return new TxReceipt(TxHash.zero(), "dropped", undefined, undefined);
    }
    static get schema() {
        return z.object({
            txHash: TxHash.schema,
            status: z.nativeEnum(TxStatus),
            executionResult: z.nativeEnum(TxExecutionResult).optional(),
            error: z.string().optional(),
            blockHash: BlockHash.schema.optional(),
            blockNumber: BlockNumberSchema.optional(),
            transactionFee: schemas.BigInt.optional()
        }).transform((fields)=>TxReceipt.from(fields));
    }
    static from(fields) {
        return new TxReceipt(fields.txHash, fields.status, fields.executionResult, fields.error, fields.transactionFee, fields.blockHash, fields.blockNumber);
    }
    static executionResultFromRevertCode(revertCode) {
        if (revertCode.equals(RevertCode.OK)) {
            return "success";
        } else if (revertCode.equals(RevertCode.APP_LOGIC_REVERTED)) {
            return "app_logic_reverted";
        } else if (revertCode.equals(RevertCode.TEARDOWN_REVERTED)) {
            return "teardown_reverted";
        } else if (revertCode.equals(RevertCode.BOTH_REVERTED)) {
            return "both_reverted";
        } else {
            throw new Error(`Unknown revert code: ${revertCode.getCode()}`);
        }
    }
}
