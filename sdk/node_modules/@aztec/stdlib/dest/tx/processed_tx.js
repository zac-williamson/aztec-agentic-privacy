import { RevertCode } from '../avm/revert_code.js';
import { SimulationError } from '../errors/simulation_error.js';
import { Gas } from '../gas/gas.js';
import { computeL2ToL1MessageHash } from '../hash/hash.js';
import { TxEffect } from './tx_effect.js';
export var TxExecutionPhase = /*#__PURE__*/ function(TxExecutionPhase) {
    TxExecutionPhase[TxExecutionPhase["SETUP"] = 0] = "SETUP";
    TxExecutionPhase[TxExecutionPhase["APP_LOGIC"] = 1] = "APP_LOGIC";
    TxExecutionPhase[TxExecutionPhase["TEARDOWN"] = 2] = "TEARDOWN";
    return TxExecutionPhase;
}({});
export function makeProcessedTxFromPrivateOnlyTx(tx, transactionFee, feePaymentPublicDataWrite, globalVariables) {
    const data = tx.data.forRollup;
    const txEffect = new TxEffect(RevertCode.OK, tx.getTxHash(), transactionFee, data.end.noteHashes.filter((h)=>!h.isZero()), data.end.nullifiers.filter((h)=>!h.isZero()), data.end.l2ToL1Msgs.filter((msg)=>!msg.contractAddress.isZero()).map((msg)=>computeL2ToL1MessageHash({
            l2Sender: msg.contractAddress,
            l1Recipient: msg.message.recipient,
            content: msg.message.content,
            rollupVersion: globalVariables.version,
            chainId: globalVariables.chainId
        })), [
        feePaymentPublicDataWrite
    ], data.end.privateLogs.filter((l)=>!l.isEmpty()), [], tx.getContractClassLogs());
    const gasUsed = {
        // Billed gas is the same as total gas since there is no teardown execution
        totalGas: tx.data.gasUsed,
        billedGas: tx.data.gasUsed,
        teardownGas: Gas.empty(),
        publicGas: Gas.empty()
    };
    return {
        hash: txEffect.txHash,
        data: tx.data,
        chonkProof: tx.chonkProof,
        avmProvingRequest: undefined,
        globalVariables,
        txEffect,
        gasUsed,
        revertCode: RevertCode.OK,
        revertReason: undefined
    };
}
export function makeProcessedTxFromTxWithPublicCalls(tx, globalVariables, avmProvingRequest, publicTxEffect, gasUsed, revertCode, revertReason) {
    const privateLogs = [
        ...tx.data.forPublic.nonRevertibleAccumulatedData.privateLogs,
        ...revertCode.isOK() ? tx.data.forPublic.revertibleAccumulatedData.privateLogs : []
    ].filter((l)=>!l.isEmpty());
    const contractClassLogs = revertCode.isOK() ? tx.getContractClassLogs() : tx.getSplitContractClassLogs(false);
    const txEffect = new TxEffect(revertCode, tx.getTxHash(), publicTxEffect.transactionFee, publicTxEffect.noteHashes, publicTxEffect.nullifiers, publicTxEffect.l2ToL1Msgs // convert messages to hashes.
    .filter((msg)=>!msg.contractAddress.isZero()).map((msg)=>computeL2ToL1MessageHash({
            l2Sender: msg.contractAddress,
            l1Recipient: msg.message.recipient,
            content: msg.message.content,
            rollupVersion: globalVariables.version,
            chainId: globalVariables.chainId
        })), publicTxEffect.publicDataWrites, privateLogs, publicTxEffect.publicLogs, contractClassLogs);
    // Some callers expect a revert reason if the tx reverted.
    const finalRevertReason = revertReason === undefined && !revertCode.isOK() ? new SimulationError('TX reverted', /*functionErrorStack=*/ [], /*revertData=*/ []) : revertReason;
    return {
        hash: txEffect.txHash,
        data: tx.data,
        chonkProof: tx.chonkProof,
        avmProvingRequest,
        globalVariables,
        txEffect,
        gasUsed,
        revertCode,
        revertReason: finalRevertReason
    };
}
