import { timesParallel } from '@aztec/foundation/collection';
import { randomBytes, randomInt } from '@aztec/foundation/crypto/random';
import { Fr } from '@aztec/foundation/curves/bn254';
import { z } from 'zod';
import { NoteSelector } from '../abi/note_selector.js';
import { PrivateCircuitPublicInputs } from '../kernel/private_circuit_public_inputs.js';
import { sortByCounter } from '../kernel/utils/order_and_comparison.js';
import { ContractClassLog } from '../logs/contract_class_log.js';
import { PreTagSchema } from '../logs/pre_tag.js';
import { Note } from '../note/note.js';
import { mapSchema, schemas } from '../schemas/index.js';
import { HashedValues } from './hashed_values.js';
/**
 * The contents of a new note.
 */ export class NoteAndSlot {
    note;
    storageSlot;
    randomness;
    noteTypeId;
    constructor(/** The note. */ note, /** The storage slot of the note. */ storageSlot, /** The randomness injected to the note. */ randomness, /** The note type identifier. */ noteTypeId){
        this.note = note;
        this.storageSlot = storageSlot;
        this.randomness = randomness;
        this.noteTypeId = noteTypeId;
    }
    static get schema() {
        return z.object({
            note: Note.schema,
            storageSlot: schemas.Fr,
            randomness: schemas.Fr,
            noteTypeId: schemas.NoteSelector
        }).transform(NoteAndSlot.from);
    }
    static from(fields) {
        return new NoteAndSlot(fields.note, fields.storageSlot, fields.randomness, fields.noteTypeId);
    }
    static random() {
        return new NoteAndSlot(Note.random(), Fr.random(), Fr.random(), NoteSelector.random());
    }
}
export class CountedContractClassLog {
    log;
    counter;
    constructor(log, counter){
        this.log = log;
        this.counter = counter;
    }
    static get schema() {
        return z.object({
            log: ContractClassLog.schema,
            counter: schemas.Integer
        }).transform(CountedContractClassLog.from);
    }
    static from(fields) {
        return new CountedContractClassLog(fields.log, fields.counter);
    }
    isEmpty() {
        return this.log.isEmpty() && !this.counter;
    }
}
export class PrivateExecutionResult {
    entrypoint;
    firstNullifier;
    publicFunctionCalldata;
    constructor(entrypoint, /** The first non-revertible nullifier emitted by any private call, or the protocol nullifier if there was none. */ firstNullifier, /** An array of calldata for the enqueued public function calls and the teardown function call. */ publicFunctionCalldata){
        this.entrypoint = entrypoint;
        this.firstNullifier = firstNullifier;
        this.publicFunctionCalldata = publicFunctionCalldata;
    }
    static get schema() {
        return z.object({
            entrypoint: PrivateCallExecutionResult.schema,
            firstNullifier: schemas.Fr,
            publicFunctionCalldata: z.array(HashedValues.schema)
        }).transform(PrivateExecutionResult.from);
    }
    static from(fields) {
        return new PrivateExecutionResult(fields.entrypoint, fields.firstNullifier, fields.publicFunctionCalldata);
    }
    static async random(nested = 1) {
        return new PrivateExecutionResult(await PrivateCallExecutionResult.random(nested), Fr.random(), [
            HashedValues.random(),
            HashedValues.random()
        ]);
    }
    /**
   * The anchor block number that this execution was simulated with.
   */ getSimulationAnchorBlockNumber() {
        return this.entrypoint.publicInputs.anchorBlockHeader.globalVariables.blockNumber;
    }
}
/**
 * The result of executing a call to a private function.
 */ export class PrivateCallExecutionResult {
    acir;
    vk;
    partialWitness;
    publicInputs;
    newNotes;
    noteHashNullifierCounterMap;
    returnValues;
    offchainEffects;
    preTags;
    nestedExecutionResults;
    contractClassLogs;
    profileResult;
    constructor(// Needed for prover
    /** The ACIR bytecode. */ acir, /** The verification key. */ vk, /** The partial witness. */ partialWitness, // Needed for the verifier (kernel)
    /** The call stack item. */ publicInputs, /** The notes created in the executed function. */ newNotes, /** Mapping of note hash counter to the counter of its nullifier. */ noteHashNullifierCounterMap, /** The raw return values of the executed function. */ returnValues, /** The offchain effects emitted during execution of this function call via the `emit_offchain_effect` oracle. */ offchainEffects, /** The pre-tags used in this tx to compute tags for private logs */ preTags, /** The nested executions. */ nestedExecutionResults, /**
     * Contract class logs emitted during execution of this function call.
     * Note: We only need to collect the ContractClassLogFields as preimages for the tx.
     * But keep them as ContractClassLog so that we can verify the log hashes before submitting the tx (TODO).
     */ contractClassLogs, profileResult){
        this.acir = acir;
        this.vk = vk;
        this.partialWitness = partialWitness;
        this.publicInputs = publicInputs;
        this.newNotes = newNotes;
        this.noteHashNullifierCounterMap = noteHashNullifierCounterMap;
        this.returnValues = returnValues;
        this.offchainEffects = offchainEffects;
        this.preTags = preTags;
        this.nestedExecutionResults = nestedExecutionResults;
        this.contractClassLogs = contractClassLogs;
        this.profileResult = profileResult;
    }
    static get schema() {
        return z.object({
            acir: schemas.Buffer,
            vk: schemas.Buffer,
            partialWitness: mapSchema(z.coerce.number(), z.string()),
            publicInputs: PrivateCircuitPublicInputs.schema,
            newNotes: z.array(NoteAndSlot.schema),
            noteHashNullifierCounterMap: mapSchema(z.coerce.number(), z.number()),
            returnValues: z.array(schemas.Fr),
            offchainEffects: z.array(z.object({
                data: z.array(schemas.Fr)
            })),
            preTags: z.array(PreTagSchema),
            nestedExecutionResults: z.array(z.lazy(()=>PrivateCallExecutionResult.schema)),
            contractClassLogs: z.array(CountedContractClassLog.schema)
        }).transform(PrivateCallExecutionResult.from);
    }
    static from(fields) {
        return new PrivateCallExecutionResult(fields.acir, fields.vk, fields.partialWitness, fields.publicInputs, fields.newNotes, fields.noteHashNullifierCounterMap, fields.returnValues, fields.offchainEffects, fields.preTags, fields.nestedExecutionResults, fields.contractClassLogs);
    }
    static async random(nested = 1) {
        return new PrivateCallExecutionResult(randomBytes(4), randomBytes(4), new Map([
            [
                1,
                'one'
            ]
        ]), PrivateCircuitPublicInputs.empty(), [
            NoteAndSlot.random()
        ], new Map([
            [
                0,
                0
            ]
        ]), [
            Fr.random()
        ], [
            {
                data: [
                    Fr.random()
                ]
            }
        ], [], await timesParallel(nested, ()=>PrivateCallExecutionResult.random(0)), [
            new CountedContractClassLog(await ContractClassLog.random(), randomInt(10))
        ]);
    }
}
export function collectNoteHashNullifierCounterMap(execResult) {
    const accum = new Map();
    const collectNoteHashNullifierCounterMapRecursive = (callResult, accum)=>{
        callResult.noteHashNullifierCounterMap.forEach((value, key)=>accum.set(key, value));
        callResult.nestedExecutionResults.forEach((nested)=>collectNoteHashNullifierCounterMapRecursive(nested, accum));
    };
    collectNoteHashNullifierCounterMapRecursive(execResult.entrypoint, accum);
    return accum;
}
/**
 * Collect all contract class logs across all nested executions.
 * @param execResult - The topmost execution result.
 * @returns All contract class logs.
 */ function collectContractClassLogs(execResult) {
    return [
        execResult.contractClassLogs,
        ...execResult.nestedExecutionResults.flatMap(collectContractClassLogs)
    ].flat();
}
/**
 * Collect all contract class logs across all nested executions and sorts by counter.
 * @param execResult - The topmost execution result.
 * @returns All contract class logs.
 */ export function collectSortedContractClassLogs(execResult) {
    const allLogs = collectContractClassLogs(execResult.entrypoint);
    const sortedLogs = sortByCounter(allLogs);
    return sortedLogs.map((l)=>l.log.fields);
}
/**
 * Collect all offchain effects emitted across all nested executions.
 * @param execResult - The execution result to collect offchain effects from.
 * @returns Array of offchain effects.
 */ export function collectOffchainEffects(execResult) {
    const collectEffectsRecursive = (callResult)=>{
        return [
            ...callResult.offchainEffects.map((msg)=>({
                    ...msg,
                    contractAddress: callResult.publicInputs.callContext.contractAddress
                })),
            ...callResult.nestedExecutionResults.flatMap((nested)=>collectEffectsRecursive(nested))
        ];
    };
    return collectEffectsRecursive(execResult.entrypoint);
}
export function getFinalMinRevertibleSideEffectCounter(execResult) {
    const collectFinalMinRevertibleSideEffectCounterRecursive = (callResult)=>{
        return callResult.nestedExecutionResults.reduce((counter, exec)=>{
            const nestedCounter = collectFinalMinRevertibleSideEffectCounterRecursive(exec);
            return nestedCounter ? nestedCounter : counter;
        }, callResult.publicInputs.minRevertibleSideEffectCounter.toNumber());
    };
    return collectFinalMinRevertibleSideEffectCounterRecursive(execResult.entrypoint);
}
export function collectNested(executionStack, extractExecutionItems) {
    const thisExecutionReads = executionStack.flatMap(extractExecutionItems);
    return thisExecutionReads.concat(executionStack.flatMap(({ nestedExecutionResults })=>collectNested(nestedExecutionResults, extractExecutionItems)));
}
export class PrivateExecutionProfileResult {
    timings;
    constructor(timings){
        this.timings = timings;
    }
}
