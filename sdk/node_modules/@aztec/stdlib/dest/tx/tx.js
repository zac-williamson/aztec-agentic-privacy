import { Buffer32 } from '@aztec/foundation/buffer';
import { Fr } from '@aztec/foundation/curves/bn254';
import { BufferReader, serializeArrayOfBufferableToVector, serializeToBuffer } from '@aztec/foundation/serialize';
import { z } from 'zod';
import { PrivateKernelTailCircuitPublicInputs } from '../kernel/private_kernel_tail_circuit_public_inputs.js';
import { ContractClassLog, ContractClassLogFields } from '../logs/contract_class_log.js';
import { Gossipable } from '../p2p/gossipable.js';
import { TopicType } from '../p2p/topic_type.js';
import { ChonkProof } from '../proofs/chonk_proof.js';
import { HashedValues } from './hashed_values.js';
import { PublicCallRequestWithCalldata } from './public_call_request_with_calldata.js';
import { TxHash } from './tx_hash.js';
/**
 * The interface of an L2 transaction.
 */ // docs:start:tx_class
export class Tx extends Gossipable {
    txHash;
    data;
    chonkProof;
    contractClassLogFields;
    publicFunctionCalldata;
    static p2pTopic = TopicType.tx;
    calldataMap;
    constructor(/**
     * Identifier of the tx.
     * It's a hash of the public inputs of the tx's proof.
     * This claimed hash is reconciled against the tx's public inputs (`this.data`) in data_validator.ts.
     */ txHash, /**
     * Output of the private kernel circuit for this tx.
     */ data, /**
     * Proof from the private kernel circuit.
     */ chonkProof, /**
     * Contract class log fields emitted from the tx.
     * Their order should match the order of the log hashes returned from `this.data.getNonEmptyContractClassLogsHashes`.
     * This claimed data is reconciled against a hash of this data (that is contained within
     * the tx's public inputs (`this.data`)), in data_validator.ts.
     */ contractClassLogFields, /**
     * An array of calldata for the enqueued public function calls and the teardown function call.
     * This claimed data is reconciled against hashes of this data (that are contained within
     * the tx's public inputs (`this.data`)), in data_validator.ts.
     */ publicFunctionCalldata){
        super(), this.txHash = txHash, this.data = data, this.chonkProof = chonkProof, this.contractClassLogFields = contractClassLogFields, this.publicFunctionCalldata = publicFunctionCalldata;
    }
    // docs:end:tx_class
    // Gossipable method
    generateP2PMessageIdentifier() {
        return Promise.resolve(new Buffer32(this.getTxHash().toBuffer()));
    }
    hasPublicCalls() {
        return this.numberOfPublicCalls() > 0;
    }
    numberOfPublicCalls() {
        return this.data.numberOfPublicCallRequests();
    }
    getNonRevertiblePublicCallRequestsWithCalldata() {
        return this.data.getNonRevertiblePublicCallRequests().map((r)=>this.#combinePublicCallRequestWithCallData(r));
    }
    getRevertiblePublicCallRequestsWithCalldata() {
        return this.data.getRevertiblePublicCallRequests().map((r)=>this.#combinePublicCallRequestWithCallData(r));
    }
    getTeardownPublicCallRequestWithCalldata() {
        const request = this.data.getTeardownPublicCallRequest();
        return request ? this.#combinePublicCallRequestWithCallData(request) : undefined;
    }
    getPublicCallRequestsWithCalldata() {
        const teardown = this.data.getTeardownPublicCallRequest();
        const callRequests = [
            ...this.data.getNonRevertiblePublicCallRequests(),
            ...this.data.getRevertiblePublicCallRequests(),
            ...teardown ? [
                teardown
            ] : []
        ];
        return callRequests.map((r)=>this.#combinePublicCallRequestWithCallData(r));
    }
    getTotalPublicCalldataCount() {
        return this.publicFunctionCalldata.reduce((accum, cd)=>accum + cd.values.length, 0);
    }
    getGasSettings() {
        return this.data.constants.txContext.gasSettings;
    }
    /**
   * Deserializes the Tx object from a Buffer.
   * @param buffer - Buffer or BufferReader object to deserialize.
   * @returns An instance of Tx.
   */ static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new Tx(reader.readObject(TxHash), reader.readObject(PrivateKernelTailCircuitPublicInputs), reader.readObject(ChonkProof), reader.readVectorUint8Prefix(ContractClassLogFields), reader.readVectorUint8Prefix(HashedValues));
    }
    /**
   * Serializes the Tx object into a Buffer.
   * @returns Buffer representation of the Tx object.
   */ toBuffer() {
        return serializeToBuffer([
            this.txHash,
            this.data,
            this.chonkProof,
            serializeArrayOfBufferableToVector(this.contractClassLogFields, 1),
            serializeArrayOfBufferableToVector(this.publicFunctionCalldata, 1)
        ]);
    }
    static get schema() {
        return z.object({
            data: PrivateKernelTailCircuitPublicInputs.schema,
            chonkProof: ChonkProof.schema,
            contractClassLogFields: z.array(ContractClassLogFields.schema),
            publicFunctionCalldata: z.array(HashedValues.schema)
        }).transform(Tx.create);
    }
    static async computeTxHash(fields) {
        const hash = fields.data.forPublic ? await fields.data.toPrivateToPublicKernelCircuitPublicInputs().hash() : await fields.data.toPrivateToRollupKernelCircuitPublicInputs().hash();
        return new TxHash(hash);
    }
    static async create(fields) {
        const txHash = await Tx.computeTxHash(fields);
        return Tx.from({
            ...fields,
            txHash
        });
    }
    static from(fields) {
        return new Tx(fields.txHash, fields.data, fields.chonkProof, fields.contractClassLogFields, fields.publicFunctionCalldata);
    }
    /**
   * Validates that the tx hash matches the computed hash from the tx data.
   * This should be called when deserializing a tx from an untrusted source.
   * @returns true if the hash is valid, false otherwise
   */ async validateTxHash() {
        const expectedHash = await Tx.computeTxHash(this);
        return this.txHash.equals(expectedHash);
    }
    /**
   * Gets public logs emitted by this tx.
   * @param logsSource - An instance of `L2LogsSource` which can be used to obtain the logs.
   * @returns The requested logs.
   */ getPublicLogs(logsSource) {
        return logsSource.getPublicLogs({
            txHash: this.getTxHash()
        });
    }
    getContractClassLogs() {
        const logHashes = this.data.getNonEmptyContractClassLogsHashes();
        return logHashes.map((logHash, i)=>ContractClassLog.from({
                contractAddress: logHash.contractAddress,
                fields: this.contractClassLogFields[i],
                emittedLength: logHash.logHash.length
            }));
    }
    /**
   * Gets either revertible or non revertible contract class logs emitted by this tx.
   * @param revertible - true for revertible only logs, false for non revertible only logs.
   * @returns The requested logs.
   */ getSplitContractClassLogs(revertible) {
        if (!this.data.forPublic) {
            throw new Error('`getSplitContractClassLogs` should only be called on txs with public calls');
        }
        const contractClassLogs = this.getContractClassLogs();
        const numNonRevertible = this.data.forPublic.nonRevertibleAccumulatedData.contractClassLogsHashes.filter((h)=>!h.isEmpty()).length;
        return revertible ? contractClassLogs.slice(numNonRevertible) : contractClassLogs.slice(0, numNonRevertible);
    }
    /**
   * Return transaction hash.
   * @returns The hash of the public inputs of the private kernel tail circuit.
   */ getTxHash() {
        return this.txHash;
    }
    getCalldataMap() {
        if (!this.calldataMap) {
            const calldataMap = new Map();
            this.publicFunctionCalldata.forEach((cd)=>calldataMap.set(cd.hash.toString(), cd.values));
            this.calldataMap = calldataMap;
        }
        return this.calldataMap;
    }
    /** Returns stats about this tx. */ getStats() {
        return {
            txHash: this.txHash.toString(),
            noteHashCount: this.data.getNonEmptyNoteHashes().length,
            nullifierCount: this.data.getNonEmptyNullifiers().length,
            privateLogCount: this.data.getNonEmptyPrivateLogs().length,
            classPublishedCount: this.data.getNonEmptyContractClassLogsHashes().length,
            contractClassLogSize: this.data.getEmittedContractClassLogsLength(),
            proofSize: this.chonkProof.fields.length,
            size: this.getSize(),
            feePaymentMethod: // needsSetup? then we pay through a fee payment contract
            this.data.forPublic?.needsSetup ? 'fpc' : 'fee_juice'
        };
    }
    sizeCache;
    getSize() {
        if (this.sizeCache == undefined) {
            this.sizeCache = this.toBuffer().length;
        }
        return this.sizeCache;
    }
    /**
   * Estimates the tx size based on its private effects. Note that the actual size of the tx
   * after processing will probably be larger, as public execution would generate more data.
   */ getEstimatedPrivateTxEffectsSize() {
        return this.data.getNonEmptyNoteHashes().length * Fr.SIZE_IN_BYTES + this.data.getNonEmptyNullifiers().length * Fr.SIZE_IN_BYTES + this.data.getEmittedPrivateLogsLength() * Fr.SIZE_IN_BYTES + this.data.getEmittedContractClassLogsLength() * Fr.SIZE_IN_BYTES;
    }
    /**
   * Clones a tx, making a deep copy of all fields.
   * @param tx - The transaction to be cloned.
   * @param cloneProof - Whether to clone the proof as well. If false, will shallow copy.
   * @returns The cloned transaction.
   */ static clone(tx, cloneProof = true) {
        const publicInputs = PrivateKernelTailCircuitPublicInputs.fromBuffer(tx.data.toBuffer());
        const chonkProof = cloneProof ? ChonkProof.fromBuffer(tx.chonkProof.toBuffer()) : tx.chonkProof;
        const contractClassLogFields = tx.contractClassLogFields.map((p)=>p.clone());
        const publicFunctionCalldata = tx.publicFunctionCalldata.map((cd)=>HashedValues.fromBuffer(cd.toBuffer()));
        const clonedTx = new Tx(tx.txHash, publicInputs, chonkProof, contractClassLogFields, publicFunctionCalldata);
        return clonedTx;
    }
    /**
   * Creates a random tx.
   * @param randomProof - Whether to create a random proof - this will be random bytes of the full size.
   * @returns A random tx.
   */ static random(args = {}) {
        return Tx.from({
            txHash: (typeof args.txHash === 'string' ? TxHash.fromString(args.txHash) : args.txHash) ?? TxHash.random(),
            data: PrivateKernelTailCircuitPublicInputs.emptyWithNullifier(),
            chonkProof: args.randomProof ? ChonkProof.random() : ChonkProof.empty(),
            contractClassLogFields: [
                ContractClassLogFields.random()
            ],
            publicFunctionCalldata: [
                HashedValues.random()
            ]
        });
    }
    /** Recomputes the tx hash. Used for testing purposes only when a property of the tx was mutated. */ async recomputeHash() {
        this.txHash = await Tx.computeTxHash(this);
        return this.txHash;
    }
    #combinePublicCallRequestWithCallData(request) {
        const calldataMap = this.getCalldataMap();
        // Assume empty calldata if nothing is given for the hash.
        // The verification of calldata vs hash should be handled outside of this class.
        const calldata = calldataMap.get(request.calldataHash.toString()) ?? [];
        return new PublicCallRequestWithCalldata(request, calldata);
    }
}
/**
 * Helper class to handle Serialization and Deserialization of Txs array.
 */ export class TxArray extends Array {
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        try {
            const txs = reader.readVector(Tx);
            return new TxArray(...txs);
        } catch  {
            throw new Error('Failed to deserialize TxArray from buffer');
        }
    }
    toBuffer() {
        return serializeArrayOfBufferableToVector(this);
    }
}
