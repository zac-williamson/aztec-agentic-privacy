import { Fr } from '@aztec/foundation/curves/bn254';
import { optional, schemas } from '@aztec/foundation/schemas';
import { z } from 'zod';
import { PrivateExecutionStepSchema } from '../kernel/private_kernel_prover_output.js';
const RoundTripStatsSchema = z.object({
    roundTrips: z.number(),
    totalBlockingTime: z.number(),
    roundTripDurations: z.array(z.number()),
    roundTripMethods: z.array(z.array(z.string()))
});
const NodeStatsSchema = z.object({
    perMethod: z.record(z.string(), z.object({
        times: z.array(z.number())
    })),
    roundTrips: RoundTripStatsSchema
});
const FunctionTimingSchema = z.object({
    functionName: z.string(),
    time: z.number(),
    oracles: optional(z.record(z.string(), z.object({
        times: z.array(z.number())
    })))
});
export const ProvingTimingsSchema = z.object({
    sync: optional(z.number()),
    proving: optional(z.number()),
    perFunction: z.array(FunctionTimingSchema),
    unaccounted: z.number(),
    total: z.number()
});
export const ProvingStatsSchema = z.object({
    timings: ProvingTimingsSchema,
    nodeRPCCalls: optional(NodeStatsSchema)
});
export const SimulationTimingsSchema = z.object({
    sync: z.number(),
    publicSimulation: optional(z.number()),
    validation: optional(z.number()),
    perFunction: z.array(FunctionTimingSchema),
    unaccounted: z.number(),
    total: z.number()
});
export const SimulationStatsSchema = z.object({
    timings: SimulationTimingsSchema,
    nodeRPCCalls: NodeStatsSchema
});
export class TxProfileResult {
    executionSteps;
    stats;
    constructor(executionSteps, stats){
        this.executionSteps = executionSteps;
        this.stats = stats;
    }
    static get schema() {
        return z.object({
            executionSteps: z.array(PrivateExecutionStepSchema),
            stats: ProvingStatsSchema
        }).transform(({ executionSteps, stats })=>new TxProfileResult(executionSteps, stats));
    }
    static random() {
        return new TxProfileResult([
            {
                functionName: 'random',
                bytecode: Buffer.from('random'),
                witness: new Map([
                    [
                        1,
                        'random'
                    ]
                ]),
                vk: Buffer.from('random'),
                timings: {
                    witgen: 1,
                    gateCount: 1
                }
            }
        ], {
            nodeRPCCalls: {
                perMethod: {
                    getBlockHeader: {
                        times: [
                            1
                        ]
                    }
                },
                roundTrips: {
                    roundTrips: 1,
                    totalBlockingTime: 1,
                    roundTripDurations: [
                        1
                    ],
                    roundTripMethods: [
                        [
                            'getBlockHeader'
                        ]
                    ]
                }
            },
            timings: {
                sync: 1,
                proving: 1,
                perFunction: [
                    {
                        functionName: 'random',
                        time: 1
                    }
                ],
                unaccounted: 1,
                total: 4
            }
        });
    }
}
export class UtilitySimulationResult {
    result;
    stats;
    constructor(result, stats){
        this.result = result;
        this.stats = stats;
    }
    static get schema() {
        return z.object({
            result: z.array(schemas.Fr),
            stats: optional(SimulationStatsSchema)
        }).transform(({ result, stats })=>new UtilitySimulationResult(result, stats));
    }
    static random() {
        return new UtilitySimulationResult([
            Fr.random()
        ], {
            nodeRPCCalls: {
                perMethod: {
                    getBlockHeader: {
                        times: [
                            1
                        ]
                    }
                },
                roundTrips: {
                    roundTrips: 1,
                    totalBlockingTime: 1,
                    roundTripDurations: [
                        1
                    ],
                    roundTripMethods: [
                        [
                            'getBlockHeader'
                        ]
                    ]
                }
            },
            timings: {
                sync: 1,
                publicSimulation: 1,
                validation: 1,
                perFunction: [
                    {
                        functionName: 'random',
                        time: 1
                    }
                ],
                unaccounted: 1,
                total: 5
            }
        });
    }
}
