import { optional } from '@aztec/foundation/schemas';
import { z } from 'zod';
import { PrivateKernelTailCircuitPublicInputs } from '../kernel/private_kernel_tail_circuit_public_inputs.js';
import { ChonkProof } from '../proofs/chonk_proof.js';
import { PrivateExecutionResult, collectOffchainEffects, collectSortedContractClassLogs } from './private_execution_result.js';
import { ProvingTimingsSchema } from './profiling.js';
import { Tx } from './tx.js';
export class TxProvingResult {
    privateExecutionResult;
    publicInputs;
    chonkProof;
    stats;
    constructor(privateExecutionResult, publicInputs, chonkProof, stats){
        this.privateExecutionResult = privateExecutionResult;
        this.publicInputs = publicInputs;
        this.chonkProof = chonkProof;
        this.stats = stats;
    }
    async toTx() {
        const contractClassLogs = collectSortedContractClassLogs(this.privateExecutionResult);
        return await Tx.create({
            data: this.publicInputs,
            chonkProof: this.chonkProof,
            contractClassLogFields: contractClassLogs,
            publicFunctionCalldata: this.privateExecutionResult.publicFunctionCalldata
        });
    }
    getOffchainEffects() {
        return collectOffchainEffects(this.privateExecutionResult);
    }
    static get schema() {
        return z.object({
            privateExecutionResult: PrivateExecutionResult.schema,
            publicInputs: PrivateKernelTailCircuitPublicInputs.schema,
            chonkProof: ChonkProof.schema,
            timings: optional(ProvingTimingsSchema)
        }).transform(TxProvingResult.from);
    }
    static from(fields) {
        return new TxProvingResult(fields.privateExecutionResult, fields.publicInputs, fields.chonkProof);
    }
    static async random() {
        return new TxProvingResult(await PrivateExecutionResult.random(), PrivateKernelTailCircuitPublicInputs.empty(), ChonkProof.empty());
    }
}
