import { AztecAddress } from '../aztec-address/index.js';
/**
 * Represents data necessary to perform an action in the network successfully.
 * This class can be considered Aztec's "minimal execution unit".
 * */ export class ExecutionPayload {
    calls;
    authWitnesses;
    capsules;
    extraHashedArgs;
    feePayer;
    constructor(/** The function calls to be executed. */ calls, /** Any transient auth witnesses needed for this execution */ authWitnesses, /** Data passed through an oracle for this execution. */ capsules, /** Extra hashed values to be injected in the execution cache */ extraHashedArgs = [], /**
     * The address that is paying for the fee in this execution payload (if any).
     * If undefined, the wallet software executing the payload will have to add a fee payment method
     */ feePayer){
        this.calls = calls;
        this.authWitnesses = authWitnesses;
        this.capsules = capsules;
        this.extraHashedArgs = extraHashedArgs;
        this.feePayer = feePayer;
    }
    static empty() {
        return new ExecutionPayload([], [], [], [], undefined);
    }
}
/**
 * Merges an array ExecutionPayloads combining their calls, authWitnesses, capsules and extraArgHashes.
 * @throws Error if multiple payloads have different fee payers set
 */ export function mergeExecutionPayloads(requests) {
    const calls = requests.map((r)=>r.calls).flat();
    const combinedAuthWitnesses = requests.map((r)=>r.authWitnesses ?? []).flat();
    const combinedCapsules = requests.map((r)=>r.capsules ?? []).flat();
    const combinedExtraHashedArgs = requests.map((r)=>r.extraHashedArgs ?? []).flat();
    // Collect unique fee payers
    const uniqueFeePayers = new Set(requests.map((r)=>r.feePayer).filter((fp)=>fp !== undefined).map((fp)=>fp.toString()));
    if (uniqueFeePayers.size > 1) {
        throw new Error(`Cannot merge execution payloads with different fee payers. Found: ${Array.from(uniqueFeePayers).join(', ')}`);
    }
    const feePayer = uniqueFeePayers.size === 1 ? AztecAddress.fromString(Array.from(uniqueFeePayers)[0]) : undefined;
    return new ExecutionPayload(calls, combinedAuthWitnesses, combinedCapsules, combinedExtraHashedArgs, feePayer);
}
