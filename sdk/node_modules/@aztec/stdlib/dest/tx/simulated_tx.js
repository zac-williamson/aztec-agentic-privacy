import { optional } from '@aztec/foundation/schemas';
import { z } from 'zod';
import { ContractArtifactSchema } from '../abi/abi.js';
import { ContractInstanceWithAddressSchema } from '../contract/interfaces/contract_instance.js';
import { Gas } from '../gas/gas.js';
import { PrivateKernelTailCircuitPublicInputs } from '../kernel/private_kernel_tail_circuit_public_inputs.js';
import { ChonkProof } from '../proofs/chonk_proof.js';
import { PrivateExecutionResult, collectSortedContractClassLogs } from './private_execution_result.js';
import { SimulationStatsSchema } from './profiling.js';
import { NestedProcessReturnValues, PublicSimulationOutput } from './public_simulation_output.js';
import { Tx } from './tx.js';
/*
 * Optional values that can be overridden during simulation. In order to simulate a transaction with these
 * set, it *must* be run without the kernel circuits, or validations will fail
 */ export class SimulationOverrides {
    contracts;
    constructor(contracts){
        this.contracts = contracts;
    }
    static get schema() {
        return z.object({
            contracts: optional(z.record(z.string(), z.object({
                instance: ContractInstanceWithAddressSchema,
                artifact: ContractArtifactSchema
            })))
        }).transform(({ contracts })=>{
            return new SimulationOverrides(contracts);
        });
    }
}
export class PrivateSimulationResult {
    privateExecutionResult;
    publicInputs;
    constructor(privateExecutionResult, publicInputs){
        this.privateExecutionResult = privateExecutionResult;
        this.publicInputs = publicInputs;
    }
    getPrivateReturnValues() {
        return accumulatePrivateReturnValues(this.privateExecutionResult);
    }
    async toSimulatedTx() {
        const contractClassLogs = collectSortedContractClassLogs(this.privateExecutionResult);
        return await Tx.create({
            data: this.publicInputs,
            chonkProof: ChonkProof.empty(),
            contractClassLogFields: contractClassLogs,
            publicFunctionCalldata: this.privateExecutionResult.publicFunctionCalldata
        });
    }
}
export class TxSimulationResult {
    privateExecutionResult;
    publicInputs;
    publicOutput;
    stats;
    constructor(privateExecutionResult, publicInputs, publicOutput, stats){
        this.privateExecutionResult = privateExecutionResult;
        this.publicInputs = publicInputs;
        this.publicOutput = publicOutput;
        this.stats = stats;
    }
    get gasUsed() {
        return this.publicOutput?.gasUsed ?? {
            totalGas: this.publicInputs.gasUsed,
            billedGas: this.publicInputs.gasUsed,
            teardownGas: Gas.empty(),
            publicGas: Gas.empty()
        };
    }
    static get schema() {
        return z.object({
            privateExecutionResult: PrivateExecutionResult.schema,
            publicInputs: PrivateKernelTailCircuitPublicInputs.schema,
            publicOutput: PublicSimulationOutput.schema.optional(),
            stats: optional(SimulationStatsSchema)
        }).transform(TxSimulationResult.from);
    }
    static from(fields) {
        return new TxSimulationResult(fields.privateExecutionResult, fields.publicInputs, fields.publicOutput, fields.stats);
    }
    static fromPrivateSimulationResultAndPublicOutput(privateSimulationResult, publicOutput, stats) {
        return new TxSimulationResult(privateSimulationResult.privateExecutionResult, privateSimulationResult.publicInputs, publicOutput, stats);
    }
    static async random() {
        return new TxSimulationResult(await PrivateExecutionResult.random(), PrivateKernelTailCircuitPublicInputs.empty(), await PublicSimulationOutput.random());
    }
    getPrivateReturnValues() {
        return new PrivateSimulationResult(this.privateExecutionResult, this.publicInputs).getPrivateReturnValues();
    }
    toSimulatedTx() {
        return new PrivateSimulationResult(this.privateExecutionResult, this.publicInputs).toSimulatedTx();
    }
    getPublicReturnValues() {
        return this.publicOutput ? this.publicOutput.publicReturnValues : [];
    }
}
/**
 * Recursively accummulate the return values of a call result and its nested executions,
 * so they can be retrieved in order.
 * @param executionResult
 * @returns
 */ export function accumulatePrivateReturnValues(executionResult) {
    const collectPrivateReturnValuesRecursive = (executionResult)=>{
        const acc = new NestedProcessReturnValues(executionResult.returnValues);
        acc.nested = executionResult.nestedExecutionResults.map((nestedExecutionResult)=>collectPrivateReturnValuesRecursive(nestedExecutionResult));
        return acc;
    };
    return collectPrivateReturnValuesRecursive(executionResult.entrypoint);
}
