var _computedKey;
import { GLOBAL_VARIABLES_LENGTH } from '@aztec/constants';
import { BlockNumber, BlockNumberSchema, SlotNumber } from '@aztec/foundation/branded-types';
import { randomInt } from '@aztec/foundation/crypto/random';
import { Fr } from '@aztec/foundation/curves/bn254';
import { EthAddress } from '@aztec/foundation/eth-address';
import { jsonStringify } from '@aztec/foundation/json-rpc';
import { BufferReader, FieldReader, bigintToUInt64BE, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
import { GasFees } from '../gas/gas_fees.js';
import { schemas } from '../schemas/index.js';
_computedKey = inspect.custom;
/**
 * Global variables of the L2 block.
 */ export class GlobalVariables {
    chainId;
    version;
    blockNumber;
    slotNumber;
    timestamp;
    coinbase;
    feeRecipient;
    gasFees;
    constructor(/** ChainId for the L2 block. */ chainId, /** Version for the L2 block. */ version, /** Block number of the L2 block. */ blockNumber, /** Slot number of the L2 block */ slotNumber, /** Timestamp of the L2 block. */ timestamp, /** Recipient of block reward. */ coinbase, /** Address to receive fees. */ feeRecipient, /** Global gas prices for this block. */ gasFees){
        this.chainId = chainId;
        this.version = version;
        this.blockNumber = blockNumber;
        this.slotNumber = slotNumber;
        this.timestamp = timestamp;
        this.coinbase = coinbase;
        this.feeRecipient = feeRecipient;
        this.gasFees = gasFees;
    }
    static get schema() {
        return z.object({
            chainId: schemas.Fr,
            version: schemas.Fr,
            blockNumber: BlockNumberSchema,
            slotNumber: schemas.SlotNumber,
            timestamp: schemas.BigInt,
            coinbase: schemas.EthAddress,
            feeRecipient: schemas.AztecAddress,
            gasFees: GasFees.schema
        }).transform(GlobalVariables.from);
    }
    getSize() {
        return this.toBuffer().length;
    }
    static from(fields) {
        return new GlobalVariables(...GlobalVariables.getFields(fields));
    }
    /**
   * Creates a GlobalVariables instance from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing GlobalVariables fields
   * @returns A GlobalVariables instance
   */ static fromPlainObject(obj) {
        return new GlobalVariables(Fr.fromPlainObject(obj.chainId), Fr.fromPlainObject(obj.version), obj.blockNumber, SlotNumber(Fr.fromPlainObject(obj.slotNumber).toNumber()), typeof obj.timestamp === 'bigint' ? obj.timestamp : BigInt(obj.timestamp), EthAddress.fromPlainObject(obj.coinbase), AztecAddress.fromPlainObject(obj.feeRecipient), GasFees.fromPlainObject(obj.gasFees));
    }
    static empty(fields = {}) {
        return GlobalVariables.from({
            blockNumber: BlockNumber.ZERO,
            slotNumber: SlotNumber.ZERO,
            timestamp: 0n,
            chainId: Fr.ZERO,
            version: Fr.ZERO,
            coinbase: EthAddress.ZERO,
            feeRecipient: AztecAddress.ZERO,
            gasFees: GasFees.empty(),
            ...fields
        });
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new GlobalVariables(Fr.fromBuffer(reader), Fr.fromBuffer(reader), BlockNumber(reader.readNumber()), SlotNumber(reader.readNumber()), reader.readUInt64(), reader.readObject(EthAddress), reader.readObject(AztecAddress), reader.readObject(GasFees));
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new GlobalVariables(reader.readField(), reader.readField(), BlockNumber(reader.readU32()), SlotNumber(reader.readU32()), reader.readField().toBigInt(), EthAddress.fromField(reader.readField()), AztecAddress.fromField(reader.readField()), GasFees.fromFields(reader));
    }
    static getFields(fields) {
        return [
            fields.chainId,
            fields.version,
            fields.blockNumber,
            fields.slotNumber,
            fields.timestamp,
            fields.coinbase,
            fields.feeRecipient,
            fields.gasFees
        ];
    }
    toBuffer() {
        return serializeToBuffer([
            this.chainId,
            this.version,
            this.blockNumber,
            this.slotNumber,
            bigintToUInt64BE(this.timestamp),
            this.coinbase,
            this.feeRecipient,
            this.gasFees
        ]);
    }
    toFields() {
        const fields = serializeToFields(...GlobalVariables.getFields(this));
        if (fields.length !== GLOBAL_VARIABLES_LENGTH) {
            throw new Error(`Invalid number of fields for GlobalVariables. Expected ${GLOBAL_VARIABLES_LENGTH}, got ${fields.length}`);
        }
        return fields;
    }
    /**
   * A trimmed version of the JSON representation of the global variables,
   * tailored for human consumption.
   */ toFriendlyJSON() {
        return {
            blockNumber: this.blockNumber,
            slotNumber: this.slotNumber,
            timestamp: this.timestamp.toString(),
            coinbase: this.coinbase.toString(),
            gasFees: jsonStringify(this.gasFees)
        };
    }
    /**
   * Converts GlobalVariables to a plain object suitable for MessagePack serialization.
   * This method ensures that slotNumber is serialized as a Fr (Field element) to match
   * the C++ struct definition which expects slot_number as FF.
   */ toJSON() {
        return {
            chainId: this.chainId,
            version: this.version,
            blockNumber: this.blockNumber,
            slotNumber: new Fr(this.slotNumber),
            timestamp: this.timestamp,
            coinbase: this.coinbase,
            feeRecipient: this.feeRecipient,
            gasFees: this.gasFees
        };
    }
    clone() {
        return GlobalVariables.fromBuffer(this.toBuffer());
    }
    isEmpty() {
        return this.chainId.isZero() && this.version.isZero() && this.blockNumber === 0 && this.slotNumber === 0 && this.timestamp === 0n && this.coinbase.isZero() && this.feeRecipient.isZero() && this.gasFees.isEmpty();
    }
    static random(overrides = {}) {
        return GlobalVariables.from({
            chainId: new Fr(randomInt(100_000)),
            version: new Fr(randomInt(100_000)),
            blockNumber: BlockNumber(randomInt(100_000)),
            slotNumber: SlotNumber(randomInt(100_000)),
            coinbase: EthAddress.random(),
            feeRecipient: AztecAddress.fromField(Fr.random()),
            gasFees: GasFees.random(),
            timestamp: BigInt(randomInt(100_000_000)),
            ...overrides
        });
    }
    toInspect() {
        return {
            chainId: this.chainId.toNumber(),
            version: this.version.toNumber(),
            blockNumber: this.blockNumber,
            slotNumber: this.slotNumber,
            timestamp: this.timestamp,
            coinbase: this.coinbase.toString(),
            feeRecipient: this.feeRecipient.toString(),
            feePerDaGas: Number(this.gasFees.feePerDaGas),
            feePerL2Gas: Number(this.gasFees.feePerL2Gas)
        };
    }
    [_computedKey]() {
        return `GlobalVariables ${inspect(this.toInspect())}`;
    }
    equals(other) {
        return this.chainId.equals(other.chainId) && this.version.equals(other.version) && this.blockNumber === other.blockNumber && this.slotNumber === other.slotNumber && this.timestamp === other.timestamp && this.coinbase.equals(other.coinbase) && this.feeRecipient.equals(other.feeRecipient) && this.gasFees.equals(other.gasFees);
    }
}
