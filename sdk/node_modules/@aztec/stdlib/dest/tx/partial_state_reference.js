import { PARTIAL_STATE_REFERENCE_LENGTH } from '@aztec/constants';
import { BufferReader, FieldReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { z } from 'zod';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
/**
 * Stores snapshots of trees which are commonly needed by base or merge rollup circuits.
 */ export class PartialStateReference {
    noteHashTree;
    nullifierTree;
    publicDataTree;
    constructor(/** Snapshot of the note hash tree. */ noteHashTree, /** Snapshot of the nullifier tree. */ nullifierTree, /** Snapshot of the public data tree. */ publicDataTree){
        this.noteHashTree = noteHashTree;
        this.nullifierTree = nullifierTree;
        this.publicDataTree = publicDataTree;
    }
    static get schema() {
        return z.object({
            noteHashTree: AppendOnlyTreeSnapshot.schema,
            nullifierTree: AppendOnlyTreeSnapshot.schema,
            publicDataTree: AppendOnlyTreeSnapshot.schema
        }).transform(({ noteHashTree, nullifierTree, publicDataTree })=>new PartialStateReference(noteHashTree, nullifierTree, publicDataTree));
    }
    getSize() {
        return this.noteHashTree.getSize() + this.nullifierTree.getSize() + this.publicDataTree.getSize();
    }
    static getFields(fields) {
        return [
            fields.noteHashTree,
            fields.nullifierTree,
            fields.publicDataTree
        ];
    }
    static from(fields) {
        return new PartialStateReference(...PartialStateReference.getFields(fields));
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PartialStateReference(reader.readObject(AppendOnlyTreeSnapshot), reader.readObject(AppendOnlyTreeSnapshot), reader.readObject(AppendOnlyTreeSnapshot));
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        const noteHashTree = AppendOnlyTreeSnapshot.fromFields(reader);
        const nullifierTree = AppendOnlyTreeSnapshot.fromFields(reader);
        const publicDataTree = AppendOnlyTreeSnapshot.fromFields(reader);
        return new PartialStateReference(noteHashTree, nullifierTree, publicDataTree);
    }
    static random() {
        return new PartialStateReference(AppendOnlyTreeSnapshot.random(), AppendOnlyTreeSnapshot.random(), AppendOnlyTreeSnapshot.random());
    }
    toAbi() {
        return [
            this.noteHashTree.toAbi(),
            this.nullifierTree.toAbi(),
            this.publicDataTree.toAbi()
        ];
    }
    static empty() {
        return new PartialStateReference(AppendOnlyTreeSnapshot.empty(), AppendOnlyTreeSnapshot.empty(), AppendOnlyTreeSnapshot.empty());
    }
    toBuffer() {
        return serializeToBuffer(this.noteHashTree, this.nullifierTree, this.publicDataTree);
    }
    toFields() {
        const fields = [
            ...this.noteHashTree.toFields(),
            ...this.nullifierTree.toFields(),
            ...this.publicDataTree.toFields()
        ];
        if (fields.length !== PARTIAL_STATE_REFERENCE_LENGTH) {
            throw new Error(`Invalid number of fields for PartialStateReference. Expected ${PARTIAL_STATE_REFERENCE_LENGTH}, got ${fields.length}`);
        }
        return fields;
    }
    isEmpty() {
        return this.noteHashTree.isEmpty() && this.nullifierTree.isEmpty() && this.publicDataTree.isEmpty();
    }
    equals(other) {
        return this.noteHashTree.equals(other.noteHashTree) && this.nullifierTree.equals(other.nullifierTree) && this.publicDataTree.equals(other.publicDataTree);
    }
}
