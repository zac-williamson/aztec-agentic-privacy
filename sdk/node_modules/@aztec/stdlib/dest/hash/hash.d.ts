import { Fr } from '@aztec/foundation/curves/bn254';
import type { EthAddress } from '@aztec/foundation/eth-address';
import { AztecAddress } from '../aztec-address/index.js';
/**
 * Computes a hash of a given verification key.
 * @param keyAsFields - The verification key as fields.
 * @returns The hash of the verification key.
 */
export declare function hashVK(keyAsFields: Fr[]): Promise<Fr>;
/**
 * Computes a note hash nonce, which will be used to create a unique note hash.
 * @param nullifierZero - The first nullifier in the tx.
 * @param noteHashIndex - The index of the note hash.
 * @returns A note hash nonce.
 */
export declare function computeNoteHashNonce(nullifierZero: Fr, noteHashIndex: number): Promise<Fr>;
/**
 * Computes a siloed note hash, given the contract address and the note hash itself.
 * A siloed note hash effectively namespaces a note hash to a specific contract.
 * @param contract - The contract address
 * @param noteHash - The note hash to silo.
 * @returns A siloed note hash.
 */
export declare function siloNoteHash(contract: AztecAddress, noteHash: Fr): Promise<Fr>;
/**
 * Computes a unique note hash.
 * @param noteNonce - The nonce that was injected into the note hash preimage in order to guarantee uniqueness.
 * @param siloedNoteHash - A siloed note hash.
 * @returns A unique note hash.
 */
export declare function computeUniqueNoteHash(noteNonce: Fr, siloedNoteHash: Fr): Promise<Fr>;
/**
 * Computes a siloed nullifier, given the contract address and the inner nullifier.
 * A siloed nullifier effectively namespaces a nullifier to a specific contract.
 * @param contract - The contract address.
 * @param innerNullifier - The nullifier to silo.
 * @returns A siloed nullifier.
 */
export declare function siloNullifier(contract: AztecAddress, innerNullifier: Fr): Promise<Fr>;
/**
 * Computes the protocol nullifier, which is the hash of the initial tx request siloed with the null msg sender address.
 * @param txRequestHash - The hash of the initial tx request.
 * @returns The siloed value of the protocol nullifier.
 *
 * @dev Must match the implementation in noir-protocol-circuits/crates/types/src/hash.nr > compute_protocol_nullifier
 */
export declare function computeProtocolNullifier(txRequestHash: Fr): Promise<Fr>;
export declare function computeSiloedPrivateLogFirstField(contract: AztecAddress, field: Fr): Promise<Fr>;
/**
 * Computes a public data tree value ready for insertion.
 * @param value - Raw public data tree value to hash into a tree-insertion-ready value.
 * @returns Value hash into a tree-insertion-ready value.

 */
export declare function computePublicDataTreeValue(value: Fr): Fr;
/**
 * Computes a public data tree index from contract address and storage slot.
 * @param contractAddress - Contract where insertion is occurring.
 * @param storageSlot - Storage slot where insertion is occurring.
 * @returns Public data tree index computed from contract address and storage slot.

 */
export declare function computePublicDataTreeLeafSlot(contractAddress: AztecAddress, storageSlot: Fr): Promise<Fr>;
/**
 * Computes the hash of a list of arguments.
 * Used for input arguments or return values for private functions, or for authwit creation.
 * @param args - Arguments to hash.
 * @returns Hash of the arguments.
 */
export declare function computeVarArgsHash(args: Fr[]): Promise<Fr>;
/**
 * Computes the hash of a public function's calldata.
 * @param calldata - Calldata to hash.
 * @returns Hash of the calldata.
 */
export declare function computeCalldataHash(calldata: Fr[]): Promise<Fr>;
/**
 * Computes a hash of a secret.
 * @dev This function is used to generate secrets for the L1 to L2 message flow and for the TransparentNote.
 * @param secret - The secret to hash (could be generated however you want e.g. `Fr.random()`)
 * @returns The hash
 */
export declare function computeSecretHash(secret: Fr): Promise<Fr>;
export declare function computeL1ToL2MessageNullifier(contract: AztecAddress, messageHash: Fr, secret: Fr): Promise<Fr>;
/**
 * Calculates a siloed hash of a scoped l2 to l1 message.
 * @returns Fr containing 248 bits of information of sha256 hash.
 */
export declare function computeL2ToL1MessageHash({ l2Sender, l1Recipient, content, rollupVersion, chainId }: {
    l2Sender: AztecAddress;
    l1Recipient: EthAddress;
    content: Fr;
    rollupVersion: Fr;
    chainId: Fr;
}): Fr;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzaC5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2hhc2gvaGFzaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDcEQsT0FBTyxLQUFLLEVBQUUsVUFBVSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFaEUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRXpEOzs7O0dBSUc7QUFDSCx3QkFBc0IsTUFBTSxDQUFDLFdBQVcsRUFBRSxFQUFFLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDLENBRzNEO0FBRUQ7Ozs7O0dBS0c7QUFDSCx3QkFBZ0Isb0JBQW9CLENBQUMsYUFBYSxFQUFFLEVBQUUsRUFBRSxhQUFhLEVBQUUsTUFBTSxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FFMUY7QUFFRDs7Ozs7O0dBTUc7QUFDSCx3QkFBZ0IsWUFBWSxDQUFDLFFBQVEsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDLENBRTlFO0FBRUQ7Ozs7O0dBS0c7QUFDSCx3QkFBZ0IscUJBQXFCLENBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxjQUFjLEVBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FFcEY7QUFFRDs7Ozs7O0dBTUc7QUFDSCx3QkFBZ0IsYUFBYSxDQUFDLFFBQVEsRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDLENBRXJGO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsd0JBQWdCLHdCQUF3QixDQUFDLGFBQWEsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUV2RTtBQUVELHdCQUFnQixpQ0FBaUMsQ0FBQyxRQUFRLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUVoRztBQUVEOzs7OztHQUtHO0FBQ0gsd0JBQWdCLDBCQUEwQixDQUFDLEtBQUssRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUV4RDtBQUVEOzs7Ozs7R0FNRztBQUNILHdCQUFnQiw2QkFBNkIsQ0FBQyxlQUFlLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUV6RztBQUVEOzs7OztHQUtHO0FBQ0gsd0JBQWdCLGtCQUFrQixDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDLENBTTFEO0FBRUQ7Ozs7R0FJRztBQUNILHdCQUFnQixtQkFBbUIsQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUUvRDtBQUVEOzs7OztHQUtHO0FBQ0gsd0JBQWdCLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUV6RDtBQUVELHdCQUFzQiw2QkFBNkIsQ0FBQyxRQUFRLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsZUFNdEc7QUFFRDs7O0dBR0c7QUFDSCx3QkFBZ0Isd0JBQXdCLENBQUMsRUFDdkMsUUFBUSxFQUNSLFdBQVcsRUFDWCxPQUFPLEVBQ1AsYUFBYSxFQUNiLE9BQU8sRUFDUixFQUFFO0lBQ0QsUUFBUSxFQUFFLFlBQVksQ0FBQztJQUN2QixXQUFXLEVBQUUsVUFBVSxDQUFDO0lBQ3hCLE9BQU8sRUFBRSxFQUFFLENBQUM7SUFDWixhQUFhLEVBQUUsRUFBRSxDQUFDO0lBQ2xCLE9BQU8sRUFBRSxFQUFFLENBQUM7Q0FDYixNQUVBIn0=