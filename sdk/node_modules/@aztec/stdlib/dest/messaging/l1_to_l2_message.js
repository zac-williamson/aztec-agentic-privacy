import { sha256ToField } from '@aztec/foundation/crypto/sha256';
import { Fr } from '@aztec/foundation/curves/bn254';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { bufferToHex } from '@aztec/foundation/string';
import { computeL1ToL2MessageNullifier } from '../hash/hash.js';
import { MerkleTreeId } from '../trees/merkle_tree_id.js';
import { L1Actor } from './l1_actor.js';
import { L2Actor } from './l2_actor.js';
/**
 * The format of an L1 to L2 Message.
 */ export class L1ToL2Message {
    sender;
    recipient;
    content;
    secretHash;
    index;
    constructor(/** The sender of the message on L1. */ sender, /** The recipient of the message on L2. */ recipient, /** The message content. */ content, /** The hash of the spending secret. */ secretHash, /** Global index of this message on the tree. */ index){
        this.sender = sender;
        this.recipient = recipient;
        this.content = content;
        this.secretHash = secretHash;
        this.index = index;
    }
    /**
   * Returns each element within its own field so that it can be consumed by an acvm oracle call.
   * @returns The message as an array of fields (in order).
   */ toFields() {
        return [
            ...this.sender.toFields(),
            ...this.recipient.toFields(),
            this.content,
            this.secretHash,
            this.index
        ];
    }
    toBuffer() {
        return serializeToBuffer(this.sender, this.recipient, this.content, this.secretHash, this.index);
    }
    hash() {
        return sha256ToField(this.toFields());
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const sender = reader.readObject(L1Actor);
        const recipient = reader.readObject(L2Actor);
        const content = Fr.fromBuffer(reader);
        const secretHash = Fr.fromBuffer(reader);
        const index = Fr.fromBuffer(reader);
        return new L1ToL2Message(sender, recipient, content, secretHash, index);
    }
    toString() {
        return bufferToHex(this.toBuffer());
    }
    static fromString(data) {
        const buffer = Buffer.from(data, 'hex');
        return L1ToL2Message.fromBuffer(buffer);
    }
    static empty() {
        return new L1ToL2Message(L1Actor.empty(), L2Actor.empty(), Fr.ZERO, Fr.ZERO, Fr.ZERO);
    }
    static async random() {
        return new L1ToL2Message(L1Actor.random(), await L2Actor.random(), Fr.random(), Fr.random(), Fr.random());
    }
}
// This functionality is not on the node because we do not want to pass the node the secret, and give the node the ability to derive a valid nullifer for an L1 to L2 message.
export async function getNonNullifiedL1ToL2MessageWitness(node, contractAddress, messageHash, secret) {
    const response = await node.getL1ToL2MessageMembershipWitness('latest', messageHash);
    if (!response) {
        throw new Error(`No L1 to L2 message found for message hash ${messageHash.toString()}`);
    }
    const [messageIndex, siblingPath] = response;
    const messageNullifier = await computeL1ToL2MessageNullifier(contractAddress, messageHash, secret);
    const [nullifierIndex] = await node.findLeavesIndexes('latest', MerkleTreeId.NULLIFIER_TREE, [
        messageNullifier
    ]);
    if (nullifierIndex !== undefined) {
        throw new Error(`No non-nullified L1 to L2 message found for message hash ${messageHash.toString()}`);
    }
    return [
        messageIndex,
        siblingPath
    ];
}
