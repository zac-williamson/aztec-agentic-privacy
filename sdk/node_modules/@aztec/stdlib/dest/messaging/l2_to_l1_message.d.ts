import { Fr } from '@aztec/foundation/curves/bn254';
import { EthAddress } from '@aztec/foundation/eth-address';
import { BufferReader, FieldReader } from '@aztec/foundation/serialize';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
export declare class L2ToL1Message {
    recipient: EthAddress;
    content: Fr;
    constructor(recipient: EthAddress, content: Fr);
    static get schema(): z.ZodEffects<z.ZodObject<{
        recipient: z.ZodType<EthAddress, any, string>;
        content: z.ZodType<Fr, any, string>;
    }, "strip", z.ZodTypeAny, {
        recipient: EthAddress;
        content: Fr;
    }, {
        recipient: string;
        content: string;
    }>, L2ToL1Message, {
        recipient: string;
        content: string;
    }>;
    /**
     * Creates an empty L2ToL1Message with default values.
     * @returns An instance of L2ToL1Message with empty fields.
     */
    static empty(): L2ToL1Message;
    /**
     * Creates an L2ToL1Message instance from a plain object without Zod validation.
     * This method is optimized for performance and skips validation, making it suitable
     * for deserializing trusted data (e.g., from C++ via MessagePack).
     * @param obj - Plain object containing L2ToL1Message fields
     * @returns An L2ToL1Message instance
     */
    static fromPlainObject(obj: any): L2ToL1Message;
    /**
     * Checks if another L2ToL1Message is equal to this instance.
     * @param other Another L2ToL1Message instance to compare with.
     * @returns True if both recipient and content are equal.
     */
    equals(other: L2ToL1Message): boolean;
    /**
     * Serialize this as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer;
    /**
     * Serializes the L2ToL1Message into an array of fields.
     * @returns An array of fields representing the serialized message.
     */
    toFields(): Fr[];
    /**
     * Deserializes an array of fields into an L2ToL1Message instance.
     * @param fields An array of fields to deserialize from.
     * @returns An instance of L2ToL1Message.
     */
    static fromFields(fields: Fr[] | FieldReader): L2ToL1Message;
    /**
     * Deserializes from a buffer or reader.
     * @param buffer - Buffer or reader to read from.
     * @returns A new instance of L2ToL1Message.
     */
    static fromBuffer(buffer: Buffer | BufferReader): L2ToL1Message;
    /**
     * Convenience method to check if the message is empty.
     * @returns True if both recipient and content are zero.
     */
    isEmpty(): boolean;
    scope(contractAddress: AztecAddress): ScopedL2ToL1Message;
}
export declare class CountedL2ToL1Message {
    message: L2ToL1Message;
    counter: number;
    constructor(message: L2ToL1Message, counter: number);
    static get schema(): z.ZodEffects<z.ZodObject<{
        message: z.ZodEffects<z.ZodObject<{
            recipient: z.ZodType<EthAddress, any, string>;
            content: z.ZodType<Fr, any, string>;
        }, "strip", z.ZodTypeAny, {
            recipient: EthAddress;
            content: Fr;
        }, {
            recipient: string;
            content: string;
        }>, L2ToL1Message, {
            recipient: string;
            content: string;
        }>;
        counter: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        message: L2ToL1Message;
        counter: number;
    }, {
        message: {
            recipient: string;
            content: string;
        };
        counter: number;
    }>, CountedL2ToL1Message, {
        message: {
            recipient: string;
            content: string;
        };
        counter: number;
    }>;
    static empty(): CountedL2ToL1Message;
    isEmpty(): boolean;
    static fromBuffer(buffer: Buffer | BufferReader): CountedL2ToL1Message;
    toBuffer(): Buffer;
    static fromFields(fields: Fr[] | FieldReader): CountedL2ToL1Message;
    toFields(): Fr[];
}
export declare class ScopedL2ToL1Message {
    message: L2ToL1Message;
    contractAddress: AztecAddress;
    constructor(message: L2ToL1Message, contractAddress: AztecAddress);
    static get schema(): z.ZodEffects<z.ZodObject<{
        message: z.ZodEffects<z.ZodObject<{
            recipient: z.ZodType<EthAddress, any, string>;
            content: z.ZodType<Fr, any, string>;
        }, "strip", z.ZodTypeAny, {
            recipient: EthAddress;
            content: Fr;
        }, {
            recipient: string;
            content: string;
        }>, L2ToL1Message, {
            recipient: string;
            content: string;
        }>;
        contractAddress: import("@aztec/foundation/schemas").ZodFor<AztecAddress>;
    }, "strip", z.ZodTypeAny, {
        message: L2ToL1Message;
        contractAddress: AztecAddress;
    }, {
        message: {
            recipient: string;
            content: string;
        };
        contractAddress?: any;
    }>, ScopedL2ToL1Message, {
        message: {
            recipient: string;
            content: string;
        };
        contractAddress?: any;
    }>;
    static empty(): ScopedL2ToL1Message;
    equals(other: ScopedL2ToL1Message): boolean;
    /**
     * Creates a ScopedL2ToL1Message instance from a plain object without Zod validation.
     * This method is optimized for performance and skips validation, making it suitable
     * for deserializing trusted data (e.g., from C++ via MessagePack).
     * @param obj - Plain object containing ScopedL2ToL1Message fields
     * @returns A ScopedL2ToL1Message instance
     */
    static fromPlainObject(obj: any): ScopedL2ToL1Message;
    isEmpty(): boolean;
    static fromBuffer(buffer: Buffer | BufferReader): ScopedL2ToL1Message;
    toBuffer(): Buffer;
    static fromFields(fields: Fr[] | FieldReader): ScopedL2ToL1Message;
    toFields(): Fr[];
}
export declare class ScopedCountedL2ToL1Message {
    inner: CountedL2ToL1Message;
    contractAddress: AztecAddress;
    constructor(inner: CountedL2ToL1Message, contractAddress: AztecAddress);
    static get schema(): z.ZodEffects<z.ZodObject<{
        inner: z.ZodEffects<z.ZodObject<{
            message: z.ZodEffects<z.ZodObject<{
                recipient: z.ZodType<EthAddress, any, string>;
                content: z.ZodType<Fr, any, string>;
            }, "strip", z.ZodTypeAny, {
                recipient: EthAddress;
                content: Fr;
            }, {
                recipient: string;
                content: string;
            }>, L2ToL1Message, {
                recipient: string;
                content: string;
            }>;
            counter: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            message: L2ToL1Message;
            counter: number;
        }, {
            message: {
                recipient: string;
                content: string;
            };
            counter: number;
        }>, CountedL2ToL1Message, {
            message: {
                recipient: string;
                content: string;
            };
            counter: number;
        }>;
        contractAddress: import("@aztec/foundation/schemas").ZodFor<AztecAddress>;
    }, "strip", z.ZodTypeAny, {
        inner: CountedL2ToL1Message;
        contractAddress: AztecAddress;
    }, {
        inner: {
            message: {
                recipient: string;
                content: string;
            };
            counter: number;
        };
        contractAddress?: any;
    }>, ScopedCountedL2ToL1Message, {
        inner: {
            message: {
                recipient: string;
                content: string;
            };
            counter: number;
        };
        contractAddress?: any;
    }>;
    static empty(): ScopedCountedL2ToL1Message;
    isEmpty(): boolean;
    static fromBuffer(buffer: Buffer | BufferReader): ScopedCountedL2ToL1Message;
    toBuffer(): Buffer;
    static fromFields(fields: Fr[] | FieldReader): ScopedCountedL2ToL1Message;
    toFields(): Fr[];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibDJfdG9fbDFfbWVzc2FnZS5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21lc3NhZ2luZy9sMl90b19sMV9tZXNzYWdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNwRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFM0QsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQXdDLE1BQU0sNkJBQTZCLENBQUM7QUFFOUcsT0FBTyxFQUFFLENBQUMsRUFBRSxNQUFNLEtBQUssQ0FBQztBQUV4QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFFekQscUJBQWEsYUFBYTtJQUVmLFNBQVMsRUFBRSxVQUFVO0lBQ3JCLE9BQU8sRUFBRSxFQUFFO0lBRnBCLFlBQ1MsU0FBUyxFQUFFLFVBQVUsRUFDckIsT0FBTyxFQUFFLEVBQUUsRUFDaEI7SUFFSixNQUFNLEtBQUssTUFBTTs7Ozs7Ozs7Ozs7O09BT2hCO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxDQUFDLEtBQUssSUFBSSxhQUFhLENBRTVCO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLGFBQWEsQ0FFOUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLEtBQUssRUFBRSxhQUFhLEdBQUcsT0FBTyxDQUVwQztJQUVEOzs7T0FHRztJQUNILFFBQVEsSUFBSSxNQUFNLENBRWpCO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUSxJQUFJLEVBQUUsRUFBRSxDQUVmO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxHQUFHLFdBQVcsR0FBRyxhQUFhLENBRzNEO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxZQUFZLEdBQUcsYUFBYSxDQUc5RDtJQUVEOzs7T0FHRztJQUNILE9BQU8sSUFBSSxPQUFPLENBRWpCO0lBRUQsS0FBSyxDQUFDLGVBQWUsRUFBRSxZQUFZLEdBQUcsbUJBQW1CLENBRXhEO0NBQ0Y7QUFFRCxxQkFBYSxvQkFBb0I7SUFFdEIsT0FBTyxFQUFFLGFBQWE7SUFDdEIsT0FBTyxFQUFFLE1BQU07SUFGeEIsWUFDUyxPQUFPLEVBQUUsYUFBYSxFQUN0QixPQUFPLEVBQUUsTUFBTSxFQUNwQjtJQUVKLE1BQU0sS0FBSyxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FPaEI7SUFFRCxNQUFNLENBQUMsS0FBSyx5QkFFWDtJQUVELE9BQU8sSUFBSSxPQUFPLENBRWpCO0lBRUQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxHQUFHLFlBQVksd0JBRzlDO0lBRUQsUUFBUSxJQUFJLE1BQU0sQ0FFakI7SUFFRCxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsR0FBRyxXQUFXLHdCQUczQztJQUVELFFBQVEsSUFBSSxFQUFFLEVBQUUsQ0FFZjtDQUNGO0FBRUQscUJBQWEsbUJBQW1CO0lBRXJCLE9BQU8sRUFBRSxhQUFhO0lBQ3RCLGVBQWUsRUFBRSxZQUFZO0lBRnRDLFlBQ1MsT0FBTyxFQUFFLGFBQWEsRUFDdEIsZUFBZSxFQUFFLFlBQVksRUFDbEM7SUFFSixNQUFNLEtBQUssTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BT2hCO0lBRUQsTUFBTSxDQUFDLEtBQUssd0JBRVg7SUFFRCxNQUFNLENBQUMsS0FBSyxFQUFFLG1CQUFtQixHQUFHLE9BQU8sQ0FFMUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQUMsZUFBZSxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsbUJBQW1CLENBS3BEO0lBRUQsT0FBTyxJQUFJLE9BQU8sQ0FFakI7SUFFRCxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUcsWUFBWSx1QkFHOUM7SUFFRCxRQUFRLElBQUksTUFBTSxDQUVqQjtJQUVELE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxHQUFHLFdBQVcsdUJBRzNDO0lBRUQsUUFBUSxJQUFJLEVBQUUsRUFBRSxDQUVmO0NBQ0Y7QUFFRCxxQkFBYSwwQkFBMEI7SUFFNUIsS0FBSyxFQUFFLG9CQUFvQjtJQUMzQixlQUFlLEVBQUUsWUFBWTtJQUZ0QyxZQUNTLEtBQUssRUFBRSxvQkFBb0IsRUFDM0IsZUFBZSxFQUFFLFlBQVksRUFDbEM7SUFFSixNQUFNLEtBQUssTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BT2hCO0lBRUQsTUFBTSxDQUFDLEtBQUssK0JBRVg7SUFFRCxPQUFPLElBQUksT0FBTyxDQUVqQjtJQUVELE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxZQUFZLDhCQUc5QztJQUVELFFBQVEsSUFBSSxNQUFNLENBRWpCO0lBRUQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEdBQUcsV0FBVyw4QkFHM0M7SUFFRCxRQUFRLElBQUksRUFBRSxFQUFFLENBRWY7Q0FDRiJ9