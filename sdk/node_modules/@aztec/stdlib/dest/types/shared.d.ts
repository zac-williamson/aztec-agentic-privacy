import { type Bufferable } from '@aztec/foundation/serialize';
/**
 * Implementation of a vector. Matches how we are serializing and deserializing vectors in cpp (length in the first position, followed by the items).
 */
export declare class Vector<T extends Bufferable> {
    /**
     * Items in the vector.
     */
    items: T[];
    constructor(
    /**
     * Items in the vector.
     */
    items: T[]);
    toBuffer(): Buffer<ArrayBufferLike>;
    toFriendlyJSON(): T[];
}
/**
 * A type alias for a 32-bit unsigned integer.
 */
export type UInt32 = number;
/**
 * A type alias for a 64-bit unsigned integer.
 */
export type UInt64 = bigint;
/**
 * A type alias for a 128-bit unsigned integer.
 */
export type UInt128 = bigint;
/**
 * CircuitType replaces ComposerType for now. When using Plonk, CircuitType is equivalent to the information of the proving system that will be used
 * to construct a proof. In the future Aztec zk stack, more information must be specified (e.g., the curve over which circuits are  constructed;
 * Plonk vs Honk; zk-SNARK or just SNARK; etc).
 */
export declare enum CircuitType {
    STANDARD = 0,
    ULTRA = 1
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhcmVkLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdHlwZXMvc2hhcmVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxLQUFLLFVBQVUsRUFBcUIsTUFBTSw2QkFBNkIsQ0FBQztBQUVqRjs7R0FFRztBQUNILHFCQUFhLE1BQU0sQ0FBQyxDQUFDLFNBQVMsVUFBVTtJQUVwQzs7T0FFRztJQUNJLEtBQUssRUFBRSxDQUFDLEVBQUU7SUFKbkI7SUFDRTs7T0FFRztJQUNJLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFDZjtJQUVKLFFBQVEsNEJBRVA7SUFFRCxjQUFjLFFBRWI7Q0FDRjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFFNUI7O0dBRUc7QUFDSCxNQUFNLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUU1Qjs7R0FFRztBQUNILE1BQU0sTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDO0FBRTdCOzs7O0dBSUc7QUFDSCxvQkFBWSxXQUFXO0lBQ3JCLFFBQVEsSUFBSTtJQUNaLEtBQUssSUFBSTtDQUNWIn0=