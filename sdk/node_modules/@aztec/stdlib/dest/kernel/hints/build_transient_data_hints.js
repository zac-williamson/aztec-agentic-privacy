import { padArrayEnd } from '@aztec/foundation/collection';
import { isValidNoteHashReadRequest } from './build_note_hash_read_request_hints.js';
import { isValidNullifierReadRequest } from './build_nullifier_read_request_hints.js';
import { ScopedValueCache } from './scoped_value_cache.js';
import { TransientDataSquashingHint } from './transient_data_squashing_hint.js';
export function buildTransientDataHints(noteHashes, nullifiers, futureNoteHashReads, futureNullifierReads, noteHashNullifierCounterMap, splitCounter) {
    const futureNoteHashReadsMap = new ScopedValueCache(futureNoteHashReads);
    const futureNullifierReadsMap = new ScopedValueCache(futureNullifierReads);
    const nullifierIndexMap = new Map();
    nullifiers.getActiveItems().forEach((n, i)=>nullifierIndexMap.set(n.counter, i));
    const hints = [];
    for(let noteHashIndex = 0; noteHashIndex < noteHashes.claimedLength; noteHashIndex++){
        const noteHash = noteHashes.array[noteHashIndex];
        const noteHashNullifierCounter = noteHashNullifierCounterMap.get(noteHash.counter);
        // The note hash might not be linked to a nullifier or it might be read in the future
        if (!noteHashNullifierCounter || futureNoteHashReadsMap.get(noteHash).find((read)=>isValidNoteHashReadRequest(read, noteHash))) {
            continue;
        }
        const nullifierIndex = nullifierIndexMap.get(noteHashNullifierCounter);
        // We might not have the corresponding nullifier yet
        if (nullifierIndex === undefined) {
            continue;
        }
        const nullifier = nullifiers.array[nullifierIndex];
        // Cannot nullify a non-revertible note hash with a revertible nullifier.
        if (noteHash.counter < splitCounter && nullifier.counter >= splitCounter) {
            continue;
        }
        // If the following errors show up, something's wrong with how we build the noteHashNullifierCounterMap in client_execution_context.ts.
        if (nullifier.counter < noteHash.counter) {
            throw new Error('Hinted nullifier has smaller counter than note hash.');
        }
        if (!nullifier.contractAddress.equals(noteHash.contractAddress)) {
            throw new Error('Contract address of hinted note hash does not match.');
        }
        if (!nullifier.nullifiedNoteHash.equals(noteHash.value)) {
            continue;
        }
        // The nullifier might be read in the future
        if (futureNullifierReadsMap.get(nullifier).find((read)=>isValidNullifierReadRequest(read, nullifier))) {
            continue;
        }
        hints.push(new TransientDataSquashingHint(nullifierIndex, noteHashIndex));
    }
    const noActionHint = new TransientDataSquashingHint(nullifiers.array.length, noteHashes.array.length);
    return {
        numTransientData: hints.length,
        hints: padArrayEnd(hints, noActionHint, nullifiers.array.length)
    };
}
