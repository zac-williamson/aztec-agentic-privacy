import { MAX_NULLIFIER_READ_REQUESTS_PER_TX } from '@aztec/constants';
import { NullifierReadRequestHintsBuilder } from './nullifier_read_request_hints.js';
import { PendingReadHint, ReadRequestActionEnum, ReadRequestResetActions } from './read_request_hints.js';
import { ScopedValueCache } from './scoped_value_cache.js';
export function isValidNullifierReadRequest(readRequest, nullifier) {
    return readRequest.value.equals(nullifier.value) && nullifier.contractAddress.equals(readRequest.contractAddress) && readRequest.counter > nullifier.counter;
}
export function getNullifierReadRequestResetActions(nullifierReadRequests, nullifiers, futureNullifiers) {
    const resetActions = ReadRequestResetActions.empty(MAX_NULLIFIER_READ_REQUESTS_PER_TX);
    const nullifierMap = new Map();
    nullifiers.getActiveItems().forEach((nullifier, index)=>{
        const value = nullifier.value.toBigInt();
        const arr = nullifierMap.get(value) ?? [];
        arr.push({
            nullifier,
            index
        });
        nullifierMap.set(value, arr);
    });
    const futureNullifiersMap = new ScopedValueCache(futureNullifiers);
    for(let i = 0; i < nullifierReadRequests.claimedLength; ++i){
        const readRequest = nullifierReadRequests.array[i];
        const pendingNullifier = nullifierMap.get(readRequest.value.toBigInt())?.find(({ nullifier })=>isValidNullifierReadRequest(readRequest, nullifier));
        if (pendingNullifier !== undefined) {
            resetActions.actions[i] = ReadRequestActionEnum.READ_AS_PENDING;
            resetActions.pendingReadHints.push(new PendingReadHint(i, pendingNullifier.index));
        } else if (!futureNullifiersMap.get(readRequest).some((futureNullifier)=>isValidNullifierReadRequest(readRequest, futureNullifier))) {
            resetActions.actions[i] = ReadRequestActionEnum.READ_AS_SETTLED;
        }
    }
    return resetActions;
}
export async function buildNullifierReadRequestHintsFromResetActions(oracle, nullifierReadRequests, resetActions, maxPending = MAX_NULLIFIER_READ_REQUESTS_PER_TX, maxSettled = MAX_NULLIFIER_READ_REQUESTS_PER_TX) {
    const builder = new NullifierReadRequestHintsBuilder(maxPending, maxSettled);
    resetActions.pendingReadHints.forEach((hint)=>{
        builder.addPendingReadRequest(hint.readRequestIndex, hint.pendingValueIndex);
    });
    // Collect all settled read requests
    const settledRequests = [];
    for(let i = 0; i < resetActions.actions.length; i++){
        if (resetActions.actions[i] === ReadRequestActionEnum.READ_AS_SETTLED) {
            settledRequests.push({
                index: i,
                readRequest: nullifierReadRequests.array[i]
            });
        }
    }
    const siloedValues = settledRequests.map(({ readRequest })=>readRequest.value);
    // Fetch all membership witnesses in parallel
    const membershipWitnesses = await Promise.all(siloedValues.map((value)=>oracle.getNullifierMembershipWitness(value)));
    // Add settled read requests to builder
    for(let i = 0; i < settledRequests.length; i++){
        builder.addSettledReadRequest(settledRequests[i].index, membershipWitnesses[i].membershipWitness, membershipWitnesses[i].leafPreimage);
    }
    return builder.toHints();
}
export async function buildNullifierReadRequestHints(oracle, nullifierReadRequests, nullifiers, futureNullifiers, maxPending = MAX_NULLIFIER_READ_REQUESTS_PER_TX, maxSettled = MAX_NULLIFIER_READ_REQUESTS_PER_TX) {
    const resetActions = getNullifierReadRequestResetActions(nullifierReadRequests, nullifiers, futureNullifiers);
    return await buildNullifierReadRequestHintsFromResetActions(oracle, nullifierReadRequests, resetActions, maxPending, maxSettled);
}
