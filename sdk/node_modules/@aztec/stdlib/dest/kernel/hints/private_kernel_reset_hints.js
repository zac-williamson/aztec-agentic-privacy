import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { KeyValidationHint } from './key_validation_hint.js';
import { noteHashReadRequestHintsFromBuffer } from './note_hash_read_request_hints.js';
import { nullifierReadRequestHintsFromBuffer } from './nullifier_read_request_hints.js';
import { TransientDataSquashingHint } from './transient_data_squashing_hint.js';
export class PrivateKernelResetHints {
    noteHashReadRequestHints;
    nullifierReadRequestHints;
    keyValidationHints;
    transientDataSquashingHints;
    constructor(/**
     * Contains hints for the transient read requests to localize corresponding commitments.
     */ noteHashReadRequestHints, /**
     * Contains hints for the nullifier read requests to locate corresponding pending or settled nullifiers.
     */ nullifierReadRequestHints, /**
     * Contains hints for key validation request.
     */ keyValidationHints, /**
     * Contains hints for the transient note hashes to locate corresponding nullifiers.
     */ transientDataSquashingHints){
        this.noteHashReadRequestHints = noteHashReadRequestHints;
        this.nullifierReadRequestHints = nullifierReadRequestHints;
        this.keyValidationHints = keyValidationHints;
        this.transientDataSquashingHints = transientDataSquashingHints;
    }
    toBuffer() {
        return serializeToBuffer(this.noteHashReadRequestHints, this.nullifierReadRequestHints, this.keyValidationHints, this.transientDataSquashingHints);
    }
    trimToSizes(numNoteHashReadRequestPending, numNoteHashReadRequestSettled, numNullifierReadRequestPending, numNullifierReadRequestSettled, numKeyValidationHints, numTransientDataSquashingHints) {
        // Noir does not allow empty arrays. So we make the minimum array size 1.
        // There is a constant for each dimension, coded in the circuit that indicates how many hints should be applied.
        // The circuit is selected based on the dimension sizes, not the hint array sizes created here.
        const useSize = (num)=>Math.max(num, 1);
        return new PrivateKernelResetHints(this.noteHashReadRequestHints.trimToSizes(useSize(numNoteHashReadRequestPending), useSize(numNoteHashReadRequestSettled)), this.nullifierReadRequestHints.trimToSizes(useSize(numNullifierReadRequestPending), useSize(numNullifierReadRequestSettled)), this.keyValidationHints.slice(0, useSize(numKeyValidationHints)), this.transientDataSquashingHints.slice(0, useSize(numTransientDataSquashingHints)));
    }
    /**
   * Deserializes from a buffer or reader.
   * @param buffer - Buffer or reader to read from.
   * @returns The deserialized instance.
   */ static fromBuffer(buffer, numNoteHashReadRequestPending, numNoteHashReadRequestSettled, numNullifierReadRequestPending, numNullifierReadRequestSettled, numKeyValidationHints, numTransientDataSquashingHints) {
        const reader = BufferReader.asReader(buffer);
        return new PrivateKernelResetHints(reader.readObject({
            fromBuffer: (buf)=>noteHashReadRequestHintsFromBuffer(buf, numNoteHashReadRequestPending, numNoteHashReadRequestSettled)
        }), reader.readObject({
            fromBuffer: (buf)=>nullifierReadRequestHintsFromBuffer(buf, numNullifierReadRequestPending, numNullifierReadRequestSettled)
        }), reader.readArray(numKeyValidationHints, KeyValidationHint), reader.readArray(numTransientDataSquashingHints, TransientDataSquashingHint));
    }
}
