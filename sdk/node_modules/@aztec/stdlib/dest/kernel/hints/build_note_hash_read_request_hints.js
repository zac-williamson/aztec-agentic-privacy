import { MAX_NOTE_HASH_READ_REQUESTS_PER_TX } from '@aztec/constants';
import { NoteHashReadRequestHintsBuilder } from './note_hash_read_request_hints.js';
import { PendingReadHint, ReadRequestActionEnum, ReadRequestResetActions } from './read_request_hints.js';
import { ScopedValueCache } from './scoped_value_cache.js';
export function isValidNoteHashReadRequest(readRequest, noteHash) {
    return noteHash.value.equals(readRequest.value) && noteHash.contractAddress.equals(readRequest.contractAddress) && readRequest.counter > noteHash.counter;
}
export function getNoteHashReadRequestResetActions(noteHashReadRequests, noteHashes, futureNoteHashes) {
    const resetActions = ReadRequestResetActions.empty(MAX_NOTE_HASH_READ_REQUESTS_PER_TX);
    const noteHashMap = new Map();
    noteHashes.getActiveItems().forEach((noteHash, index)=>{
        const value = noteHash.value.toBigInt();
        const arr = noteHashMap.get(value) ?? [];
        arr.push({
            noteHash,
            index
        });
        noteHashMap.set(value, arr);
    });
    const futureNoteHashMap = new ScopedValueCache(futureNoteHashes);
    for(let i = 0; i < noteHashReadRequests.claimedLength; ++i){
        const readRequest = noteHashReadRequests.array[i];
        const pendingNoteHash = noteHashMap.get(readRequest.value.toBigInt())?.find((n)=>isValidNoteHashReadRequest(readRequest, n.noteHash));
        if (pendingNoteHash !== undefined) {
            resetActions.actions[i] = ReadRequestActionEnum.READ_AS_PENDING;
            resetActions.pendingReadHints.push(new PendingReadHint(i, pendingNoteHash.index));
        } else if (!futureNoteHashMap.get(readRequest).find((futureNoteHash)=>isValidNoteHashReadRequest(readRequest, futureNoteHash))) {
            resetActions.actions[i] = ReadRequestActionEnum.READ_AS_SETTLED;
        }
    }
    return resetActions;
}
export async function buildNoteHashReadRequestHintsFromResetActions(oracle, noteHashReadRequests, noteHashes, resetActions, maxPending = MAX_NOTE_HASH_READ_REQUESTS_PER_TX, maxSettled = MAX_NOTE_HASH_READ_REQUESTS_PER_TX) {
    const builder = new NoteHashReadRequestHintsBuilder(maxPending, maxSettled);
    resetActions.pendingReadHints.forEach((hint)=>{
        builder.addPendingReadRequest(hint.readRequestIndex, hint.pendingValueIndex);
    });
    // Collect all settled read requests
    const settledRequests = [];
    for(let i = 0; i < resetActions.actions.length; i++){
        if (resetActions.actions[i] === ReadRequestActionEnum.READ_AS_SETTLED) {
            settledRequests.push({
                index: i,
                readRequest: noteHashReadRequests.array[i]
            });
        }
    }
    // Fetch all membership witnesses in parallel
    const membershipWitnesses = await Promise.all(settledRequests.map(({ readRequest })=>oracle.getNoteHashMembershipWitness(readRequest.value)));
    // Add settled read requests to builder
    for(let i = 0; i < settledRequests.length; i++){
        const membershipWitness = membershipWitnesses[i];
        if (!membershipWitness) {
            throw new Error('Read request is reading an unknown note hash.');
        }
        builder.addSettledReadRequest(settledRequests[i].index, membershipWitness, settledRequests[i].readRequest.value);
    }
    const noteHashMap = new Map();
    noteHashes.getActiveItems().forEach((noteHash, index)=>{
        const value = noteHash.value.toBigInt();
        const arr = noteHashMap.get(value) ?? [];
        arr.push({
            noteHash,
            index
        });
        noteHashMap.set(value, arr);
    });
    return builder.toHints();
}
export async function buildNoteHashReadRequestHints(oracle, noteHashReadRequests, noteHashes, futureNoteHashes, maxPending = MAX_NOTE_HASH_READ_REQUESTS_PER_TX, maxSettled = MAX_NOTE_HASH_READ_REQUESTS_PER_TX) {
    const resetActions = getNoteHashReadRequestResetActions(noteHashReadRequests, noteHashes, futureNoteHashes);
    return await buildNoteHashReadRequestHintsFromResetActions(oracle, noteHashReadRequests, noteHashes, resetActions, maxPending, maxSettled);
}
