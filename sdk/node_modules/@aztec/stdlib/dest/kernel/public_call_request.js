var _computedKey, _computedKey1;
import { COUNTED_PUBLIC_CALL_REQUEST_LENGTH, PUBLIC_CALL_REQUEST_LENGTH } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, FieldReader, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
import { computeCalldataHash } from '../hash/index.js';
_computedKey = inspect.custom;
/**
 * Represents a request to call a public function.
 */ export class PublicCallRequest {
    msgSender;
    contractAddress;
    isStaticCall;
    calldataHash;
    constructor(/**
     * Address of the account which represents the entity who invoked the call.
     */ msgSender, /**
     * The contract address being called.
     */ contractAddress, /**
     * Determines whether the call is modifying state.
     */ isStaticCall, /**
     * Hash of the calldata of the function being called.
     */ calldataHash){
        this.msgSender = msgSender;
        this.contractAddress = contractAddress;
        this.isStaticCall = isStaticCall;
        this.calldataHash = calldataHash;
    }
    static get schema() {
        return z.object({
            msgSender: AztecAddress.schema,
            contractAddress: AztecAddress.schema,
            isStaticCall: z.boolean(),
            calldataHash: schemas.Fr
        }).transform(({ msgSender, contractAddress, isStaticCall, calldataHash })=>{
            return new PublicCallRequest(msgSender, contractAddress, isStaticCall, calldataHash);
        });
    }
    getSize() {
        return this.isEmpty() ? 0 : this.toBuffer().length;
    }
    static from(fields) {
        return new PublicCallRequest(...PublicCallRequest.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.msgSender,
            fields.contractAddress,
            fields.isStaticCall,
            fields.calldataHash
        ];
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new PublicCallRequest(reader.readObject(AztecAddress), reader.readObject(AztecAddress), reader.readBoolean(), reader.readField());
    }
    toFields() {
        const fields = serializeToFields(...PublicCallRequest.getFields(this));
        if (fields.length !== PUBLIC_CALL_REQUEST_LENGTH) {
            throw new Error(`Invalid number of fields for PublicCallRequest. Expected ${PUBLIC_CALL_REQUEST_LENGTH}, got ${fields.length}`);
        }
        return fields;
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PublicCallRequest(reader.readObject(AztecAddress), reader.readObject(AztecAddress), reader.readBoolean(), reader.readObject(Fr));
    }
    toBuffer() {
        return serializeToBuffer(...PublicCallRequest.getFields(this));
    }
    static empty() {
        return new PublicCallRequest(AztecAddress.ZERO, AztecAddress.ZERO, false, Fr.ZERO);
    }
    /**
   * Creates a PublicCallRequest instance from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing PublicCallRequest fields
   * @returns A PublicCallRequest instance
   */ static fromPlainObject(obj) {
        return new PublicCallRequest(AztecAddress.fromPlainObject(obj.msgSender), AztecAddress.fromPlainObject(obj.contractAddress), obj.isStaticCall, Fr.fromPlainObject(obj.calldataHash));
    }
    isEmpty() {
        return this.msgSender.isZero() && this.contractAddress.isZero() && !this.isStaticCall && this.calldataHash.isEmpty();
    }
    [_computedKey]() {
        return `PublicCallRequest {
      msgSender: ${this.msgSender}
      contractAddress: ${this.contractAddress}
      isStaticCall: ${this.isStaticCall}
      calldataHash: ${this.calldataHash}
    }`;
    }
    static async fromCalldata(msgSender, contractAddress, isStaticCall, calldata) {
        const calldataHash = await computeCalldataHash(calldata);
        return new PublicCallRequest(msgSender, contractAddress, isStaticCall, calldataHash);
    }
}
_computedKey1 = inspect.custom;
/**
 * Represents lengths of arrays of public call requests.
 */ export class PublicCallRequestArrayLengths {
    setupCalls;
    appLogicCalls;
    teardownCall;
    constructor(/**
     * Number of setup call requests
     */ setupCalls, /**
     * Number of app logic call requests
     */ appLogicCalls, /**
     * Whether there is a teardown call request
     */ teardownCall){
        this.setupCalls = setupCalls;
        this.appLogicCalls = appLogicCalls;
        this.teardownCall = teardownCall;
    }
    static get schema() {
        return z.object({
            setupCalls: z.number(),
            appLogicCalls: z.number(),
            teardownCall: z.boolean()
        }).transform(({ setupCalls, appLogicCalls, teardownCall })=>{
            return new PublicCallRequestArrayLengths(setupCalls, appLogicCalls, teardownCall);
        });
    }
    static getFields(fields) {
        return [
            fields.setupCalls,
            fields.appLogicCalls,
            fields.teardownCall
        ];
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new PublicCallRequestArrayLengths(reader.readU32(), reader.readU32(), reader.readBoolean());
    }
    toFields() {
        return serializeToFields(...PublicCallRequestArrayLengths.getFields(this));
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PublicCallRequestArrayLengths(reader.readNumber(), reader.readNumber(), reader.readBoolean());
    }
    toBuffer() {
        return serializeToBuffer(...PublicCallRequestArrayLengths.getFields(this));
    }
    static empty() {
        return new PublicCallRequestArrayLengths(0, 0, false);
    }
    /**
   * Creates a PublicCallRequestArrayLengths instance from a plain object without Zod validation.
   * This method is optimized for performance and skips validation, making it suitable
   * for deserializing trusted data (e.g., from C++ via MessagePack).
   * @param obj - Plain object containing PublicCallRequestArrayLengths fields
   * @returns A PublicCallRequestArrayLengths instance
   */ static fromPlainObject(obj) {
        return new PublicCallRequestArrayLengths(obj.setupCalls, obj.appLogicCalls, obj.teardownCall);
    }
    [_computedKey1]() {
        return `PublicCallRequestArrayLengths {
      setupCalls: ${this.setupCalls}
      appLogicCalls: ${this.appLogicCalls}
      teardownCall: ${this.teardownCall}
    }`;
    }
}
export class CountedPublicCallRequest {
    inner;
    counter;
    constructor(inner, counter){
        this.inner = inner;
        this.counter = counter;
    }
    getSize() {
        return this.isEmpty() ? 0 : this.toBuffer().length;
    }
    static getFields(fields) {
        return [
            fields.inner,
            fields.counter
        ];
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new CountedPublicCallRequest(reader.readObject(PublicCallRequest), reader.readU32());
    }
    toFields() {
        const fields = serializeToFields(...CountedPublicCallRequest.getFields(this));
        if (fields.length !== COUNTED_PUBLIC_CALL_REQUEST_LENGTH) {
            throw new Error(`Invalid number of fields for CountedPublicCallRequest. Expected ${COUNTED_PUBLIC_CALL_REQUEST_LENGTH}, got ${fields.length}`);
        }
        return fields;
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new CountedPublicCallRequest(reader.readObject(PublicCallRequest), reader.readNumber());
    }
    toBuffer() {
        return serializeToBuffer(...CountedPublicCallRequest.getFields(this));
    }
    static empty() {
        return new CountedPublicCallRequest(PublicCallRequest.empty(), 0);
    }
    isEmpty() {
        return this.inner.isEmpty() && this.counter == 0;
    }
}
