import { Fr } from '@aztec/foundation/curves/bn254';
import { bufferSchemaFor } from '@aztec/foundation/schemas';
import { BufferReader, bigintToUInt64BE, serializeToBuffer } from '@aztec/foundation/serialize';
import { AztecAddress } from '../aztec-address/index.js';
import { PrivateTxConstantData } from '../tx/private_tx_constant_data.js';
import { PrivateAccumulatedData } from './private_accumulated_data.js';
import { PrivateValidationRequests } from './private_validation_requests.js';
import { PublicCallRequest } from './public_call_request.js';
/**
 * Public inputs to the inner private kernel circuit
 */ export class PrivateKernelCircuitPublicInputs {
    constants;
    minRevertibleSideEffectCounter;
    validationRequests;
    end;
    publicTeardownCallRequest;
    feePayer;
    expirationTimestamp;
    isPrivateOnly;
    claimedFirstNullifier;
    claimedRevertibleCounter;
    constructor(/**
     * Data which is not modified by the circuits.
     */ constants, /**
     * The side effect counter that non-revertible side effects are all beneath.
     */ minRevertibleSideEffectCounter, /**
     * Validation requests accumulated from public functions.
     */ validationRequests, /**
     * Data accumulated from both public and private circuits.
     */ end, /**
     * The call request for the public teardown function
     */ publicTeardownCallRequest, /**
     * The address of the fee payer for the transaction
     */ feePayer, /**
     * The timestamp by which the transaction must be included in a block.
     */ expirationTimestamp, /**
     * Wether this is a private only tx or not
     */ isPrivateOnly, /**
     * The nullifier that will be used for nonce generation
     */ claimedFirstNullifier, /**
     * A claim to the final min revertible side effect counter of a tx.
     */ claimedRevertibleCounter){
        this.constants = constants;
        this.minRevertibleSideEffectCounter = minRevertibleSideEffectCounter;
        this.validationRequests = validationRequests;
        this.end = end;
        this.publicTeardownCallRequest = publicTeardownCallRequest;
        this.feePayer = feePayer;
        this.expirationTimestamp = expirationTimestamp;
        this.isPrivateOnly = isPrivateOnly;
        this.claimedFirstNullifier = claimedFirstNullifier;
        this.claimedRevertibleCounter = claimedRevertibleCounter;
    }
    static get schema() {
        return bufferSchemaFor(PrivateKernelCircuitPublicInputs);
    }
    toJSON() {
        return this.toBuffer();
    }
    toBuffer() {
        return serializeToBuffer(this.constants, this.minRevertibleSideEffectCounter, this.validationRequests, this.end, this.publicTeardownCallRequest, this.feePayer, bigintToUInt64BE(this.expirationTimestamp), this.isPrivateOnly, this.claimedFirstNullifier, this.claimedRevertibleCounter);
    }
    /**
   * Deserializes from a buffer or reader, corresponding to a write in cpp.
   * @param buffer - Buffer or reader to read from.
   * @returns A new instance of PrivateKernelInnerCircuitPublicInputs.
   */ static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PrivateKernelCircuitPublicInputs(reader.readObject(PrivateTxConstantData), reader.readObject(Fr), reader.readObject(PrivateValidationRequests), reader.readObject(PrivateAccumulatedData), reader.readObject(PublicCallRequest), reader.readObject(AztecAddress), reader.readUInt64(), reader.readBoolean(), reader.readObject(Fr), reader.readNumber());
    }
    static empty() {
        return new PrivateKernelCircuitPublicInputs(PrivateTxConstantData.empty(), Fr.zero(), PrivateValidationRequests.empty(), PrivateAccumulatedData.empty(), PublicCallRequest.empty(), AztecAddress.ZERO, 0n, false, Fr.zero(), 0);
    }
}
