import { BlobAccumulator, FinalBlobBatchingChallenges } from '@aztec/blob-lib/types';
import { MAX_CHECKPOINTS_PER_EPOCH } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { EthAddress } from '@aztec/foundation/eth-address';
import { bufferSchemaFor } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { EpochConstantData } from './epoch_constant_data.js';
/**
 * Output of the checkpoint root and checkpoint merge rollup circuits.
 */ export class CheckpointRollupPublicInputs {
    constants;
    previousArchive;
    newArchive;
    previousOutHash;
    newOutHash;
    checkpointHeaderHashes;
    fees;
    startBlobAccumulator;
    endBlobAccumulator;
    finalBlobChallenges;
    constructor(/**
     * Constants for the entire epoch.
     */ constants, /**
     * Archive tree immediately before this checkpoint range.
     */ previousArchive, /**
     * Archive tree after adding this checkpoint range.
     */ newArchive, /**
     * The out hash tree snapshot immediately before this checkpoint range.
     */ previousOutHash, /**
     * The out hash tree snapshot after applying this checkpoint range.
     */ newOutHash, /**
     * The hashes of the headers of the constituent checkpoints.
     */ checkpointHeaderHashes, /**
     * The summed transaction fees and recipients of the constituent checkpoints.
     */ fees, /**
     * Accumulated opening proofs for all blobs before this checkpoint range.
     */ startBlobAccumulator, /**
     * Accumulated opening proofs for all blobs after applying this checkpoint range.
     */ endBlobAccumulator, /**
     * Final values z and gamma, shared across the epoch.
     */ finalBlobChallenges){
        this.constants = constants;
        this.previousArchive = previousArchive;
        this.newArchive = newArchive;
        this.previousOutHash = previousOutHash;
        this.newOutHash = newOutHash;
        this.checkpointHeaderHashes = checkpointHeaderHashes;
        this.fees = fees;
        this.startBlobAccumulator = startBlobAccumulator;
        this.endBlobAccumulator = endBlobAccumulator;
        this.finalBlobChallenges = finalBlobChallenges;
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new CheckpointRollupPublicInputs(reader.readObject(EpochConstantData), reader.readObject(AppendOnlyTreeSnapshot), reader.readObject(AppendOnlyTreeSnapshot), reader.readObject(AppendOnlyTreeSnapshot), reader.readObject(AppendOnlyTreeSnapshot), reader.readArray(MAX_CHECKPOINTS_PER_EPOCH, Fr), reader.readArray(MAX_CHECKPOINTS_PER_EPOCH, FeeRecipient), reader.readObject(BlobAccumulator), reader.readObject(BlobAccumulator), reader.readObject(FinalBlobBatchingChallenges));
    }
    toBuffer() {
        return serializeToBuffer(this.constants, this.previousArchive, this.newArchive, this.previousOutHash, this.newOutHash, this.checkpointHeaderHashes, this.fees, this.startBlobAccumulator, this.endBlobAccumulator, this.finalBlobChallenges);
    }
    toString() {
        return bufferToHex(this.toBuffer());
    }
    static fromString(str) {
        return CheckpointRollupPublicInputs.fromBuffer(hexToBuffer(str));
    }
    /** Returns a buffer representation for JSON serialization. */ toJSON() {
        return this.toBuffer();
    }
    /** Creates an instance from a hex string. */ static get schema() {
        return bufferSchemaFor(CheckpointRollupPublicInputs);
    }
}
export class FeeRecipient {
    recipient;
    value;
    constructor(recipient, value){
        this.recipient = recipient;
        this.value = value;
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new FeeRecipient(reader.readObject(EthAddress), Fr.fromBuffer(reader));
    }
    toBuffer() {
        return serializeToBuffer(this.recipient, this.value);
    }
    static getFields(fields) {
        return [
            fields.recipient,
            fields.value
        ];
    }
    toFields() {
        return serializeToFields(...FeeRecipient.getFields(this));
    }
    static empty() {
        return new FeeRecipient(EthAddress.ZERO, Fr.ZERO);
    }
    isEmpty() {
        return this.value.isZero() && this.recipient.isZero();
    }
    toFriendlyJSON() {
        if (this.isEmpty()) {
            return {};
        }
        return {
            recipient: this.recipient.toString(),
            value: this.value.toString()
        };
    }
    static random() {
        return new FeeRecipient(EthAddress.random(), Fr.random());
    }
}
