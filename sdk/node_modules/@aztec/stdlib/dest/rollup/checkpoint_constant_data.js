var _computedKey;
import { SlotNumber } from '@aztec/foundation/branded-types';
import { Fr } from '@aztec/foundation/curves/bn254';
import { EthAddress } from '@aztec/foundation/eth-address';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { AztecAddress } from '../aztec-address/index.js';
import { GasFees } from '../gas/gas_fees.js';
_computedKey = inspect.custom;
/**
 * Constants that are the same for the entire checkpoint.
 * Used in circuits during rollup proving.
 */ export class CheckpointConstantData {
    chainId;
    version;
    vkTreeRoot;
    protocolContractsHash;
    proverId;
    slotNumber;
    coinbase;
    feeRecipient;
    gasFees;
    constructor(/** ChainId of the rollup. */ chainId, /** Version of the rollup. */ version, /** Root of the verification key tree. */ vkTreeRoot, /** Hash of the protocol contracts list. */ protocolContractsHash, /** Identifier of the prover. */ proverId, /** Slot number of the checkpoint. */ slotNumber, /** Coinbase address of the rollup. */ coinbase, /** Address to receive fees. */ feeRecipient, /** Global gas fees for this checkpoint. */ gasFees){
        this.chainId = chainId;
        this.version = version;
        this.vkTreeRoot = vkTreeRoot;
        this.protocolContractsHash = protocolContractsHash;
        this.proverId = proverId;
        this.slotNumber = slotNumber;
        this.coinbase = coinbase;
        this.feeRecipient = feeRecipient;
        this.gasFees = gasFees;
    }
    static from(fields) {
        return new CheckpointConstantData(...CheckpointConstantData.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.chainId,
            fields.version,
            fields.vkTreeRoot,
            fields.protocolContractsHash,
            fields.proverId,
            fields.slotNumber,
            fields.coinbase,
            fields.feeRecipient,
            fields.gasFees
        ];
    }
    static empty() {
        return new CheckpointConstantData(Fr.ZERO, Fr.ZERO, Fr.ZERO, Fr.ZERO, Fr.ZERO, SlotNumber.ZERO, EthAddress.ZERO, AztecAddress.ZERO, GasFees.empty());
    }
    toBuffer() {
        return serializeToBuffer(this.chainId, this.version, this.vkTreeRoot, this.protocolContractsHash, this.proverId, new Fr(this.slotNumber), this.coinbase, this.feeRecipient, this.gasFees);
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new CheckpointConstantData(Fr.fromBuffer(reader), Fr.fromBuffer(reader), Fr.fromBuffer(reader), Fr.fromBuffer(reader), Fr.fromBuffer(reader), SlotNumber(Fr.fromBuffer(reader).toNumber()), reader.readObject(EthAddress), reader.readObject(AztecAddress), reader.readObject(GasFees));
    }
    /**
   * Returns the slot number as a SlotNumber branded type.
   * @deprecated Use slotNumber directly instead.
   */ getSlotNumber() {
        return this.slotNumber;
    }
    toInspect() {
        return {
            chainId: this.chainId.toNumber(),
            version: this.version.toNumber(),
            vkTreeRoot: this.vkTreeRoot.toString(),
            protocolContractsHash: this.protocolContractsHash.toString(),
            proverId: this.proverId.toString(),
            slotNumber: this.slotNumber,
            coinbase: this.coinbase.toString(),
            feeRecipient: this.feeRecipient.toString(),
            gasFees: this.gasFees.toInspect()
        };
    }
    [_computedKey]() {
        return `CheckpointConstantData ${inspect(this.toInspect())}`;
    }
}
