import { SpongeBlob } from '@aztec/blob-lib/types';
import { ARCHIVE_HEIGHT, MAX_CONTRACT_CLASS_LOGS_PER_TX } from '@aztec/constants';
import { makeTuple } from '@aztec/foundation/array';
import { Fr } from '@aztec/foundation/curves/bn254';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
import { ContractClassLogFields } from '../logs/index.js';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { PublicDataTreeLeafPreimage } from '../trees/public_data_leaf.js';
import { PartialStateReference } from '../tx/partial_state_reference.js';
import { BlockConstantData } from './block_constant_data.js';
import { TreeSnapshotDiffHints } from './tree_snapshot_diff_hints.js';
export class PrivateBaseRollupHints {
    start;
    startSpongeBlob;
    treeSnapshotDiffHints;
    feePayerBalanceLeafPreimage;
    anchorBlockArchiveSiblingPath;
    contractClassLogsFields;
    constants;
    constructor(/**
     * Partial state reference at the start of the rollup.
     */ start, /**
     * Sponge state to absorb blob inputs at the start of the rollup.
     */ startSpongeBlob, /**
     * Hints used while proving state diff validity.
     */ treeSnapshotDiffHints, /**
     * Public data tree leaf preimage for accessing the balance of the fee payer.
     */ feePayerBalanceLeafPreimage, /**
     * Membership witnesses of blocks referred by each of the 2 kernels.
     */ anchorBlockArchiveSiblingPath, /**
     * Preimages to the kernel's contractClassLogsHashes.
     */ contractClassLogsFields, /**
     * Data which is not modified by the base rollup circuit.
     */ constants){
        this.start = start;
        this.startSpongeBlob = startSpongeBlob;
        this.treeSnapshotDiffHints = treeSnapshotDiffHints;
        this.feePayerBalanceLeafPreimage = feePayerBalanceLeafPreimage;
        this.anchorBlockArchiveSiblingPath = anchorBlockArchiveSiblingPath;
        this.contractClassLogsFields = contractClassLogsFields;
        this.constants = constants;
    }
    static from(fields) {
        return new PrivateBaseRollupHints(...PrivateBaseRollupHints.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.start,
            fields.startSpongeBlob,
            fields.treeSnapshotDiffHints,
            fields.feePayerBalanceLeafPreimage,
            fields.anchorBlockArchiveSiblingPath,
            fields.contractClassLogsFields,
            fields.constants
        ];
    }
    /**
   * Serializes the inputs to a buffer.
   * @returns The inputs serialized to a buffer.
   */ toBuffer() {
        return serializeToBuffer(...PrivateBaseRollupHints.getFields(this));
    }
    /**
   * Serializes the inputs to a hex string.
   * @returns The instance serialized to a hex string.
   */ toString() {
        return bufferToHex(this.toBuffer());
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PrivateBaseRollupHints(reader.readObject(PartialStateReference), reader.readObject(SpongeBlob), reader.readObject(TreeSnapshotDiffHints), reader.readObject(PublicDataTreeLeafPreimage), reader.readArray(ARCHIVE_HEIGHT, Fr), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, ()=>reader.readObject(ContractClassLogFields)), reader.readObject(BlockConstantData));
    }
    static fromString(str) {
        return PrivateBaseRollupHints.fromBuffer(hexToBuffer(str));
    }
    static empty() {
        return new PrivateBaseRollupHints(PartialStateReference.empty(), SpongeBlob.empty(), TreeSnapshotDiffHints.empty(), PublicDataTreeLeafPreimage.empty(), makeTuple(ARCHIVE_HEIGHT, Fr.zero), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, ContractClassLogFields.empty), BlockConstantData.empty());
    }
}
export class PublicBaseRollupHints {
    startSpongeBlob;
    lastArchive;
    anchorBlockArchiveSiblingPath;
    contractClassLogsFields;
    constructor(/**
     * Sponge state to absorb blob inputs at the start of the rollup.
     */ startSpongeBlob, /**
     * Archive tree snapshot at the very beginning of the block containing this base rollup.
     */ lastArchive, /**
     * Membership witnesses of blocks referred by each of the 2 kernels.
     */ anchorBlockArchiveSiblingPath, /**
     * Preimages to the kernel's contractClassLogsHashes.
     */ contractClassLogsFields){
        this.startSpongeBlob = startSpongeBlob;
        this.lastArchive = lastArchive;
        this.anchorBlockArchiveSiblingPath = anchorBlockArchiveSiblingPath;
        this.contractClassLogsFields = contractClassLogsFields;
    }
    static from(fields) {
        return new PublicBaseRollupHints(...PublicBaseRollupHints.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.startSpongeBlob,
            fields.lastArchive,
            fields.anchorBlockArchiveSiblingPath,
            fields.contractClassLogsFields
        ];
    }
    /**
   * Serializes the inputs to a buffer.
   * @returns The inputs serialized to a buffer.
   */ toBuffer() {
        return serializeToBuffer(...PublicBaseRollupHints.getFields(this));
    }
    /**
   * Serializes the inputs to a hex string.
   * @returns The instance serialized to a hex string.
   */ toString() {
        return bufferToHex(this.toBuffer());
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PublicBaseRollupHints(reader.readObject(SpongeBlob), reader.readObject(AppendOnlyTreeSnapshot), reader.readArray(ARCHIVE_HEIGHT, Fr), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, ()=>reader.readObject(ContractClassLogFields)));
    }
    static fromString(str) {
        return PublicBaseRollupHints.fromBuffer(hexToBuffer(str));
    }
    static empty() {
        return new PublicBaseRollupHints(SpongeBlob.empty(), AppendOnlyTreeSnapshot.empty(), makeTuple(ARCHIVE_HEIGHT, Fr.zero), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, ContractClassLogFields.empty));
    }
}
