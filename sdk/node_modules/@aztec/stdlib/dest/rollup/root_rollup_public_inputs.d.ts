import { FinalBlobAccumulator } from '@aztec/blob-lib/types';
import { MAX_CHECKPOINTS_PER_EPOCH } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { BufferReader, type Tuple } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { FeeRecipient } from './checkpoint_rollup_public_inputs.js';
import { EpochConstantData } from './epoch_constant_data.js';
/**
 * Represents public inputs of the root rollup circuit.
 *
 * NOTE: in practice, we'll hash all of this up into a single public input, for cheap onchain verification.
 */
export declare class RootRollupPublicInputs {
    /** Root of the archive tree before this rollup is processed */
    previousArchiveRoot: Fr;
    /** Root of the archive tree after this rollup is processed */
    endArchiveRoot: Fr;
    /**
     * Root of the balanced merkle tree consisting of the out hashes of all checkpoints in this epoch.
     * The out hash of the first checkpoint in the epoch is inserted at index 0, the second at index 1, and so on.
     */
    outHash: Fr;
    /** Hashes of checkpoint headers for this rollup. */
    checkpointHeaderHashes: Tuple<Fr, typeof MAX_CHECKPOINTS_PER_EPOCH>;
    fees: Tuple<FeeRecipient, typeof MAX_CHECKPOINTS_PER_EPOCH>;
    constants: EpochConstantData;
    blobPublicInputs: FinalBlobAccumulator;
    constructor(
    /** Root of the archive tree before this rollup is processed */
    previousArchiveRoot: Fr, 
    /** Root of the archive tree after this rollup is processed */
    endArchiveRoot: Fr, 
    /**
     * Root of the balanced merkle tree consisting of the out hashes of all checkpoints in this epoch.
     * The out hash of the first checkpoint in the epoch is inserted at index 0, the second at index 1, and so on.
     */
    outHash: Fr, 
    /** Hashes of checkpoint headers for this rollup. */
    checkpointHeaderHashes: Tuple<Fr, typeof MAX_CHECKPOINTS_PER_EPOCH>, fees: Tuple<FeeRecipient, typeof MAX_CHECKPOINTS_PER_EPOCH>, constants: EpochConstantData, blobPublicInputs: FinalBlobAccumulator);
    static getFields(fields: FieldsOf<RootRollupPublicInputs>): readonly [Fr, Fr, Fr, [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], [FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient, FeeRecipient], EpochConstantData, FinalBlobAccumulator];
    toBuffer(): Buffer<ArrayBufferLike>;
    toFields(): Fr[];
    static from(fields: FieldsOf<RootRollupPublicInputs>): RootRollupPublicInputs;
    /**
     * Deserializes a buffer into a `RootRollupPublicInputs` object.
     * @param buffer - The buffer to deserialize.
     * @returns The deserialized `RootRollupPublicInputs` object.
     */
    static fromBuffer(buffer: Buffer | BufferReader): RootRollupPublicInputs;
    toString(): `0x${string}`;
    static fromString(str: string): RootRollupPublicInputs;
    /** Returns a representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a string. */
    static get schema(): import("zod").ZodType<RootRollupPublicInputs, any, string>;
    /** Creates a random instance. Used for testing only - will not prove/verify. */
    static random(): RootRollupPublicInputs;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm9vdF9yb2xsdXBfcHVibGljX2lucHV0cy5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3JvbGx1cC9yb290X3JvbGx1cF9wdWJsaWNfaW5wdXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzdELE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTdELE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUVwRCxPQUFPLEVBQUUsWUFBWSxFQUFFLEtBQUssS0FBSyxFQUF3QyxNQUFNLDZCQUE2QixDQUFDO0FBRTdHLE9BQU8sS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRXhELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUNwRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUU3RDs7OztHQUlHO0FBQ0gscUJBQWEsc0JBQXNCO0lBRS9CLCtEQUErRDtJQUN4RCxtQkFBbUIsRUFBRSxFQUFFO0lBQzlCLDhEQUE4RDtJQUN2RCxjQUFjLEVBQUUsRUFBRTtJQUN6Qjs7O09BR0c7SUFDSSxPQUFPLEVBQUUsRUFBRTtJQUNsQixvREFBb0Q7SUFDN0Msc0JBQXNCLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxPQUFPLHlCQUF5QixDQUFDO0lBQ25FLElBQUksRUFBRSxLQUFLLENBQUMsWUFBWSxFQUFFLE9BQU8seUJBQXlCLENBQUM7SUFDM0QsU0FBUyxFQUFFLGlCQUFpQjtJQUM1QixnQkFBZ0IsRUFBRSxvQkFBb0I7SUFkL0M7SUFDRSwrREFBK0Q7SUFDeEQsbUJBQW1CLEVBQUUsRUFBRTtJQUM5Qiw4REFBOEQ7SUFDdkQsY0FBYyxFQUFFLEVBQUU7SUFDekI7OztPQUdHO0lBQ0ksT0FBTyxFQUFFLEVBQUU7SUFDbEIsb0RBQW9EO0lBQzdDLHNCQUFzQixFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsT0FBTyx5QkFBeUIsQ0FBQyxFQUNuRSxJQUFJLEVBQUUsS0FBSyxDQUFDLFlBQVksRUFBRSxPQUFPLHlCQUF5QixDQUFDLEVBQzNELFNBQVMsRUFBRSxpQkFBaUIsRUFDNUIsZ0JBQWdCLEVBQUUsb0JBQW9CLEVBQzNDO0lBRUosTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLHNCQUFzQixDQUFDLHNvQkFVeEQ7SUFFRCxRQUFRLDRCQUVQO0lBRUQsUUFBUSxJQUFJLEVBQUUsRUFBRSxDQUVmO0lBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsc0JBQXNCLENBRTVFO0lBRUQ7Ozs7T0FJRztJQUNILE9BQWMsVUFBVSxDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUcsWUFBWSxHQUFHLHNCQUFzQixDQVc5RTtJQUVELFFBQVEsa0JBRVA7SUFFRCxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxNQUFNLDBCQUU1QjtJQUVELHVEQUF1RDtJQUN2RCxNQUFNLDRCQUVMO0lBRUQseUNBQXlDO0lBQ3pDLE1BQU0sS0FBSyxNQUFNLCtEQUVoQjtJQUVELGdGQUFnRjtJQUNoRixNQUFNLENBQUMsTUFBTSwyQkFVWjtDQUNGIn0=