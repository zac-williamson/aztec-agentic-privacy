import { BlobAccumulator, FinalBlobBatchingChallenges } from '@aztec/blob-lib/types';
import { MAX_CHECKPOINTS_PER_EPOCH } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { EthAddress } from '@aztec/foundation/eth-address';
import { BufferReader, type Tuple } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { EpochConstantData } from './epoch_constant_data.js';
/**
 * Output of the checkpoint root and checkpoint merge rollup circuits.
 */
export declare class CheckpointRollupPublicInputs {
    /**
     * Constants for the entire epoch.
     */
    constants: EpochConstantData;
    /**
     * Archive tree immediately before this checkpoint range.
     */
    previousArchive: AppendOnlyTreeSnapshot;
    /**
     * Archive tree after adding this checkpoint range.
     */
    newArchive: AppendOnlyTreeSnapshot;
    /**
     * The out hash tree snapshot immediately before this checkpoint range.
     */
    previousOutHash: AppendOnlyTreeSnapshot;
    /**
     * The out hash tree snapshot after applying this checkpoint range.
     */
    newOutHash: AppendOnlyTreeSnapshot;
    /**
     * The hashes of the headers of the constituent checkpoints.
     */
    checkpointHeaderHashes: Tuple<Fr, typeof MAX_CHECKPOINTS_PER_EPOCH>;
    /**
     * The summed transaction fees and recipients of the constituent checkpoints.
     */
    fees: Tuple<FeeRecipient, typeof MAX_CHECKPOINTS_PER_EPOCH>;
    /**
     * Accumulated opening proofs for all blobs before this checkpoint range.
     */
    startBlobAccumulator: BlobAccumulator;
    /**
     * Accumulated opening proofs for all blobs after applying this checkpoint range.
     */
    endBlobAccumulator: BlobAccumulator;
    /**
     * Final values z and gamma, shared across the epoch.
     */
    finalBlobChallenges: FinalBlobBatchingChallenges;
    constructor(
    /**
     * Constants for the entire epoch.
     */
    constants: EpochConstantData, 
    /**
     * Archive tree immediately before this checkpoint range.
     */
    previousArchive: AppendOnlyTreeSnapshot, 
    /**
     * Archive tree after adding this checkpoint range.
     */
    newArchive: AppendOnlyTreeSnapshot, 
    /**
     * The out hash tree snapshot immediately before this checkpoint range.
     */
    previousOutHash: AppendOnlyTreeSnapshot, 
    /**
     * The out hash tree snapshot after applying this checkpoint range.
     */
    newOutHash: AppendOnlyTreeSnapshot, 
    /**
     * The hashes of the headers of the constituent checkpoints.
     */
    checkpointHeaderHashes: Tuple<Fr, typeof MAX_CHECKPOINTS_PER_EPOCH>, 
    /**
     * The summed transaction fees and recipients of the constituent checkpoints.
     */
    fees: Tuple<FeeRecipient, typeof MAX_CHECKPOINTS_PER_EPOCH>, 
    /**
     * Accumulated opening proofs for all blobs before this checkpoint range.
     */
    startBlobAccumulator: BlobAccumulator, 
    /**
     * Accumulated opening proofs for all blobs after applying this checkpoint range.
     */
    endBlobAccumulator: BlobAccumulator, 
    /**
     * Final values z and gamma, shared across the epoch.
     */
    finalBlobChallenges: FinalBlobBatchingChallenges);
    static fromBuffer(buffer: Buffer | BufferReader): CheckpointRollupPublicInputs;
    toBuffer(): Buffer<ArrayBufferLike>;
    toString(): `0x${string}`;
    static fromString(str: string): CheckpointRollupPublicInputs;
    /** Returns a buffer representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string. */
    static get schema(): import("zod").ZodType<CheckpointRollupPublicInputs, any, string>;
}
export declare class FeeRecipient {
    recipient: EthAddress;
    value: Fr;
    constructor(recipient: EthAddress, value: Fr);
    static fromBuffer(buffer: Buffer | BufferReader): FeeRecipient;
    toBuffer(): Buffer<ArrayBufferLike>;
    static getFields(fields: FieldsOf<FeeRecipient>): readonly [EthAddress, Fr];
    toFields(): Fr[];
    static empty(): FeeRecipient;
    isEmpty(): boolean;
    toFriendlyJSON(): {
        recipient?: undefined;
        value?: undefined;
    } | {
        recipient: `0x${string}`;
        value: `0x${string}`;
    };
    static random(): FeeRecipient;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2twb2ludF9yb2xsdXBfcHVibGljX2lucHV0cy5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3JvbGx1cC9jaGVja3BvaW50X3JvbGx1cF9wdWJsaWNfaW5wdXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxlQUFlLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNyRixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUM3RCxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBRTNELE9BQU8sRUFBRSxZQUFZLEVBQUUsS0FBSyxLQUFLLEVBQXdDLE1BQU0sNkJBQTZCLENBQUM7QUFFN0csT0FBTyxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFeEQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFDL0UsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFN0Q7O0dBRUc7QUFDSCxxQkFBYSw0QkFBNEI7SUFFckM7O09BRUc7SUFDSSxTQUFTLEVBQUUsaUJBQWlCO0lBQ25DOztPQUVHO0lBQ0ksZUFBZSxFQUFFLHNCQUFzQjtJQUM5Qzs7T0FFRztJQUNJLFVBQVUsRUFBRSxzQkFBc0I7SUFDekM7O09BRUc7SUFDSSxlQUFlLEVBQUUsc0JBQXNCO0lBQzlDOztPQUVHO0lBQ0ksVUFBVSxFQUFFLHNCQUFzQjtJQUN6Qzs7T0FFRztJQUNJLHNCQUFzQixFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsT0FBTyx5QkFBeUIsQ0FBQztJQUMxRTs7T0FFRztJQUNJLElBQUksRUFBRSxLQUFLLENBQUMsWUFBWSxFQUFFLE9BQU8seUJBQXlCLENBQUM7SUFDbEU7O09BRUc7SUFDSSxvQkFBb0IsRUFBRSxlQUFlO0lBQzVDOztPQUVHO0lBQ0ksa0JBQWtCLEVBQUUsZUFBZTtJQUMxQzs7T0FFRztJQUNJLG1CQUFtQixFQUFFLDJCQUEyQjtJQXhDekQ7SUFDRTs7T0FFRztJQUNJLFNBQVMsRUFBRSxpQkFBaUI7SUFDbkM7O09BRUc7SUFDSSxlQUFlLEVBQUUsc0JBQXNCO0lBQzlDOztPQUVHO0lBQ0ksVUFBVSxFQUFFLHNCQUFzQjtJQUN6Qzs7T0FFRztJQUNJLGVBQWUsRUFBRSxzQkFBc0I7SUFDOUM7O09BRUc7SUFDSSxVQUFVLEVBQUUsc0JBQXNCO0lBQ3pDOztPQUVHO0lBQ0ksc0JBQXNCLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxPQUFPLHlCQUF5QixDQUFDO0lBQzFFOztPQUVHO0lBQ0ksSUFBSSxFQUFFLEtBQUssQ0FBQyxZQUFZLEVBQUUsT0FBTyx5QkFBeUIsQ0FBQztJQUNsRTs7T0FFRztJQUNJLG9CQUFvQixFQUFFLGVBQWU7SUFDNUM7O09BRUc7SUFDSSxrQkFBa0IsRUFBRSxlQUFlO0lBQzFDOztPQUVHO0lBQ0ksbUJBQW1CLEVBQUUsMkJBQTJCLEVBQ3JEO0lBRUosTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxHQUFHLFlBQVksZ0NBYzlDO0lBRUQsUUFBUSw0QkFhUDtJQUVELFFBQVEsa0JBRVA7SUFFRCxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxNQUFNLGdDQUU1QjtJQUVELDhEQUE4RDtJQUM5RCxNQUFNLDRCQUVMO0lBRUQsNkNBQTZDO0lBQzdDLE1BQU0sS0FBSyxNQUFNLHFFQUVoQjtDQUNGO0FBRUQscUJBQWEsWUFBWTtJQUVkLFNBQVMsRUFBRSxVQUFVO0lBQ3JCLEtBQUssRUFBRSxFQUFFO0lBRmxCLFlBQ1MsU0FBUyxFQUFFLFVBQVUsRUFDckIsS0FBSyxFQUFFLEVBQUUsRUFDZDtJQUVKLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxZQUFZLEdBQUcsWUFBWSxDQUc3RDtJQUVELFFBQVEsNEJBRVA7SUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsWUFBWSxDQUFDLDZCQUU5QztJQUVELFFBQVEsU0FFUDtJQUVELE1BQU0sQ0FBQyxLQUFLLGlCQUVYO0lBRUQsT0FBTyxZQUVOO0lBRUQsY0FBYzs7Ozs7O01BS2I7SUFFRCxNQUFNLENBQUMsTUFBTSxpQkFFWjtDQUNGIn0=