import { Fr } from '@aztec/foundation/curves/bn254';
import { BufferReader } from '@aztec/foundation/serialize';
import { Proof } from './proof.js';
/**
 * The Recursive proof class is a wrapper around the circuit's proof.
 * We store the proof in 2 forms for convenience. The first is in the 'fields' format.
 * This is a list of fields, for which there are distinct lengths based on the level of recursion.
 * This 'fields' version does not contain the circuits public inputs
 * We also store the raw binary proof which van be directly verified.
 *
 * The 'fieldsValid' member is set to false in the case where this object is constructed solely from the 'binary' proof
 * This is usually when the proof has been received from clients and signals to provers that the 'fields' version needs to be generated
 */
export declare class RecursiveProof<N extends number> {
    /**
     * Holds the serialized proof data in an array of fields, this is without the public inputs
     */
    proof: Fr[];
    /**
     * Holds the serialized proof data in a binary buffer, this contains the public inputs
     */
    binaryProof: Proof;
    /**
     * This flag determines if the 'proof' member is valid, or if we need to generate it from the 'binaryProof' first
     */
    fieldsValid: boolean;
    proofLength: N;
    constructor(
    /**
     * Holds the serialized proof data in an array of fields, this is without the public inputs
     */
    proof: Fr[], 
    /**
     * Holds the serialized proof data in a binary buffer, this contains the public inputs
     */
    binaryProof: Proof, 
    /**
     * This flag determines if the 'proof' member is valid, or if we need to generate it from the 'binaryProof' first
     */
    fieldsValid: boolean, proofLength: N);
    /**
     * Create a Proof from a Buffer or BufferReader.
     * Expects a length-encoding.
     *
     * @param buffer - A Buffer or BufferReader containing the length-encoded proof data.
     * @returns A Proof instance containing the decoded proof data.
     */
    static fromBuffer<N extends number>(buffer: Buffer | BufferReader, expectedSize?: N): RecursiveProof<N>;
    /**
     * Convert the Proof instance to a custom Buffer format.
     * This function serializes the Proof's buffer length and data sequentially into a new Buffer.
     *
     * @returns A Buffer containing the serialized proof data in custom format.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Serialize the Proof instance to a hex string.
     * @returns The hex string representation of the proof data.
     */
    toString(): `0x${string}`;
    /**
     * Deserialize a Proof instance from a hex string.
     * @param str - A hex string to deserialize from.
     * @returns - A new Proof instance.
     */
    static fromString<N extends number>(str: string, expectedSize?: N): RecursiveProof<N>;
    /** Returns a buffer representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string with expected size. */
    static schemaFor<N extends number>(expectedSize?: N): import("zod").ZodEffects<import("@aztec/foundation/schemas").ZodFor<Buffer<ArrayBufferLike>>, RecursiveProof<N>, any>;
}
/**
 * Makes an empty proof.
 * Note: Used for local devnet milestone where we are not proving anything yet.
 * @returns The empty "proof".
 */
export declare function makeEmptyRecursiveProof<N extends number>(size: N): RecursiveProof<N>;
export declare function makeRecursiveProof<PROOF_LENGTH extends number>(size: PROOF_LENGTH, seed?: number): RecursiveProof<PROOF_LENGTH>;
/**
 * Makes an instance of the recursive proof from a binary only proof
 * @returns The proof object
 */
export declare function makeRecursiveProofFromBinary<PROOF_LENGTH extends number>(proof: Proof, size: PROOF_LENGTH): RecursiveProof<PROOF_LENGTH>;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjdXJzaXZlX3Byb29mLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcHJvb2ZzL3JlY3Vyc2l2ZV9wcm9vZi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFFcEQsT0FBTyxFQUFFLFlBQVksRUFBcUIsTUFBTSw2QkFBNkIsQ0FBQztBQUc5RSxPQUFPLEVBQUUsS0FBSyxFQUFrQixNQUFNLFlBQVksQ0FBQztBQUVuRDs7Ozs7Ozs7O0dBU0c7QUFDSCxxQkFBYSxjQUFjLENBQUMsQ0FBQyxTQUFTLE1BQU07SUFFeEM7O09BRUc7SUFDSSxLQUFLLEVBQUUsRUFBRSxFQUFFO0lBRWxCOztPQUVHO0lBQ0ksV0FBVyxFQUFFLEtBQUs7SUFDekI7O09BRUc7SUFDSSxXQUFXLEVBQUUsT0FBTztJQUNwQixXQUFXLEVBQUUsQ0FBQztJQWR2QjtJQUNFOztPQUVHO0lBQ0ksS0FBSyxFQUFFLEVBQUUsRUFBRTtJQUVsQjs7T0FFRztJQUNJLFdBQVcsRUFBRSxLQUFLO0lBQ3pCOztPQUVHO0lBQ0ksV0FBVyxFQUFFLE9BQU8sRUFDcEIsV0FBVyxFQUFFLENBQUMsRUFLdEI7SUFFRDs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsU0FBUyxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sR0FBRyxZQUFZLEVBQUUsWUFBWSxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FZdEc7SUFFRDs7Ozs7T0FLRztJQUNJLFFBQVEsNEJBRWQ7SUFFRDs7O09BR0c7SUFDSSxRQUFRLGtCQUVkO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxTQUFTLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLFlBQVksQ0FBQyxFQUFFLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBRXBGO0lBRUQsOERBQThEO0lBQzlELE1BQU0sNEJBRUw7SUFFRCxnRUFBZ0U7SUFDaEUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFNBQVMsTUFBTSxFQUFFLFlBQVksQ0FBQyxFQUFFLENBQUMseUhBRWxEO0NBQ0Y7QUFFRDs7OztHQUlHO0FBQ0gsd0JBQWdCLHVCQUF1QixDQUFDLENBQUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMscUJBRWhFO0FBRUQsd0JBQWdCLGtCQUFrQixDQUFDLFlBQVksU0FBUyxNQUFNLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxJQUFJLFNBQUksZ0NBTzNGO0FBRUQ7OztHQUdHO0FBQ0gsd0JBQWdCLDRCQUE0QixDQUFDLFlBQVksU0FBUyxNQUFNLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsWUFBWSxnQ0FFekcifQ==