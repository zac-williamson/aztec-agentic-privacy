import type { CHONK_PROOF_LENGTH, RECURSIVE_PROOF_LENGTH, RECURSIVE_ROLLUP_HONK_PROOF_LENGTH } from '@aztec/constants';
import { BufferReader, type Bufferable } from '@aztec/foundation/serialize';
import { RecursiveProof } from '../proofs/recursive_proof.js';
import { VkData } from '../vks/index.js';
/**
 * Represents the data of a recursive proof.
 */
export declare class ProofData<T extends Bufferable, PROOF_LENGTH extends number> {
    publicInputs: T;
    proof: RecursiveProof<PROOF_LENGTH>;
    vkData: VkData;
    constructor(publicInputs: T, proof: RecursiveProof<PROOF_LENGTH>, vkData: VkData);
    toBuffer(): Buffer;
    static fromBuffer<T extends Bufferable, PROOF_LENGTH extends number>(buffer: Buffer | BufferReader, publicInputs: {
        fromBuffer: (reader: BufferReader) => T;
    }): ProofData<T, PROOF_LENGTH>;
}
/**
 * Represents the data of a recursive proof for a circuit with a fixed verification key.
 */
export declare class ProofDataForFixedVk<T extends Bufferable, PROOF_LENGTH extends number> {
    publicInputs: T;
    proof: RecursiveProof<PROOF_LENGTH>;
    constructor(publicInputs: T, proof: RecursiveProof<PROOF_LENGTH>);
    toBuffer(): Buffer;
    static fromBuffer<T extends Bufferable, PROOF_LENGTH extends number>(buffer: Buffer | BufferReader, publicInputs: {
        fromBuffer: (reader: BufferReader) => T;
    }): ProofDataForFixedVk<T, PROOF_LENGTH>;
}
export type ChonkProofData<T extends Bufferable> = ProofData<T, typeof CHONK_PROOF_LENGTH>;
export type UltraHonkProofData<T extends Bufferable> = ProofData<T, typeof RECURSIVE_PROOF_LENGTH>;
export type RollupHonkProofData<T extends Bufferable> = ProofData<T, typeof RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvb2ZfZGF0YS5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Byb29mcy9wcm9vZl9kYXRhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxFQUFFLGtCQUFrQixFQUFFLHNCQUFzQixFQUFFLGtDQUFrQyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDdkgsT0FBTyxFQUFFLFlBQVksRUFBRSxLQUFLLFVBQVUsRUFBcUIsTUFBTSw2QkFBNkIsQ0FBQztBQUUvRixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDOUQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXpDOztHQUVHO0FBQ0gscUJBQWEsU0FBUyxDQUFDLENBQUMsU0FBUyxVQUFVLEVBQUUsWUFBWSxTQUFTLE1BQU07SUFFN0QsWUFBWSxFQUFFLENBQUM7SUFDZixLQUFLLEVBQUUsY0FBYyxDQUFDLFlBQVksQ0FBQztJQUNuQyxNQUFNLEVBQUUsTUFBTTtJQUh2QixZQUNTLFlBQVksRUFBRSxDQUFDLEVBQ2YsS0FBSyxFQUFFLGNBQWMsQ0FBQyxZQUFZLENBQUMsRUFDbkMsTUFBTSxFQUFFLE1BQU0sRUFDbkI7SUFFRyxRQUFRLElBQUksTUFBTSxDQUV4QjtJQUVELE9BQWMsVUFBVSxDQUFDLENBQUMsU0FBUyxVQUFVLEVBQUUsWUFBWSxTQUFTLE1BQU0sRUFDeEUsTUFBTSxFQUFFLE1BQU0sR0FBRyxZQUFZLEVBQzdCLFlBQVksRUFBRTtRQUNaLFVBQVUsRUFBRSxDQUFDLE1BQU0sRUFBRSxZQUFZLEtBQUssQ0FBQyxDQUFDO0tBQ3pDLEdBQ0EsU0FBUyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FHNUI7Q0FDRjtBQUVEOztHQUVHO0FBQ0gscUJBQWEsbUJBQW1CLENBQUMsQ0FBQyxTQUFTLFVBQVUsRUFBRSxZQUFZLFNBQVMsTUFBTTtJQUV2RSxZQUFZLEVBQUUsQ0FBQztJQUNmLEtBQUssRUFBRSxjQUFjLENBQUMsWUFBWSxDQUFDO0lBRjVDLFlBQ1MsWUFBWSxFQUFFLENBQUMsRUFDZixLQUFLLEVBQUUsY0FBYyxDQUFDLFlBQVksQ0FBQyxFQUN4QztJQUVHLFFBQVEsSUFBSSxNQUFNLENBRXhCO0lBRUQsT0FBYyxVQUFVLENBQUMsQ0FBQyxTQUFTLFVBQVUsRUFBRSxZQUFZLFNBQVMsTUFBTSxFQUN4RSxNQUFNLEVBQUUsTUFBTSxHQUFHLFlBQVksRUFDN0IsWUFBWSxFQUFFO1FBQ1osVUFBVSxFQUFFLENBQUMsTUFBTSxFQUFFLFlBQVksS0FBSyxDQUFDLENBQUM7S0FDekMsR0FDQSxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBR3RDO0NBQ0Y7QUFFRCxNQUFNLE1BQU0sY0FBYyxDQUFDLENBQUMsU0FBUyxVQUFVLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLGtCQUFrQixDQUFDLENBQUM7QUFFM0YsTUFBTSxNQUFNLGtCQUFrQixDQUFDLENBQUMsU0FBUyxVQUFVLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLHNCQUFzQixDQUFDLENBQUM7QUFFbkcsTUFBTSxNQUFNLG1CQUFtQixDQUFDLENBQUMsU0FBUyxVQUFVLElBQUksU0FBUyxDQUFDLENBQUMsRUFBRSxPQUFPLGtDQUFrQyxDQUFDLENBQUMifQ==