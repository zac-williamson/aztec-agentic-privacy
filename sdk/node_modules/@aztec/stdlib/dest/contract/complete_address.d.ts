import { Fr } from '@aztec/foundation/curves/bn254';
import { BufferReader } from '@aztec/foundation/serialize';
import { AztecAddress } from '../aztec-address/index.js';
import { PublicKeys } from '../keys/public_keys.js';
import { computePartialAddress } from './contract_address.js';
import type { PartialAddress } from './partial_address.js';
/**
 * A complete address is a combination of an Aztec address, a public key and a partial address.
 *
 * @remarks We have introduced this type because it is common that these 3 values are used together. They are commonly
 *          used together because it is the information needed to send user a note.
 * @remarks See the link below for details about how address is computed:
 *          https://github.com/AztecProtocol/aztec-packages/blob/master/docs/docs/concepts/foundation/accounts/keys.md#addresses-partial-addresses-and-public-keys
 */
export declare class CompleteAddress {
    /** Contract address (typically of an account contract) */
    address: AztecAddress;
    /** User public keys */
    publicKeys: PublicKeys;
    /** Partial key corresponding to the public key to the address. */
    partialAddress: PartialAddress;
    private constructor();
    static create(address: AztecAddress, publicKeys: PublicKeys, partialAddress: PartialAddress): Promise<CompleteAddress>;
    /** Size in bytes of an instance */
    static readonly SIZE_IN_BYTES: number;
    static get schema(): import("zod").ZodType<never, any, string>;
    toJSON(): string;
    static random(): Promise<CompleteAddress>;
    static fromSecretKeyAndPartialAddress(secretKey: Fr, partialAddress: Fr): Promise<CompleteAddress>;
    getPreaddress(): Promise<Fr>;
    static fromSecretKeyAndInstance(secretKey: Fr, instance: Parameters<typeof computePartialAddress>[0]): Promise<CompleteAddress>;
    /** Throws if the address is not correctly derived from the public key and partial address.*/
    validate(): Promise<void>;
    /**
     * Gets a readable string representation of the complete address.
     * @returns A readable string representation of the complete address.
     */
    toReadableString(): string;
    /**
     * Determines if this CompleteAddress instance is equal to the given CompleteAddress instance.
     * Equality is based on the content of their respective buffers.
     *
     * @param other - The CompleteAddress instance to compare against.
     * @returns True if the buffers of both instances are equal, false otherwise.
     */
    equals(other: CompleteAddress): boolean;
    /**
     * Converts the CompleteAddress instance into a Buffer.
     * This method should be used when encoding the address for storage, transmission or serialization purposes.
     *
     * @returns A Buffer representation of the CompleteAddress instance.
     */
    toBuffer(): Buffer;
    /**
     * Creates an CompleteAddress instance from a given buffer or BufferReader.
     * If the input is a Buffer, it wraps it in a BufferReader before processing.
     * Throws an error if the input length is not equal to the expected size.
     *
     * @param buffer - The input buffer or BufferReader containing the address data.
     * @returns - A new CompleteAddress instance with the extracted address data.
     */
    static fromBuffer(buffer: Buffer | BufferReader): Promise<CompleteAddress>;
    /**
     * Create a CompleteAddress instance from a hex-encoded string.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 128 hex characters representing the x and y coordinates.
     * Throws an error if the input length is invalid or coordinate values are out of range.
     *
     * @param address - The hex-encoded string representing the complete address.
     * @returns A Point instance.
     */
    static fromString(address: string): Promise<CompleteAddress>;
    /**
     * Convert the CompleteAddress to a hexadecimal string representation, with a "0x" prefix.
     * The resulting string will have a length of 66 characters (including the prefix).
     *
     * @returns A hexadecimal string representation of the CompleteAddress.
     */
    toString(): string;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGxldGVfYWRkcmVzcy5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvbnRyYWN0L2NvbXBsZXRlX2FkZHJlc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRXBELE9BQU8sRUFBRSxZQUFZLEVBQXFCLE1BQU0sNkJBQTZCLENBQUM7QUFHOUUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRXpELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RCxPQUFPLEtBQUssRUFBRSxjQUFjLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUUzRDs7Ozs7OztHQU9HO0FBQ0gscUJBQWEsZUFBZTtJQUV4QiwwREFBMEQ7SUFDbkQsT0FBTyxFQUFFLFlBQVk7SUFDNUIsdUJBQXVCO0lBQ2hCLFVBQVUsRUFBRSxVQUFVO0lBQzdCLGtFQUFrRTtJQUMzRCxjQUFjLEVBQUUsY0FBYztJQU52QyxPQUFPLGVBT0g7SUFFSixPQUFhLE1BQU0sQ0FDakIsT0FBTyxFQUFFLFlBQVksRUFDckIsVUFBVSxFQUFFLFVBQVUsRUFDdEIsY0FBYyxFQUFFLGNBQWMsR0FDN0IsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUkxQjtJQUVELG1DQUFtQztJQUNuQyxNQUFNLENBQUMsUUFBUSxDQUFDLGFBQWEsU0FBVztJQUV4QyxNQUFNLEtBQUssTUFBTSw4Q0FFaEI7SUFFRCxNQUFNLFdBRUw7SUFFRCxPQUFhLE1BQU0sSUFBSSxPQUFPLENBQUMsZUFBZSxDQUFDLENBRTlDO0lBRUQsT0FBYSw4QkFBOEIsQ0FBQyxTQUFTLEVBQUUsRUFBRSxFQUFFLGNBQWMsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUt2RztJQUVLLGFBQWEsZ0JBRWxCO0lBRUQsT0FBYSx3QkFBd0IsQ0FDbkMsU0FBUyxFQUFFLEVBQUUsRUFDYixRQUFRLEVBQUUsVUFBVSxDQUFDLE9BQU8scUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FDcEQsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUcxQjtJQUVELDZGQUE2RjtJQUNoRixRQUFRLGtCQVFwQjtJQUVEOzs7T0FHRztJQUNJLGdCQUFnQixJQUFJLE1BQU0sQ0FFaEM7SUFFRDs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQUMsS0FBSyxFQUFFLGVBQWUsR0FBRyxPQUFPLENBTXRDO0lBRUQ7Ozs7O09BS0c7SUFDSCxRQUFRLElBQUksTUFBTSxDQUVqQjtJQUVEOzs7Ozs7O09BT0c7SUFDSCxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUcsWUFBWSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FNekU7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsTUFBTSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FFM0Q7SUFFRDs7Ozs7T0FLRztJQUNILFFBQVEsSUFBSSxNQUFNLENBRWpCO0NBQ0YifQ==