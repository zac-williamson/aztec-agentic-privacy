import { Fr } from '@aztec/foundation/curves/bn254';
import { z } from 'zod';
import { FunctionSelector } from '../../abi/index.js';
declare const VERSION: 1;
/**
 * A Contract Class in the protocol. Aztec differentiates contracts classes and instances, where a
 * contract class represents the code of the contract, but holds no state. Classes are identified by
 * an id that is a commitment to all its data.
 */
export interface ContractClass {
    /** Version of the contract class. */
    version: typeof VERSION;
    /**
     * Hash of the contract artifact. The specification of this hash is not enforced by the protocol. Should include
     * commitments to code of utility functions and compilation metadata. Intended to be used by clients to verify that
     * an offchain fetched artifact matches a registered class.
     */
    artifactHash: Fr;
    /** List of individual private functions, constructors included. */
    privateFunctions: PrivateFunction[];
    /** Bytecode for the public_dispatch function, or empty. */
    packedBytecode: Buffer;
}
/** Private function definition within a contract class. */
export interface PrivateFunction {
    /** Selector of the function. Calculated as the hash of the method name and parameters. The specification of this is not enforced by the protocol. */
    selector: FunctionSelector;
    /** Hash of the verification key associated to this private function. */
    vkHash: Fr;
}
/** Private function definition with executable bytecode. */
export interface ExecutablePrivateFunction extends PrivateFunction {
    /** ACIR and Brillig bytecode */
    bytecode: Buffer;
}
/** Utility function definition. */
export interface UtilityFunction {
    /** Selector of the function. Calculated as the hash of the method name and parameters. The specification of this is not enforced by the protocol. */
    selector: FunctionSelector;
    /** Brillig. */
    bytecode: Buffer;
}
/** Sibling paths and sibling commitments for proving membership of a private function within a contract class. */
export type PrivateFunctionMembershipProof = {
    artifactMetadataHash: Fr;
    functionMetadataHash: Fr;
    utilityFunctionsTreeRoot: Fr;
    privateFunctionTreeSiblingPath: Fr[];
    privateFunctionTreeLeafIndex: number;
    artifactTreeSiblingPath: Fr[];
    artifactTreeLeafIndex: number;
};
/** A private function with a membership proof. */
export type ExecutablePrivateFunctionWithMembershipProof = ExecutablePrivateFunction & PrivateFunctionMembershipProof;
/** Sibling paths and commitments for proving membership of a utility  function within a contract class. */
export type UtilityFunctionMembershipProof = {
    artifactMetadataHash: Fr;
    functionMetadataHash: Fr;
    privateFunctionsArtifactTreeRoot: Fr;
    artifactTreeSiblingPath: Fr[];
    artifactTreeLeafIndex: number;
};
/** A utility function with a membership proof. */
export type UtilityFunctionWithMembershipProof = UtilityFunction & UtilityFunctionMembershipProof;
export declare const ContractClassSchema: z.ZodObject<{
    version: z.ZodLiteral<1>;
    artifactHash: z.ZodType<Fr, any, string>;
    privateFunctions: z.ZodArray<z.ZodObject<{
        selector: import("@aztec/foundation/schemas").ZodFor<FunctionSelector>;
        vkHash: z.ZodType<Fr, any, string>;
    }, "strip", z.ZodTypeAny, {
        selector: FunctionSelector;
        vkHash: Fr;
    }, {
        selector?: any;
        vkHash: string;
    }>, "many">;
    packedBytecode: import("@aztec/foundation/schemas").ZodFor<Buffer<ArrayBufferLike>>;
}, "strip", z.ZodTypeAny, {
    version: 1;
    artifactHash: Fr;
    privateFunctions: {
        selector: FunctionSelector;
        vkHash: Fr;
    }[];
    packedBytecode: Buffer<ArrayBufferLike>;
}, {
    version: 1;
    artifactHash: string;
    privateFunctions: {
        selector?: any;
        vkHash: string;
    }[];
    packedBytecode?: any;
}>;
/** Commitments to fields of a contract class. */
interface ContractClassCommitments {
    /** Identifier of the contract class. */
    id: Fr;
    /** Commitment to the public bytecode. */
    publicBytecodeCommitment: Fr;
    /** Root of the private functions tree  */
    privateFunctionsRoot: Fr;
}
/** A contract class with its precomputed id. */
export type ContractClassWithId = ContractClass & Pick<ContractClassCommitments, 'id'>;
export declare const ContractClassWithIdSchema: z.ZodObject<{
    version: z.ZodLiteral<1>;
    artifactHash: z.ZodType<Fr, any, string>;
    privateFunctions: z.ZodArray<z.ZodObject<{
        selector: import("@aztec/foundation/schemas").ZodFor<FunctionSelector>;
        vkHash: z.ZodType<Fr, any, string>;
    }, "strip", z.ZodTypeAny, {
        selector: FunctionSelector;
        vkHash: Fr;
    }, {
        selector?: any;
        vkHash: string;
    }>, "many">;
    packedBytecode: import("@aztec/foundation/schemas").ZodFor<Buffer<ArrayBufferLike>>;
} & {
    id: z.ZodType<Fr, any, string>;
}, "strip", z.ZodTypeAny, {
    version: 1;
    artifactHash: Fr;
    privateFunctions: {
        selector: FunctionSelector;
        vkHash: Fr;
    }[];
    packedBytecode: Buffer<ArrayBufferLike>;
    id: Fr;
}, {
    version: 1;
    artifactHash: string;
    privateFunctions: {
        selector?: any;
        vkHash: string;
    }[];
    packedBytecode?: any;
    id: string;
}>;
/** A contract class with public bytecode information, and optional private and utility functions. */
export type ContractClassPublic = {
    privateFunctions: ExecutablePrivateFunctionWithMembershipProof[];
    utilityFunctions: UtilityFunctionWithMembershipProof[];
} & Pick<ContractClassCommitments, 'id' | 'privateFunctionsRoot'> & Omit<ContractClass, 'privateFunctions'>;
export type ContractClassPublicWithCommitment = ContractClassPublic & Pick<ContractClassCommitments, 'publicBytecodeCommitment'>;
export declare const ContractClassPublicSchema: z.ZodIntersection<z.ZodObject<{
    id: z.ZodType<Fr, any, string>;
    privateFunctionsRoot: z.ZodType<Fr, any, string>;
    privateFunctions: z.ZodArray<z.ZodIntersection<z.ZodIntersection<z.ZodObject<{
        selector: import("@aztec/foundation/schemas").ZodFor<FunctionSelector>;
        vkHash: z.ZodType<Fr, any, string>;
    }, "strip", z.ZodTypeAny, {
        selector: FunctionSelector;
        vkHash: Fr;
    }, {
        selector?: any;
        vkHash: string;
    }>, z.ZodObject<{
        bytecode: import("@aztec/foundation/schemas").ZodFor<Buffer<ArrayBufferLike>>;
    }, "strip", z.ZodTypeAny, {
        bytecode: Buffer<ArrayBufferLike>;
    }, {
        bytecode?: any;
    }>>, z.ZodObject<{
        artifactMetadataHash: z.ZodType<Fr, any, string>;
        functionMetadataHash: z.ZodType<Fr, any, string>;
        utilityFunctionsTreeRoot: z.ZodType<Fr, any, string>;
        privateFunctionTreeSiblingPath: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        privateFunctionTreeLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
        artifactTreeSiblingPath: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        artifactTreeLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        artifactMetadataHash: Fr;
        functionMetadataHash: Fr;
        utilityFunctionsTreeRoot: Fr;
        privateFunctionTreeSiblingPath: Fr[];
        privateFunctionTreeLeafIndex: number;
        artifactTreeSiblingPath: Fr[];
        artifactTreeLeafIndex: number;
    }, {
        artifactMetadataHash: string;
        functionMetadataHash: string;
        utilityFunctionsTreeRoot: string;
        privateFunctionTreeSiblingPath: string[];
        privateFunctionTreeLeafIndex: string | number | bigint;
        artifactTreeSiblingPath: string[];
        artifactTreeLeafIndex: string | number | bigint;
    }>>, "many">;
    utilityFunctions: z.ZodArray<z.ZodIntersection<z.ZodObject<{
        selector: import("@aztec/foundation/schemas").ZodFor<FunctionSelector>;
        bytecode: import("@aztec/foundation/schemas").ZodFor<Buffer<ArrayBufferLike>>;
    }, "strip", z.ZodTypeAny, {
        selector: FunctionSelector;
        bytecode: Buffer<ArrayBufferLike>;
    }, {
        selector?: any;
        bytecode?: any;
    }>, z.ZodObject<{
        artifactMetadataHash: z.ZodType<Fr, any, string>;
        functionMetadataHash: z.ZodType<Fr, any, string>;
        privateFunctionsArtifactTreeRoot: z.ZodType<Fr, any, string>;
        artifactTreeSiblingPath: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        artifactTreeLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        artifactMetadataHash: Fr;
        functionMetadataHash: Fr;
        privateFunctionsArtifactTreeRoot: Fr;
        artifactTreeSiblingPath: Fr[];
        artifactTreeLeafIndex: number;
    }, {
        artifactMetadataHash: string;
        functionMetadataHash: string;
        privateFunctionsArtifactTreeRoot: string;
        artifactTreeSiblingPath: string[];
        artifactTreeLeafIndex: string | number | bigint;
    }>>, "many">;
}, "strip", z.ZodTypeAny, {
    id: Fr;
    privateFunctionsRoot: Fr;
    privateFunctions: ({
        selector: FunctionSelector;
        vkHash: Fr;
    } & {
        bytecode: Buffer<ArrayBufferLike>;
    } & {
        artifactMetadataHash: Fr;
        functionMetadataHash: Fr;
        utilityFunctionsTreeRoot: Fr;
        privateFunctionTreeSiblingPath: Fr[];
        privateFunctionTreeLeafIndex: number;
        artifactTreeSiblingPath: Fr[];
        artifactTreeLeafIndex: number;
    })[];
    utilityFunctions: ({
        selector: FunctionSelector;
        bytecode: Buffer<ArrayBufferLike>;
    } & {
        artifactMetadataHash: Fr;
        functionMetadataHash: Fr;
        privateFunctionsArtifactTreeRoot: Fr;
        artifactTreeSiblingPath: Fr[];
        artifactTreeLeafIndex: number;
    })[];
}, {
    id: string;
    privateFunctionsRoot: string;
    privateFunctions: ({
        selector?: any;
        vkHash: string;
    } & {
        bytecode?: any;
    } & {
        artifactMetadataHash: string;
        functionMetadataHash: string;
        utilityFunctionsTreeRoot: string;
        privateFunctionTreeSiblingPath: string[];
        privateFunctionTreeLeafIndex: string | number | bigint;
        artifactTreeSiblingPath: string[];
        artifactTreeLeafIndex: string | number | bigint;
    })[];
    utilityFunctions: ({
        selector?: any;
        bytecode?: any;
    } & {
        artifactMetadataHash: string;
        functionMetadataHash: string;
        privateFunctionsArtifactTreeRoot: string;
        artifactTreeSiblingPath: string[];
        artifactTreeLeafIndex: string | number | bigint;
    })[];
}>, z.ZodObject<Omit<{
    version: z.ZodLiteral<1>;
    artifactHash: z.ZodType<Fr, any, string>;
    privateFunctions: z.ZodArray<z.ZodObject<{
        selector: import("@aztec/foundation/schemas").ZodFor<FunctionSelector>;
        vkHash: z.ZodType<Fr, any, string>;
    }, "strip", z.ZodTypeAny, {
        selector: FunctionSelector;
        vkHash: Fr;
    }, {
        selector?: any;
        vkHash: string;
    }>, "many">;
    packedBytecode: import("@aztec/foundation/schemas").ZodFor<Buffer<ArrayBufferLike>>;
}, "privateFunctions">, "strip", z.ZodTypeAny, {
    version: 1;
    artifactHash: Fr;
    packedBytecode: Buffer<ArrayBufferLike>;
}, {
    version: 1;
    artifactHash: string;
    packedBytecode?: any;
}>>;
/** The contract class with the block it was initially deployed at */
export type ContractClassPublicWithBlockNumber = {
    l2BlockNumber: number;
} & ContractClassPublic;
/**
 * Creates a ContractClassPublic from a plain object without Zod validation.
 * Suitable for deserializing trusted data (e.g., from C++ via MessagePack).
 * Note: privateFunctions and utilityFunctions are set to empty arrays since
 * C++ does not provide them.
 */
export declare function contractClassPublicFromPlainObject(obj: any): ContractClassPublic;
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJhY3RfY2xhc3MuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb250cmFjdC9pbnRlcmZhY2VzL2NvbnRyYWN0X2NsYXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUdwRCxPQUFPLEVBQUUsQ0FBQyxFQUFFLE1BQU0sS0FBSyxDQUFDO0FBRXhCLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXRELFFBQUEsTUFBTSxPQUFPLEdBQWEsQ0FBQztBQUUzQjs7OztHQUlHO0FBQ0gsTUFBTSxXQUFXLGFBQWE7SUFDNUIscUNBQXFDO0lBQ3JDLE9BQU8sRUFBRSxPQUFPLE9BQU8sQ0FBQztJQUN4Qjs7OztPQUlHO0lBQ0gsWUFBWSxFQUFFLEVBQUUsQ0FBQztJQUNqQixtRUFBbUU7SUFDbkUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLENBQUM7SUFDcEMsMkRBQTJEO0lBQzNELGNBQWMsRUFBRSxNQUFNLENBQUM7Q0FDeEI7QUFFRCwyREFBMkQ7QUFDM0QsTUFBTSxXQUFXLGVBQWU7SUFDOUIscUpBQXFKO0lBQ3JKLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQztJQUMzQix3RUFBd0U7SUFDeEUsTUFBTSxFQUFFLEVBQUUsQ0FBQztDQUNaO0FBU0QsNERBQTREO0FBQzVELE1BQU0sV0FBVyx5QkFBMEIsU0FBUSxlQUFlO0lBQ2hFLGdDQUFnQztJQUNoQyxRQUFRLEVBQUUsTUFBTSxDQUFDO0NBQ2xCO0FBTUQsbUNBQW1DO0FBQ25DLE1BQU0sV0FBVyxlQUFlO0lBQzlCLHFKQUFxSjtJQUNySixRQUFRLEVBQUUsZ0JBQWdCLENBQUM7SUFDM0IsZUFBZTtJQUNmLFFBQVEsRUFBRSxNQUFNLENBQUM7Q0FDbEI7QUFTRCxrSEFBa0g7QUFDbEgsTUFBTSxNQUFNLDhCQUE4QixHQUFHO0lBQzNDLG9CQUFvQixFQUFFLEVBQUUsQ0FBQztJQUN6QixvQkFBb0IsRUFBRSxFQUFFLENBQUM7SUFDekIsd0JBQXdCLEVBQUUsRUFBRSxDQUFDO0lBQzdCLDhCQUE4QixFQUFFLEVBQUUsRUFBRSxDQUFDO0lBQ3JDLDRCQUE0QixFQUFFLE1BQU0sQ0FBQztJQUNyQyx1QkFBdUIsRUFBRSxFQUFFLEVBQUUsQ0FBQztJQUM5QixxQkFBcUIsRUFBRSxNQUFNLENBQUM7Q0FDL0IsQ0FBQztBQWNGLGtEQUFrRDtBQUNsRCxNQUFNLE1BQU0sNENBQTRDLEdBQUcseUJBQXlCLEdBQUcsOEJBQThCLENBQUM7QUFFdEgsMkdBQTJHO0FBQzNHLE1BQU0sTUFBTSw4QkFBOEIsR0FBRztJQUMzQyxvQkFBb0IsRUFBRSxFQUFFLENBQUM7SUFDekIsb0JBQW9CLEVBQUUsRUFBRSxDQUFDO0lBQ3pCLGdDQUFnQyxFQUFFLEVBQUUsQ0FBQztJQUNyQyx1QkFBdUIsRUFBRSxFQUFFLEVBQUUsQ0FBQztJQUM5QixxQkFBcUIsRUFBRSxNQUFNLENBQUM7Q0FDL0IsQ0FBQztBQVlGLGtEQUFrRDtBQUNsRCxNQUFNLE1BQU0sa0NBQWtDLEdBQUcsZUFBZSxHQUFHLDhCQUE4QixDQUFDO0FBRWxHLGVBQU8sTUFBTSxtQkFBbUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQU8vQixDQUFDO0FBRUYsaURBQWlEO0FBQ2pELFVBQVUsd0JBQXdCO0lBQ2hDLHdDQUF3QztJQUN4QyxFQUFFLEVBQUUsRUFBRSxDQUFDO0lBQ1AseUNBQXlDO0lBQ3pDLHdCQUF3QixFQUFFLEVBQUUsQ0FBQztJQUM3QiwwQ0FBMEM7SUFDMUMsb0JBQW9CLEVBQUUsRUFBRSxDQUFDO0NBQzFCO0FBRUQsZ0RBQWdEO0FBQ2hELE1BQU0sTUFBTSxtQkFBbUIsR0FBRyxhQUFhLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixFQUFFLElBQUksQ0FBQyxDQUFDO0FBRXZGLGVBQU8sTUFBTSx5QkFBeUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFJckMsQ0FBQztBQUVGLHFHQUFxRztBQUNyRyxNQUFNLE1BQU0sbUJBQW1CLEdBQUc7SUFDaEMsZ0JBQWdCLEVBQUUsNENBQTRDLEVBQUUsQ0FBQztJQUNqRSxnQkFBZ0IsRUFBRSxrQ0FBa0MsRUFBRSxDQUFDO0NBQ3hELEdBQUcsSUFBSSxDQUFDLHdCQUF3QixFQUFFLElBQUksR0FBRyxzQkFBc0IsQ0FBQyxHQUMvRCxJQUFJLENBQUMsYUFBYSxFQUFFLGtCQUFrQixDQUFDLENBQUM7QUFFMUMsTUFBTSxNQUFNLGlDQUFpQyxHQUFHLG1CQUFtQixHQUNqRSxJQUFJLENBQUMsd0JBQXdCLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztBQUU3RCxlQUFPLE1BQU0seUJBQXlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FTckMsQ0FBQztBQUVGLHFFQUFxRTtBQUNyRSxNQUFNLE1BQU0sa0NBQWtDLEdBQUc7SUFBRSxhQUFhLEVBQUUsTUFBTSxDQUFBO0NBQUUsR0FBRyxtQkFBbUIsQ0FBQztBQUVqRzs7Ozs7R0FLRztBQUNILHdCQUFnQixrQ0FBa0MsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLG1CQUFtQixDQVVoRiJ9