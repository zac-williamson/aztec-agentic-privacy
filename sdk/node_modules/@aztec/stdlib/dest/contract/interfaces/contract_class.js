import { Fr } from '@aztec/foundation/curves/bn254';
import { schemas, zodFor } from '@aztec/foundation/schemas';
import { z } from 'zod';
import { FunctionSelector } from '../../abi/index.js';
const VERSION = 1;
const PrivateFunctionSchema = zodFor()(z.object({
    selector: FunctionSelector.schema,
    vkHash: schemas.Fr
}));
const ExecutablePrivateFunctionSchema = zodFor()(PrivateFunctionSchema.and(z.object({
    bytecode: schemas.Buffer
})));
const UtilityFunctionSchema = zodFor()(z.object({
    selector: FunctionSelector.schema,
    bytecode: schemas.Buffer
}));
const PrivateFunctionMembershipProofSchema = zodFor()(z.object({
    artifactMetadataHash: schemas.Fr,
    functionMetadataHash: schemas.Fr,
    utilityFunctionsTreeRoot: schemas.Fr,
    privateFunctionTreeSiblingPath: z.array(schemas.Fr),
    privateFunctionTreeLeafIndex: schemas.Integer,
    artifactTreeSiblingPath: z.array(schemas.Fr),
    artifactTreeLeafIndex: schemas.Integer
}));
const UtilityFunctionMembershipProofSchema = zodFor()(z.object({
    artifactMetadataHash: schemas.Fr,
    functionMetadataHash: schemas.Fr,
    privateFunctionsArtifactTreeRoot: schemas.Fr,
    artifactTreeSiblingPath: z.array(schemas.Fr),
    artifactTreeLeafIndex: schemas.Integer
}));
export const ContractClassSchema = zodFor()(z.object({
    version: z.literal(VERSION),
    artifactHash: schemas.Fr,
    privateFunctions: z.array(PrivateFunctionSchema),
    packedBytecode: schemas.Buffer
}));
export const ContractClassWithIdSchema = zodFor()(ContractClassSchema.extend({
    id: schemas.Fr
}));
export const ContractClassPublicSchema = zodFor()(z.object({
    id: schemas.Fr,
    privateFunctionsRoot: schemas.Fr,
    privateFunctions: z.array(ExecutablePrivateFunctionSchema.and(PrivateFunctionMembershipProofSchema)),
    utilityFunctions: z.array(UtilityFunctionSchema.and(UtilityFunctionMembershipProofSchema))
}).and(ContractClassSchema.omit({
    privateFunctions: true
})));
/**
 * Creates a ContractClassPublic from a plain object without Zod validation.
 * Suitable for deserializing trusted data (e.g., from C++ via MessagePack).
 * Note: privateFunctions and utilityFunctions are set to empty arrays since
 * C++ does not provide them.
 */ export function contractClassPublicFromPlainObject(obj) {
    return {
        id: Fr.fromPlainObject(obj.id),
        version: 1,
        artifactHash: Fr.fromPlainObject(obj.artifactHash),
        privateFunctionsRoot: Fr.fromPlainObject(obj.privateFunctionsRoot),
        privateFunctions: [],
        utilityFunctions: [],
        packedBytecode: obj.packedBytecode instanceof Buffer ? obj.packedBytecode : Buffer.from(obj.packedBytecode)
    };
}
