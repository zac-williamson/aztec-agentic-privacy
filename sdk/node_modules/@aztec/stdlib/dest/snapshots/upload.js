import { fromEntries, getEntries, pick } from '@aztec/foundation/collection';
import { jsonStringify } from '@aztec/foundation/json-rpc';
import { isoDate } from '@aztec/foundation/string';
import { getBasePath, getSnapshotIndex, getSnapshotIndexPath } from './download.js';
export async function uploadSnapshotData(localPaths, schemaVersions, metadata, store, opts = {}) {
    const timestamp = Date.now();
    const date = isoDate();
    const basePath = getBasePath(metadata);
    const targetPathFor = opts.pathFor ?? ((key)=>`${basePath}/${key}-${date}-${metadata.l2BlockHash}.db`);
    const dataUrls = fromEntries(await Promise.all(getEntries(localPaths).map(async ([key, path])=>[
            key,
            await store.upload(targetPathFor(key), path, {
                compress: true,
                public: !opts.private
            })
        ])));
    return {
        ...pick(metadata, 'l1BlockNumber', 'l2BlockHash', 'l2BlockNumber'),
        schemaVersions,
        timestamp,
        dataUrls
    };
}
export async function uploadSnapshotToIndex(localPaths, schemaVersions, metadata, store) {
    const newSnapshotMetadata = await uploadSnapshotData(localPaths, schemaVersions, metadata, store);
    const snapshotsIndex = await getSnapshotIndex(metadata, store) ?? createEmptyIndex(metadata);
    snapshotsIndex.snapshots.unshift(newSnapshotMetadata);
    await store.save(getSnapshotIndexPath(metadata), Buffer.from(jsonStringify(snapshotsIndex, true)), {
        public: true,
        compress: false,
        metadata: {
            ['Cache-control']: 'no-store'
        }
    });
    return newSnapshotMetadata;
}
function createEmptyIndex(metadata) {
    return {
        ...pick(metadata, 'l1ChainId', 'rollupVersion', 'rollupAddress'),
        snapshots: []
    };
}
