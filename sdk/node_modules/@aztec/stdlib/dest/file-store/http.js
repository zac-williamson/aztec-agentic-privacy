import { createLogger } from '@aztec/foundation/log';
import { makeBackoff, retry } from '@aztec/foundation/retry';
import axios from 'axios';
import { createWriteStream } from 'fs';
import { mkdir } from 'fs/promises';
import { dirname } from 'path';
import { pipeline } from 'stream/promises';
export class HttpFileStore {
    baseUrl;
    log;
    axiosInstance;
    fetch;
    constructor(baseUrl, log = createLogger('stdlib:http-file-store')){
        this.baseUrl = baseUrl;
        this.log = log;
        this.axiosInstance = axios.create();
        this.fetch = async (config)=>{
            return await retry(()=>this.axiosInstance.request(config), `Fetching ${config.url}`, makeBackoff([
                1,
                1,
                3
            ]), this.log, /*failSilently=*/ true);
        };
    }
    async read(pathOrUrl) {
        const url = this.getUrl(pathOrUrl);
        try {
            const response = await this.fetch({
                url,
                method: 'GET',
                responseType: 'arraybuffer'
            });
            return Buffer.from(response.data);
        } catch (error) {
            throw new Error(`Error fetching file from ${url}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async download(pathOrUrl, destPath) {
        const url = this.getUrl(pathOrUrl);
        try {
            this.log.debug(`Downloading file from ${url} to ${destPath}`);
            const response = await this.fetch({
                url,
                method: 'GET',
                responseType: 'stream'
            });
            this.log.debug(`Response ${response.status} (${response.statusText}) from ${url}, writing to ${destPath}`);
            await mkdir(dirname(destPath), {
                recursive: true
            });
            await pipeline(response.data, createWriteStream(destPath));
            this.log.debug(`Download of ${url} to ${destPath} complete`);
        } catch (error) {
            throw new Error(`Error fetching file from ${url}`, {
                cause: error
            });
        }
    }
    async exists(pathOrUrl) {
        const url = this.getUrl(pathOrUrl);
        try {
            await this.fetch({
                url,
                method: 'HEAD'
            });
            return true;
        } catch  {
            return false;
        }
    }
    getUrl(path) {
        return URL.canParse(path) ? path : `${this.baseUrl.replace(/\/$/, '')}/${path}`;
    }
}
