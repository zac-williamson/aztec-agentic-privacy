import { access, mkdir, readFile, writeFile } from 'fs/promises';
import { dirname, resolve } from 'path';
import { promisify } from 'util';
import { gunzip as gunzipCb, gzip as gzipCb } from 'zlib';
const gzip = promisify(gzipCb);
const gunzip = promisify(gunzipCb);
export class LocalFileStore {
    basePath;
    constructor(basePath){
        this.basePath = basePath;
    }
    async save(path, data, opts) {
        const fullPath = this.getFullPath(path);
        await mkdir(dirname(fullPath), {
            recursive: true
        });
        const toWrite = opts?.compress ? await gzip(data) : data;
        await writeFile(fullPath, toWrite);
        return `file://${fullPath}`;
    }
    async upload(destPath, srcPath, _opts) {
        const data = await readFile(srcPath);
        return this.save(destPath, data);
    }
    async read(pathOrUrlStr) {
        const fullPath = this.getFullPath(pathOrUrlStr);
        const data = await readFile(fullPath);
        if (data.length >= 2 && data[0] === 0x1f && data[1] === 0x8b) {
            return await gunzip(data);
        }
        return data;
    }
    async download(pathOrUrlStr, destPath) {
        const data = await this.read(pathOrUrlStr);
        const fullPath = this.getFullPath(destPath);
        await writeFile(fullPath, data);
    }
    exists(pathOrUrlStr) {
        const fullPath = this.getFullPath(pathOrUrlStr);
        return access(fullPath).then(()=>true).catch(()=>false);
    }
    getFullPath(pathOrUrl) {
        if (URL.canParse(pathOrUrl)) {
            return new URL(pathOrUrl).pathname;
        } else {
            return resolve(this.basePath, pathOrUrl);
        }
    }
}
