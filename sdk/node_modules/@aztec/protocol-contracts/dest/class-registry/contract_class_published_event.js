import { CONTRACT_CLASS_PUBLISHED_MAGIC_VALUE } from '@aztec/constants';
import { FieldReader } from '@aztec/foundation/serialize';
import { bufferFromFields } from '@aztec/stdlib/abi';
import { computeContractClassId, computePublicBytecodeCommitment } from '@aztec/stdlib/contract';
import { ProtocolContractAddress } from '../protocol_contract_data.js';
/** Event emitted from the ContractClassRegistry. */ export class ContractClassPublishedEvent {
    contractClassId;
    version;
    artifactHash;
    privateFunctionsRoot;
    packedPublicBytecode;
    constructor(contractClassId, version, artifactHash, privateFunctionsRoot, packedPublicBytecode){
        this.contractClassId = contractClassId;
        this.version = version;
        this.artifactHash = artifactHash;
        this.privateFunctionsRoot = privateFunctionsRoot;
        this.packedPublicBytecode = packedPublicBytecode;
    }
    static isContractClassPublishedEvent(log) {
        return log.contractAddress.equals(ProtocolContractAddress.ContractClassRegistry) && log.fields.fields[0].toBigInt() === CONTRACT_CLASS_PUBLISHED_MAGIC_VALUE;
    }
    static fromLog(log) {
        // See how the log is serialized in `noir-projects/noir-contracts/contracts/protocol/contract_class_registry_contract/src/events/class_published.nr`.
        const fieldsWithoutTag = log.fields.fields.slice(1);
        const reader = new FieldReader(fieldsWithoutTag);
        const contractClassId = reader.readField();
        const version = reader.readField().toNumber();
        const artifactHash = reader.readField();
        const privateFunctionsRoot = reader.readField();
        const packedPublicBytecode = bufferFromFields(reader.readFieldArray(fieldsWithoutTag.length - reader.cursor));
        return new ContractClassPublishedEvent(contractClassId, version, artifactHash, privateFunctionsRoot, packedPublicBytecode);
    }
    async toContractClassPublic() {
        const computedClassId = await computeContractClassId({
            artifactHash: this.artifactHash,
            privateFunctionsRoot: this.privateFunctionsRoot,
            publicBytecodeCommitment: await computePublicBytecodeCommitment(this.packedPublicBytecode)
        });
        if (!computedClassId.equals(this.contractClassId)) {
            throw new Error(`Invalid contract class id: computed ${computedClassId.toString()} but event broadcasted ${this.contractClassId.toString()}`);
        }
        if (this.version !== 1) {
            throw new Error(`Unexpected contract class version ${this.version}`);
        }
        return {
            id: this.contractClassId,
            artifactHash: this.artifactHash,
            packedBytecode: this.packedPublicBytecode,
            privateFunctionsRoot: this.privateFunctionsRoot,
            version: this.version,
            privateFunctions: [],
            utilityFunctions: []
        };
    }
    static extractContractClassEvents(logs) {
        return logs.filter((log)=>ContractClassPublishedEvent.isContractClassPublishedEvent(log)).map((log)=>ContractClassPublishedEvent.fromLog(log));
    }
}
