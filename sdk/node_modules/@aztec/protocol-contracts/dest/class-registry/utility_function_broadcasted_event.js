import { ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, CONTRACT_CLASS_REGISTRY_UTILITY_FUNCTION_BROADCASTED_MAGIC_VALUE, MAX_PACKED_BYTECODE_SIZE_PER_UTILITY_FUNCTION_IN_FIELDS } from '@aztec/constants';
import { removeArrayPaddingEnd } from '@aztec/foundation/collection';
import { Fr } from '@aztec/foundation/curves/bn254';
import { FieldReader } from '@aztec/foundation/serialize';
import { FunctionSelector, bufferFromFields } from '@aztec/stdlib/abi';
import { ProtocolContractAddress } from '../protocol_contract_data.js';
/** Event emitted from the ContractClassRegistry. */ export class UtilityFunctionBroadcastedEvent {
    contractClassId;
    artifactMetadataHash;
    privateFunctionsArtifactTreeRoot;
    artifactFunctionTreeSiblingPath;
    artifactFunctionTreeLeafIndex;
    utilityFunction;
    constructor(contractClassId, artifactMetadataHash, privateFunctionsArtifactTreeRoot, artifactFunctionTreeSiblingPath, artifactFunctionTreeLeafIndex, utilityFunction){
        this.contractClassId = contractClassId;
        this.artifactMetadataHash = artifactMetadataHash;
        this.privateFunctionsArtifactTreeRoot = privateFunctionsArtifactTreeRoot;
        this.artifactFunctionTreeSiblingPath = artifactFunctionTreeSiblingPath;
        this.artifactFunctionTreeLeafIndex = artifactFunctionTreeLeafIndex;
        this.utilityFunction = utilityFunction;
    }
    static isUtilityFunctionBroadcastedEvent(log) {
        return log.contractAddress.equals(ProtocolContractAddress.ContractClassRegistry) && log.fields.fields[0].toBigInt() === CONTRACT_CLASS_REGISTRY_UTILITY_FUNCTION_BROADCASTED_MAGIC_VALUE;
    }
    static fromLog(log) {
        const reader = new FieldReader(log.fields.fields.slice(1));
        const event = UtilityFunctionBroadcastedEvent.fromFields(reader);
        while(!reader.isFinished()){
            const field = reader.readField();
            if (!field.isZero()) {
                throw new Error(`Unexpected data after parsing UtilityFunctionBroadcastedEvent: ${field.toString()}`);
            }
        }
        return event;
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        const contractClassId = reader.readField();
        const artifactMetadataHash = reader.readField();
        const privateFunctionsArtifactTreeRoot = reader.readField();
        const artifactFunctionTreeSiblingPath = reader.readFieldArray(ARTIFACT_FUNCTION_TREE_MAX_HEIGHT);
        const artifactFunctionTreeLeafIndex = reader.readField().toNumber();
        const utilityFunction = BroadcastedUtilityFunction.fromFields(reader);
        return new UtilityFunctionBroadcastedEvent(contractClassId, artifactMetadataHash, privateFunctionsArtifactTreeRoot, artifactFunctionTreeSiblingPath, artifactFunctionTreeLeafIndex, utilityFunction);
    }
    toFunctionWithMembershipProof() {
        // We should be able to safely remove the zero elements that pad the variable-length sibling path,
        // since a sibling with value zero can only occur on the tree leaves, so the sibling path will never end
        // in a zero. The only exception is a tree with depth 2 with one non-zero leaf, where the sibling path would
        // be a single zero element, but in that case the artifact tree should be just the single leaf.
        const artifactTreeSiblingPath = removeArrayPaddingEnd(this.artifactFunctionTreeSiblingPath, Fr.isZero);
        return {
            ...this.utilityFunction,
            bytecode: this.utilityFunction.bytecode,
            functionMetadataHash: this.utilityFunction.metadataHash,
            artifactMetadataHash: this.artifactMetadataHash,
            privateFunctionsArtifactTreeRoot: this.privateFunctionsArtifactTreeRoot,
            artifactTreeSiblingPath,
            artifactTreeLeafIndex: this.artifactFunctionTreeLeafIndex
        };
    }
}
export class BroadcastedUtilityFunction {
    selector;
    metadataHash;
    bytecode;
    constructor(/** Selector of the function. Calculated as the hash of the method name and parameters. The specification of this is not enforced by the protocol. */ selector, /** Artifact metadata hash */ metadataHash, /** Brillig bytecode */ bytecode){
        this.selector = selector;
        this.metadataHash = metadataHash;
        this.bytecode = bytecode;
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        const selector = FunctionSelector.fromField(reader.readField());
        const metadataHash = reader.readField();
        // The '* 1' removes the 'Type instantiation is excessively deep and possibly infinite. ts(2589)' err
        const encodedBytecode = reader.readFieldArray(MAX_PACKED_BYTECODE_SIZE_PER_UTILITY_FUNCTION_IN_FIELDS * 1);
        const bytecode = bufferFromFields(encodedBytecode);
        return new BroadcastedUtilityFunction(selector, metadataHash, bytecode);
    }
}
