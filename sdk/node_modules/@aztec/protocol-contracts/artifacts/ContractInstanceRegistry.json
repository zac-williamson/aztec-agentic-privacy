{
  "transpiled": true,
  "noir_version": "1.0.0-beta.18+2db78f8894936db05c53430f364360ac9cc5c61f",
  "name": "ContractInstanceRegistry",
  "functions": [
    {
      "name": "get_update_delay",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 64
          },
          "visibility": "public"
        },
        "error_types": {
          "5755400808989454547": {
            "error_kind": "string",
            "string": "Function get_update_delay can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUlAAAAQScCAQQAJwICBAAfCgABAAIARCUAAABCLQIBRCcCAgREJwIDBAE7DgADAAImJQAAAnUeAgACCScCAwEBJAIAAgAAAF4lAAACmx4CAAIBKQIAAwDvUlNNJwIEAAErAgAFAAAAAAAAAAADAAAAAAAAAAAtCAEGJwIHBAUACAEHAScDBgQBACIGAgctCgcILQ4DCAAiCAIILQ4ECAAiCAIILQ4CCAAiCAIILQ4FCC0LBgIAIgICAi0OAgYtCAECJwIDBAUACAEDAScDAgQBACIGAgMAIgICBD8PAAMABCcCAwQBACoCAwUtCwUEJwICAAAKKgQCAycCAgEACioDAgUkAgAFAAABICUAAAKtHgIAAgYeAgADAC8qAAQAAwAFHAoFBAQcCgQDAAIqBQMELAIAAwAtXgmLgro3tDuZoTFhGP0g1C9RZsnp8T+16mWpbR4KbQQqBAMFHAoFBgQcCgYEAAIqBQQGBCoGAwUcCgUHARwKBwYAHAoGBwECKgUGCCwCAAUAMDPqJG5QbomOl/Vwyv/XBMsLtGAxP7cgsp4TnlwQAAEEKggFCRwKCQoEHAoKCAACKgkICgQqCgMJHAoJCgEcCgoDABwKAwoBAioJAwsEKgsFCRwKCQsEHAoLBQAcCgUJBRYKCgUcCgMKBRwKBQMFBCoKCQUcCggJBRYKBwgcCgYHBRwKCAYFBCoHCQgcCgQJBQwqAgkEKQIAAgUAAVGAJAIABAAAAlwjAAACRAQqBwgDBCoGAgQAKgMEAi0KAgEjAAACdAQqCgUEBCoDAgUAKgQFAi0KAgEjAAACdCYoAAAEBHhFDAAABAMkAAADAAACmioBAAEF2sX11rRKMm08BAIBJioBAAEFT99KitfP8NM8BAIBJioBAAEFursh14IzGGQ8BAIBJg==",
      "debug_symbols": "nZjbbuJADIbfJddcjA9zMK+yqira0hUSohULK60q3n1tiCdQaUa7c1N+/pAv9tjjpPma3rYv55/Pu8P7x69p/eNrejnu9vvdz+f9x+vmtPs4qPs1BfuTYVrTasppWvNqKnD7kOuH8LRO+qHfQH8DocwCaBbELvwQ+yF2J7oT3UnoIs3CoriJOIsSXPgliochDpR8ExjQhQGjCggu4izQHXSH3CF32MJIJtIsojvRflNUpODCnexOdqeQC00ZUYXFjOaIOhRWE1mopIcIwIU5mgWhObr+ZCt2FUlPp2iizCKbk0yYk1XYRamYKLMQd64XldXEQR3WqzMHFxozg4oYXJij8bBlymTCHA2DLdObcMfKxNGEORoPiznZRLyJGMwpJuazYpDZAXbhDpojJuQWfCSaHeuxq2B3rMeiZhGtxyJeLqvJO/z5dNxurcHvWl43wufmuD2cpvXhvN+vpt+b/fn6o1+fm8P187Q56lFFbg9v+qnA991+a+qyWs4O7VNB28pPV41YEREeGNBmSMI0IyRxXgjyQMBOFKGwBwFhIWQczYNbeXQZHBcGJ2oxYptBVugrgRIP5cEISwwsrRhyP4+KkFgJhR8IpU3A4uuge7Gez5AeANJpCagFFUSoCCr5sas6S1HERtGVUSRJm9FpTYpYE1naSqfaI6HTmgilzAgESWOMpSCow7bN4DaDsziDCy3bFOSfwyCRpax3df0eRq+1QLy/QW8JrdaCHiJARQS6Q9DgHintmdXpUBSprRGAW2Fgr0H1vuINygLNudfpz1SXM0Nz7PXSoFBnLwUuzTSog8hUVyLH3ERwr6YYUy0q5vY9IPYgwfpmhgTiJiR1FnTZrkmfs5qIToNirhtemiO8l4hIxiWPu6J8D6JX12iPMreixE4Y3bqW2hoFpVVXgt4mwTq4hJZEKMt/MFKdOlrhQUaUZbPGIQaFCJWRYJBRd7w+B9MogysD8xgDYq6MlAYZS3sgjMZR6nroA9gYA5dcMA3GgaXWlmA0juWh5/758b8YFOuupYSDjFLHMcMwo64H4+B+4WW/8Oh+ycTLrWVwTUudplRkcM9J9vnBIUiT8c932rvafhunsTfG9K7m4zTc/aOkFb9cnvTr5nV3fHjpcTHYcbd52W/nr+/nw+vd0dOfTz/iL00+jx+v27fzcWuk5c2JvWL4AUFWAPxkL0Xsq/7XDxieLnb5vw=="
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5755400808989454547": {
            "error_kind": "string",
            "string": "Function get_update_delay can only be called statically"
          },
          "6804164082532189961": {
            "error_kind": "string",
            "string": "New update delay is too low"
          },
          "12511970388699677811": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "12579274401768182412": {
            "error_kind": "string",
            "string": "New contract class is not registered"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15353471697975175405": {
            "error_kind": "string",
            "string": "msg.sender is not deployed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "publish_for_public_execution",
      "is_unconstrained": false,
      "custom_attributes": [
        "abi_private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "salt",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "contract_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "initialization_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "public_keys",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::public_keys::PublicKeys",
              "fields": [
                {
                  "name": "npk_m",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::public_keys::NpkM",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                          "fields": [
                            {
                              "name": "x",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "y",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "is_infinite",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "ivpk_m",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::public_keys::IvpkM",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                          "fields": [
                            {
                              "name": "x",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "y",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "is_infinite",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "ovpk_m",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::public_keys::OvpkM",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                          "fields": [
                            {
                              "name": "x",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "y",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "is_infinite",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tpk_m",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::public_keys::TpkM",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                          "fields": [
                            {
                              "name": "x",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "y",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "is_infinite",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "universal_deploy",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "expiration_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_separators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_separator::KeyValidationRequestAndSeparator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "key_type_domain_separator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log",
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 16,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "718532354304118388": {
            "error_kind": "string",
            "string": "Point not on curve"
          },
          "4135474769840782447": {
            "error_kind": "string",
            "string": "Point at infinity should have canonical representation (0 0)"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+2dd3xURduGM8+z9CYgTTrSexcVC4TQpBcRCxjIApGQhE1CsRJ7NyTYCyhVEETEgooV+9xSrCgWsGAHUezCd2jZTZYls0lu+d739/IPw+bZ65mZM3P2zMzmQrNn3/5Masa4pMS0SWMnpATG7i+PH+uf4R+fkZ6Ykgxfoy36TebKnknx4yf3TJnROyN5fGx8UlLmwmE9BvWJy85cPCoxPdmfliYNHILUOARVdiFVPd0hqLqd5RBVwymqjkut6roE1XMJqu8S1MCp5g2doho5RR3vFNXYpfItXcZCG5eg9i5BnVyCOpvMZT0DiUlJiRP3/XxOTFZWTlbWugYxR/5jMpf2SEvzB9LP9gdScrJmZ69r0D5hUGBrh3ktnhwS93hm5lnnNe/0dd+Za1Jnx27dnbPTewv07iNj323z+eTCYO+JiK18qHCYjlg9JCXNn5iQktxxiD8wJSM9ft/cz56T2zFedXPLTXJLTUN+fs8c6L3Q+6BzofPy1jwnu+AubOYQ42Vw6oP7C0TFRF/B5k4VvM+pgg8wKtjCqYJznSo436GChRlF94eUHwgpzw8pz/NG0gLoQugi6OLo+6GlUz8scOqHJYwL1cqpggudKvggo4KtnSq4yKmCS0kjaUlI+cGQ8tKQ8mJvJC2DPgRdDl0RfT+0ceqHZU798DDjQrV1quBDThVcyahgO6cKLneq4COkkfRwSHllSPmRkPIKbyStgj4KXQ19LPp+aO/UD6uc+uFxxoXq4FTBR50q+ASjgh2dKrjaqYJPkkbS4yHlJ0LKT4aUH/NG0hroU9Cnoc9E3w+dnPphjVM/rGVcqM5OFXzKqYLPki7U2pDysyHlp0PKz3gX6jno89AXoC/m7YdshzY2dmrhSw6Li4LXLR6nQfQ1rOpUw3UFgMzQWU41XHd6YZYzLx85u04ZdllhsK8U2DtaGOyrEbF6qFCo8fpySPmVwy6/XvVG62vQ16FvQN/Mu4o12ZmLhicmT0zyH2hHAS03TR1mXS6w4NWxzt4XPSU1yQ+1bstpl/FkTfQj3psnTtcRxVRHNMh7JUrOju5KxBQcEtK5b0W/VzE7x6ESHtmtc99yilpf8BUoTB3Xz3bNXkBQ9Nk7e9gch4HV2WnwrXeK2hDtrlR2sX12b+BcwA1u99iN0T60uGE3HRl7ybgvLiwM9u2IWF9ubQvzibDpMNtxzUJ+/rb3efAO9F3oe9D3o74c3tXwetpt1r/j1BEfkB7lPggpvxtSfi+k/L7XGZuhH0I/gm4pYn+HfupuzvcJ/DH0E+in0M+i7vHmLbMId6YWFGrz5m6DfyujRS3ccm+L9jaR7YBt6ZT6c8KHcHOvN90a/sWRg3bs3bszT/Zsp9vBNq9ZOU6N92rAGHOt2jCorSnUVq3cLtWXjBa1dsv9FWN+tHFKvZ0wP1p5venW8K8p8+Mrr1lO82O7VwPGmGvbnkFtR6G2bet2qb5htKidW+5vGfOjvVPq7wjzo63Xm24N/54yP771muU0P77zasAYcx06MagdKdQOHdwu1Q+MFnV0y/0jY350ckq9gzA/Oni96dbwnZT58aPXLKf5scOrQbRjznGt+tORsW1HVexfGOyuiNgKubUtzJLsp9xy89xSi5Cf7/IWZD9Df4Huhv7K+h7Bz0598NvR+x7BL04V/P3ofY9gt1MF/yDtH/wWUv49pPxHSPlXbyT9Cf0L+jf0H9b3CP506oc9R+97BH85VXDv0fsewd8uFfTFkEbSnpDy3mDZFxPy+j9z4DPwCXwKn4/0PQKfceqHEkftewQ+capgyaP2PQKfOlWwFGck+UqElEuGlEuFlH3eSCoNXxn4ysJXjvQ9Al9pp34oT+qH8iHlMiHlsiHlcl4/VICvInyV4DumEM8nvspHrv0Fd/RHoWpfOaRcIeQe8HHeTWNfFfiqwncsfNXyHhZKlIeFHqng65Cde1zoqx4s1ijEt5xz3KrkdAmqh0edmy/KY9VwGGZ5elCzj3hOnT9DtN1dveD6BE9nfTWL7ejbV/Mwl8Ktk/Ony5/fYzuxahXYmzFOLallZxWmKTWcotyaclx4U/K/yakpxx32VyNWDMxISk8cPj4+KT7gFefkZC6JTUlOS49PTncYDOGxsr7qmIySC84b36ZZhbifalaZc8Vp6266/LRmraPgxoRWu3pIuUY0lcuBrzZ8deCre5hmr4ybMs6fkOBPiM0ITPP3SEjwGh7MUzukXCekXDcY1Cq31Dr4yyBRVq8efPXhy/cVDF/Ud9V6BXdoYX5LxO1wFU5juGEx3Vga5uusEjnRfNGnZObCHoFA/MwtMXVdwmNdglJcgpJdgtJdggIuQfEuQeOLrU79iq0L0oqtTvHFVienfnIafkNcgjJcgsa5BCW5BCUW22WZVGz9lOASdJJLUAOXoItcgi45eOuYuz+4xoDJp1Ta2Kf5F3+PGf7bqnHL5nTpvXhrk20/jJn7Sfedj25rV4x3bqcbt1u+Ji7Ziun7l26gZsUFal5coBbFBWpVXKDWxQVqW1ygdsUF6lBcoI4OIPdvlTmcXtCep3wNnZ6nGhXT81SjBtGfgcU4tKML4/DNOCTuykgsDolPYCRWh8TdCpO4IOiJTjvpz0Wb2mUun8ToSJ9D4pMZiUs4JO7OSFzSIfEpjMSlHBKfykhc2iHxaYzEZRwSn85IXNYhcQ9G4nIOiXsyEpd3SBzLSFzBIXEvRuKKDonjGIkrOSTuzUh8jEPiPozElR0S92UkruKQuB8jcVWHxP0ZiY91SHwGI3E1h8QDGImrOyQeyEhcwyHxIEbimg6JBzMS13JIPISR+DiHxEMZiWs7JB7GSFzHIfFwRuK6DolHMBLXc0g8kpG4vkPiMxmJGzgkHsVI3NAh8VmMxI0cEo9mJD7eIfHZjEX3OQzouYydifOcdibWMa5OY4fqjWG0eWwx7QkW4hqez4DGM6DjGNDxDGgCA+pnQCcwoBMZ0EkMaCIDegEDOpkBTWJApzCgyQxoCgOayoBOZUADDGgaA5rOgGYwoNMY0OkM6AwGdCYDeiEDehEDejEDegkDeikDehkDamdRqJkU6uUU6hUU6pUU6lUU6tUU6jUU6rUU6nUU6vUU6g0U6o0U6k0U6s0U6i0UahaFOptCzY6Smu3wC+1N9zkhC869X25pXTZzrNNvkOhrjI0kO8cp90uU3LdmFygm2OP1IWVk3Eah3k6h3kGh3kmh3kWh3k2h3kOh3kuh3kehzqVQ51Go91OoD1Co8ynUBRTqQgp1EYW6mEJdQqE+SKEupVCXUagPUajLKdQVFOrDFOpKCvURCnUVhfoohbqaQn2MQn2cQn2CQn2SQl1DoT5FoT5NoT5Doa6lUJ+lUCm/b2Kfp1BfoFBfpFBfitKX70ZdR6nryxTqKxTqqxTqaxTq6xTqGxTqmxQqZ+cJFOpbFOp6CnUDhbqRQt1Eob5Nob5Dob5Lob5Hob5PoX5AoW6mUD+kUD+iULdQqB9TqJ9QqJ9SqJ9RqFsp1G0U6ucU6hcU6pcU6lcU6nYK9WsK9RsK9VsK9TsK9XsK9QcK9UcKdQeFupNC/YlC3UWh/kyh/kKh7qZQf6VQf6NQf6dQ/6BQ/6RQ/6JQ/6ZQ/6FQ91CoexlUmBgO1nCwwsEqB+vjYEtwsCU52FIcbGkOtgwHW5aDLcfBludgK3CwFTnYShzsMRxsZQ62CgdblYM9loOtxsFW52BrcLA1OdhaHOxxHGxtDrYOB1uXg63HwdbnYBtwsA052EYc7PEcbGMOtgkH25SDbcbBNudgW3CwLTnYVhxsaw62DQfbloNtx8G252A7cLAdOdhOHGxnDrYLB9uVgz2Bg+3GwZ7IwZ7EwZ7MwXbnYE/hYE/lYE/jYE/nYHtwsD052FgOthcHG8fB9uZg+3CwfTnYfhxsfw72DA52AAc7kIMdxMEO5mCHcLBDOdhhHOxwDnYEBzuSgz2Tgx3FwZ7FwY7mYM/mYM/hYM/lYM/jYMdwsGM52PM52HgOdhwHO56DTeBg/RzsBA52Igc7iYNN5GAv4GAnc7BJHOwUDjaZg03hYFM52KkcbICDTeNg0znYDA52Ggc7nYOdwcHO5GAv5GAv4mAv5mAv4WAv5WAv42BncbCZHOzlHOwVHOyVHOxVHOzVHOw1HOy1HOx1HOz1HOwNHOyNHOxNHOzNHOwtHGwWBzubg83mYHM42Dkc7K0c7G0c7O0c7B0c7J0c7F0c7N0c7D0c7L0c7H0c7FwOdh4Hez8H+wAHO5+DXcDBLuRgF3GwiznYJRzsgxzsUg52GQf7EAe7nINdwcE+zMGu5GAf4WBXcbCPcrCrOdjHONjHOdgnONgnOdg1HOxTHOzTHOwzHOxaDvZZDvY5DvZ5DvYFDvZFDvYlDnYdB/syB/sKB/sqB/saB/s6B/sGB/smB2s5WHCwb3Gw6znYDRzsRg52Ewf7Ngf7Dgf7Lgf7Hgf7Pgf7AQe7mYP9kIP9iIPdwsF+zMF+wsF+ysF+xsFu5WC3cbCfc7BfcLBfcrBfcbDbOdivOdhvONhvOdjvONjvOdgfONgfOdgdHOxODvYnDnYXB/szB/sLB7ubg/2Vg/2Ng/2dg/2Dg/2Tg/2Lg/2bg/2Hg93DwXL8t8Lx3wrHfysc/61w/LfC8d8Kx38rHP+tcPy3wvHfCsd/Kxz/rXD8t8Lx3wrHfysc/61w/LfC8d8Kx38rVThYjv9WOP5b4fhvheO/FY7/Vjj+W+H4b4Xjv5Wo/bfZTtg62QX/H6jwcbyzUpfTpnoubVLOkZ5wXLrCcekKx6UrHJeucFy6wnHpCselKxyXrnBcusJx6QrHpSscl65wXLrCcekKx6UrHJeucFy6wnHpCselKx05WI5LVzguXeG4dIXj0hWOS1c4Ll3huHSF49IVjktXOC5d4bh0hePSFY5LVzguXeG4dIXj0hWOS1c4Ll3huHSF49IVjktXOC5d4bh0hePSFY5LVwYUvIwvDJbj0hWOS1c4Ll3huHSF49KVYRwsx6UrHJeucFy6wnHpCselKxyXrnBcusJx6QrHpSscl65wXLrCcekKx6UrHJeucFy6wnHpCselKxyXrnBcujJhXYNaNT7vsvH80TFvD98+7rq3dj+Ss+f+eXfk3DT/y541ztw7oO6m8EOPAo8z9h/kFJycY9yVSdE+qbm0qYlT6qitvC6pmzqlvoCRuplT6smM1M2dUicxUrdwSj2FkbqVU+pkRurWTqlTGKnbOqVOZaRu55R6KiN1B6fUAUbqjk6po7Ufz85xOereAN3odiPnaJKFo0mWaUdu/I69e3cVBju9MNe/YOwMp69akE7kOTJl4ciUhSNTFo5MWTgyZeHIlIUjUxaOTFk4MmXhyJSFI1MWjkxZODJl4ciUhSNTFo5MWTgyZeHIlIUjUxaOTFk4MmXhyJSFI1MWjkxZODJlyeZgOTJl4ciUhSNTFo5MWTgyZeHIlIUjUxaOTFk4MmXhyJSFI1MWjkxZODJl4ciUhSNTFo5MWTgyZeHIlIUjUxaOTFk4MmXhyJSFI1MWjkxZODJl4ciUhSNTFo5MWTgyZeHIlIUjU5ZVHCxHpiwcmbJwZMrCkSkLR6YsHJmycGTKwpEpC0emLByZsnBkysKRKQtHpiwcmbJwZMrCkSkLR6YsHJmycGTKwpEpC0emLByZsnBkysKRKQtHpiwcmbKQfvOaI1MWjkxZODJl4ciUZRMHy5EpC0emLByZsnBkysKRKQtHpiwcmbJwZMrCkSkLR6YsHJmycGTKwpEpC0emLByZsnBkysKRKQtHpiwcmbJwZMrCkSkLR6YsHJmycGTKwpEpC0emLByZsnBkysKRKQtHpiwcmbLs4mA5MmXhyJSFI1MWjkxZODJl4ciUhSNTFo5MWTgyZeHIlIUjUxaOTFk4MmXlyJSVI1NWjkxZOTJl5ciUlSNTVo5MWTkyZeXIlJUjU1aOTFk5MmXlyJSVI1NWjkxZOTJl5ciUlSNT1iocLEemrByZsnJkysqRKStHpqwcmbJyZMrKkSlrbQ62Dgdbl4PlSJ2VI0BWjgBZOb9uqRwBsnIEyMoRICtHgKwcAbJyBMjKESArR4CsHAGycgTIyhEgK0eArBwBsnIEyMoRICtHgKwdOViOAFk5AmTlCJCVI0BWjgBZOQJk5QiQlSNAVo4AWTkCZOUIkJUjQFaOAFk5AmTlCJCVI0BWjgBZOQJk5QiQlSNAVo4AWTkCZOUIkJUjQFaOAFkHcLAcAbJyBMjKESArR4CsHAGyDuNgOQJk5QiQlSNAVo4AWTkCZOUIkJUjQFaOAFk5AmTlCJCVI0BWjgBZOQJk5QiQlSNAVo4AWTkCZOUIkJUjQNYJHCxHbayTONhEDvYCDnYyB5vEwU7hYJM52BQONpWDncrBBjjYNA6WY8lVjiVXp3Gw0znYGRwsx3+rHP+tcvy3yvHfKsd/qxz/rXL8t8rx3yrHf6sc/61y/LfK8d8qx3+rHP+tcvy3yvHfKsd/qxz/rXL8t8rx3yrHf6sc/61y/LfK8d8qx3+r2Rwsx3+rHP+tcvy3ehvlv4lUjv9WOf5b5fhv1cl/O9A/JSUws19yYnpOlS06oUvXE7qdeNLJ3U859bTTe/SM7RXXu0/ffv3PGDBw0OAhQ4cNHzHyzFFnjT77nHPPGzP2/Phx4xP8EyZOSrxgctKU5JTUqYG09Ixp02fMvPCiiy+59DI7y2bay+0V9kp7lb3aXmOvtdfZ6+0N9kZ7k73Z3mKz7GybbXPsHHurvc3ebu+wd9q77N32Hnuvvc/OtfPs/fYBO98usAvtIrvYLrEP2qV2mX3ILrcr7MN2pX3ErrKP2tX2Mfu4fcI+adfYp+zT9hm71j5rn7PP2xfsi/Ylu86+bF+xr9rX7Ov2DfumtRb2LbvebrAb7Sb7tn3Hvmvfs+/bD+xm+6H9yG6xH9tP7Kf2M7vVbrOf2y/sl/Yru91+bb+x39rv7Pf2B/uj3WF32p/sLvuz/cXutr/a3+zv9g/7p/3L/m3/sXvsXpgYGAMjMArjgykBUxKmFExpmDIwZWHKwZSHqQBTEaYSzDEwlWGqwFSFORamGkx1mBowNWFqwRwHUxumDkxdmHow9WEawDSEaQRzPExjmCYwTWGawTSHaQHTEqYVTGuYNjBtYdrBtIfpANMRphNMZ5guMF1hToDpBnMizEkwJ8N0hzkF5lSY02BOh+kB0xMmFqYXTBxMb5g+MH1h+sH0hzkDZgDMQJhBMINhhsAMhRkGMxxmBMxImDNhRsGcBTMa5myYc2DOhTkPZgzMWJjzYeJhxsGMh0mA8cNMgJkIMwkmEeYCmMkwSTBTYJJhUmBSYabCBGDSYNJhMmCmwUyHmQEzE+ZCmItgLoa5BOZSmMtgZsFkwlwOcwXMlTBXwVwNcw3MtTDXwVwPcwPMjTA3wdwMcwtMFsxsmGyYHJg5MLfC3AZzO8wdMHfC3AVzN8w9MPfC3AczF2YezP0wD8DMh1kAsxBmEcximCUwD8IshVkG8xDMcpgVMA/DrIR5BGYVzKMwq2Eeg3kc5gmYJ2HWwDwF8zTMMzBrYZ6FeQ7meZgXYF6EeQlmHczLMK/AvArzGszrMG/AvAljYQDzFsx6mA0wG2E2wbwN8w7MuzDvwbwP8wHMZpgPYT6C2QLzMcwnMJ/CfAazFWYbzOcwX8B8CfMVzHaYr2G+gfkW5juY72F+gPkRZgfMTpifYHbB/AzzC8xumF9hfoP5HeYPmD9h/oL5G+YfmD0weyExEAMRiEJ8kBKQkpBSkNKQMpCykHKQ8pAKkIqQSpBjIJUhVSBVIcdCqkGqQ2pAakJqQY6D1IbUgdSF1IPUhzSANIQ0ghwPaQxpAmkKaQZpDmkBaQlpBWkNaQNpC2kHaQ/pAOkI6QTpDOkC6Qo5AdINciLkJMjJkO6QUyCnQk6DnA7pAekJiYX0gsRBekP6QPpC+kH6Q86ADIAMhAyCDIYMgQyFDIMMh4yAjIScCRkFOQsyGnI25BzIuZDzIGMgYyHnQ+Ih4yDjIQkQP2QCZCJkEiQRcgFkMiQJMgWSDEmBpEKmQgKQNEg6JAMyDTIdMgMyE3Ih5CLIxZBLIJdCLoPMgmRCLodcAbkSchXkasg1kGsh10Guh9wAuRFyE+RmyC2QLMhsSDYkBzIHcivkNsjtkDsgd0LugtwNuQdyL+Q+yFzIPMj9kAcg8yELIAshiyCLIUsgD0KWQpZBHoIsh6yAPAxZCXkEsgryKGQ15DHI45AnIE9C1kCegjwNeQayFvIs5DnI85AXIC9CXoKsg7wMeQXyKuQ1yOuQNyBvQiwEkLcg6yEbIBshmyBvQ96BvAt5D/I+5APIZsiHkI8gWyAfQz6BfAr5DLIVsg3yOeQLyJeQryDbIV9DvoF8C/kO8j3kB8iPkB2QnZCfILsgP0N+geyG/Ar5DfI75A/In5C/IH9D/oHsgeyFxkC9j2GBKtQHLQEtCS0FLQ0tAy0LLQctD60ArQitBD0GWhlaBVoVeiy0GrQ6tAa0JrQW9DhobWgdaF1oPWh9aANoQ2gj6PHQxtAm0KbQZtDm0BbQltBW0NbQNtC20HbQ9tAO0I7QTtDO0C7QrtAToN2gJ0JPgp4M7Q49BXoq9DTo6dAe0J7QWGgvaBy0N7QPtC+0H7Q/9AzoAOhA6CDoYOgQ6FDoMOhw6AjvyN87nveO0r1jb++I2jtO9o5+vWNa70jVO/70jiq9Y0XvCNA7rvOO1rxjMO/Iyjte8o6CvGMb74jFOw7xji68YwbvSMDbvve22r1tcW8L29tu9raGvW1cb8vV2x71tjK9bUdvi9DbzvO23rxtMm9Ly9t+8raKvG0dbwvG2y7xtja8bQhvy8Bb3ntLcW/Z7C1xveWot3T0lnneksxbPnlLHW9Z4i0hvMd979Hce4z2Hnm9x1PvUdJ77PMe0bzHqaXD/OkZgeRe8enxW2K6xBhRX4mSpUqXKVuufIWKlY6pXKXqsdWq16hZ67jaderWq9+gYaPjGzdp2qx5i5atWrdp2659h46dOmdlbYmpmp25oMf4xEDr7PUbSn33y5uvTMzKOvhS2/CXuoa/FJu9/sSE5gkzf+6ecuilXuEv9cteX+b3tWOu+75i+qGX+odHnRH+0pDwNw4NjxoW/tKo8DeeFR41OvylMeFvnJ69fnm5TT3Xzi095tBLM8NfujS8c2xmyGu3Z29uHr//uXns+JQpqfHpieOS/GNTAvHjvb+m+QNpiSnJY6cH4lNT/YEtMdUzF8amJKel52Qu6pUY8I9Pl8zF/ZLT/RP9gfkjO3Us+JE7//tNVO+f1Sv/+2Oiy98rc0FsfFLS7HK5nCXD/Eleo6f5o6uJty4II0i0hIf21SXBmyuxKakzc5vUK7ROIfADNa9Q5Jr3KoaaLxienpI6OztCTfNdo9iFvRP9SQUf4pdfdODucbClx2Qu650S8CdOTN73z1s3N85IT0xKTJ95YJUXmztYB+8fq2ceGKpZWbMzlx9YsPVISAj409JyazE7c9HwxCmpSf4D1TmULF9lfVF1xYxemct6JibH71sepg9OvfUQRZcM8FKPmBSfvI8SHKy5SRb1z5iS2m9Cdu4bqmUu75eccKCmEWdI1yP8ZsWHL+9+b3X/jlMyF4zwZuvs7OD7D03Vgy3OXp2YNjY5IykpcUKiPzA21e+lTZ64JabWUZ7bfYo4t/scHDcVw8e3RkeScIKv2Oe2hsLnD0yZlmc25cbn+4kc+kncwdZWOhhx8OXeoZCizvPeRe5JE36nkBBY3glfNe+EX5MaSJwWn+7vlzbo0GAdcmCshk3xIDF3kufW84GRHbIjxpuIP5HsvLeLfP8Ku2DhjSrajaVPcd1Yav57N5YVCf59zxApaf6xkxKT07fE1PvvvaUUuiWFnUoOt5TQqXWEW8phbxxxoaGRbilS5FbEFfnWKuG3lNBbad5bSs19f+er72GemxaM7NCxW1hoaHcenPbLD8zJ/f8YnDonJGD+8IxxBTwOBX966IGoaoeY9+t/2mVmq+pdUwZPu/LTEcsvPXZ+i+2Vav6Y0X3aH1tSIufzzR+YkRShVZHvTRL+cRLec/9P7lt1/7371pKk9EN3rIb/ewg6+Od/D0EH/vzLD0G1jzDnF8VNzYhPSoswtXNnUPAN1TMX7HvRe7KKDM2dmG53jDxX7AC91pGWpN7jl0MHRU5icpP85zxyNfj3bl2bmySnpCdOmDl2fMDvPSsnhCzsDu7hpAZSZsw8+js3cUW8sR2a6uX/Cx/Fir6nE8fe0zni1szagyu1QfuHYuyBkZi7aDvMlkwwBWVTJu4/cFNmVVLKxENTNne79eyjPGmnFnHSTj04XnoW+VmiTTihRLFPWl8o/OBqIDcqtxD8ZOuWLyguWIgc1DtYiBzUJ1iIHNQ3WIgc1C9YiBzUP1iIHHRGsBA5aECwEDloYLAQOWhQsBA5aHCwEDloSLAQOWhosBA5aFiwEDloeLAQOWhEsBA5aGSwEDnozGAhctCoYCFy0FnBQuSg0cFC5KCzg4XIQecEC5GDzg0WIgedFyxEDhoTLEQOGhssRA46P1iIHBQfLIQGRX4UKOoHeFyR75B189fOF/zYCGOXjI5d7/AfyWa+90gQ+mlsQjPk//At7IeHyZc8mCI3fXibJe+aUsPXRLnPDSFVzvOTEvk+T7xPwtgj7cAU+cF0XJHHQCXiGDjmv2gMaHGOgbxr6v0xg4q8JJj6by0JDntRS+W/qBrskDz9UzoYkOf1MsGuPWyCsgc3Q0Jz5LJKhT3Klx2YuWBASnxC7gslg29a6LUy4A/PXPLwmUvnb1rp4HA57BvK5H9DmeAbDmxu9M67vBpR5MflSpFGe4nw0S6Rqn+kKaIhbwpdCi49eEg/IGViVtacI5y7PdjXH5/aIxCInxkyvErUjfgO3+HfUbLSnMOc+HXLXHgg8HDHgd3qhr24v23533JgRVqpeJakU4trSTr631uSrjyQxuvlsYnJ0/yB9Dvzd0K1Ii5Hjy2eJVxMsD654PwLZ8fvoMSE7ZQe6vhDm6/5c0r4NSodtux2zG4iZY+Z3ytxWtiVCt6gc5t9qCP+D0NDrkBgnwEA",
      "debug_symbols": "tVvhbts4DH6X/M4PURQpqq8yHIZuyx0KFN3QtQcchr37kakkOylEaHb6J6Qd6zNFf6QoS/51+Hb68vrP54env7//PNx9+nX48vzw+Pjwz+fH71/vXx6+P+nZX4dgP5AOdwC/jwc4H7EeBT2K7SjpP/lNyOGOVJTDHesF2pr1QmwX5re/ip5LDTjqAdlB1n/geJDwJuBN6E3gt17SrPr88nw62eUrM9X4H/fPp6eXw93T6+Pj8fDv/ePr+aKfP+6fzvLl/ln/DcfD6embSgX8++HxZNrv49I6jJvGSKm2jlFKB0DVJyF23F1iu7kk6c0hX7THcXtmru0504b2OWBtnyFsah9b+zi8v9P/AlTblwhb2pO09rmM2su4PUBIrQeq86oPMmsDJGlGANHiRYFphADdiMC5I0ScJlIqJVcICri4ki6NsPsMuVgaFwrSFhsohsZmiis6XNuQnG5EbEYkDEs3Urp8pEabEQZmbhgoGMcYfAOM7DxVRGjRqXpa96bM+5RC92ke+7Q4Pk0Bmk8TpMUK7desFQjNHbTuyJUVEZw8Cyw9z8aF43xpRIxespDUs8UqXaBcPpSIHsljCzUpXMYYDkmRGgSWVbCWy4wRPYpqiDaIgGUbBkDzBgLFMYZD0ZRLy79pTXMo27qSw7au8BJtnGE/htA2jLL0ZU2OawyMH+vSUkI3o8jQDDdgpVlBmlNHAYueFZha9kKUpSMk8xBEyzNBHkF4/eAl8WQapj90hvjFBoYFIF8BOPmTSmi+5BB5mDJS2J+6EuxPXSnuTV0J96cuF2MydSXaHWeuGZNpx8eI0jHSOP15DNXyD3v5t7IjTxeQlLmHey48ChNya1CE3K3Q4B9FKzkUBZKeuoAKlA0hzyFLD9gQh31xHkqiHrGJKA974o3xqSPAqqanTb2AYcVETg26lKA5L480TRdtvFRcHFMemuAws5SFmLyMIkiXQUbFm6E2VklYbEC+NIJvkDv5BrmTd+dOvkHu5BvkTt6fO/kGuXMawynZXIzJko3Lx7pjsmTzgk1WwZbTMNiyQ1GIpXkD0ooc7zBwf7jltD/cMu0Nt8z7w83FmAy3LLv55ZoxGW4+xlyp4g0p2N9GMK5euF0NKeJQNBI2Z0RazRcTXGHg1Mi4eluWAs77YjJteFZIJ6gQD63wEEp/9VyobEPg1o3CvBdh/TQ2ItBeP3gILqukETNq3TNkVYl7WeUhzDHCQ5hjhIswxYhJBIcRswi01w9bGcGROyM4DhkBIeylhAsxxwkXYo4UPsQUK2YhHFpMQ9BuX2wmRm5PJObVlOQ9MWQ/MWQ/MWQ/MWQ/MWQ/MWQ/MWQvMbzaJoW+lppoOF0Gb9mIoEhfrYF1Dc9XIM5L+YidXDEJjAkKsr+KB2/laLaMhxj21vHgrR3NFvI+yGQlD97y0WQpP98bZ8XEB5mcEMyDOBNwH2SylIYoH+zXyTm4H8Gxv/gjXIG8i2CEGwQfxhsEH+Lu4MN0g+BzQWaDD3k/SVxDZuPGB5mbSftMo9z8SuuVqXdM89aVUF8Vdb+m1e6VawzvpX3pK2SwHsGvdtG4GDF0ssaQaIyB3iLGslC3skL+xIplj0EoMLaCPtQKkNJ3OgTe5k8QvAFG2I2hgdswkMbccFeWsIet3gu3YSRMHSPdAiNvxKDlBSvzVoy+Rrau7zb3ZSsG9X1BQBD2Y+BWjLRgcBpjlL1R61vRIw7YiRZvlWnOCn9Q6LmY1u+x3g0K3mIExT7GUSxpOCj4GKs6aO2OawxvmUn6oJ+Eb4FRhhjTTo3Bcaq3SJ/6SKvBJ+POeGuh5ylbJQiNMbI3TaVeezCtI38zxpAgLgKHBWG4SA/uQhOX0qfs4/0G4C00Ud96u95fJH9ihfRNmkUQx1bwx2570FdRfSu1vgEbe1S8V1up1z+chxieFQCLFWOEc2Ux9Abn9lxBQVYTl6s6XdxSbileYB2z89vyc+p1WCbAcV8cdgBg30qiehxugzvP+D6UH7Twg+Ryi89fenT/9eH58hMP+0rDNhZFUB8qL2KsEqtMVVKVXGWuUqosbxJDlRUPKx5WPKx4WPGw4mHFw4qHFS8F21moEqqMVaJNq1SmKsn2Y6vkKu2TFDsvVZY3SaFKsO3wKmOVaMOZylQl2ZCgkqvMVRYbwY8HBtu1ojJWiVUmi1KVVKV9+KL4nO3rDZVqj9h1xWbsx0MO9iZAJVQZq8Qqk+20V6l4RdtntkSoMtvGG5VSZXmT9gHNWdoXNKF9Q2MfYAiaol2QZIpiCDWFm5KbIqYYjn2XA9qREs7kVsWQbWt9iU3BpqSmGLLtji7clNwUaUqpiiayrkHXYtewa6lr1DXuWu6adK3fA873KKZB1+weRhbtV9fsHrY5Uvth2vk6Phe/puWuybkENK007RxLtjkILJqqZvcwYoBFFNhsHiymwHY1gEUVZLuvxVXV7B5ybmv3kPN15az9tsh/frj/8niy4LXwfn362mJZD1/++9H+aR90/Xj+/vX07fX5ZHG/+qpLfz/poBbB8gIsp8oxJjsV+yn1Xyx2CpdT+YjRTqX3WOfPufTST5yPOf91fPtbuS8KYmnofw==",
      "verification_key": "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"
    },
    {
      "name": "set_update_delay",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "new_update_delay",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "6804164082532189961": {
            "error_kind": "string",
            "string": "New update delay is too low"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15353471697975175405": {
            "error_kind": "string",
            "string": "msg.sender is not deployed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "update",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "new_contract_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "12579274401768182412": {
            "error_kind": "string",
            "string": "New contract class is not registered"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15353471697975175405": {
            "error_kind": "string",
            "string": "msg.sender is not deployed"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    }
  ],
  "outputs": {
    "globals": {},
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "CONTRACT_INSTANCE_PUBLISHED_MAGIC_VALUE",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "version",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            {
              "name": "salt",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "contract_class_id",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::contract_class_id::ContractClassId"
              }
            },
            {
              "name": "initialization_hash",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "public_keys",
              "type": {
                "fields": [
                  {
                    "name": "npk_m",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::public_keys::NpkM"
                    }
                  },
                  {
                    "name": "ivpk_m",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::public_keys::IvpkM"
                    }
                  },
                  {
                    "name": "ovpk_m",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::public_keys::OvpkM"
                    }
                  },
                  {
                    "name": "tpk_m",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::public_keys::TpkM"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::public_keys::PublicKeys"
              }
            },
            {
              "name": "deployer",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractInstanceRegistry::ContractInstancePublished"
        },
        {
          "fields": [
            {
              "name": "CONTRACT_INSTANCE_UPDATED_MAGIC_VALUE",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "address",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            },
            {
              "name": "prev_contract_class_id",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::contract_class_id::ContractClassId"
              }
            },
            {
              "name": "new_contract_class_id",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::contract_class_id::ContractClassId"
              }
            },
            {
              "name": "timestamp_of_change",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "ContractInstanceRegistry::ContractInstanceUpdated"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "ContractInstanceRegistry::get_update_delay_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 64
              }
            }
          ],
          "kind": "struct",
          "path": "ContractInstanceRegistry::get_update_delay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_salt",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  },
                  {
                    "name": "_initialization_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_public_keys",
                    "type": {
                      "fields": [
                        {
                          "name": "npk_m",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "x",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "y",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "is_infinite",
                                      "type": {
                                        "kind": "boolean"
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::public_keys::NpkM"
                          }
                        },
                        {
                          "name": "ivpk_m",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "x",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "y",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "is_infinite",
                                      "type": {
                                        "kind": "boolean"
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::public_keys::IvpkM"
                          }
                        },
                        {
                          "name": "ovpk_m",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "x",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "y",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "is_infinite",
                                      "type": {
                                        "kind": "boolean"
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::public_keys::OvpkM"
                          }
                        },
                        {
                          "name": "tpk_m",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "x",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "y",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "is_infinite",
                                      "type": {
                                        "kind": "boolean"
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::public_keys::TpkM"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::public_keys::PublicKeys"
                    }
                  },
                  {
                    "name": "_universal_deploy",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractInstanceRegistry::publish_for_public_execution_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractInstanceRegistry::publish_for_public_execution_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_update_delay",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractInstanceRegistry::set_update_delay_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractInstanceRegistry::set_update_delay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_new_contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractInstanceRegistry::update_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractInstanceRegistry::update_abi"
        }
      ]
    }
  },
  "file_map": {
    "0": {
      "path": "std/aes128.nr",
      "source": "// docs:start:aes128\n// Given a plaintext as an array of bytes, returns the corresponding aes128 ciphertext (CBC mode). Input padding is performed using PKCS#7, so that the output length is `input.len() + (16 - input.len() % 16)`.\npub fn aes128_encrypt<let N: u32>(\n    input: [u8; N],\n    iv: [u8; 16],\n    key: [u8; 16],\n) -> [u8; N + 16 - N % 16] {\n    let padding_length = (16 - N % 16) as u8;\n    let mut padded_input: [u8; N + 16 - N % 16] = [0; N + 16 - N % 16];\n    for i in 0..N {\n        padded_input[i] = input[i];\n    }\n    for i in N..N + 16 - N % 16 {\n        padded_input[i] = padding_length;\n    }\n    let output = aes128_encrypt_padded_input(padded_input, iv, key);\n    output\n}\n\n#[foreign(aes128_encrypt)]\nfn aes128_encrypt_padded_input<let N: u32>(input: [u8; N], iv: [u8; 16], key: [u8; 16]) -> [u8; N] {}\n\n// docs:end:aes128\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n//\n// IMPORTANT: Prefer `multi_scalar_mul()` over repeated `embedded_curve_add()`\n// for adding multiple points. This is significantly more efficient.\n// For adding exactly 2 points, use `embedded_curve_add()` directly.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// Elliptic curve addition\n/// IMPORTANT: this function is expected to perform a full addition in order to handle all corner cases:\n/// - points on the curve\n/// - point doubling\n/// - point at infinity\n/// As a result, you may not get optimal performance, depending on the assumptions of your inputs.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // avoid calling the black box function for trivial cases\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_inner(point1, point2)\n        }\n    } else {\n        embedded_curve_add_inner(point1, point2)\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// EC addition wrapper for the foreign function\nfn embedded_curve_add_inner(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    crate::assert_constant(separator);\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "230": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called\n/// and if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 12;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "298": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.2.3/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let num_extra_fields = in_len % RATE;\n            if num_extra_fields != 0 {\n                let remainder_start = in_len - num_extra_fields;\n                state[0] += input[remainder_start];\n                if num_extra_fields > 1 {\n                    state[1] += input[remainder_start + 1]\n                }\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4)\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a vector.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let vector = array.as_vector();\n    /// assert_eq(vector, [1, 2].as_vector());\n    /// ```\n    #[builtin(as_vector)]\n    pub fn as_vector(self) -> [T] {}\n\n    /// Returns this array as a vector.\n    /// This method is deprecated in favor of `as_vector`.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let vector = array.as_slice();\n    /// assert_eq(vector, [1, 2].as_vector());\n    /// ```\n    #[builtin(as_vector)]\n    #[deprecated(\"This method has been renamed to `as_vector`\")]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "356": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, DOM_SEP__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE},\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::sqrt,\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address as x, and then solving for y in the\n        // equation which defines the grumpkin curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = x * x * x - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        sqrt(y_squared).map(|y| {\n            // If we get a negative y coordinate (y > (r - 1) / 2), we swap it to the\n            // positive one (where y <= (r - 1) / 2) by negating it.\n            let final_y = if Self::is_positive(y) { y } else { -y };\n\n            AddressPoint { inner: Point { x: self.inner, y: final_y, is_infinite: false } }\n        })\n    }\n\n    /// Determines whether a y-coordinate is in the lower (positive) or upper (negative) \"half\" of the field.\n    /// I.e.\n    /// y <= (r - 1)/2 => positive.\n    /// y > (r - 1)/2 => negative.\n    /// An AddressPoint always uses the \"positive\" y.\n    fn is_positive(y: Field) -> bool {\n        // Note: The field modulus r is MAX_FIELD_VALUE + 1.\n        let MID = MAX_FIELD_VALUE / 2; // (r - 1) / 2\n        let MID_PLUS_1 = MID + 1; // (r - 1)/2 + 1\n        // Note: y <= m implies y < m + 1.\n        y.lt(MID_PLUS_1)\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        //\n        //                          address = address_point.x\n        //                                          |\n        //                                    address_point = pre_address * G + Ivpk_m (always choose \"positive\" y-coord)\n        //                                                        |               ^\n        //                                                        |               |.....................\n        //                                                    pre_address                              .\n        //                                               /                   \\                         .\n        //                                             /                       \\                       .\n        //                               partial_address                        public_keys_hash       .\n        //                           /                    \\                     /   /    \\    \\        .\n        //                         /                        \\              Npk_m Ivpk_m Ovpk_m Tpk_m   .\n        //          contract_class_id                         \\                     |...................\n        //             /   |    \\                               \\\n        // artifact_hash   |    public_bytecode_commitment       salted_initialization_hash\n        //                 |                                         /     /        \\\n        //     private_function_tree_root              deployer_address  salt   initialization_hash\n        //             /       \\                                                /              \\\n        //          ...          ...                              constructor_fn_selector   constructor_args_hash\n        //         /                \\\n        //     /     \\            /      \\\n        //   leaf   leaf        leaf    leaf\n        //           ^\n        //           |\n        //           |---h(function_selector, vk_hash)\n        //               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        //               Each of these represents a private function of the contract.\n\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            DOM_SEP__CONTRACT_ADDRESS_V1,\n        );\n\n        // Note: `.add()` will fail within the blackbox fn if either of the points are not on the curve. (See tests below).\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn check_max_field_value() {\n    // Check that it is indeed r-1.\n    assert_eq(MAX_FIELD_VALUE + 1, 0);\n}\n\n#[test]\nfn check_is_positive() {\n    assert(AztecAddress::is_positive(0));\n    assert(AztecAddress::is_positive(1));\n    assert(!AztecAddress::is_positive(-1));\n    assert(AztecAddress::is_positive(MAX_FIELD_VALUE / 2));\n    assert(!AztecAddress::is_positive((MAX_FIELD_VALUE / 2) + 1));\n}\n\n// Gives us confidence that we don't need to manually check that the input public keys need to be on the curve for `add`,\n// because the blackbox function does this check for us.\n#[test(should_fail_with = \"is not on curve\")]\nfn check_embedded_curve_point_add() {\n    // Choose a point not on the curve:\n    let p1 = Point { x: 1, y: 1, is_infinite: false };\n    let p2 = Point::generator();\n    let _ = p1 + p2;\n}\n\n// Gives us confidence that we don't need to manually check that the input public keys need to be on the curve for `add`,\n// because the blackbox function does this check for us.\n#[test(should_fail_with = \"is not on curve\")]\nfn check_embedded_curve_point_add_2() {\n    // Choose a point not on the curve in the 2nd position.\n    let p1 = Point::generator();\n    let p2 = Point { x: 1, y: 1, is_infinite: false };\n    let _ = p1 + p2;\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x2f66081d4bb077fbe8e8abe96a3516a713a3d7e34360b4e985da0da95092b37d;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], DOM_SEP__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x286c7755f2924b1e53b00bcaf1adaffe7287bd74bba7a02f4ab867e3892d28da;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(point.y * point.y, point.x * point.x * point.x - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "359": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::DOM_SEP__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Empty, Serialize, ToField},\n};\nuse std::meta::derive;\n\n// Partial address\n#[derive(Deserialize, Eq, Serialize)]\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Empty for PartialAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            DOM_SEP__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\nmod test {\n    use crate::{address::partial_address::PartialAddress, traits::{Deserialize, Serialize}};\n\n    #[test]\n    fn serialization_of_partial_address() {\n        let item = PartialAddress::from_field(1);\n        let serialized: [Field; 1] = item.serialize();\n        let deserialized = PartialAddress::deserialize(serialized);\n        assert_eq(item, deserialized);\n    }\n}\n"
    },
    "361": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::DOM_SEP__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\n#[derive(Eq)]\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            DOM_SEP__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "379": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/delayed_public_mutable/delayed_public_mutable_values.nr",
      "source": "use crate::{\n    delayed_public_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    hash::poseidon2_hash,\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// DelayedPublicMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.timestamp_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct DelayedPublicMutableValues<T, let INITIAL_DELAY: u64> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u64> DelayedPublicMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        DelayedPublicMutableValues { svc, sdc }\n    }\n}\n\n/// Extracts a ScheduledValueChange struct from the packed representation of the full DelayedPublicMutable.\n/// TODO: impl the packable trait for ScheduledValueChange.\npub fn unpack_value_change<T, let M: u32>(packed: [Field; 2 * M + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N = M>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, M + 1);\n\n    // We first cast to u32 as the timestamp_of_change is packed into the same field as the delay change and it\n    // occupies the first 32 bits of the field.\n    let timestamp_of_change = (packed[0] as u32) as u64;\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        timestamp_of_change,\n    )\n}\n\n/// Extracts a ScheduledDelayChange struct from 0th field of the packed representation of the full DelayedPublicMutable.\n/// This function expects to be called with just the first field of the packed representation, which contains sdc\n/// and svc timestamp_of_change. We'll discard the svc component.\npub fn unpack_delay_change<let INITIAL_DELAY: u64>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc timestamp_of_change. We'll discard the svc component.\n    let svc_timestamp_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_timestamp_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    // Note that below we cast the values to u64 as that is the default type of timestamp in the system. Us packing\n    // the values as u32 is a tech debt that is not worth tackling.\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner as u64)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner as u64)\n        } else {\n            Option::none()\n        },\n        timestamp_of_change: sdc_timestamp_of_change as u64,\n    }\n}\n\n// Q: do these evaluate at comptime or runtime?\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the timestamp_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u64> Packable for DelayedPublicMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable,\n{\n    let N: u32 = 2 * <T as Packable>::N + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result = [0; Self::N];\n\n        // We pack sdc.pre, sdc.post, sdc.timestamp_of_change and svc.timestamp_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.timestamp_of_change: u32 | svc.timestamp_of_change: u32 ]\n        // Note that the code below no longer works after 2106 as by that time the timestamp will overflow u32. This is a tech debt that is not worth tackling.\n        result[0] = self.svc.timestamp_of_change as Field\n            + ((self.sdc.timestamp_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..<T as Packable>::N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + <T as Packable>::N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    // Note: inefficient if all you want to unpack is the svc; use unpack_value_change instead.\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let svc = unpack_value_change::<T, _>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> Hash for DelayedPublicMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "382": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/delayed_public_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by DelayedPublicMutable to store the minimum delay with which a ScheduledValueChange\n// object can schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u64> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u64>,\n    pub(crate) post: Option<u64>,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<let INITIAL_DELAY: u64> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u64>, post: Option<u64>, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// WARNING: This function only returns a meaningful value when called in public with the current timestamp - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_timestamp: u64) -> u64 {\n        // The post value becomes the current one at the timestamp of change, so any transaction that is included at or\n        // after the timestamp of change will use the post value.\n        if current_timestamp < self.timestamp_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the timestamp at which it will become the current\n    /// delay. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u64, u64) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.timestamp_of_change)\n    }\n\n    /// Schedules a change to the delay, given the `current_timestamp` and the `current` delay.\n    /// This function is only meaningful when called in public with the current timestamp.\n    /// The timestamp at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u64, current_timestamp: u64) {\n        let current = self.get_current(current_timestamp);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let time_until_delay_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            //\n            //\n            //                                Earliest `svc.timestamp_of_change`,     Earliest `svc.timestamp_of_change`\n            //   `current_timestamp`          if the delay had remained unchanged     immediately after this scheduling fn.\n            //      v                                                          v              v\n            //  ====|==========================================================|==============|==>\n            //      |                                                          |              |\n            //      [------------------`current` delay-------------------------]              |\n            //      |                                                                         |\n            //      [-------------------------`new` (longer) delay----------------------------]\n            //      |\n            //      [] <--- `time_until_delay_change` is `0`; the change is immediate.\n            //      |\n            //      ^\n            //      The newly-calculated `self.timestamp_of_change` (unchanged)\n\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //\n            //                                                   Earliest `svc.timestamp_of_change`,\n            //                                                   if the delay had remained unchanged\n            //                                                   AND\n            //                                                   Earliest `svc.timestamp_of_change`,\n            //   `current_timestamp`                             immediately after this scheduling fn.\n            //  ====|============================|=============================|=================>\n            //      |                                                          |\n            //      [---------------------`current` delay----------------------]\n            //                                   |                             |\n            //                                   [- --`new` (shorter) delay----]\n            //                                   |                             ^\n            //      [-`time_until_delay_change`--]                             |\n            //                                   |                             |\n            //                                   ^                             |\n            //                                   The newly-calculated          |\n            //                                  `self.timestamp_of_change`     |\n            //                                                                 |\n            //                                                      The new `self.timestamp_of_change`\n            //                                                      is calculated so that these ends\n            //                                                      align.\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.timestamp_of_change = current_timestamp + time_until_delay_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// anchor block timestamp. It only returns a meaningful value when called in private with anchor block timestamps.\n    /// The output of this function can be passed into `ScheduledValueChange.get_time_horizon` to properly\n    /// constrain the `expiration_timestamp` when reading delayed mutable state.\n    /// This value typically equals the current delay at the timestamp following the anchor block one (the earliest one\n    /// in which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    ///\n    /// Alternative explanation: returns the maximum amount of time (from the anchor block timestamp) that a state read\n    /// (as at the anchor block timestamp) will remain valid.\n    /// A read might end up being valid for less time in the case where a `svc.timestamp_of_change` has already been\n    /// set and if it's sooner than the output of this function. In that case, the `scheduled_value_change.nr`'s\n    /// `get_time_horizon` function will realize this.\n    ///\n    pub fn get_effective_minimum_delay_at(self, anchor_block_timestamp: u64) -> u64 {\n        // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n        // timestamp of change the current delay will be the scheduled one, with an overall delay from the anchor block\n        // timestamp equal to the time until the change plus the new delay. If this value is lower\n        // than the current delay, then that is the effective minimum delay.\n\n        // If using some block as the anchor block of some tx, then note that if you\n        // read a `delayed_mutable` from that anchor block, you're actually reading the\n        // `delayed_mutable` _as at the very end_ of that block.\n        // Therefore the `delayed_mutable` that you will read _as at the very start of the next\n        // block_ will be _the very same_ `delayed_mutable` (nothing can possibly have changed).\n        // Therefore the first opportunity to schedule a value change (from the anchor block timestamp)\n        // is the first tx of a subsequent block. Blocks within the same checkpoint can share\n        // timestamps, so the earliest scheduling timestamp can equal the anchor block timestamp.\n        // So should you choose to go ahead and schedule a value change in a subsequent block,\n        // it will only take effect after the \"current\" delay (as dictated by the\n        // `delayed_mutable` of that tx, which is the same as the `delayed_mutable` as at the\n        // anchor block timestamp).\n        // In all, the time between the anchor block's timestamp and the earliest-possible value\n        // timestamp_of_change, is therefore: the \"current\" delay (as at the time of the anchor\n        // timestamp).\n        // Reads must only be valid until _just before_ the earliest-possible value change --\n        // i.e. 1 second before the earliest-possible value change.\n        // That is, reads are only valid for the \"current\" delay (as at the time of the anchor\n        // block timestamp) _at most_.\n        //\n        //  ____________                               ____________\n        // |            |                             |            |\n        // |  Block     |<-- 0 or more seconds gap -->|  Block     |\n        // |____________|                             |____________|\n        //              ^                              ^\n        //              |                              You can schedule a value change from here.\n        //              |\n        //    Suppose this is your anchor block.\n        //    The delayed_mutable (and hence the \"current\" delay) as at the end of this block will\n        //    be the same as at the start of the next block.\n        //\n        if self.timestamp_of_change <= anchor_block_timestamp {\n            //\n            //              `self.timestamp_of_change` <= `anchor_block_timestamp`\n            //                    v                              v\n            // ===================|==============================|=========\n            // ^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            // `self.pre` is      |`self.post` takes effect from here.\n            // effective before.  |\n            //\n            // So in this `if` case, `self.post` is in effect at the time of the `anchor_block_timestamp`.\n            //\n            // If no delay changes are scheduled (as at the time of the anchor timestamp), then the \"current delay\" (as\n            // at the time of the anchor block timestamp) is `self.post - 1` (or the `INITIAL_DELAY - 1` if never set).\n            self.post.unwrap_or(INITIAL_DELAY) - 1\n        } else {\n            //\n            //          `anchor_block_timestamp` < `self.timestamp_of_change`\n            //                                           v\n            // ===================|======================|====================================\n            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            //           `self.pre` is effective         |`self.post` takes effect from here.\n            //           during this period.             |\n            //\n            //\n            // So in this `else` case, `self.pre` is in effect at the time of the `anchor_block_timestamp`.\n            //\n            //\n            //\n            // If a delay change _is_ already scheduled (as at the time of the anchor block timestamp):\n            //      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            //                   |________________\n            //                                    |\n            //                                    v                          Earliest possible\n            //  `anchor_block_          Scheduled delay change:               `svc.timestamp_of_change`\n            //  timestamp`      <      `self.timestamp_of_change`            (if not already set [^1])\n            //     v                              v                                    v\n            //  ===|==============================|====================================|================>\n            //     |                              .                                    .\n            //     |                              .                                    .\n            //     |__ Earliest possible timestamp at which a                          .\n            //     .    function could call `schedule_change` for a new                .\n            //     .    _value_ change.................................................| And the earliest timestamp at\n            //     .                              .                                    . which the new value would take effect,\n            //     .                              .                                    . as dictated by `self.pre`.\n            //     .                              .                                    .\n            //     [---------------`self.pre` delay------------------------------------]\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     ********************************************************************.\n            //     *                                                                  *.\n            //     [----------------`self.pre - 1`------------------------------------].\n            //     *                                                                  *.\n            //     * If reading a _value_ at that (<--) anchor timestamp, then the    *.\n            //     * read will remain valid for this duration, unless a shorter       *.\n            //     * delay has been scheduled (see just below in this diagram).       *.\n            //     * See the `min` calc in the code below.                            *.\n            //     *                                                                  *.\n            //     * Future enhancement, recorded here so we don't have to            *.\n            //     * re-remember it:                                                  *.\n            //     * If a _deferred, longer_ delay has been scheduled (not yet        *.\n            //     * possible), it might yet still be cancelled, in which case this   *.\n            //     * `pre - 1` delay would also bite (meaning reads would remain      *.\n            //     * valid for this duration).                                        *.\n            //     *                                                                  *.\n            //     ********************************************************************.\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     [---`time_until_delay_change`--]                                    .\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     SCENARIO 1: an already-scheduled delay is shorter than the `self.pre` delay:\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     .                              [-`self.post` delay-]                .\n            //     .                              . (if shorter      ^^                .\n            //     .                              .  than `pre`)     ||_ new values can take effect from here.\n            //     .                              .                  |\n            //     .                              .                  |_ reads are only valid until here:\n            //     .                              .                  .  `anchor_block_timestamp + time_until_delay_change + self.post - 1`\n            //     .                              .                  .                 .\n            //     ***************************************************                 .\n            //     *                                                 *                 .\n            //     [----`time_until_delay_change + self.post - 1`----]                 .\n            //     *                                                 *                 .\n            //     * If reading a _value_ at that (<--) anchor       *                 .\n            //     * timestamp, then the read will remain valid      *                 .\n            //     * for this duration:                              *                 .\n            //     *                                                 *                 .\n            //     ***************************************************                 .\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     SCENARIO 2: an already-scheduled delay is longer than the `self.pre` delay, AND is deferred:\n            //     (note: scheduling deferred delay changes is not yet possible)\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     .                              .                                    .\n            //     .                              [-`self.post` delay (if longer than `pre` & deferred)------------------]\n            //     .                              .  (scheduling deferred delay changes is not yet possible)            ^^\n            //     .                              .                                                                     ||\n            //     .                              .     reads would only be valid until here:___________________________||\n            //     .                              .     `anchor_block_timestamp + time_until_delay_change + self.post - 1` |\n            //     .                              .                                                                      |\n            //     .                              .                        new values would take effect from here,_______|\n            //     .                              .                        but only once this longer delay takes effect  .\n            //     .                              .                                    .                                 .\n            //     .                              .                                    .                                 .\n            //     .                              .                                    .                                 .\n            //     ******************************************************************************************************.\n            //     *                                                                                                    *.\n            //     [----`time_until_delay_change + self.post - 1`-------------------------------------------------------].\n            //     *                                                                                                    *.\n            //     * Given a longer, deferred delay, then if reading a _value_ at that (<--) anchor block timestamp, then *.\n            //     * you might think the read would remain valid for this duration.                                     *.\n            //     * BUT, in this case of this deferred, longer-than-`self.pre` delay, the `pre` delay ends sooner (by  *.\n            //     * construction) (see above in this diagram).                                                         *.\n            //     * And since this scheduled delay (`post`) can be cancelled up until the time it takes effect,        *.\n            //     * any reads as at that (<--) anchor block timestamp would cautiously only be valid until the earlier   *.\n            //     * `pre` delay expiry.                                                                                *.\n            //     *                                                                                                    *.\n            //     ******************************************************************************************************.\n            //\n            //\n            //\n            // [^1] If a svc.timestamp_of_change has already been set, and if it's sooner than the\n            //      output of this function, then it will bite within `scheduled_value_change.nr`'s\n            //      `get_time_horizon` function.\n            let time_until_delay_change = self.timestamp_of_change - anchor_block_timestamp;\n\n            let time_until_next_delay_change = min(\n                self.pre.unwrap_or(INITIAL_DELAY), // in case the scheduled delay (`post`) gets cancelled before it takes effect.\n                time_until_delay_change + self.post.unwrap_or(INITIAL_DELAY),\n            );\n\n            // The effective minimum delay equals the minimum time until a value change, minus 1, since reads are\n            // valid only up to (but not including) the moment the value can change.\n            time_until_next_delay_change - 1\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "384": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/delayed_public_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by DelayedPublicMutable to represent a value that changes from `pre` to `post` at some timestamp\n// called the `timestamp_of_change`. The value can only be made to change by scheduling a change event at some future\n// timestamp after some minimum delay measured in seconds has elapsed. This means that at any given timestamp we know\n// both the current value and the smallest timestamp at which the value might change - this is called the\n// 'time horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given timestamp. This function can be called both in public\n    /// (where `timestamp` is simply the current timestamp, i.e. the timestamp at which the current transaction will be\n    /// included) and in private (where `timestamp` is the anchor block's timestamp). Reading in private is only safe\n    /// if the transaction's `expiration_timestamp` property is set to a value lower or equal to the time horizon (see\n    /// `get_time_horizon()`).\n    pub fn get_current_at(self, timestamp: u64) -> T {\n        // The post value becomes the current one at the timestamp of change. This means different things in each realm:\n        // - in public, any transaction that is included at the timestamp of change will use the post value\n        // - in private, any transaction that includes the timestamp of change as part of the historical state will use\n        //   the post value (barring any follow-up changes)\n        if timestamp < self.timestamp_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the timestamp at which it will become the current\n    /// value. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u64) {\n        (self.post, self.timestamp_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the timestamp of change. Note that this\n    // value might not be the current anymore since timestamp of change might have already passed.\n    pub fn get_previous(self) -> (T, u64) {\n        (self.pre, self.timestamp_of_change)\n    }\n\n    /// Returns the largest timestamp at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private where the proof is constructed against an anchor block, since\n    /// due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum time in seconds that needs to\n    /// elapse from the next block's timestamp until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a anchor block's timestamp is only safe to use\n    /// if the transaction's `expiration_timestamp` property is set to a value lower or equal to the time horizon\n    /// computed using the same anchor timestamp.\n    pub fn get_time_horizon(self, anchor_block_timestamp: u64, minimum_delay: u64) -> u64 {\n        // The time horizon is the very last timestamp in which the current value is known. Any timestamp past the\n        // horizon (i.e. with a timestamp larger than the time horizon) may have a different current value.\n        // Reading the current value in private typically requires constraining the maximum valid timestamp to be equal\n        // to the time horizon.\n        if anchor_block_timestamp >= self.timestamp_of_change {\n            // Once the timestamp of change has passed (block with timestamp >= timestamp_of_change was mined),\n            // the current value (post) will not change unless a new value change is scheduled. This did not happen at\n            // the anchor timestamp (or else it would not be greater or equal to the timestamp of change), and\n            // therefore could only happen after the anchor timestamp. The earliest would be the immediate next\n            // timestamp, and so the smallest possible next timestamp of change equals `anchor_block_timestamp + 1 +\n            // minimum_delay`. Our time horizon is simply the previous timestamp to that one.\n            //\n            //   timestamp of    anchor\n            //      change       timestamp          time horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            anchor_block_timestamp + minimum_delay\n        } else {\n            // If the timestamp of change has not yet been reached however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the time horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the timestamp of change is in the past: the time horizon is\n            //      the timestamp prior to the earliest one in which a new timestamp of change might land.\n            //\n            //         anchor\n            //         timestamp                      time horizon    timestamp of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` seconds away from the anchor timestamp, in which case\n            //      the timestamp of change would become the limiting factor for the time horizon, which would equal\n            //      the timestamp right before the timestamp of change (since by definition the value changes at the\n            //      timestamp of change).\n            //\n            //           anchor                         time horizon\n            //           timestamp   timestamp of change    if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the timestamp of change to an\n            // arbitrary value, and therefore scenario a) is not currently possible. However implementing #5501 would\n            // allow for this to happen.\n            // Because anchor_block_timestamp < self.timestamp_of_change, then timestamp_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                anchor_block_timestamp + minimum_delay,\n                self.timestamp_of_change - 1,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current timestamp. This function is only meaningful when\n    /// called in public with the current timestamp.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_timestamp: u64,\n        minimum_delay: u64,\n        timestamp_of_change: u64,\n    ) {\n        assert(timestamp_of_change >= current_timestamp + minimum_delay);\n\n        self.pre = self.get_current_at(current_timestamp);\n        self.post = new_value;\n        self.timestamp_of_change = timestamp_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "387": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector, nullifier::Nullifier, private_log::PrivateLog,\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, DOM_SEP__NOTE_HASH_NONCE,\n        DOM_SEP__PRIVATE_LOG_FIRST_FIELD, DOM_SEP__SILOED_NOTE_HASH, DOM_SEP__SILOED_NULLIFIER,\n        DOM_SEP__UNIQUE_NOTE_HASH, FUNCTION_TREE_HEIGHT, NULL_MSG_SENDER_CONTRACT_ADDRESS,\n        TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\n// TODO: refactor these into their own files: sha256, poseidon2, some protocol-specific hash computations, some merkle computations.\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn compute_siloed_note_hash(contract_address: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address.to_field(), note_hash],\n        DOM_SEP__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique, siloed note hashes from siloed note hashes.\n///\n/// The protocol injects uniqueness into every note_hash, so that every single note_hash in the\n/// tree is unique. This prevents faerie gold attacks, where a malicious sender could create\n/// two identical note_hashes for a recipient (meaning only one would be nullifiable in future).\n///\n/// Most privacy protocols will inject the note's leaf_index (its position in the Note Hashes Tree)\n/// into the note, but this requires the creator of a note to wait until their tx is included in\n/// a block to know the note's final note hash (the unique, siloed note hash), because inserting\n/// leaves into trees is the job of a block producer.\n///\n/// We took a different approach so that the creator of a note will know each note's unique, siloed\n/// note hash before broadcasting their tx to the network.\n/// (There was also a historical requirement relating to \"chained transactions\" -- a feature that\n/// Aztec Connect had to enable notes to be spent from distinct txs earlier in the same block,\n/// and hence before an archive block root had been established for that block -- but that feature\n/// was abandoned for the Aztec Network for having too many bad tradeoffs).\n///\n/// (\n///   Edit: it is no longer true that all final note_hashes will be known by the creator of a tx\n///   before they send it to the network. If a tx makes public function calls, then _revertible_\n///   note_hashes that are created in private will not be made unique in private by the Reset circuit,\n///   but will instead be made unique by the AVM, because the `note_index_in_tx` will not be known\n///   until the AVM has executed the public functions of the tx. (See an explanation in\n///   reset_output_composer.nr for why).\n///   For some such txs, the `note_index_in_tx` might still be predictable through simulation, but\n///   for txs whose public functions create a varying number of non-revertible notes (determined at\n///   runtime), the `note_index_in_tx` will not be deterministically derivable before submitting the\n///   tx to the network.\n/// )\n///\n/// We use the `first_nullifier` of a tx as a seed of uniqueness. We have a guarantee that there will\n/// always be at least one nullifier per tx, because the init circuit will create one if one isn't\n/// created naturally by any functions of the tx. (Search \"protocol_nullifier\").\n/// We combine the `first_nullifier` with the note's index (its position within this tx's new\n/// note_hashes array) (`note_index_in_tx`) to get a truly unique value to inject into a note, which\n/// we call a `note_nonce`.\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, DOM_SEP__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        DOM_SEP__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_note_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier(contract_address: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address.to_field(), nullifier],\n        DOM_SEP__SILOED_NULLIFIER,\n    )\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    // The protocol nullifier is ascribed a special side-effect counter of 1. No other side-effect\n    // can have counter 1 (see `validate_as_first_call` for that assertion).\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_first_field(\n    contract_address: AztecAddress,\n    field: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address.to_field(), field],\n        DOM_SEP__PRIVATE_LOG_FIRST_FIELD,\n    )\n}\n\npub fn compute_siloed_private_log(contract_address: AztecAddress, log: PrivateLog) -> PrivateLog {\n    let mut fields = log.fields;\n    fields[0] = compute_siloed_private_log_first_field(contract_address, fields[0]);\n    PrivateLog::new(fields, log.length)\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_siloed_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    key_type_domain_separator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        key_type_domain_separator,\n    )\n}\n\npub fn compute_l2_to_l1_message_hash(\n    message: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = message.contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = message.inner.recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = message.inner.content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\n// TODO: consider a variant that enables domain separation with a u32 (we seem to have standardised u32s for domain separators)\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn subarray_hash_matches_fixed() {\n    let mut values_to_hash = [3; 17];\n    let mut padded = values_to_hash.concat([0; 11]);\n    let subarray_hash = poseidon2_hash_subarray(padded, values_to_hash.len());\n\n    // Hash the entire values_to_hash.\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(values_to_hash, values_to_hash.len());\n\n    assert_eq(subarray_hash, fixed_len_hash);\n}\n\n#[test]\nfn subarray_hash_matches_variable() {\n    let mut values_to_hash = [3; 17];\n    let mut padded = values_to_hash.concat([0; 11]);\n    let subarray_hash = poseidon2_hash_subarray(padded, values_to_hash.len());\n\n    // Hash up to values_to_hash.len() fields of the padded array.\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(padded, values_to_hash.len());\n\n    assert_eq(subarray_hash, variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn unique_siloed_note_hash_matches_typescript() {\n    let inner_note_hash = 1;\n    let contract_address = AztecAddress::from_field(2);\n    let first_nullifier = 3;\n    let note_index_in_tx = 4;\n\n    let siloed_note_hash = compute_siloed_note_hash(contract_address, inner_note_hash);\n    let siloed_note_hash_from_ts =\n        0x1986a4bea3eddb1fff917d629a13e10f63f514f401bdd61838c6b475db949169;\n    assert_eq(siloed_note_hash, siloed_note_hash_from_ts);\n\n    let nonce: Field = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    let note_hash_nonce_from_ts =\n        0x28e7799791bf066a57bb51fdd0fbcaf3f0926414314c7db515ea343f44f5d58b;\n    assert_eq(nonce, note_hash_nonce_from_ts);\n\n    let unique_siloed_note_hash_from_nonce = compute_unique_note_hash(nonce, siloed_note_hash);\n    let unique_siloed_note_hash = compute_note_nonce_and_unique_note_hash(\n        siloed_note_hash,\n        first_nullifier,\n        note_index_in_tx,\n    );\n    assert_eq(unique_siloed_note_hash_from_nonce, unique_siloed_note_hash);\n\n    let unique_siloed_note_hash_from_ts =\n        0x29949aef207b715303b24639737c17fbfeb375c1d965ecfa85c7e4f0febb7d16;\n    assert_eq(unique_siloed_note_hash, unique_siloed_note_hash_from_ts);\n}\n\n#[test]\nfn siloed_nullifier_matches_typescript() {\n    let contract_address = AztecAddress::from_field(123);\n    let nullifier = 456;\n\n    let res = compute_siloed_nullifier(contract_address, nullifier);\n\n    let siloed_nullifier_from_ts =\n        0x169b50336c1f29afdb8a03d955a81e485f5ac7d5f0b8065673d1e407e5877813;\n\n    assert_eq(res, siloed_nullifier_from_ts);\n}\n\n#[test]\nfn siloed_private_log_first_field_matches_typescript() {\n    let contract_address = AztecAddress::from_field(123);\n    let field = 456;\n    let res = compute_siloed_private_log_first_field(contract_address, field);\n\n    let siloed_private_log_first_field_from_ts =\n        0x29480984f7b9257fded523d50addbcfc8d1d33adcf2db73ef3390a8fd5cdffaa;\n\n    assert_eq(res, siloed_private_log_first_field_from_ts);\n}\n\n#[test]\nfn empty_l2_to_l1_message_hash_matches_typescript() {\n    // All zeroes\n    let res = compute_l2_to_l1_message_hash(\n        L2ToL1Message { recipient: EthAddress::zero(), content: 0 }.scope(AztecAddress::from_field(\n            0,\n        )),\n        0,\n        0,\n    );\n\n    let empty_l2_to_l1_msg_hash_from_ts =\n        0x003b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992;\n\n    assert_eq(res, empty_l2_to_l1_msg_hash_from_ts);\n}\n\n#[test]\nfn l2_to_l1_message_hash_matches_typescript() {\n    let message = L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n        AztecAddress::from_field(3),\n    );\n    let version = 4;\n    let chainId = 5;\n\n    let hash = compute_l2_to_l1_message_hash(message, version, chainId);\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let l2_to_l1_message_hash_from_ts =\n        0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, l2_to_l1_message_hash_from_ts);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "389": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/logging.nr",
      "source": "// Log levels matching the JS logger:\n\n// global SILENT_LOG_LEVEL: u8 = 0;\nglobal FATAL_LOG_LEVEL: u8 = 1;\nglobal ERROR_LOG_LEVEL: u8 = 2;\nglobal WARN_LOG_LEVEL: u8 = 3;\nglobal INFO_LOG_LEVEL: u8 = 4;\nglobal VERBOSE_LOG_LEVEL: u8 = 5;\nglobal DEBUG_LOG_LEVEL: u8 = 6;\nglobal TRACE_LOG_LEVEL: u8 = 7;\n\n// --- Per-level log functions (no format args) ---\n\npub fn fatal_log<let N: u32>(msg: str<N>) {\n    fatal_log_format(msg, []);\n}\n\npub fn error_log<let N: u32>(msg: str<N>) {\n    error_log_format(msg, []);\n}\n\npub fn warn_log<let N: u32>(msg: str<N>) {\n    warn_log_format(msg, []);\n}\n\npub fn info_log<let N: u32>(msg: str<N>) {\n    info_log_format(msg, []);\n}\n\npub fn verbose_log<let N: u32>(msg: str<N>) {\n    verbose_log_format(msg, []);\n}\n\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\npub fn trace_log<let N: u32>(msg: str<N>) {\n    trace_log_format(msg, []);\n}\n\n// --- Per-level log functions (with format args) ---\n\npub fn fatal_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    log_format(FATAL_LOG_LEVEL, msg, args);\n}\n\npub fn error_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    log_format(ERROR_LOG_LEVEL, msg, args);\n}\n\npub fn warn_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    log_format(WARN_LOG_LEVEL, msg, args);\n}\n\npub fn info_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    log_format(INFO_LOG_LEVEL, msg, args);\n}\n\npub fn verbose_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    log_format(VERBOSE_LOG_LEVEL, msg, args);\n}\n\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    log_format(DEBUG_LOG_LEVEL, msg, args);\n}\n\npub fn trace_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    log_format(TRACE_LOG_LEVEL, msg, args);\n}\n\nfn log_format<let M: u32, let N: u32>(log_level: u8, msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { log_oracle_wrapper(log_level, msg, args) };\n}\n\nunconstrained fn log_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    log_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityLog)]\nunconstrained fn log_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "403": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\npub fn validate_on_curve(p: Point) {\n    // y^2 == x^3 - 17\n    let x = p.x;\n    let y = p.y;\n    if p.is_infinite {\n        // Assert the canonical representation of infinity\n        assert_eq(x, 0, \"Point at infinity should have canonical representation (0 0)\");\n        assert_eq(y, 0, \"Point at infinity should have canonical representation (0 0)\");\n    } else {\n        assert_eq(y * y, x * x * x - 17, \"Point not on curve\");\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n\nmod tests {\n    use super::validate_on_curve;\n    use std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn test_validate_on_curve_generator() {\n        // The generator point should be on the curve\n        let generator = Point::generator();\n        validate_on_curve(generator);\n    }\n\n    #[test]\n    unconstrained fn test_validate_on_curve_infinity() {\n        // Canonical infinite point (x=0, y=0) should pass\n        let infinity = Point { x: 0, y: 0, is_infinite: true };\n        validate_on_curve(infinity);\n    }\n\n    #[test(should_fail_with = \"Point not on curve\")]\n    unconstrained fn test_validate_on_curve_invalid_point() {\n        // A point not on the curve should fail\n        let invalid = Point { x: 1, y: 1, is_infinite: false };\n        validate_on_curve(invalid);\n    }\n\n    #[test(should_fail_with = \"Point at infinity should have canonical representation (0 0)\")]\n    unconstrained fn test_validate_on_curve_infinity_non_canonical_x() {\n        // Infinite point with non-zero x should fail\n        let invalid_infinity = Point { x: 1, y: 0, is_infinite: true };\n        validate_on_curve(invalid_infinity);\n    }\n\n    #[test(should_fail_with = \"Point at infinity should have canonical representation (0 0)\")]\n    unconstrained fn test_validate_on_curve_infinity_non_canonical_y() {\n        // Infinite point with non-zero y should fail\n        let invalid_infinity = Point { x: 0, y: 1, is_infinite: true };\n        validate_on_curve(invalid_infinity);\n    }\n}\n"
    },
    "411": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, DOM_SEP__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::validate_on_curve,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse std::{default::Default, meta::derive};\nuse std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            DOM_SEP__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n\n    pub fn validate_on_curve(self) {\n        validate_on_curve(self.npk_m.inner);\n        validate_on_curve(self.ivpk_m.inner);\n        validate_on_curve(self.ovpk_m.inner);\n        validate_on_curve(self.tpk_m.inner);\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n\n        // The following value was generated by `public_keys.test.ts`.\n        let expected_public_keys_hash =\n            0x056998309f6c119e4d753e404f94fef859dddfa530a9379634ceb0854b29bf7a;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n\n        // The following value was generated by `public_keys.test.ts`.\n        let test_data_default_hash =\n            0x023547e676dba19784188825b901a0e70d8ad978300d21d6185a54281b734da0;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "416": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{\n    constants::DOM_SEP__PUBLIC_STORAGE_MAP_SLOT, hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n// TODO: Move this to src/public_data/storage/map.nr\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash_with_separator(\n        [storage_slot, key.to_field()],\n        DOM_SEP__PUBLIC_STORAGE_MAP_SLOT,\n    )\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x2d225f361108379adc2da91378b9702675c5546b57e78bafc1e74ec7fec55967;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U>(message: T) -> U\nwhere\n    T: StringLike,\n{\n    assert(false, message);\n    crate::mem::zeroed()\n}\n\ntrait StringLike {}\n\nimpl<let N: u32> StringLike for str<N> {}\nimpl<let N: u32, T> StringLike for fmtstr<N, T> {}\n"
    },
    "433": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "439": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub(crate) mod assert_trailing_zeros;\npub(crate) mod splice_at_count;\npub(crate) mod find_index;\npub(crate) mod get_sorted_tuples;\npub(crate) mod claimed_length_array;\n\n// Re-exports.\npub use assert_trailing_zeros::assert_trailing_zeros;\npub use claimed_length_array::ClaimedLengthArray;\npub use find_index::{find_first_index, find_last_index};\npub use get_sorted_tuples::{get_sorted_tuples, SortedTuple};\npub use splice_at_count::splice_at_count;\n\nuse crate::traits::Empty;\n\n// TODO: Consider making this a part of the noir stdlib.\n/// Helper fn to create a subarray from a given array.\npub fn subarray<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\n/// Helper function to count the number of non-empty elements in a validated array.\n/// Danger: This is only safe to call if the input arrays have been \"validated\" (dense lhs, empty rhs).\n/// 1. All elements before the first empty element are non-empty\n/// 2. All elements after and including the first empty element are empty\n/// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc comment above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_first_index(array, |elem: T| elem.is_empty()) };\n\n    validate_array_length_hint(array, length);\n\n    length\n}\n\n// Extracted into a standalone function to enable testing of bad hints.\nfn validate_array_length_hint<T, let N: u32>(array: [T; N], length: u32)\nwhere\n    T: Empty,\n{\n    // Note: if length > N, the below `array` access will throw an out of bounds error.\n\n    if length != N {\n        array[length].assert_empty(\"Expected array[length] to be empty\");\n    }\n\n    if length != 0 {\n        assert(\n            !array[length - 1].is_empty(),\n            \"Expected claimed final element of array (array[length - 1]) to be nonempty\",\n        );\n    }\n}\n\n// Returns an array length defined by fully trimming _all_ \"empty\" items\n// from the RHS.\npub unconstrained fn trimmed_array_length_hint<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty,\n{\n    let index_of_last_nonempty = find_last_index(array, |elem: T| !elem.is_empty());\n    let length: u32 = if index_of_last_nonempty != N {\n        1 + index_of_last_nonempty\n    } else {\n        0\n    };\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n// ==================== subarray tests ====================\n\n#[test]\nfn test_subarray() {\n    assert_eq(subarray::<_, 5, 3>([10, 20, 30, 40, 50], 1), [20, 30, 40]);\n    assert_eq(subarray::<_, 5, 2>([10, 20, 30, 40, 50], 0), [10, 20]);\n    assert_eq(subarray::<_, 3, 0>([10, 20, 30], 2), []);\n    assert_eq(subarray::<_, 3, 1>([10, 20, 30], 2), [30]);\n}\n\n#[test(should_fail_with = \"out of bounds\")]\nfn test_subarray_offset_out_of_bounds() {\n    let _: [Field; 1] = subarray([10, 20, 30], 5);\n}\n\n#[test(should_fail_with = \"out of bounds\")]\nfn test_subarray_result_size_exceeds_available() {\n    let _: [Field; 3] = subarray([10, 20, 30, 40, 50], 3);\n}\n\n// ==================== array_length tests ====================\n\n#[test]\nfn test_array_length_empty_array() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    // This is why the arrays being passed-into `array_length` must already have been \"validated\"\n    // (dense lhs, empty rhs).\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n// ==================== validate_array_length_hint tests ====================\n\n#[test]\nfn test_validate_array_length_hint_valid() {\n    validate_array_length_hint([0, 0, 0], 0);\n    validate_array_length_hint([10, 20, 0], 2);\n    validate_array_length_hint([10, 20, 30], 3);\n}\n\n#[test(should_fail_with = \"Expected array[length] to be empty\")]\nfn test_validate_array_length_hint_claims_zero_when_not_empty() {\n    // Invalid: hint says length 0, but first element is not empty\n    validate_array_length_hint([10, 20, 30], 0);\n}\n\n#[test(should_fail_with = \"Expected array[length] to be empty\")]\nfn test_validate_array_length_hint_too_short() {\n    // Invalid: hint says length 1, but element at index 1 is not empty\n    validate_array_length_hint([10, 20, 0], 1);\n}\n\n#[test(should_fail_with = \"Expected claimed final element of array (array[length - 1]) to be nonempty\")]\nfn test_validate_array_length_hint_too_long() {\n    // Invalid: hint says length 2, but element at index 1 is empty\n    validate_array_length_hint([10, 0, 0], 2);\n}\n\n#[test(should_fail_with = \"Expected claimed final element of array (array[length - 1]) to be nonempty\")]\nfn test_validate_array_length_hint_of_empty_too_long() {\n    // Invalid: hint says length 2, but element at index 1 is empty\n    validate_array_length_hint([0, 0, 0], 2);\n}\n\n#[test(should_fail_with = \"out of bounds\")]\nfn test_validate_array_length_hint_out_of_bounds() {\n    // Invalid: hint says length 4, but array only has 3 elements\n    validate_array_length_hint([10, 20, 30], 4);\n}\n\n// ==================== trimmed_array_length_hint tests ====================\n\n#[test]\nunconstrained fn test_trimmed_array_length_hint_with_trailing_empties() {\n    assert_eq(trimmed_array_length_hint([10, 20, 30, 0, 0]), 3);\n}\n\n#[test]\nunconstrained fn test_trimmed_array_length_hint_fully_empty() {\n    assert_eq(trimmed_array_length_hint([0, 0, 0, 0, 0]), 0);\n}\n\n#[test]\nunconstrained fn test_trimmed_array_length_hint_no_empties() {\n    assert_eq(trimmed_array_length_hint([10, 20, 30, 40, 50]), 5);\n}\n\n#[test]\nunconstrained fn test_trimmed_array_length_hint_with_gaps() {\n    // Unlike array_length, this trims from the right only, so gaps don't matter\n    assert_eq(trimmed_array_length_hint([10, 0, 30, 0, 0]), 3);\n}\n\n// ==================== array_length_until tests ====================\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n// ==================== check_permutation tests ====================\n\n#[test]\nfn test_check_permutation() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn test_check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn test_check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n// ==================== array_padded_with tests ====================\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "446": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/serde/src/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn peek_offset(&mut self, offset: u32) -> Field {\n        self.data[self.offset + offset]\n    }\n\n    pub fn advance_offset(&mut self, offset: u32) {\n        self.offset += offset;\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "447": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/serde/src/serialization.nr",
      "source": "use crate::{reader::Reader, writer::Writer};\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut writer: Writer<Self::N> = Writer::new();\n///         self.stream_serialize(&mut writer);\n///         writer.finish()\n///     }\n///\n///     fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n///         let bytes = self.as_bytes();\n///         for i in 0..bytes.len() {\n///             writer.write(bytes[i] as Field);\n///         }\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; Self::N];\n\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>);\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut writer: Writer<Self::N> = Writer::new();\n///         self.stream_serialize(&mut writer);\n///         writer.finish()\n///     }\n///\n///     #[inline_always]\n///     fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n///         Serialize::stream_serialize(self.fields, writer);\n///         Serialize::stream_serialize(self.length, writer);\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let params_len_quote = get_params_len_quote(params);\n\n    let function_body = params\n        .map(|(name, _typ): (Quoted, Type)| {\n            quote {\n                $crate::serialization::Serialize::stream_serialize(self.$name, writer);\n            }\n        })\n        .join(quote {});\n\n    quote {\n        impl$generics_declarations $crate::serialization::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n\n            fn serialize(self) -> [Field; Self::N] {\n                let mut writer: $crate::writer::Writer<Self::N> = $crate::writer::Writer::new();\n                $crate::serialization::Serialize::stream_serialize(self, &mut writer);\n                writer.finish()\n            }\n\n\n            #[inline_always]\n             fn stream_serialize<let K: u32>(self, writer: &mut $crate::writer::Writer<K>) {\n                $function_body\n            }\n        }\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         let mut reader = Reader::new(fields);\n///         let result = Self::stream_deserialize(&mut reader);\n///         reader.finish();\n///         result\n///     }\n///\n///     fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n///         let mut bytes = [0 as u8; M];\n///         for i in 0..M {\n///             bytes[i] = reader.read() as u8;\n///         }\n///         str::<M>::from(bytes)\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self;\n\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self;\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         let mut reader = Reader::new(fields);\n///         let result = Self::stream_deserialize(&mut reader);\n///         reader.finish();\n///         result\n///     }\n///\n///     #[inline_always]\n///     fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n///         let x = <AztecAddress as Deserialize>::stream_deserialize(reader);\n///         let y = <Field as Deserialize>::stream_deserialize(reader);\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::serialization::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let $param_name = <$param_type as Deserialize>::stream_deserialize(reader);\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::serialization::Deserialize::stream_deserialize(reader) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::serialization::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            fn deserialize(fields: [Field; Self::N]) -> Self {\n                let mut reader = $crate::reader::Reader::new(fields);\n                let result = Self::stream_deserialize(&mut reader);\n                reader.finish();\n                result\n            }\n\n            #[inline_always]\n            fn stream_deserialize<let K: u32>(reader: &mut $crate::reader::Reader<K>) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\ncomptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::serialization::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n"
    },
    "449": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/serde/src/type_impls.nr",
      "source": "use crate::{reader::Reader, serialization::{Deserialize, Serialize}, writer::Writer};\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> bool {\n        reader.read() != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self);\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read()\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u8 as Field);\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u16 as Field);\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u32 as Field);\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u64 as Field);\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        for i in 0..M {\n            self[i].stream_serialize(writer);\n        }\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        let mut result: [T; M] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = T::stream_deserialize(reader);\n        }\n        result\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write_bool(self.is_some());\n        if self.is_some() {\n            self.unwrap_unchecked().stream_serialize(writer);\n        } else {\n            writer.advance_offset(<T as Serialize>::N);\n        }\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        if reader.read_bool() {\n            Option::some(<T as Deserialize>::stream_deserialize(reader))\n        } else {\n            reader.advance_offset(<T as Deserialize>::N);\n            Option::none()\n        }\n    }\n}\n\nglobal SCALAR_SIZE: u32 = 2;\n\nimpl Serialize for EmbeddedCurveScalar {\n\n    let N: u32 = SCALAR_SIZE;\n\n    fn serialize(self) -> [Field; SCALAR_SIZE] {\n        [self.lo, self.hi]\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self.lo);\n        writer.write(self.hi);\n    }\n}\n\nimpl Deserialize for EmbeddedCurveScalar {\n    let N: u32 = SCALAR_SIZE;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        Self { lo: fields[0], hi: fields[1] }\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        Self { lo: reader.read(), hi: reader.read() }\n    }\n}\n\nglobal POINT_SIZE: u32 = 3;\n\nimpl Serialize for EmbeddedCurvePoint {\n    let N: u32 = POINT_SIZE;\n\n    fn serialize(self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self.x);\n        writer.write(self.y);\n        writer.write(self.is_infinite as Field);\n    }\n}\n\nimpl Deserialize for EmbeddedCurvePoint {\n    let N: u32 = POINT_SIZE;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        Self { x: fields[0], y: fields[1], is_infinite: fields[2] != 0 }\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        Self { x: reader.read(), y: reader.read(), is_infinite: reader.read_bool() }\n    }\n}\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        let u8_arr = <[u8; Self::N] as Deserialize>::stream_deserialize(reader);\n        str::<Self::N>::from(u8_arr)\n    }\n}\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        self.as_bytes().stream_serialize(writer);\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n        let payload_len = Self::N - 1;\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = reader.peek_offset(payload_len) as u32;\n\n        for i in 0..M {\n            if i < len {\n                new_bounded_vec.push(<T as Deserialize>::stream_deserialize(reader));\n            }\n        }\n\n        // +1 for the length of the BoundedVec\n        reader.advance_offset((M - len) * <T as Deserialize>::N + 1);\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(_reader: &mut Reader<K>) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        self.storage().stream_serialize(writer);\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        writer.write_u32(self.len() as u32);\n    }\n}\n\n// Create a slice of the given length with each element made from `f(i)` where `i` is the current index\ncomptime fn make_slice<Env, T>(length: u32, f: fn[Env](u32) -> T) -> [T] {\n    let mut slice = @[];\n    for i in 0..length {\n        slice = slice.push_back(f(i));\n    }\n    slice\n}\n\n// Implements Serialize and Deserialize for an arbitrary tuple type\ncomptime fn impl_serialize_for_tuple(_m: Module, length: u32) -> Quoted {\n    // `T0`, `T1`, `T2`\n    let type_names = make_slice(length, |i| f\"T{i}\".quoted_contents());\n\n    // `result0`, `result1`, `result2`\n    let result_names = make_slice(length, |i| f\"result{i}\".quoted_contents());\n\n    // `T0, T1, T2`\n    let field_generics = type_names.join(quote [,]);\n\n    // `<T0 as Serialize>::N + <T1 as Serialize>::N + <T2 as Serialize>::N`\n    let full_size_serialize = type_names\n        .map(|type_name| quote {\n        <$type_name as Serialize>::N\n    })\n        .join(quote [+]);\n\n    // `<T0 as Deserialize>::N + <T1 as Deserialize>::N + <T2 as Deserialize>::N`\n    let full_size_deserialize = type_names\n        .map(|type_name| quote {\n        <$type_name as Deserialize>::N\n    })\n        .join(quote [+]);\n\n    // `T0: Serialize, T1: Serialize, T2: Serialize,`\n    let serialize_constraints = type_names\n        .map(|field_name| quote {\n        $field_name: Serialize,\n    })\n        .join(quote []);\n\n    // `T0: Deserialize, T1: Deserialize, T2: Deserialize,`\n    let deserialize_constraints = type_names\n        .map(|field_name| quote {\n        $field_name: Deserialize,\n    })\n        .join(quote []);\n\n    // Statements to serialize each field\n    let serialized_fields = type_names\n        .mapi(|i, _type_name| quote {\n            $crate::serialization::Serialize::stream_serialize(self.$i, writer);\n    })\n        .join(quote []);\n\n    // Statements to deserialize each field\n    let deserialized_fields = type_names\n        .mapi(|i, type_name| {\n            let result_name = result_names[i];\n            quote {\n            let $result_name = <$type_name as $crate::serialization::Deserialize>::stream_deserialize(reader);\n        }\n        })\n        .join(quote []);\n    let deserialize_results = result_names.join(quote [,]);\n\n    quote {\n        impl<$field_generics> Serialize for ($field_generics) where $serialize_constraints {\n            let N: u32 = $full_size_serialize;\n\n            fn serialize(self) -> [Field; Self::N] {\n                let mut writer: $crate::writer::Writer<Self::N> = $crate::writer::Writer::new();\n                self.stream_serialize(&mut writer);\n                writer.finish()\n            }\n\n            #[inline_always]\n            fn stream_serialize<let K: u32>(self, writer: &mut $crate::writer::Writer<K>) {\n\n                $serialized_fields\n            }\n        }\n\n        impl<$field_generics> Deserialize for ($field_generics) where $deserialize_constraints {\n            let N: u32 = $full_size_deserialize;\n\n            fn deserialize(fields: [Field; Self::N]) -> Self {\n                let mut reader = $crate::reader::Reader::new(fields);\n                let result = Self::stream_deserialize(&mut reader);\n                reader.finish();\n                result\n            }\n    \n            #[inline_always]\n            fn stream_deserialize<let K: u32>(reader: &mut $crate::reader::Reader<K>) -> Self {\n                $deserialized_fields\n                ($deserialize_results)\n            }\n        }\n    }\n}\n\n// Keeping these manual impls. They are more efficient since they do not\n// require copying sub-arrays from any serialized arrays.\nimpl<T1> Serialize for (T1,)\nwhere\n    T1: Serialize,\n{\n    let N: u32 = <T1 as Serialize>::N;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: crate::writer::Writer<Self::N> = crate::writer::Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        self.0.stream_serialize(writer);\n    }\n}\n\nimpl<T1> Deserialize for (T1,)\nwhere\n    T1: Deserialize,\n{\n    let N: u32 = <T1 as Deserialize>::N;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::reader::Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        (<T1 as Deserialize>::stream_deserialize(reader),)\n    }\n}\n\n#[impl_serialize_for_tuple(2)]\n#[impl_serialize_for_tuple(3)]\n#[impl_serialize_for_tuple(4)]\n#[impl_serialize_for_tuple(5)]\n#[impl_serialize_for_tuple(6)]\nmod impls {\n    use crate::serialization::{Deserialize, Serialize};\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_vectors() {\n        let vector_1 = [0, 1, 2, 3].as_vector();\n        let vector_2 = [0, 1, 2].as_vector();\n        assert(!vector_1.eq(vector_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_vectors() {\n        assert(\n            [2_u32].as_vector().cmp([1_u32, 1_u32, 1_u32].as_vector())\n                == super::Ordering::greater(),\n        );\n        assert(\n            [1_u32, 2_u32].as_vector().cmp([1_u32, 2_u32, 3_u32].as_vector())\n                == super::Ordering::less(),\n        );\n    }\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/contract_instance_registry_contract/src/main.nr",
      "source": "/// Protocol contract responsible for deploying contract instances and managing contract upgrades.\n///\n/// In Aztec, contracts are split into *classes* (code, registered via ContractClassRegistry) and *instances*\n/// (deployments of a class at a unique address). This contract handles contract instance publishing and contract\n/// updates (updating instance to a new class).\npub contract ContractInstanceRegistry {\n    use aztec::{\n        context::{PrivateContext, PublicContext},\n        hash::hash_args,\n        nullifier::utils::compute_nullifier_existence_request,\n        oracle::{avm, logging::debug_log_format, version::assert_compatible_oracle_version},\n        protocol::{\n            abis::function_selector::FunctionSelector,\n            address::{AztecAddress, PartialAddress},\n            constants::{\n                CONTRACT_CLASS_REGISTRY_CONTRACT_ADDRESS, CONTRACT_INSTANCE_PUBLISHED_MAGIC_VALUE,\n                CONTRACT_INSTANCE_UPDATED_MAGIC_VALUE, DEFAULT_UPDATE_DELAY, MINIMUM_UPDATE_DELAY,\n            },\n            contract_class_id::ContractClassId,\n            public_keys::PublicKeys,\n            traits::{Deserialize, Serialize, ToField},\n            utils::reader::Reader,\n        },\n        state_vars::{DelayedPublicMutable, Map, StateVariable},\n    };\n\n    #[abi(events)]\n    struct ContractInstancePublished {\n        CONTRACT_INSTANCE_PUBLISHED_MAGIC_VALUE: Field,\n        address: AztecAddress,\n        version: u8,\n        salt: Field,\n        contract_class_id: ContractClassId,\n        initialization_hash: Field,\n        public_keys: PublicKeys,\n        deployer: AztecAddress,\n    }\n\n    // Custom serialization is required because we don't want to waste one field for the `is_infinite` flag of public\n    // key points (public key points will never be the infinity point).\n    impl ContractInstancePublished {\n        fn serialize_non_standard(self) -> [Field; 15] {\n            [\n                self.CONTRACT_INSTANCE_PUBLISHED_MAGIC_VALUE,\n                self.address.to_field(),\n                self.version.to_field(),\n                self.salt,\n                self.contract_class_id.to_field(),\n                self.initialization_hash,\n                self.public_keys.npk_m.serialize()[0],\n                self.public_keys.npk_m.serialize()[1],\n                self.public_keys.ivpk_m.serialize()[0],\n                self.public_keys.ivpk_m.serialize()[1],\n                self.public_keys.ovpk_m.serialize()[0],\n                self.public_keys.ovpk_m.serialize()[1],\n                self.public_keys.tpk_m.serialize()[0],\n                self.public_keys.tpk_m.serialize()[1],\n                self.deployer.to_field(),\n            ]\n        }\n    }\n\n    #[abi(events)]\n    #[derive(Serialize)]\n    struct ContractInstanceUpdated {\n        CONTRACT_INSTANCE_UPDATED_MAGIC_VALUE: Field,\n        address: AztecAddress,\n        prev_contract_class_id: ContractClassId,\n        new_contract_class_id: ContractClassId,\n        timestamp_of_change: u64,\n    }\n\n    struct Storage<Context> {\n        /// Map from contract instance address to a `DelayedPublicMutable` holding the updated contract class ID.\n        updated_class_ids: Map<AztecAddress, DelayedPublicMutable<ContractClassId, DEFAULT_UPDATE_DELAY, Context>, Context>,\n    }\n\n    /// Publishes a new contract instance.\n    ///\n    /// The caller provides deployment parameters (salt, class_id, init_hash, public_keys, universal_deploy).\n    /// The `universal_deploy` flag controls whether the deployer address is bound into the contract address:\n    /// when true, deployer is zero (anyone can deploy the same instance); when false, deployer is the caller.\n    ///\n    /// This function:\n    /// 1. Verifies the contract class is registered in ContractClassRegistry (nullifier existence check).\n    /// 2. Validates public key points are on the Grumpkin curve (preventing AVM DoS via invalid points).\n    /// 3. Computes the deterministic contract address from the deployment parameters.\n    /// 4. Emits the address as a nullifier (proving publication preventing duplicate deployment)\n    ///    --> this address nullifier is then checked to exist by the AVM upon public function execution (if it doesn't\n    ///        exist AVM reverts)\n    /// 5. Broadcasts a `ContractInstancePublished` event so nodes can reconstruct the instance.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n    fn publish_for_public_execution(\n        inputs: aztec::context::inputs::PrivateContextInputs,\n        salt: Field,\n        contract_class_id: ContractClassId,\n        initialization_hash: Field,\n        public_keys: PublicKeys,\n        universal_deploy: bool,\n    ) -> return_data aztec::protocol::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n        // MACRO CODE START\n        // Note: The macros initially inserted a phase check here, but since there is no phase change in this function\n        // body, I have removed that check.\n        assert_compatible_oracle_version();\n\n        let serialized_params: [Field; 16] = [\n            salt,\n            contract_class_id.to_field(),\n            initialization_hash,\n        ]\n            .concat(public_keys.serialize())\n            .concat([universal_deploy.to_field()]);\n\n        let args_hash: Field = hash_args(serialized_params);\n        let mut context: PrivateContext = PrivateContext::new(inputs, args_hash);\n        // MACRO CODE END\n\n        // Verify the contract class is registered by checking for its nullifier at the ContractClassRegistry address.\n        let nullifier_existence_request = compute_nullifier_existence_request(\n            contract_class_id.to_field(),\n            CONTRACT_CLASS_REGISTRY_CONTRACT_ADDRESS,\n        );\n        context.assert_nullifier_exists(nullifier_existence_request);\n\n        // For universal deployments, deployer is zero so the resulting address is the same regardless of who initiates\n        // deployment.\n        let deployer = if universal_deploy {\n            AztecAddress::zero()\n        } else {\n            context.maybe_msg_sender().unwrap()\n        };\n\n        let partial_address =\n            PartialAddress::compute(contract_class_id, salt, initialization_hash, deployer);\n\n        // Validate public key points lie on the Grumpkin curve to prevent AVM DoS attacks.\n        public_keys.validate_on_curve();\n\n        let address = AztecAddress::compute(public_keys, partial_address);\n\n        // Emit address as nullifier: prevents duplicate deployment and proves publication.\n        context.push_nullifier(address.to_field());\n\n        // Broadcast deployment event. Uses non-standard serialization (2 fields per point,\n        // omitting is_infinite) for TypeScript SDK compatibility.\n        let event = ContractInstancePublished {\n            CONTRACT_INSTANCE_PUBLISHED_MAGIC_VALUE,\n            contract_class_id,\n            address,\n            public_keys,\n            initialization_hash,\n            salt,\n            deployer,\n            version: 1,\n        };\n        let payload = event.serialize_non_standard();\n        debug_log_format(\"ContractInstancePublished: {}\", payload);\n        // We pad the payload with [0] to match the length required by emit_private_log. Since the log is not\n        // encrypted, padding with zero rather than a random value is acceptable (we don't care about privacy here).\n        let padded_log = payload.concat([0]);\n        let length = payload.len();\n        context.emit_private_log(padded_log, length);\n\n        // MACRO CODE START\n        context.finish()\n        // MACRO CODE END\n    }\n\n    /// Schedules an upgrade of the calling contract instance to a new contract class.\n    ///\n    /// The change is time-delayed via `DelayedPublicMutable` and only takes effect after the configured\n    /// delay has elapsed. Only the contract instance itself can call this function (msg.sender == address).\n    ///\n    /// This function:\n    /// 1. Verifies msg.sender is a deployed contract (its address nullifier exists).\n    /// 2. Verifies the new class is registered in ContractClassRegistry.\n    /// 3. Schedules the class ID change and emits a `ContractInstanceUpdated` event.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    unconstrained fn update(new_contract_class_id: ContractClassId) {\n        // MACRO CODE START\n        let context: PublicContext = PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 1] =\n                    avm::calldata_copy(1, <ContractClassId as Serialize>::N);\n                hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<PublicContext> = Storage::init(context);\n        // MACRO CODE END\n\n        let address = context.maybe_msg_sender().unwrap();\n\n        // Safety: we're using the nullifier's existence as a guarantee of the availability of the contract's\n        // information through publishing, which is safe - we just need this information to be _eventually_ available.\n        assert(\n            context.nullifier_exists_unsafe(address.to_field(), context.this_address()),\n            \"msg.sender is not deployed\",\n        );\n\n        // Safety: we're using the nullifier's existence as a guarantee of the availability of the new contract class'\n        // information through registration, which is safe - we just need this information to be _eventually_ available.\n        assert(\n            context.nullifier_exists_unsafe(\n                new_contract_class_id.to_field(),\n                CONTRACT_CLASS_REGISTRY_CONTRACT_ADDRESS,\n            ),\n            \"New contract class is not registered\",\n        );\n\n        let scheduled_value_update = storage\n            .updated_class_ids\n            .at(address)\n            .schedule_and_return_value_change(new_contract_class_id);\n        let (prev_contract_class_id, timestamp_of_change) = scheduled_value_update.get_previous();\n\n        let event = ContractInstanceUpdated {\n            CONTRACT_INSTANCE_UPDATED_MAGIC_VALUE,\n            address,\n            prev_contract_class_id,\n            new_contract_class_id,\n            timestamp_of_change,\n        };\n        context.emit_public_log(event);\n    }\n\n    /// Schedules a change to the upgrade delay for the calling contract instance. The delay change is\n    /// itself delayed (preventing atomically reducing delay + scheduling an instant upgrade). The new\n    /// delay must be at least `MINIMUM_UPDATE_DELAY`.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    unconstrained fn set_update_delay(new_update_delay: u64) {\n        // MACRO CODE START\n        let context: PublicContext = PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 1] = avm::calldata_copy(1, <u64 as Serialize>::N);\n                hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<PublicContext> = Storage::init(context);\n        // MACRO CODE END\n\n        let msg_sender = context.maybe_msg_sender().unwrap();\n\n        // Safety: we're using the nullifier's existence as a guarantee of the availability of the contract's\n        // information through publishing, which is safe - we just need this information to be _eventually_ available.\n        assert(\n            context.nullifier_exists_unsafe(msg_sender.to_field(), context.this_address()),\n            \"msg.sender is not deployed\",\n        );\n\n        assert(new_update_delay >= MINIMUM_UPDATE_DELAY, \"New update delay is too low\");\n\n        storage.updated_class_ids.at(msg_sender).schedule_delay_change(new_update_delay);\n    }\n\n    /// Returns the current update delay for the calling contract instance.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_view]\n    unconstrained fn get_update_delay() -> pub u64 {\n        // MACRO CODE START\n        let context: PublicContext = PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 0] = avm::calldata_copy(1, 0);\n                hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<PublicContext> = Storage::init(context);\n        assert(context.is_static_call(), \"Function get_update_delay can only be called statically\");\n        // MACRO CODE END\n\n        storage.updated_class_ids.at(avm::sender()).get_current_delay()\n    }\n\n    // THE REST OF THE CODE IN THIS CONTRACT WAS ORIGINALLY INJECTED BY THE #[aztec] MACRO.\n\n    global UPDATE_SELECTOR: Field =\n        comptime { FunctionSelector::from_signature(\"update((Field))\").to_field() };\n    global SET_UPDATE_DELAY_SELECTOR: Field =\n        comptime { FunctionSelector::from_signature(\"set_update_delay(u64)\").to_field() };\n    global GET_UPDATE_DELAY_SELECTOR: Field =\n        comptime { FunctionSelector::from_signature(\"get_update_delay()\").to_field() };\n\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    pub unconstrained fn public_dispatch(selector: Field) {\n        if selector == UPDATE_SELECTOR {\n            let input_calldata: [Field; 1] =\n                avm::calldata_copy(1, <ContractClassId as Serialize>::N);\n            let mut reader: Reader<1> = Reader::new(input_calldata);\n            let arg0: ContractClassId =\n                <ContractClassId as Deserialize>::stream_deserialize(&mut reader);\n            update(arg0);\n            avm::avm_return([].as_vector());\n        };\n        if selector == SET_UPDATE_DELAY_SELECTOR {\n            let input_calldata: [Field; 1] = avm::calldata_copy(1, <u64 as Serialize>::N);\n            let mut reader: Reader<1> = Reader::new(input_calldata);\n            let arg0: u64 = <u64 as Deserialize>::stream_deserialize(&mut reader);\n            set_update_delay(arg0);\n            avm::avm_return([].as_vector());\n        };\n        if selector == GET_UPDATE_DELAY_SELECTOR {\n            let return_value: [Field; 1] = <u64 as Serialize>::serialize(get_update_delay());\n            avm::avm_return(return_value.as_vector());\n        };\n        panic(f\"Unknown selector {selector}\")\n    }\n\n    impl<Context> Storage<Context> {\n        fn init(context: Context) -> Self {\n            Self {\n                updated_class_ids: <Map<AztecAddress, DelayedPublicMutable<ContractClassId, DEFAULT_UPDATE_DELAY, Context>, Context> as StateVariable<1, Context>>::new(\n                    context,\n                    1,\n                ),\n            }\n        }\n    }\n\n    pub struct publish_for_public_execution_parameters {\n        pub _salt: Field,\n        pub _contract_class_id: ContractClassId,\n        pub _initialization_hash: Field,\n        pub _public_keys: PublicKeys,\n        pub _universal_deploy: bool,\n    }\n\n    pub struct update_parameters {\n        pub _new_contract_class_id: ContractClassId,\n    }\n\n    pub struct set_update_delay_parameters {\n        pub _new_update_delay: u64,\n    }\n\n    pub struct get_update_delay_parameters {}\n\n    #[abi(functions)]\n    pub struct publish_for_public_execution_abi {\n        parameters: publish_for_public_execution_parameters,\n    }\n\n    #[abi(functions)]\n    pub struct update_abi {\n        parameters: update_parameters,\n    }\n\n    #[abi(functions)]\n    pub struct set_update_delay_abi {\n        parameters: set_update_delay_parameters,\n    }\n\n    #[abi(functions)]\n    pub struct get_update_delay_abi {\n        parameters: get_update_delay_parameters,\n        return_type: u64,\n    }\n}\n"
    },
    "58": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, NullifierExistenceRequest, ReturnsHash},\n    hash::hash_args,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            is_side_effect_counter_revertible_oracle_wrapper, notify_enqueued_public_function_call,\n            notify_set_min_revertible_side_effect_counter,\n        },\n        execution_cache,\n        logs::notify_created_contract_class_log,\n        nullifiers::notify_created_nullifier,\n    },\n};\nuse crate::protocol::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_TX_LIFETIME, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::{Counted, scoped::Scoped},\n    traits::Empty,\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// Minimal PrivateContext for protocol contracts going to audit.\n/// Contains only the methods actually used by: fee_juice, auth_registry, contract_class_registry, contract_instance_registry\n#[derive(Eq)]\npub struct PrivateContext {\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub expiration_timestamp: u64,\n\n    pub nullifier_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    pub expected_non_revertible_side_effect_counter: u32,\n    pub expected_revertible_side_effect_counter: u32,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            expiration_timestamp: inputs.anchor_block_header.global_variables.timestamp\n            + MAX_TX_LIFETIME,\n            nullifier_read_requests: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call (similar to msg.sender in Solidity).\n    pub fn maybe_msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Returns the contract address of the current function being executed.\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the protocol version.\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Returns the anchor block header.\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Sets the hash of the return values for this private function.\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            expiration_timestamp: self.expiration_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::empty(), // Not used by protocol contracts\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_separators: ClaimedLengthArray::empty(), // Not used by protocol contracts\n            note_hashes: ClaimedLengthArray::empty(), // Not used by protocol contracts\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n            expected_non_revertible_side_effect_counter: self\n                .expected_non_revertible_side_effect_counter,\n            expected_revertible_side_effect_counter: self.expected_revertible_side_effect_counter,\n        }\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx. Used by fee_juice.\n    pub fn end_setup(&mut self) {\n        self.side_effect_counter += 1;\n        self.min_revertible_side_effect_counter = self.next_counter();\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    pub fn in_revertible_phase(&mut self) -> bool {\n        let current_counter = self.side_effect_counter;\n\n        // Safety: Kernel will validate that the claim is correct by validating the expected counters.\n        let is_revertible =\n            unsafe { is_side_effect_counter_revertible_oracle_wrapper(current_counter) };\n\n        if is_revertible {\n            if (self.expected_revertible_side_effect_counter == 0)\n                | (current_counter < self.expected_revertible_side_effect_counter) {\n                self.expected_revertible_side_effect_counter = current_counter;\n            }\n        } else if current_counter > self.expected_non_revertible_side_effect_counter {\n            self.expected_non_revertible_side_effect_counter = current_counter;\n        }\n\n        is_revertible\n    }\n\n    /// Sets a deadline for when this transaction must be included in a block.\n    pub fn set_expiration_timestamp(&mut self, expiration_timestamp: u64) {\n        self.expiration_timestamp = std::cmp::min(self.expiration_timestamp, expiration_timestamp);\n    }\n\n    /// Pushes a new nullifier. Used by class_registry and instance_registry.\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Asserts that a nullifier has been emitted. Used by instance_registry.\n    pub fn assert_nullifier_exists(\n        &mut self,\n        nullifier_existence_request: NullifierExistenceRequest,\n    ) {\n        let nullifier = nullifier_existence_request.nullifier();\n        let contract_address =\n            nullifier_existence_request.maybe_contract_address().unwrap_or(AztecAddress::zero());\n\n        let request = Scoped::new(\n            Counted::new(nullifier, self.next_counter()),\n            contract_address,\n        );\n\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2). Used by fee_juice.\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log. Used by instance_registry.\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    /// Emits a contract class log. Used by class_registry.\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond\n        // length are zero. However, it won't be able to check that we didn't add extra padding (trailing zeroes) or\n        // that we cut trailing zeroes from the end.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter\n        // bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be\n        // constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Makes a read-only call to a private function. Used by auth_registry for authwit.\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function with a calldata hash. Used by fee_juice and auth_registry.\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            expiration_timestamp: 0,\n            nullifier_read_requests: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n}\n"
    },
    "59": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/context/public_context.nr",
      "source": "use crate::{\n    context::gas::GasOpts,\n    hash::{\n        compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n        compute_siloed_nullifier,\n    },\n    oracle::avm,\n};\nuse crate::protocol::{\n    abis::function_selector::FunctionSelector,\n    address::{AztecAddress, EthAddress},\n    constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS},\n    traits::{Empty, FromField, Packable, Serialize, ToField},\n};\n\n/// Minimal PublicContext for protocol contracts going to audit.\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::emit_public_log(Serialize::serialize(log).as_vector()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular leaf_index.\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message tree at a particular leaf index.\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { avm::l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Returns `true` if an `unsiloed_nullifier` has been emitted by `contract_address`.\n    pub fn nullifier_exists_unsafe(\n        _self: Self,\n        unsiloed_nullifier: Field,\n        contract_address: AztecAddress,\n    ) -> bool {\n        let siloed_nullifier = compute_siloed_nullifier(contract_address, unsiloed_nullifier);\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::nullifier_exists(siloed_nullifier) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists_unsafe(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\".\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        avm::call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = avm::success_copy();\n\n        let result_data = avm::returndata_copy(0, avm::returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm::revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        avm::call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = avm::success_copy();\n\n        let result_data = avm::returndata_copy(0, avm::returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm::revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Note Hash Tree.\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Nullifier Tree.\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    pub fn maybe_msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { avm::sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { avm::calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::chain_id()\n        }\n    }\n\n    /// Returns the protocol version.\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::version()\n        }\n    }\n\n    /// Returns the current block number.\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas.\n    pub fn min_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::min_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA gas.\n    pub fn min_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::min_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available.\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA gas available.\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context.\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    pub fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe {\n                avm::storage_read(storage_slot + i as Field, self.this_address().to_field())\n            };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { avm::storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/hash.nr",
      "source": "//! Aztec hash functions.\n\nuse crate::protocol::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        DOM_SEP__FUNCTION_ARGS, DOM_SEP__MESSAGE_NULLIFIER, DOM_SEP__PUBLIC_BYTECODE,\n        DOM_SEP__PUBLIC_CALLDATA, DOM_SEP__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    traits::ToField,\n};\n\npub use crate::protocol::hash::compute_siloed_nullifier;\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], DOM_SEP__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], DOM_SEP__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, DOM_SEP__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, DOM_SEP__PUBLIC_CALLDATA)\n}\n\n/// Computes the public bytecode commitment for a contract class. The commitment is `hash([(length | separator),\n/// ...bytecode])`.\n///\n/// @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n/// packed_bytecode is mutable so that we can avoid copying the array to construct one starting with first_field\n/// instead of length. @returns The public bytecode commitment.\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 = (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode. AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Append it to the separator before hashing.\n    let first_field = DOM_SEP__PUBLIC_BYTECODE.to_field() + (packed_public_bytecode[0] as u64 << 32) as Field;\n    packed_public_bytecode[0] = first_field;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored. +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/nullifier/utils.nr",
      "source": "use crate::{context::NullifierExistenceRequest, oracle::nullifiers::is_nullifier_pending};\n\nuse crate::protocol::{address::aztec_address::AztecAddress, hash::compute_siloed_nullifier};\n\n/// Returns the [NullifierExistenceRequest] used to prove a nullifier exists.\npub fn compute_nullifier_existence_request(\n    unsiloed_nullifier: Field,\n    contract_address: AztecAddress,\n) -> NullifierExistenceRequest {\n    let pending_read_request =\n        NullifierExistenceRequest::for_pending(unsiloed_nullifier, contract_address);\n\n    let siloed_nullifier = compute_siloed_nullifier(contract_address, unsiloed_nullifier);\n    let settled_read_request = NullifierExistenceRequest::for_settled(siloed_nullifier);\n\n    // Safety: This is a hint to check whether we are reading a pending or settled nullifier. The chosen read request\n    // will be validated by the kernel. Failure to provide a correct hint will cause the read request validation to\n    // fail.\n    let should_use_pending_read_request =\n        unsafe { is_nullifier_pending(unsiloed_nullifier, contract_address) };\n\n    if should_use_pending_read_request {\n        pending_read_request\n    } else {\n        settled_read_request\n    }\n}\n"
    },
    "72": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/avm.nr",
      "source": "//! AVM oracles.\n//!\n//! There are only available during public execution. Calling any of them from a private or utility function will\n//! result in runtime errors.\n\nuse crate::protocol::address::{AztecAddress, EthAddress};\n\npub unconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\npub unconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\npub unconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\npub unconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\npub unconstrained fn version() -> Field {\n    version_opcode()\n}\npub unconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\npub unconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\npub unconstrained fn min_fee_per_l2_gas() -> u128 {\n    min_fee_per_l2_gas_opcode()\n}\npub unconstrained fn min_fee_per_da_gas() -> u128 {\n    min_fee_per_da_gas_opcode()\n}\npub unconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\npub unconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\npub unconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\npub unconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\npub unconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\npub unconstrained fn nullifier_exists(siloed_nullifier: Field) -> u1 {\n    nullifier_exists_opcode(siloed_nullifier)\n}\npub unconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\npub unconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\npub unconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\npub unconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\npub unconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n/// `success_copy` is placed immediately after the CALL opcode to get the success value\npub unconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\npub unconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\npub unconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\n/// The additional prefix is to avoid clashing with the `return` Noir keyword.\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n/// This opcode reverts using the exact data given. In general it should only be used to do rethrows, where the revert\n/// data is the same as the original revert data. For normal reverts, use Noir's `assert` which, on top of reverting,\n/// will also add an error selector to the revert data.\npub unconstrained fn revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\npub unconstrained fn storage_read(storage_slot: Field, contract_address: Field) -> Field {\n    storage_read_opcode(storage_slot, contract_address)\n}\n\npub unconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeMinFeePerL2Gas)]\nunconstrained fn min_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeMinFeePerDaGas)]\nunconstrained fn min_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(siloed_nullifier: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitPublicLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take\n// that route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take\n// that route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field, contract_address: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "81": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/nullifiers.nr",
      "source": "//! Nullifier creation, existence checks, etc.\n\nuse crate::protocol::address::aztec_address::AztecAddress;\n\n/// Notifies the simulator that a nullifier has been created, so that its correct status (pending or settled) can be\n/// determined when reading nullifiers in subsequent private function calls. The first non-revertible nullifier emitted\n/// is also used to compute note nonces.\npub fn notify_created_nullifier(inner_nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle(inner_nullifier) };\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_inner_nullifier: Field) {}\n\n/// Returns true if the nullifier has been emitted in the same transaction, i.e. if [notify_created_nullifier] has been\n/// called for this inner nullifier from the contract with the specified address.\n///\n/// Note that despite sharing pending transaction information with the app, this is not a privacy leak: anyone in the\n/// network can always determine in which transaction a inner nullifier was emitted by a given contract by simply\n/// inspecting transaction effects. What _would_ constitute a leak would be to share the list of inner pending\n/// nullifiers, as that would reveal their preimages.\npub unconstrained fn is_nullifier_pending(\n    inner_nullifier: Field,\n    contract_address: AztecAddress,\n) -> bool {\n    is_nullifier_pending_oracle(inner_nullifier, contract_address)\n}\n\n#[oracle(privateIsNullifierPending)]\nunconstrained fn is_nullifier_pending_oracle(\n    _inner_nullifier: Field,\n    _contract_address: AztecAddress,\n) -> bool {}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before\n/// the current transaction is included in a block. While this might seem of little use at first, certain design\n/// patterns benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n"
    },
    "83": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/state_vars/delayed_public_mutable.nr",
      "source": "use crate::protocol::{\n    delayed_public_mutable::{\n        delayed_public_mutable_values::{unpack_delay_change, unpack_value_change},\n        DelayedPublicMutableValues,\n        ScheduledDelayChange,\n        ScheduledValueChange,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::StateVariable,\n    utils::WithHash,\n};\n\n/// Public mutable values with private read access.\npub struct DelayedPublicMutable<T, let InitialDelay: u64, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// DelayedPublicMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention\nimpl<T, let InitialDelay: u64, Context, let M: u32> StateVariable<M + 1, Context> for DelayedPublicMutable<T, InitialDelay, Context>\nwhere\n    DelayedPublicMutableValues<T, InitialDelay>: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, let InitialDelay: u64> DelayedPublicMutable<T, InitialDelay, PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change(self, new_value: T)\n    where\n        T: Packable,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change(self, new_value: T) -> ScheduledValueChange<T>\n    where\n        T: Packable,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n        let current_delay = delay_change.get_current(current_timestamp);\n\n        // TODO: make this configurable https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let timestamp_of_change = current_timestamp + current_delay;\n        value_change.schedule_change(\n            new_value,\n            current_timestamp,\n            current_delay,\n            timestamp_of_change,\n        );\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u64)\n    where\n        T: Packable,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n\n        delay_change.schedule_change(new_delay, current_timestamp);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value(self) -> T\n    where\n        T: Packable,\n    {\n        let current_timestamp = self.context.timestamp();\n        let value_change = self.read_value_change();\n\n        value_change.get_current_at(current_timestamp)\n    }\n\n    pub fn get_current_delay(self) -> u64\n    where\n        T: Packable,\n    {\n        let current_timestamp = self.context.timestamp();\n        self.read_delay_change().get_current(current_timestamp)\n    }\n\n    pub fn get_scheduled_value(self) -> (T, u64)\n    where\n        T: Packable,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay(self) -> (u64, u64)\n    where\n        T: Packable,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T>\n    where\n        T: Packable,\n    {\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, <T as Packable>::N>(packed)\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<InitialDelay>\n    where\n        T: Packable,\n    {\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<InitialDelay>(packed)\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<InitialDelay>,\n    )\n    where\n        T: Packable,\n    {\n        let values = WithHash::new(DelayedPublicMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let InitialDelay: u64> DelayedPublicMutable<T, InitialDelay, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value(self) -> T\n    where\n        T: Packable,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        let (value_change, delay_change, anchor_timestamp) = self.anchor_read_from_public_storage();\n\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(anchor_timestamp);\n        let time_horizon = value_change.get_time_horizon(anchor_timestamp, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any timestamp after the time horizon.\n        self.context.set_expiration_timestamp(time_horizon);\n\n        value_change.get_current_at(anchor_timestamp)\n    }\n\n    fn anchor_read_from_public_storage(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<InitialDelay>, u64)\n    where\n        T: Packable,\n    {\n        let header = self.context.get_anchor_block_header();\n        let address = self.context.this_address();\n\n        let anchor_timestamp = header.global_variables.timestamp;\n\n        let values: DelayedPublicMutableValues<T, InitialDelay> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, anchor_timestamp)\n    }\n}\n\nimpl<T, let InitialDelay: u64> DelayedPublicMutable<T, InitialDelay, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value(self) -> T\n    where\n        T: Packable,\n    {\n        let dpmv: DelayedPublicMutableValues<T, InitialDelay> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let current_timestamp = self.context.timestamp();\n        dpmv.svc.get_current_at(current_timestamp)\n    }\n}\n"
    },
    "84": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/state_vars/map.nr",
      "source": "use crate::protocol::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::StateVariable;\n\n/// A key-value container for state variables.\n///\n/// A key-value storage container that maps keys to state variables, similar to Solidity mappings.\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity.\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "90": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::storage::public_storage_historical_read,\n    oracle,\n};\nuse crate::protocol::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check and then proving inclusion\n/// only of the hash in public storage. This reduces the number of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    /// Reads the value stored in this [WithHash] from public storage.\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header_to_read_from: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot. Instead, we get an oracle to provide us the values, and instead we prove\n        // inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of the\n        // size of T.\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe { oracle::storage::storage_read(header_to_read_from, address, storage_slot) },\n        );\n\n        // The actual `value` (of type T, of packed length M fields) is stored in contiguous fields from the\n        // `storage_slot`. The _hash_ of the `value` is stored at the end, at slot: `storage_slot + M`.\n        let hash =\n            public_storage_historical_read(header_to_read_from, storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero (i.e.\n            // the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n"
    }
  }
}
