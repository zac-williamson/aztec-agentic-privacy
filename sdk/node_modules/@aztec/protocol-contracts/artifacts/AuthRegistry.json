{
  "transpiled": true,
  "noir_version": "1.0.0-beta.18+2db78f8894936db05c53430f364360ac9cc5c61f",
  "name": "AuthRegistry",
  "functions": [
    {
      "name": "_set_authorized",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "abi": {
        "parameters": [
          {
            "name": "approver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "authorize",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13929691561421487185": {
            "error_kind": "string",
            "string": "Function _set_authorized can only be called by the same contract"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "rZnRTiM7DIbfZa57ETuJY/Mqq9WqC2VVqSqoC0c6Qrz7sTNxphxpRpByQ7/+bf44jieeDm/Tw+H3659fx/Pj09/p7sfb9PtyPJ2Of36dnu73L8ens6pvU7A/kqY73E0i013eTRD0LdmrzK9Q5lfE6Q7AoDSI1CAFh9wgu5JdIVcoOXCDEh3cmX0utimSgoBDdpAZMEQHbgCuWOwV0IaTATWIrkRXUnJQZ9TZMUcHbkCukCvFFQu+AoMDNZDgkB1sCg0sWrZn4AaADtTAgp/BlRgcbDgZSIPkSkYHDSwGBVIlxt2UbHhMBhpP1E1PmRqQzhXJIDco9uVikBykAbvCrogrwjPkgA6lAYADNcDgkB2aYY6a3sgKVBqwfUcULKszNIWCKikY5AZWtAkMSoPoihXtDPZlNNBJk+aHcnLgBrbvFQo4aPBJc0i23TO4YoGlbJDbl6U5l5AcXIHo0OYqNeYKZqhbUGxPUzGQBlaZiQ24AblSI6xADdgV26YKtk1JDGQGDslBDbOmjmtgxaA0qIFVcMUuohmoQc1qBTtONL1sycyaXi7oQA04OGQHG6U5ZIkOPIOE6OAKuAKuoM2lqRMrm5wNNNSsOZSEDbLGnIuBTarZEDuaZrDhYiANiivFFS4NBB2aAsHKbiZQSwqVshN2zcIkqCTz1BBqxDOxU+paKk52WTfSNBIa2UXbyGaLRnbZNuoax07sJK5pqJ3M2c5YsGu1UdfqOnKl3OYFW8dMdiI16pqtoxE72Tqo9hc7n2aq6yiVyKl0zbZgJjt3GnXNdqES2olDXKk4QdfqOqT2M2jzYl1HJTsZGy2aONl12Iid+jqwrwNtHaW2StuPmWw/GnWNu8Zdk66JRlqsXqKdayW8v+8m796/Xi6HgzXvq3auTf55fzmcX6a78+vptJv+2Z9e65f+Pu/P9fVlf9FP1fNwftBXNXw8ng5G77tldFgfqtVp11cdrkzULTJ88IB1j2jnTHWIlPr4gl+IoYQlBglrMcR1DwLmZkFaMIuDfHBI6w5Y3ABlcBXXmRRcW8Wmh7bO7pFTWfMoGx5orWq20PuT7sDpgwNvZII9hijcxyegDwaybiBgfbg6CJRlOyOXjzW1kQoK0bNJIS1lGT8fBCcPQo+G9SBw3YN1ZPNg7SHrHhuVGTP2bC77iZrZz26o3hn7hsZAaxsKeSOZPRUlwJrB5+uSVq9QuL0w4ebKhG8oTby5NOEbahO/oTbx5tqE24sTN4oz85LNZUOYBouTV4sTN9cRenFChLUwkLfi4Jh6HJzSWhPCjcrI4GFkvKrwGL8QRpGyhAGyFkaEzZwSdhNtrqsmGxUaqXg+YoE80lMl9J2VK4f/V+iWBS8FKihDFmK/M5pFLmMWBboF44gFBnILvQ9OQxYpeC4w4VgUKS4WV33gKxY59IVkpDGLHLpFhjGLlBYLHIyCukXhm6MYtegFrr9ThgocKWG3yGObStR3hMpgFLnngjjcvJAxC22f3o4icxq0WNpqGNrUKBG6Ba2nM280d32s570kcVwqHOTzUQj1KKSMLUSWWzYZK3DoTUBx7GIPkhaLsYsdoJeWPogYXAgtFrcvZNAClhMcUhmzyKVbkAxa9CZwfR8+upBRi/7UAEHGWhEum4rAgxZhsZBbFzJqsfw8Q+S4/ks1jB05P/Xd/v54+fAPq3fzuhz3v0+H9vbx9Xx/9enLv8/+if/D6/nydH94eL0czGn5r5f++YF6l6UP3H7ac1B9W2jHYG/APtNHnNqafr5bKP8B"
    },
    {
      "name": "consume",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5525725861591553972": {
            "error_kind": "string",
            "string": "rejecting all"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17089945683942782951": {
            "error_kind": "string",
            "string": "unauthorized"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "is_consumable",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17312933876399746100": {
            "error_kind": "string",
            "string": "Function is_consumable can only be called statically"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "rZndTiM9DIbvpcccxE7ixNzKaoUKlFWlqqAufNInxL2vndgZOJgRSjlhnnGZd/yXeDp93z0e7t/+3B3PT89/d7e/3nf3l+PpdPxzd3p+2L8en89ifd8F/cNpdxtvdsy723Szg1D6EXB3y3os/YjUjzHYMfdjsvNk59nOc7Jj7UeKdjS9YvpFdAEFKjhkBzbg6FA7YIgOxQD08qRABugWdEtMDqosd8cUHapBdkt2C7lFXW9QwIEManDIDnILVMc0vx1qhxjQgQzU+Q5uweCglycFNohuSeggjsUgkMUS9SqSy6N+RNmgmCUluVfMCnKvSAIaVwOtSSwKZKBFiVUhG3BwMEsOwWFY2ACiQzVAdCgGERzIILlg0taUZOYSDVj+OQUF6kABHNQCAprMBig3TZINitHBLRp7g6z/HBXE+ST5IU1dh+TABqUYVIkiZYViwG5pjkkyS3MsKZhygeAwLKZcMDlUg6iCUoKiCypVheygV0k2SvOwgVuahwrNwwZu0XopVK1XDgrZANwCIphBgfu9KkaHahDdEouB9mEHMlBXs6S3ajKzpLeWaqCOdSADrWkHvSorcAcOycEt4BZwC7pFd6acFPQjKQHr6s5FoRpk8TmLh0x6U1YgA10gFBSyQXVLdYtuRB1qBwghOmnfGYkmgZLuQUbDpn4SNsr93kLspD1vNGy6JxlVJ5I8UmxUnHRfor6Jk1MdNt2ROumWZOS2tu930p2fcqPihMPW4iAlXbjtvm0WdNKla7TY2ElngpHmryjp7mqkd6tt5OCgYWs1aKQ7kJHb2jwwUuU2sHTzMRo2jaOERsXuiy2OTuSUhq3F0UgXolEa5HHgiKONiaL1bXPCiJzqsNVh42Fjt7UhUaCR2uDj42bnw/vu9XI46Oz+NM1lxr/sL4fz6+72/HY63ez+25/e2j/9fdmf2/F1f5FPJfrD+VGOIvh0PB2UPm6Wq8P6pZIhnRztcuFchkSGLxqwrsGEZBJM6ZMCf1HADS9CTe6EtO1QKDgbB6/FsamRdNMyjVTDmkbe1hgSnIdCTV8UaF1BHjxMIHId1yegLwJloxygo7KXA8oSRKzli0Rdl6AQPREUEi0S3/dhFJTlqW3VB9goR2V9WmoalYnXNTZaM2YcyVzaSp7bvl1PYPZ6yrJdqyfEjWSOVMgDxJrA99uS15fo9X0JVzcm/EBnwtWtCT/Qm/gDvYlX9yZc35y40Zy5LtlcClJprjkz0Fpz4kYcrE/FvSCy4684gbQ1PzD7CBIu6zOobIkEKEMkxLQqstWeUKsnFAOuSvDGOiuuIF8010bhViDMBZc4Ul1zIm42Z/KyyjBdd2O7KOlTUXg1GXFr8xwlobgIpBi/3aAcfNsChry6zrYk6rLMGHlKgpf+5FzmJAoMiYozEhjIJeQtS5qSSMFzgQnnvEhxkaAwJZHDCCQjzUnkMCQyzEmktEjgpBc0JEq92otZidHgSDDV4EgJh0SeKyrRqAiVSS/yyAXVcHUgcxLyEDD2zlrTpMTycBCmiho5wpCg9XRqxtY0krxiMo1UP+2/wN/3gml4wWUuEF4ePHmuwWEMAcG5xS6vWBaJucUOMFpL3mpMBkKLxPWBTErAsoNDKnMSuQwJ4kmJMQQ+f5uYDWRWYjzwIfDcKMKlqCI3KREWCb42kFmJ5UsmYo2rEgXmtpzfcrZ/OF6+/OT1oVqX4/7+dLDTp7fzw6dPX/9/8U/8J7OXy/PD4fHtclCl5Xcz+fMLZeOVt3e/9VWqnMqzeI16AvqZvCWVofD7Q135Bw=="
    },
    {
      "name": "is_reject_all",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "11691217184967371519": {
            "error_kind": "string",
            "string": "Function is_reject_all can only be called statically"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYlAAAARScCAgQBJwIDBAAfCgACAAMARC0IRAElAAAARi0CAUUnAgIERScCAwQBOw4AAwACJiUAAAFAHgIAAgknAgMBASQCAAIAAABiJQAAAWYpAgACAO9SU00nAgMAASsCAAQAAAAAAAAAAAMAAAAAAAAAAC0IAQUnAgYEBQAIAQYBJwMFBAEAIgUCBi0KBgctDgIHACIHAgctDgMHACIHAgctDgEHACIHAgctDgQHLQsFAQAiAQIBLQ4BBS0IAQEnAgIEBQAIAQIBJwMBBAEAIgUCAgAiAQIDPw8AAgADJwICBAEAKgECBC0LBAMnAgEAAAoqAwECJwIBAQAKKgIBBCQCAAQAAAEfJQAAAXgeAgABAC8qAAMAAQACHAoCAwEcCgMBABwKAQIBLQoCASYoAAAEBHhGDAAABAMkAAADAAABZSoBAAEF2sX11rRKMm08BAIBJioBAAEFoj+MFkXsKv88BAIBJioBAAEFursh14IzGGQ8BAIBJg==",
      "debug_symbols": "nZZRjuMgDIbvwnMewBiDe5XRqErbdBQpSqtMu9Kqyt0XOjhpVgKN+lL+mPDFxsbloU7d4f6178fz5VvtPh7qMPXD0H/th8uxvfWXMVofSqcf79TONirEB4yDew5sf4agdsY0ymifhYEsrBUhUyhTKBYnFicWMiJcFl6LQBGcRZBPBHGDBcj0I0AbEQlok+AsDIoQC4gFxGLFgskNTMJl4cTi0juUBGdBYiGxeLEEEBFDBogi+QyRY3UEAiXhsjBPyzw3StKyv01dl7LykqeYvWs7deNN7cb7MDTqTzvcny99X9vxOd7aKc7qRnXjKY4ReO6HLqm5WVfr8lJjrIa8PGrABeHMhmHKDKYU1BPBhH4l8IYAFS90wMUJvRI8vBsHleKoMhD0wkA0JYarMGIdCQLYLYSAGwKVCRDEB8thWY+GNgBfSYdZNpMB1iBs8BtEKCMCg2xmYOIigssI62AJY00oxJA2VVVJB8TjnxHxJNN7jDUdAMGWGZXiRM/CwGBhYRj+tRuWeU3qS1b/d6NWWIZZCstqKhWWqSBcsJlAem0Vgd48H6SLvaJWneilOD2UnDCh1ivASbuJ2hf7jeEaRBu/QLTFYtOq7AetBUqgoYiotE7wS4kzltpeLRCOu7jGgaHohK0dVZTCsK7iRj0p+JIULm+Gq+2npIRejhlaO8+f8bE99tPmGjMn1NS3h6HLj+f7eHyZvf29yoxcg67T5did7lOXSOtdKP0hf5BpiD7TXSc+eN14+JzTp/8B"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5525725861591553972": {
            "error_kind": "string",
            "string": "rejecting all"
          },
          "11691217184967371519": {
            "error_kind": "string",
            "string": "Function is_reject_all can only be called statically"
          },
          "12511970388699677811": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13929691561421487185": {
            "error_kind": "string",
            "string": "Function _set_authorized can only be called by the same contract"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17089945683942782951": {
            "error_kind": "string",
            "string": "unauthorized"
          },
          "17312933876399746100": {
            "error_kind": "string",
            "string": "Function is_consumable can only be called statically"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "set_authorized",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "authorize",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABEclAAAASicCAwQCJwIEBAAfCgADAAQARRwARkYBLQhFAS0IRgIlAAAAVScCAQRHJwICBAA7DgACAAEnAEMEAycARAAAJiUAAAFWHgIAAwEnAgQAAikCAAUA71JTTS0IAQYnAgcEBAAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIACIIAggtDgQIACIIAggtDgMIJwIEBActCAAHLQoGCC0IQwkACAAEACUAAAF8LQIAAC0KCAMKIgNEBCcCBgEACioEBgckAgAHAAAA3iUAAAT1LQgBBCcCBwQEAAgBBwEnAwQEAQAiBAIHLQoHCC0OBQgAIggCCC0OAwgAIggCCC0OAQgnAgMEBy0IAActCgQILQhDCQAIAAMAJQAAAXwtAgAALQoIAQoiAUQDCioDBgQkAgAEAAABSiUAAAT1HAoCAwAwCgADAAEmKAAABAR4RwwAAAQDJAAAAwAAAXsqAQABBdrF9da0SjJtPAQCASYlAAABVhwKAgQAKwIABQAAAAAAAAAAAQAAAAAAAAAABCoEBQYtCAEEAAABAgEtCAEFJwIHBAUACAEHAScDBQQBACIFAgctCgcILQxECAAiCAIILQxECAAiCAIILQxECAAiCAIILQ4GCC0OBQQGIgJDBScCBgQAJwIHAQEnAggEAScCCQQCLQoGAyMAAAIKDCoDBQokAgAKAAADiiMAAAIcBiICQwUEIgVDCgIqAgoDCioDBgUWCgUKJAIABQAAAyQjAAACQQIqAgMFDioDAgskAgALAAACWCUAAAUHLQsECwAqCwgNLQsNDAwiBUMNJAIADQAAAnclAAAFGQAiAQIOACoOBQ8tCw8NACoMDQ4tAgsDJwAEBAUlAAAFKy0IBQwAKgwIDS0ODg0tDgwEDCoIAwskAgALAAACuyMAAAMkACoMCQstCwsDACoFCAsOKgULDSQCAA0AAALbJQAABYoMIgtDBSQCAAUAAALtJQAABRkAIgECBwAqBwsNLQsNBQAqAwUBLQIMAycABAQFJQAABSstCAUDACoDCQUtDgEFLQ4DBCMAAAMkCioCBgESKgEKAiQCAAIAAAM7IwAAA3gtCwQBLQsBAgAiAgICLQ4CAS0IAQInAgMEBQAIAQMBJwMCBAEAIgECAwAiAgIFPw8AAwAFLQ4CBCMAAAN4LQsEAQAqAQgDLQsDAi0KAgEmLQsECgAqCggMLQsMCwQiA0MMBiIMQw4KKg4DDSQCAA0AAAOzJQAABZwMIgxDDSQCAA0AAAPFJQAABRkAIgECDgAqDgwPLQsPDQAqCw0OLQIKAycABAQFJQAABSstCAULACoLCA0tDg4NACoLCQ0tCw0KACoMCA0OKgwNDiQCAA4AAAQTJQAABYoMIg1DDiQCAA4AAAQlJQAABRkAIgECDwAqDw0QLQsQDgAqCg4NLQILAycABAQFJQAABSstCAUKACoKCQ4tDg0OACIKQw0tCw0LACoMCQ0OKgwNDiQCAA4AAARzJQAABYoMIg1DDCQCAAwAAASFJQAABRkAIgECDgAqDg0PLQsPDAAqCwwNLQIKAycABAQFJQAABSstCAULACILQwwtDg0MLQsLCgAiCgIKLQ4KCy0IAQonAgwEBQAIAQwBJwMKBAEAIgsCDAAiCgINPw8ADAANLQ4KBAAqAwgKLQoKAyMAAAIKKgEAAQW6uyHXgjMYZDwEAgEmKgEAAQUbvGXQP9zq3DwEAgEmKgEAAQXkCFBFArWMHzwEAgEmLQEDBgoABgIHJAAABwAABUEjAAAFSi0AAwUjAAAFiS0AAQUAAAEEAQAAAwQJLQADCi0ABQsKAAoJDCQAAAwAAAWELQEKCC0ECAsAAAoCCgAACwILIwAABWAnAQUEASYqAQABBdAH6/TLxmeQPAQCASYqAQABBQUEG5kgr2BMPAQCASY=",
      "debug_symbols": "rZnRbhs5DEX/xc9+ECmRkvorRVG4qVsYMJzATRZYFPn35dWImmSBMVK5L54z19YVRXGGY/v37vvx28vPr6fLj8dfu0+ff+++XU/n8+nn1/Pjw+H59Hgx9fcu4KXaK+93VXaf8n5HIfRjXY4U+7EsR+7n3M9jP495OSbqR12O0v2k+4v5UjDQ5FA6ZHbQDoUcXEG0C2A4A+oCHJKDK5Q7MJwzQDtEcnAluZJcQegLJIfaQaND6YDgOQByBwS/gDjUDgh+ga7EEB0w3GKOxA6usHSI2DIFQKkGmCJiOPITab9LRA62nGijEgcHfDgCaoeYHFxJriRXJDrkDsoO2iGTg09RgoMbFstYTPudYFMaJHxGANJBXEHVRFupaOiA9EZLuBR2cAUlDFDUcCwATFoBtQPKeYHSASXRACWRAkA7JFcQWLJkagsMHxZ3FndWV9Sds8/VYgagJJJtgWLfk2UjI8IFbFSybGREuIAriLBBi7CBK9imBWBoGcsIbAFXUKtJAaXPhVpdIHcoruBCa1DJQRYoLdQMgLOlt3Du0AJrIB2wpwvYKAmA0gGFtIAr6oq6kl3JmMtSV1A2YltQqoUqDMgL1GAxi0VYySaVBBAHGy6WhMrJwZXoSmKH3EFcQdUtAEPLYc3BYSgwtLRUVHibtIUKqNGhK3Z35UHZCZeqlEbqhItVaiNxikOLxSnFQUMTdVJz1tBInfLQsAQlEK7SZd62iIWqUx1aWweIcL/qZOtQ3IgJd6xOmC2CmAYNDZnvVJ3S0JD8TnBGhgh3mk5Da+uQRurzYh2dxKkODevoVDsx1tHJ18FjHdzW0bod9qOTOMWhxaGloaWhCSLVRtD09XW/8z789fl6PKINv2nM1q6fDtfj5Xn36fJyPu93/xzOL+1Dv54Ol3Z8PlztXdvF4+W7Hc3wx+l8BL3u19Fhe2iM6FptdLR+MgyE3jnQDQdclouBpjE+84cjsHY4IiDdiiBuOyDH3YG4ynAo6Z1D2nbg4imMtYzx1jLfGci2QSW0heZQKa9pjCW/s9BtCw1oi83C+tWah/jxGEryGJhpM4aybWE3Ve4WpWrdtKg3tlN4pDIPA7a0fnQ37ar03YxBt3aTbpSkjkTkQFsGHy3JmDYvivtrku4uSvoLVUl3lyX9hbqkv1CYdHdl0v2lyTdKU8qazXVDik6VpmyWJt9cRRilSZG2guAbpWlPBdH3FM8Kb+Ko701u1IWQhyH8pr5j/IMwcs1rGFQ3w8i3TER5mNj3gU2TG/UZNXs+YiaZaIP2fOKXO9U3Dv+vz1sWZS1Pe76dsqh4lu0WkucsMg2LwjMWHNQt7HEsTVmk4LngxHNRpLhaaJiykDAWIqxzFhKGhdCcRUqrBU9GocMil7ujmLUYBc5KUwXOmnhYyNymqo4d0TwZhYxcaAl3L2TOwpqnN6NYSpq0WJtqmNrUWCMNC91OZ7rR2pP9OtE9UolrhVP9eBRVRxQ1zy2krg9sda7AaTQBw7mL3b6mrxZzFzvRKC37Pjy5EF0t7l/IpAWtd3BKec5C8rDQOmkxmsDbp/DZhcxalDIs6lwr4nVTmcqkRVgt6r0LmbVYv5wxl7hpoTp3y/liZ4eH0/Xdvyyv8LqeDt/Ox3764+Xy8Obd53+f/B3/l+bp+vhw/P5yPcJp/avGXj7bXw97LvwFP8fZqT1zZcUJ4T2rWeuVX14Ryn8="
    },
    {
      "name": "set_authorized_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "abi_private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "approver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "authorize",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "expiration_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_separators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_separator::KeyValidationRequestAndSeparator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "key_type_domain_separator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log",
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 16,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "9894212961085021188": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tVpbbhs7DN2Lv/0hiqREZStFUbipWxgwnMBNClwU3fulPCPNOKlY1XJ/cuSZ8AxF8aHXz82X/efXb58Op69P3zcPH35uPp8Px+Ph26fj0+Pu5fB00qc/Ny7/Ado8gP+13UD+hXHz4LcbFAV95vMzj5sH0jZNwBOECeIEMkHaPESVdhPABEoiCjgBTaAs4BTDjDGjfhEvX1RJAOXzM+KMNCPPmKVBpaj0BPUH/6Yj4fIPqh780l/FCp9ezvt9frMyixrreXfen142D6fX43G7+bE7vl7+6fvz7nTBl91Z36rW+9MXRSX8ejjuc+vXdpF2bVGKPAsHH6t45F55jr7Iw0o+9soPqB6ofFqcLJ/GXnmROMsn51vy3JbHUEyHkao8UbgiCG0CT4XAh9gk6NNAsElgmCD5VExArmWCNNoDawwTzgQR4Qb3AQfFCcCtVPDY7UYxpVT9CBczMlwxABqeVHuRkG/RQcBL0QHUei0dDF8gcjBTEMHKH9H3ayE1ojy4phbRcAgIpSPerxJKuFYCxPBJECrW9H5xCpRrr4BkDYivPUkhNTm8YQ3kQoFp5VhJrhnAYHBYhkSb6TYOgGINBPZtDrRyfCphSoILB6R+NUIoLo4hwm1dWXMI38aRFpOuB/YdR/y35kjJVTWSNNWwgs0z1WBLvhVsaHkoUihaoKwopJ+CeRkTDC0Kqx+aeEo/2LX7YfhnwpIzUlgRXKcMJGNE2dURZY5NQ1iltFYyAl6lvls6sYqPt50w3DLW6IhxGQjy/RokqqXQt1Uw0iaFMpQaI0vSBOnXoRYhcGszXutAZpZwi0e23SHP/UYrCOF4BSEarSDE4xXE5OisIDSeMk01OitIN4dRQUyOzgrC8G/N0VlBrGDTECsrGACPrVBhw0UhujL5hSjxJorga94JK4O+pTAWQoAQak803TRLGY9PPfkOU0++w9QzDE89wx3ma+EOc60wPvUMd5hr/cHBUl0nol8tNd84WAimPeoCK7TWqrYWnmDRou3mwfBR0HVeJaG1o/8VSaxTR21HbAZcZ+DLetF6HXARTItgNQgvCT24v6AQqT1xsUmBw5kjkpU56sgmzanNqI9GSQiOSi4OjhdHx7/Qoi9/xTiev6KM5q+YxvOXydGZv2S80ttq9OUv28lj7HByM1ol1LQhIrdUeu/q1Nw7phaFmDlU6i4VuOYCQeK4k4uMO7mkUSdPbnx2b3J0zu6TH3ZyU43OeLU56iYohtV29LtCb7poXcJ6J83VYzJcVP2hbopHpFZlTIaLci1J6z0VgX4dBEp5ToLN6pwM9wSWmneAE6Rb9nYk1r0dWaWutxvCDqyqhlir2mqW0H9Mk5hrrAq1lbAqPC4Vnlb2fLst7e5QXMHxeOLRw4zRzAMujqcem6Qz94BLw8nHVqQz+/STGJsLNknnnAMA/7FJ7rBDrXL1gJS4GXgwumayDigd12SsMdHWwVrsMCz7JAyxmdIB7pFP/6CLj3XDhQmbS0Cwjh9SPfdVP5IbTu2TX86+0cGVWT/qr93j4Xx9QQPy/QaNdsiXGTLKjGlC7xS14/m+xAV9TgrTfQmc70ugn+5LXDDkMJtubVxQZkw5GU4XNy4IOQimqxs0392g+fJGToP59sYFQ74QMN3euKDMqHx5b4lcPmxWhBmVLxc3whmVL19lIM7nMYohH20oxnyuoSjZVIppQnYzQi7Rivl+iFMixtKgPDy5waURSiOWhuSGfobT3AiuNC4XT1TzkJnzQWXA0sjMPrvOj935sPt83OchyoP4enosI6Y/X/57Lm/KpZvn89Pj/svreZ9Hd3XzRv9+0Dj2kEd/un6jTzxvkT9up9d6zEOcX/sqoWteCvkRVom0xfROgt5/g+1vhCqhceD1G9kv/wc=",
      "verification_key": "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"
    },
    {
      "name": "set_reject_all",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "reject",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUlAAAARicCAgQBJwIDBAAfCgACAAMARBwAREQBLQhEASUAAABHJwIBBEUnAgIEADsOAAIAASYlAAABGh4CAAIBKQIAAwDvUlNNJwIEAAErAgAFAAAAAAAAAAADAAAAAAAAAAAtCAEGJwIHBAUACAEHAScDBgQBACIGAgctCgcILQ4DCAAiCAIILQ4ECAAiCAIILQ4CCAAiCAIILQ4FCC0LBgIAIgICAi0OAgYtCAECJwIDBAUACAEDAScDAgQBACIGAgMAIgICBD8PAAMABCcCAwQBACoCAwUtCwUEJwICAAAKKgQCAycCAgEACioDAgUkAgAFAAABDiUAAAFAHAoBAgAwCgACAAQmKAAABAR4RQwAAAQDJAAAAwAAAT8qAQABBdrF9da0SjJtPAQCASYqAQABBbq7IdeCMxhkPAQCASY=",
      "debug_symbols": "nZXbjqMwDIbfJddcxM7RfZVRVdGWjpAQrZiy0qri3dcUh8NIQbNzw+8Y8uHYTvJS1+rcf57q9nb/UoePlzp3ddPUn6fmfimf9b1l70vp8RG8OmChIqgDFYr0JO4tAH5S1KLiNzI2MrYytlY0TuqMaJjUo6hwA4gKJ9CkUTiROQBsECYjTAZqTEbyQPJA8iD/HnA0ohgmecz4jWXDYjKSxyWPSx7vxAi8ToijwR6EYShUyujp2VXVmNBVijnxj7Kr2qc6tH3TFOpP2fTvj74eZfvWZ9nxW12oqr2yMvBWN9VoDcUyW+enWtAgsy2AnQEONgTIE4wlARi/zA/44wh0oDkCrXMRmDwB0DohAJKbCdFuCDZPwJhSaCjO8y34DcDlAcQ9JwRCrmxCmBg2CJ9HRJ4oiEiesoiwUwqH8zLCDEBe0hoQd/LAW0YICOR/hViKwfvGZBGw1xKBEsNGgzMD6KdRGKKloquSfo9ir6uAUl/ygeVzXQU7CBeNEPyqsaP/1dZYddX3zen2VqHnvQEGckHATmOCjiY1N9t2dUhs6wE7rekgheFwtcOM+Y8wAoUlDKBsGLQHcR5niIeYg+BOWYwPKR8mgNuceUcelZe621yVw8jq6vLcVDK89e1l9fb595HepKv20d0v1bXvqpG03LfAzw9nC0fH8YLlgdeFx+Mw/vof"
    },
    {
      "name": "utility_is_consumable",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    }
  ],
  "outputs": {
    "globals": {},
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_approver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_message_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_authorize",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AuthRegistry::_set_authorized_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AuthRegistry::_set_authorized_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_on_behalf_of",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AuthRegistry::consume_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "AuthRegistry::consume_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_on_behalf_of",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_message_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AuthRegistry::is_consumable_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "AuthRegistry::is_consumable_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_on_behalf_of",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AuthRegistry::is_reject_all_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "AuthRegistry::is_reject_all_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_message_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_authorize",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AuthRegistry::set_authorized_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AuthRegistry::set_authorized_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_approver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_message_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_authorize",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AuthRegistry::set_authorized_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AuthRegistry::set_authorized_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_reject",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AuthRegistry::set_reject_all_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AuthRegistry::set_reject_all_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_on_behalf_of",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_message_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AuthRegistry::utility_is_consumable_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "AuthRegistry::utility_is_consumable_abi"
        }
      ]
    }
  },
  "file_map": {
    "0": {
      "path": "std/aes128.nr",
      "source": "// docs:start:aes128\n// Given a plaintext as an array of bytes, returns the corresponding aes128 ciphertext (CBC mode). Input padding is performed using PKCS#7, so that the output length is `input.len() + (16 - input.len() % 16)`.\npub fn aes128_encrypt<let N: u32>(\n    input: [u8; N],\n    iv: [u8; 16],\n    key: [u8; 16],\n) -> [u8; N + 16 - N % 16] {\n    let padding_length = (16 - N % 16) as u8;\n    let mut padded_input: [u8; N + 16 - N % 16] = [0; N + 16 - N % 16];\n    for i in 0..N {\n        padded_input[i] = input[i];\n    }\n    for i in N..N + 16 - N % 16 {\n        padded_input[i] = padding_length;\n    }\n    let output = aes128_encrypt_padded_input(padded_input, iv, key);\n    output\n}\n\n#[foreign(aes128_encrypt)]\nfn aes128_encrypt_padded_input<let N: u32>(input: [u8; N], iv: [u8; 16], key: [u8; 16]) -> [u8; N] {}\n\n// docs:end:aes128\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    crate::assert_constant(separator);\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "230": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called\n/// and if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 12;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "298": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.2.3/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let num_extra_fields = in_len % RATE;\n            if num_extra_fields != 0 {\n                let remainder_start = in_len - num_extra_fields;\n                state[0] += input[remainder_start];\n                if num_extra_fields > 1 {\n                    state[1] += input[remainder_start + 1]\n                }\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4)\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a vector.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let vector = array.as_vector();\n    /// assert_eq(vector, [1, 2].as_vector());\n    /// ```\n    #[builtin(as_vector)]\n    pub fn as_vector(self) -> [T] {}\n\n    /// Returns this array as a vector.\n    /// This method is deprecated in favor of `as_vector`.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let vector = array.as_slice();\n    /// assert_eq(vector, [1, 2].as_vector());\n    /// ```\n    #[builtin(as_vector)]\n    #[deprecated(\"This method has been renamed to `as_vector`\")]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "309": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/block_header.nr",
      "source": "use crate::{\n    abis::{\n        append_only_tree_snapshot::AppendOnlyTreeSnapshot, global_variables::GlobalVariables,\n        state_reference::StateReference,\n    },\n    constants::{BLOCK_HEADER_LENGTH, DOM_SEP__BLOCK_HEADER_HASH, GENESIS_BLOCK_HEADER_HASH},\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Empty, Hash, Serialize},\n};\nuse std::meta::derive;\n\n// docs:start:block-header\n#[derive(Deserialize, Eq, Serialize)]\npub struct BlockHeader {\n    pub last_archive: AppendOnlyTreeSnapshot,\n    pub state: StateReference,\n\n    // The hash of the sponge blob for this block, which commits to the tx effects added in this block.\n    // Note: it may also include tx effects from previous blocks within the same checkpoint.\n    // When proving tx effects from this block only, we must refer to the `sponge_blob_hash` in the previous block\n    // header to show that the effect was added after the previous block.\n    // The previous block header can be validated using a membership proof of the last leaf in `last_archive`.\n    pub sponge_blob_hash: Field,\n\n    pub global_variables: GlobalVariables,\n    pub total_fees: Field,\n    pub total_mana_used: Field,\n}\n// docs:end:block-header\n\nimpl Empty for BlockHeader {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::empty(),\n            state: StateReference::empty(),\n            sponge_blob_hash: 0,\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0,\n            total_mana_used: 0,\n        }\n    }\n}\n\nimpl Hash for BlockHeader {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), DOM_SEP__BLOCK_HEADER_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = BlockHeader::empty();\n    // We use the BLOCK_HEADER_LENGTH constant to ensure that there is a match\n    // between the derived trait implementation and the constant.\n    let serialized: [Field; BLOCK_HEADER_LENGTH] = header.serialize();\n    let deserialized = BlockHeader::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_of_genesis_block_header() {\n    let mut header = BlockHeader::empty();\n    // The following values are taken from world_state.test.cpp > WorldStateTest.GetInitialTreeInfoForAllTrees.\n    header.state.l1_to_l2_message_tree.root =\n        0x0d582c10ff8115413aa5b70564fdd2f3cefe1f33a1e43a47bc495081e91e73e5;\n    header.state.partial.note_hash_tree.root =\n        0x2ac5dda169f6bb3b9ca09bbac34e14c94d1654597db740153a1288d859a8a30a;\n    header.state.partial.nullifier_tree.root =\n        0x1ec3788cd1c32e54d889d67fe29e481114f9d4afe9b44b229aa29d8ad528dd31;\n    header.state.partial.nullifier_tree.next_available_leaf_index = 128;\n    header.state.partial.public_data_tree.root =\n        0x23c08a6b1297210c5e24c76b9a936250a1ce2721576c26ea797c7ec35f9e46a9;\n    header.state.partial.public_data_tree.next_available_leaf_index = 128;\n\n    let hash = header.hash();\n    assert_eq(hash, GENESIS_BLOCK_HEADER_HASH);\n}\n\n#[test]\nfn hash_of_empty_block_header_match_typescript() {\n    let header = BlockHeader::empty();\n    let hash = header.hash();\n\n    // Value from block_header.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x0bdc537052dea0f80db9698585dff9f32063b86b6d4934ac17c30c81e8e416d3;\n    assert_eq(hash, test_data_empty_hash);\n}\n"
    },
    "387": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector, nullifier::Nullifier, private_log::PrivateLog,\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, DOM_SEP__NOTE_HASH_NONCE,\n        DOM_SEP__PRIVATE_LOG_FIRST_FIELD, DOM_SEP__SILOED_NOTE_HASH, DOM_SEP__SILOED_NULLIFIER,\n        DOM_SEP__UNIQUE_NOTE_HASH, FUNCTION_TREE_HEIGHT, NULL_MSG_SENDER_CONTRACT_ADDRESS,\n        TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\n// TODO: refactor these into their own files: sha256, poseidon2, some protocol-specific hash computations, some merkle computations.\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn compute_siloed_note_hash(contract_address: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address.to_field(), note_hash],\n        DOM_SEP__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique, siloed note hashes from siloed note hashes.\n///\n/// The protocol injects uniqueness into every note_hash, so that every single note_hash in the\n/// tree is unique. This prevents faerie gold attacks, where a malicious sender could create\n/// two identical note_hashes for a recipient (meaning only one would be nullifiable in future).\n///\n/// Most privacy protocols will inject the note's leaf_index (its position in the Note Hashes Tree)\n/// into the note, but this requires the creator of a note to wait until their tx is included in\n/// a block to know the note's final note hash (the unique, siloed note hash), because inserting\n/// leaves into trees is the job of a block producer.\n///\n/// We took a different approach so that the creator of a note will know each note's unique, siloed\n/// note hash before broadcasting their tx to the network.\n/// (There was also a historical requirement relating to \"chained transactions\" -- a feature that\n/// Aztec Connect had to enable notes to be spent from distinct txs earlier in the same block,\n/// and hence before an archive block root had been established for that block -- but that feature\n/// was abandoned for the Aztec Network for having too many bad tradeoffs).\n///\n/// (\n///   Edit: it is no longer true that all final note_hashes will be known by the creator of a tx\n///   before they send it to the network. If a tx makes public function calls, then _revertible_\n///   note_hashes that are created in private will not be made unique in private by the Reset circuit,\n///   but will instead be made unique by the AVM, because the `note_index_in_tx` will not be known\n///   until the AVM has executed the public functions of the tx. (See an explanation in\n///   reset_output_composer.nr for why).\n///   For some such txs, the `note_index_in_tx` might still be predictable through simulation, but\n///   for txs whose public functions create a varying number of non-revertible notes (determined at\n///   runtime), the `note_index_in_tx` will not be deterministically derivable before submitting the\n///   tx to the network.\n/// )\n///\n/// We use the `first_nullifier` of a tx as a seed of uniqueness. We have a guarantee that there will\n/// always be at least one nullifier per tx, because the init circuit will create one if one isn't\n/// created naturally by any functions of the tx. (Search \"protocol_nullifier\").\n/// We combine the `first_nullifier` with the note's index (its position within this tx's new\n/// note_hashes array) (`note_index_in_tx`) to get a truly unique value to inject into a note, which\n/// we call a `note_nonce`.\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, DOM_SEP__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        DOM_SEP__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_note_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier(contract_address: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address.to_field(), nullifier],\n        DOM_SEP__SILOED_NULLIFIER,\n    )\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    // The protocol nullifier is ascribed a special side-effect counter of 1. No other side-effect\n    // can have counter 1 (see `validate_as_first_call` for that assertion).\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_first_field(\n    contract_address: AztecAddress,\n    field: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address.to_field(), field],\n        DOM_SEP__PRIVATE_LOG_FIRST_FIELD,\n    )\n}\n\npub fn compute_siloed_private_log(contract_address: AztecAddress, log: PrivateLog) -> PrivateLog {\n    let mut fields = log.fields;\n    fields[0] = compute_siloed_private_log_first_field(contract_address, fields[0]);\n    PrivateLog::new(fields, log.length)\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_siloed_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    key_type_domain_separator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        key_type_domain_separator,\n    )\n}\n\npub fn compute_l2_to_l1_message_hash(\n    message: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = message.contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = message.inner.recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = message.inner.content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\n// TODO: consider a variant that enables domain separation with a u32 (we seem to have standardised u32s for domain separators)\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn subarray_hash_matches_fixed() {\n    let mut values_to_hash = [3; 17];\n    let mut padded = values_to_hash.concat([0; 11]);\n    let subarray_hash = poseidon2_hash_subarray(padded, values_to_hash.len());\n\n    // Hash the entire values_to_hash.\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(values_to_hash, values_to_hash.len());\n\n    assert_eq(subarray_hash, fixed_len_hash);\n}\n\n#[test]\nfn subarray_hash_matches_variable() {\n    let mut values_to_hash = [3; 17];\n    let mut padded = values_to_hash.concat([0; 11]);\n    let subarray_hash = poseidon2_hash_subarray(padded, values_to_hash.len());\n\n    // Hash up to values_to_hash.len() fields of the padded array.\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(padded, values_to_hash.len());\n\n    assert_eq(subarray_hash, variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn unique_siloed_note_hash_matches_typescript() {\n    let inner_note_hash = 1;\n    let contract_address = AztecAddress::from_field(2);\n    let first_nullifier = 3;\n    let note_index_in_tx = 4;\n\n    let siloed_note_hash = compute_siloed_note_hash(contract_address, inner_note_hash);\n    let siloed_note_hash_from_ts =\n        0x1986a4bea3eddb1fff917d629a13e10f63f514f401bdd61838c6b475db949169;\n    assert_eq(siloed_note_hash, siloed_note_hash_from_ts);\n\n    let nonce: Field = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    let note_hash_nonce_from_ts =\n        0x28e7799791bf066a57bb51fdd0fbcaf3f0926414314c7db515ea343f44f5d58b;\n    assert_eq(nonce, note_hash_nonce_from_ts);\n\n    let unique_siloed_note_hash_from_nonce = compute_unique_note_hash(nonce, siloed_note_hash);\n    let unique_siloed_note_hash = compute_note_nonce_and_unique_note_hash(\n        siloed_note_hash,\n        first_nullifier,\n        note_index_in_tx,\n    );\n    assert_eq(unique_siloed_note_hash_from_nonce, unique_siloed_note_hash);\n\n    let unique_siloed_note_hash_from_ts =\n        0x29949aef207b715303b24639737c17fbfeb375c1d965ecfa85c7e4f0febb7d16;\n    assert_eq(unique_siloed_note_hash, unique_siloed_note_hash_from_ts);\n}\n\n#[test]\nfn siloed_nullifier_matches_typescript() {\n    let contract_address = AztecAddress::from_field(123);\n    let nullifier = 456;\n\n    let res = compute_siloed_nullifier(contract_address, nullifier);\n\n    let siloed_nullifier_from_ts =\n        0x169b50336c1f29afdb8a03d955a81e485f5ac7d5f0b8065673d1e407e5877813;\n\n    assert_eq(res, siloed_nullifier_from_ts);\n}\n\n#[test]\nfn siloed_private_log_first_field_matches_typescript() {\n    let contract_address = AztecAddress::from_field(123);\n    let field = 456;\n    let res = compute_siloed_private_log_first_field(contract_address, field);\n\n    let siloed_private_log_first_field_from_ts =\n        0x29480984f7b9257fded523d50addbcfc8d1d33adcf2db73ef3390a8fd5cdffaa;\n\n    assert_eq(res, siloed_private_log_first_field_from_ts);\n}\n\n#[test]\nfn empty_l2_to_l1_message_hash_matches_typescript() {\n    // All zeroes\n    let res = compute_l2_to_l1_message_hash(\n        L2ToL1Message { recipient: EthAddress::zero(), content: 0 }.scope(AztecAddress::from_field(\n            0,\n        )),\n        0,\n        0,\n    );\n\n    let empty_l2_to_l1_msg_hash_from_ts =\n        0x003b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992;\n\n    assert_eq(res, empty_l2_to_l1_msg_hash_from_ts);\n}\n\n#[test]\nfn l2_to_l1_message_hash_matches_typescript() {\n    let message = L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n        AztecAddress::from_field(3),\n    );\n    let version = 4;\n    let chainId = 5;\n\n    let hash = compute_l2_to_l1_message_hash(message, version, chainId);\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let l2_to_l1_message_hash_from_ts =\n        0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, l2_to_l1_message_hash_from_ts);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "416": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{\n    constants::DOM_SEP__PUBLIC_STORAGE_MAP_SLOT, hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n// TODO: Move this to src/public_data/storage/map.nr\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash_with_separator(\n        [storage_slot, key.to_field()],\n        DOM_SEP__PUBLIC_STORAGE_MAP_SLOT,\n    )\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x2d225f361108379adc2da91378b9702675c5546b57e78bafc1e74ec7fec55967;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U>(message: T) -> U\nwhere\n    T: StringLike,\n{\n    assert(false, message);\n    crate::mem::zeroed()\n}\n\ntrait StringLike {}\n\nimpl<let N: u32> StringLike for str<N> {}\nimpl<let N: u32, T> StringLike for fmtstr<N, T> {}\n"
    },
    "433": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "446": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/serde/src/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn peek_offset(&mut self, offset: u32) -> Field {\n        self.data[self.offset + offset]\n    }\n\n    pub fn advance_offset(&mut self, offset: u32) {\n        self.offset += offset;\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "447": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/serde/src/serialization.nr",
      "source": "use crate::{reader::Reader, writer::Writer};\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut writer: Writer<Self::N> = Writer::new();\n///         self.stream_serialize(&mut writer);\n///         writer.finish()\n///     }\n///\n///     fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n///         let bytes = self.as_bytes();\n///         for i in 0..bytes.len() {\n///             writer.write(bytes[i] as Field);\n///         }\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; Self::N];\n\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>);\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut writer: Writer<Self::N> = Writer::new();\n///         self.stream_serialize(&mut writer);\n///         writer.finish()\n///     }\n///\n///     #[inline_always]\n///     fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n///         Serialize::stream_serialize(self.fields, writer);\n///         Serialize::stream_serialize(self.length, writer);\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let params_len_quote = get_params_len_quote(params);\n\n    let function_body = params\n        .map(|(name, _typ): (Quoted, Type)| {\n            quote {\n                $crate::serialization::Serialize::stream_serialize(self.$name, writer);\n            }\n        })\n        .join(quote {});\n\n    quote {\n        impl$generics_declarations $crate::serialization::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n\n            fn serialize(self) -> [Field; Self::N] {\n                let mut writer: $crate::writer::Writer<Self::N> = $crate::writer::Writer::new();\n                $crate::serialization::Serialize::stream_serialize(self, &mut writer);\n                writer.finish()\n            }\n\n\n            #[inline_always]\n             fn stream_serialize<let K: u32>(self, writer: &mut $crate::writer::Writer<K>) {\n                $function_body\n            }\n        }\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         let mut reader = Reader::new(fields);\n///         let result = Self::stream_deserialize(&mut reader);\n///         reader.finish();\n///         result\n///     }\n///\n///     fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n///         let mut bytes = [0 as u8; M];\n///         for i in 0..M {\n///             bytes[i] = reader.read() as u8;\n///         }\n///         str::<M>::from(bytes)\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self;\n\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self;\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         let mut reader = Reader::new(fields);\n///         let result = Self::stream_deserialize(&mut reader);\n///         reader.finish();\n///         result\n///     }\n///\n///     #[inline_always]\n///     fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n///         let x = <AztecAddress as Deserialize>::stream_deserialize(reader);\n///         let y = <Field as Deserialize>::stream_deserialize(reader);\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::serialization::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let $param_name = <$param_type as Deserialize>::stream_deserialize(reader);\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::serialization::Deserialize::stream_deserialize(reader) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::serialization::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            fn deserialize(fields: [Field; Self::N]) -> Self {\n                let mut reader = $crate::reader::Reader::new(fields);\n                let result = Self::stream_deserialize(&mut reader);\n                reader.finish();\n                result\n            }\n\n            #[inline_always]\n            fn stream_deserialize<let K: u32>(reader: &mut $crate::reader::Reader<K>) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\ncomptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::serialization::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n"
    },
    "449": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/serde/src/type_impls.nr",
      "source": "use crate::{reader::Reader, serialization::{Deserialize, Serialize}, writer::Writer};\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> bool {\n        reader.read() != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self);\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read()\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u8 as Field);\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u16 as Field);\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u32 as Field);\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u64 as Field);\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        for i in 0..M {\n            self[i].stream_serialize(writer);\n        }\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        let mut result: [T; M] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = T::stream_deserialize(reader);\n        }\n        result\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write_bool(self.is_some());\n        if self.is_some() {\n            self.unwrap_unchecked().stream_serialize(writer);\n        } else {\n            writer.advance_offset(<T as Serialize>::N);\n        }\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        if reader.read_bool() {\n            Option::some(<T as Deserialize>::stream_deserialize(reader))\n        } else {\n            reader.advance_offset(<T as Deserialize>::N);\n            Option::none()\n        }\n    }\n}\n\nglobal SCALAR_SIZE: u32 = 2;\n\nimpl Serialize for EmbeddedCurveScalar {\n\n    let N: u32 = SCALAR_SIZE;\n\n    fn serialize(self) -> [Field; SCALAR_SIZE] {\n        [self.lo, self.hi]\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self.lo);\n        writer.write(self.hi);\n    }\n}\n\nimpl Deserialize for EmbeddedCurveScalar {\n    let N: u32 = SCALAR_SIZE;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        Self { lo: fields[0], hi: fields[1] }\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        Self { lo: reader.read(), hi: reader.read() }\n    }\n}\n\nglobal POINT_SIZE: u32 = 3;\n\nimpl Serialize for EmbeddedCurvePoint {\n    let N: u32 = POINT_SIZE;\n\n    fn serialize(self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self.x);\n        writer.write(self.y);\n        writer.write(self.is_infinite as Field);\n    }\n}\n\nimpl Deserialize for EmbeddedCurvePoint {\n    let N: u32 = POINT_SIZE;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        Self { x: fields[0], y: fields[1], is_infinite: fields[2] != 0 }\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        Self { x: reader.read(), y: reader.read(), is_infinite: reader.read_bool() }\n    }\n}\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        let u8_arr = <[u8; Self::N] as Deserialize>::stream_deserialize(reader);\n        str::<Self::N>::from(u8_arr)\n    }\n}\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        self.as_bytes().stream_serialize(writer);\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n        let payload_len = Self::N - 1;\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = reader.peek_offset(payload_len) as u32;\n\n        for i in 0..M {\n            if i < len {\n                new_bounded_vec.push(<T as Deserialize>::stream_deserialize(reader));\n            }\n        }\n\n        // +1 for the length of the BoundedVec\n        reader.advance_offset((M - len) * <T as Deserialize>::N + 1);\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(_reader: &mut Reader<K>) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        self.storage().stream_serialize(writer);\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        writer.write_u32(self.len() as u32);\n    }\n}\n\n// Create a slice of the given length with each element made from `f(i)` where `i` is the current index\ncomptime fn make_slice<Env, T>(length: u32, f: fn[Env](u32) -> T) -> [T] {\n    let mut slice = @[];\n    for i in 0..length {\n        slice = slice.push_back(f(i));\n    }\n    slice\n}\n\n// Implements Serialize and Deserialize for an arbitrary tuple type\ncomptime fn impl_serialize_for_tuple(_m: Module, length: u32) -> Quoted {\n    // `T0`, `T1`, `T2`\n    let type_names = make_slice(length, |i| f\"T{i}\".quoted_contents());\n\n    // `result0`, `result1`, `result2`\n    let result_names = make_slice(length, |i| f\"result{i}\".quoted_contents());\n\n    // `T0, T1, T2`\n    let field_generics = type_names.join(quote [,]);\n\n    // `<T0 as Serialize>::N + <T1 as Serialize>::N + <T2 as Serialize>::N`\n    let full_size_serialize = type_names\n        .map(|type_name| quote {\n        <$type_name as Serialize>::N\n    })\n        .join(quote [+]);\n\n    // `<T0 as Deserialize>::N + <T1 as Deserialize>::N + <T2 as Deserialize>::N`\n    let full_size_deserialize = type_names\n        .map(|type_name| quote {\n        <$type_name as Deserialize>::N\n    })\n        .join(quote [+]);\n\n    // `T0: Serialize, T1: Serialize, T2: Serialize,`\n    let serialize_constraints = type_names\n        .map(|field_name| quote {\n        $field_name: Serialize,\n    })\n        .join(quote []);\n\n    // `T0: Deserialize, T1: Deserialize, T2: Deserialize,`\n    let deserialize_constraints = type_names\n        .map(|field_name| quote {\n        $field_name: Deserialize,\n    })\n        .join(quote []);\n\n    // Statements to serialize each field\n    let serialized_fields = type_names\n        .mapi(|i, _type_name| quote {\n            $crate::serialization::Serialize::stream_serialize(self.$i, writer);\n    })\n        .join(quote []);\n\n    // Statements to deserialize each field\n    let deserialized_fields = type_names\n        .mapi(|i, type_name| {\n            let result_name = result_names[i];\n            quote {\n            let $result_name = <$type_name as $crate::serialization::Deserialize>::stream_deserialize(reader);\n        }\n        })\n        .join(quote []);\n    let deserialize_results = result_names.join(quote [,]);\n\n    quote {\n        impl<$field_generics> Serialize for ($field_generics) where $serialize_constraints {\n            let N: u32 = $full_size_serialize;\n\n            fn serialize(self) -> [Field; Self::N] {\n                let mut writer: $crate::writer::Writer<Self::N> = $crate::writer::Writer::new();\n                self.stream_serialize(&mut writer);\n                writer.finish()\n            }\n\n            #[inline_always]\n            fn stream_serialize<let K: u32>(self, writer: &mut $crate::writer::Writer<K>) {\n\n                $serialized_fields\n            }\n        }\n\n        impl<$field_generics> Deserialize for ($field_generics) where $deserialize_constraints {\n            let N: u32 = $full_size_deserialize;\n\n            fn deserialize(fields: [Field; Self::N]) -> Self {\n                let mut reader = $crate::reader::Reader::new(fields);\n                let result = Self::stream_deserialize(&mut reader);\n                reader.finish();\n                result\n            }\n    \n            #[inline_always]\n            fn stream_deserialize<let K: u32>(reader: &mut $crate::reader::Reader<K>) -> Self {\n                $deserialized_fields\n                ($deserialize_results)\n            }\n        }\n    }\n}\n\n// Keeping these manual impls. They are more efficient since they do not\n// require copying sub-arrays from any serialized arrays.\nimpl<T1> Serialize for (T1,)\nwhere\n    T1: Serialize,\n{\n    let N: u32 = <T1 as Serialize>::N;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: crate::writer::Writer<Self::N> = crate::writer::Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        self.0.stream_serialize(writer);\n    }\n}\n\nimpl<T1> Deserialize for (T1,)\nwhere\n    T1: Deserialize,\n{\n    let N: u32 = <T1 as Deserialize>::N;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::reader::Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        (<T1 as Deserialize>::stream_deserialize(reader),)\n    }\n}\n\n#[impl_serialize_for_tuple(2)]\n#[impl_serialize_for_tuple(3)]\n#[impl_serialize_for_tuple(4)]\n#[impl_serialize_for_tuple(5)]\n#[impl_serialize_for_tuple(6)]\nmod impls {\n    use crate::serialization::{Deserialize, Serialize};\n}\n"
    },
    "450": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/serde/src/writer.nr",
      "source": "pub struct Writer<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Writer<N> {\n    pub fn new() -> Self {\n        Self { data: [0; N], offset: 0 }\n    }\n\n    pub fn write(&mut self, value: Field) {\n        self.data[self.offset] = value;\n        self.offset += 1;\n    }\n\n    pub fn write_u32(&mut self, value: u32) {\n        self.write(value as Field);\n    }\n\n    pub fn write_u64(&mut self, value: u64) {\n        self.write(value as Field);\n    }\n\n    pub fn write_bool(&mut self, value: bool) {\n        self.write(value as Field);\n    }\n\n    pub fn write_array<let K: u32>(&mut self, value: [Field; K]) {\n        for i in 0..K {\n            self.data[i + self.offset] = value[i];\n        }\n        self.offset += K;\n    }\n\n    pub fn write_struct<T, let K: u32>(&mut self, value: T, serialize: fn(T) -> [Field; K]) {\n        self.write_array(serialize(value));\n    }\n\n    pub fn write_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        value: [T; C],\n        serialize: fn(T) -> [Field; K],\n    ) {\n        for i in 0..C {\n            self.write_struct(value[i], serialize);\n        }\n    }\n\n    pub fn advance_offset(&mut self, offset: u32) {\n        self.offset += offset;\n    }\n\n    pub fn finish(self) -> [Field; N] {\n        assert_eq(self.offset, self.data.len(), \"Writer did not write all data\");\n        self.data\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_vectors() {\n        let vector_1 = [0, 1, 2, 3].as_vector();\n        let vector_2 = [0, 1, 2].as_vector();\n        assert(!vector_1.eq(vector_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_vectors() {\n        assert(\n            [2_u32].as_vector().cmp([1_u32, 1_u32, 1_u32].as_vector())\n                == super::Ordering::greater(),\n        );\n        assert(\n            [1_u32, 2_u32].as_vector().cmp([1_u32, 2_u32, 3_u32].as_vector())\n                == super::Ordering::less(),\n        );\n    }\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/auth_registry_contract/src/main.nr",
      "source": "/// A contract that manages public authentication witnesses (authwits) on the Aztec network.\n///\n/// In Aztec, private authwits are verified by account contracts directly (via oracles on the user's device). Public\n/// authwits, however, require this onchain registry because local oracles cannot be used for global execution. Users pre-approve\n/// actions by storing `message_hash -> true` mappings via `set_authorized`, and consumer contracts verify and\n/// atomically revoke these approvals via `consume`.\n///\n/// The `message_hash` includes the consumer address, chain ID, and protocol version, preventing cross-chain and\n/// cross-contract replay. Each approval can only be consumed once. Users can also enable `reject_all` as an emergency\n/// kill switch to invalidate all outstanding approvals at once.\n///\n/// A private-to-public bridge is provided via `set_authorized_private`: a user signs a private authwit, and any party\n/// holding it can call this function to insert the corresponding public approval.\n///\n/// Note that there is no expiration time enforced on the approved actions in this contract as this can be achieved by\n/// including an expiration timestamp in the `message` (`message_hash` preimage) and having the consumer contract\n/// constrain that value.\npub contract AuthRegistry {\n    use aztec::{\n        authwit::auth::{\n            assert_current_call_valid_authwit, compute_authwit_message_hash, IS_VALID_SELECTOR,\n        },\n        context::{PrivateContext, PublicContext, UtilityContext},\n        hash::{hash_args, hash_calldata_array},\n        oracle::{avm, execution_cache, version::assert_compatible_oracle_version},\n        protocol::{\n            abis::function_selector::FunctionSelector,\n            address::AztecAddress,\n            traits::{Deserialize, FromField, Serialize, ToField},\n            utils::reader::Reader,\n        },\n        state_vars::{Map, PublicMutable, StateVariable},\n    };\n\n    struct Storage<Context> {\n        /// Per-address flag that, when true, causes all `consume` calls for that address to revert. Provides an\n        /// emergency \"mass revocation\" mechanism. Does not delete existing approvals - if later set back to false,\n        /// unconsumed approvals become consumable again.\n        reject_all: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        /// Per-user, per-message authorization status. `approved_actions[user][message_hash]` is set to true by\n        /// `set_authorized` and atomically revoked by `consume` to prevent replay.\n        approved_actions: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n    }\n\n    /// Approves or revokes a `message_hash` for the caller.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    unconstrained fn set_authorized(message_hash: Field, authorize: bool) {\n        // MACRO CODE START\n        let context: PublicContext = PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 2] =\n                    avm::calldata_copy(1, <Field as Serialize>::N + <bool as Serialize>::N);\n                hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<PublicContext> = Storage::init(context);\n        // MACRO CODE END\n\n        storage.approved_actions.at(avm::sender()).at(message_hash).write(authorize);\n    }\n\n    /// Enables or disables mass rejection of all authwits for the caller. When enabled, all `consume` calls for the\n    /// caller's address will revert regardless of individual approvals.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    unconstrained fn set_reject_all(reject: bool) {\n        // MACRO CODE START\n        let context: PublicContext = PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 1] = avm::calldata_copy(1, <bool as Serialize>::N);\n                hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<PublicContext> = Storage::init(context);\n        // MACRO CODE END\n\n        storage.reject_all.at(avm::sender()).write(reject);\n    }\n\n    /// Consumes (verifies and atomically revokes) an authorization on behalf of `on_behalf_of`.\n    ///\n    /// Called by consumer contracts (e.g. Token) to verify a user has authorized an action. This function:\n    /// 1. Checks that `on_behalf_of` has not enabled `reject_all`.\n    /// 2. Recomputes the `message_hash` from the caller (consumer), chain ID, version, and `inner_hash`, binding the\n    ///    approval to this specific consumer contract.\n    /// 3. Verifies the message was approved and atomically revokes it to prevent replay.\n    ///\n    /// Returns `IS_VALID_SELECTOR` (0x47dacd73) on success instead of a boolean. This follows the EIP-1271 pattern:\n    /// a failed or malformed call would return the default zero value, which is indistinguishable from `false`. By\n    /// requiring a specific magic value, the caller can reliably distinguish a successful validation from a failed\n    /// call. The function also reverts on failure as a first line of defense, making the magic return value a\n    /// defense-in-depth measure against subtle integration bugs on the caller side.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    unconstrained fn consume(on_behalf_of: AztecAddress, inner_hash: Field) -> pub Field {\n        // MACRO CODE START\n        let context: PublicContext = PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 2] =\n                    avm::calldata_copy(1, <AztecAddress as Serialize>::N + <Field as Serialize>::N);\n                hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<PublicContext> = Storage::init(context);\n        // MACRO CODE END\n\n        // reject_all is checked first so it takes precedence over individual approvals.\n        assert_eq(false, storage.reject_all.at(on_behalf_of).read(), \"rejecting all\");\n\n        // The msg_sender here is the consumer contract, not the original user. This binds\n        // the approval to a specific consumer, preventing cross-contract replay.\n        let message_hash = compute_authwit_message_hash(\n            context.maybe_msg_sender().unwrap(),\n            context.chain_id(),\n            context.version(),\n            inner_hash,\n        );\n\n        let authorized = storage.approved_actions.at(on_behalf_of).at(message_hash).read();\n        assert_eq(true, authorized, \"unauthorized\");\n        // Revoke the approval to prevent replay.\n        storage.approved_actions.at(on_behalf_of).at(message_hash).write(false);\n\n        IS_VALID_SELECTOR\n    }\n\n    /// Bridges a private authwit into a public authorization entry.\n    ///\n    /// Allows any party to insert a public approval on behalf of `approver`, provided they present a valid private\n    /// authwit from that approver. Useful when e.g. Alice wants Bob to insert a public authwit for her so they can\n    /// execute a trade - Alice signs a private authwit and Bob calls this function.\n    ///\n    /// This function:\n    /// 1. Verifies the approver's private authwit via `assert_current_call_valid_authwit` (static call + nullifier\n    ///    emission to prevent replay).\n    /// 2. Enqueues a public call to `_set_authorized` to write the approval during the public phase.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n    fn set_authorized_private(\n        inputs: aztec::context::inputs::PrivateContextInputs,\n        approver: AztecAddress,\n        message_hash: Field,\n        authorize: bool,\n    ) -> return_data aztec::protocol::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n        // MACRO CODE START\n        // Note: The macros initially inserted a phase check here, but since there is no phase change in this function\n        // body or in the subsequent enqueued public function call, I have removed that check.\n        assert_compatible_oracle_version();\n\n        let serialized_params: [Field; 3] =\n            [approver.to_field(), message_hash, authorize.to_field()];\n        let args_hash: Field = hash_args(serialized_params);\n        let mut context: PrivateContext = PrivateContext::new(inputs, args_hash);\n\n        // MACRO CODE END\n\n        // The generic parameter `3` is the number of function arguments (approver, message_hash, authorize).\n        assert_current_call_valid_authwit::<3>(&mut context, approver);\n\n        // Enqueue a public call to _set_authorized to write the approval into public storage.\n        {\n            let enqueue_params: [Field; 3] =\n                [approver.to_field(), message_hash, authorize.to_field()];\n            let selector: FunctionSelector = FunctionSelector::from_field(_SET_AUTHORIZED_SELECTOR);\n            let calldata: [Field; 4] = [selector.to_field()].concat(enqueue_params);\n            let calldata_hash: Field = hash_calldata_array(calldata);\n            execution_cache::store(calldata, calldata_hash);\n            context.call_public_function_with_calldata_hash(\n                context.this_address(),\n                calldata_hash,\n                false,\n                false,\n            );\n        }\n\n        // MACRO CODE START\n        context.finish()\n        // MACRO CODE END\n    }\n\n    /// A function that writes an authorization entry for an arbitrary `approver`. Only callable by this contract\n    /// itself (`#[only_self]`), ensuring it is only reachable through the validated `set_authorized_private` flow.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_only_self]\n    unconstrained fn _set_authorized(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        // MACRO CODE START\n        let context: PublicContext = PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 3] = avm::calldata_copy(\n                    1,\n                    (<AztecAddress as Serialize>::N + <Field as Serialize>::N)\n                        + <bool as Serialize>::N,\n                );\n                hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<PublicContext> = Storage::init(context);\n\n        assert(\n            avm::sender() == context.this_address(),\n            \"Function _set_authorized can only be called by the same contract\",\n        );\n        // MACRO CODE END\n\n        storage.approved_actions.at(approver).at(message_hash).write(authorize);\n    }\n\n    /// Returns whether `on_behalf_of` has enabled the `reject_all` flag.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_view]\n    unconstrained fn is_reject_all(on_behalf_of: AztecAddress) -> pub bool {\n        // MACRO CODE START\n        let context: PublicContext = PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 1] =\n                    avm::calldata_copy(1, <AztecAddress as Serialize>::N);\n                hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<PublicContext> = Storage::init(context);\n\n        assert(context.is_static_call(), \"Function is_reject_all can only be called statically\");\n        // MACRO CODE END\n\n        storage.reject_all.at(on_behalf_of).read()\n    }\n\n    /// Returns whether a specific `message_hash` is currently approved for `on_behalf_of`.\n    /// Does NOT check the `reject_all` flag - also check `is_reject_all` for a complete picture.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_view]\n    unconstrained fn is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> pub bool {\n        // MACRO CODE START\n        let context: PublicContext = PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 2] =\n                    avm::calldata_copy(1, <AztecAddress as Serialize>::N + <Field as Serialize>::N);\n                hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<PublicContext> = Storage::init(context);\n\n        assert(context.is_static_call(), \"Function is_consumable can only be called statically\");\n        // MACRO CODE END\n\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n\n    /// Utility version of `is_consumable`\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n    unconstrained fn utility_is_consumable(\n        on_behalf_of: AztecAddress,\n        message_hash: Field,\n    ) -> pub bool {\n        // MACRO CODE START\n        assert_compatible_oracle_version();\n\n        let context: UtilityContext = UtilityContext::new();\n        let storage: Storage<UtilityContext> = Storage::init(context);\n        // MACRO CODE END\n\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n\n    // THE REST OF THE CODE IN THIS CONTRACT WAS ORIGINALLY INJECTED BY THE #[aztec] MACRO.\n\n    global SET_AUTHORIZED_SELECTOR: Field =\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\").to_field() };\n\n    global SET_REJECT_ALL_SELECTOR: Field =\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\").to_field() };\n\n    global CONSUME_SELECTOR: Field =\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\").to_field() };\n\n    global _SET_AUTHORIZED_SELECTOR: Field = comptime {\n        FunctionSelector::from_signature(\"_set_authorized((Field),Field,bool)\").to_field()\n    };\n\n    global IS_REJECT_ALL_SELECTOR: Field =\n        comptime { FunctionSelector::from_signature(\"is_reject_all((Field))\").to_field() };\n\n    global IS_CONSUMABLE_SELECTOR: Field =\n        comptime { FunctionSelector::from_signature(\"is_consumable((Field),Field)\").to_field() };\n\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    pub unconstrained fn public_dispatch(selector: Field) {\n        if selector == SET_AUTHORIZED_SELECTOR {\n            let input_calldata: [Field; 2] =\n                avm::calldata_copy(1, <Field as Serialize>::N + <bool as Serialize>::N);\n            let mut reader: Reader<2> = Reader::new(input_calldata);\n            let arg0: Field = <Field as Deserialize>::stream_deserialize(&mut reader);\n            let arg1: bool = <bool as Deserialize>::stream_deserialize(&mut reader);\n            set_authorized(arg0, arg1);\n            avm::avm_return([].as_vector());\n        };\n        if selector == SET_REJECT_ALL_SELECTOR {\n            let input_calldata: [Field; 1] = avm::calldata_copy(1, <bool as Serialize>::N);\n            let mut reader: Reader<1> = Reader::new(input_calldata);\n            let arg0: bool = <bool as Deserialize>::stream_deserialize(&mut reader);\n            set_reject_all(arg0);\n            avm::avm_return([].as_vector());\n        };\n        if selector == CONSUME_SELECTOR {\n            let input_calldata: [Field; 2] =\n                avm::calldata_copy(1, <AztecAddress as Serialize>::N + <Field as Serialize>::N);\n            let mut reader: Reader<2> = Reader::new(input_calldata);\n            let arg0: AztecAddress = <AztecAddress as Deserialize>::stream_deserialize(&mut reader);\n            let arg1: Field = <Field as Deserialize>::stream_deserialize(&mut reader);\n            let return_value: [Field; 1] = <Field as Serialize>::serialize(consume(arg0, arg1));\n            avm::avm_return(return_value.as_vector());\n        };\n        if selector == _SET_AUTHORIZED_SELECTOR {\n            let input_calldata: [Field; 3] = avm::calldata_copy(\n                1,\n                (<AztecAddress as Serialize>::N + <Field as Serialize>::N) + <bool as Serialize>::N,\n            );\n            let mut reader: Reader<3> = Reader::new(input_calldata);\n            let arg0: AztecAddress = <AztecAddress as Deserialize>::stream_deserialize(&mut reader);\n            let arg1: Field = <Field as Deserialize>::stream_deserialize(&mut reader);\n            let arg2: bool = <bool as Deserialize>::stream_deserialize(&mut reader);\n            _set_authorized(arg0, arg1, arg2);\n            avm::avm_return([].as_vector());\n        };\n        if selector == IS_REJECT_ALL_SELECTOR {\n            let input_calldata: [Field; 1] = avm::calldata_copy(1, <AztecAddress as Serialize>::N);\n            let mut reader: Reader<1> = Reader::new(input_calldata);\n            let arg0: AztecAddress = <AztecAddress as Deserialize>::stream_deserialize(&mut reader);\n            let return_value: [Field; 1] = <bool as Serialize>::serialize(is_reject_all(arg0));\n            avm::avm_return(return_value.as_vector());\n        };\n        if selector == IS_CONSUMABLE_SELECTOR {\n            let input_calldata: [Field; 2] =\n                avm::calldata_copy(1, <AztecAddress as Serialize>::N + <Field as Serialize>::N);\n            let mut reader: Reader<2> = Reader::new(input_calldata);\n            let arg0: AztecAddress = <AztecAddress as Deserialize>::stream_deserialize(&mut reader);\n            let arg1: Field = <Field as Deserialize>::stream_deserialize(&mut reader);\n            let return_value: [Field; 1] =\n                <bool as Serialize>::serialize(is_consumable(arg0, arg1));\n            avm::avm_return(return_value.as_vector());\n        };\n        panic(f\"Unknown selector {selector}\")\n    }\n\n    impl<Context> Storage<Context> {\n        fn init(context: Context) -> Self {\n            Self {\n                reject_all: <Map<AztecAddress, PublicMutable<bool, Context>, Context> as StateVariable<1, Context>>::new(\n                    context,\n                    1,\n                ),\n                approved_actions: <Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context> as StateVariable<1, Context>>::new(\n                    context,\n                    2,\n                ),\n            }\n        }\n    }\n\n    pub struct _set_authorized_parameters {\n        pub _approver: AztecAddress,\n        pub _message_hash: Field,\n        pub _authorize: bool,\n    }\n\n    pub struct consume_parameters {\n        pub _on_behalf_of: AztecAddress,\n        pub _inner_hash: Field,\n    }\n\n    pub struct is_consumable_parameters {\n        pub _on_behalf_of: AztecAddress,\n        pub _message_hash: Field,\n    }\n\n    pub struct is_reject_all_parameters {\n        pub _on_behalf_of: AztecAddress,\n    }\n\n    pub struct set_authorized_parameters {\n        pub _message_hash: Field,\n        pub _authorize: bool,\n    }\n\n    pub struct set_authorized_private_parameters {\n        pub _approver: AztecAddress,\n        pub _message_hash: Field,\n        pub _authorize: bool,\n    }\n\n    pub struct set_reject_all_parameters {\n        pub _reject: bool,\n    }\n\n    pub struct utility_is_consumable_parameters {\n        pub _on_behalf_of: AztecAddress,\n        pub _message_hash: Field,\n    }\n\n    #[abi(functions)]\n    pub struct _set_authorized_abi {\n        parameters: _set_authorized_parameters,\n    }\n\n    #[abi(functions)]\n    pub struct consume_abi {\n        parameters: consume_parameters,\n        return_type: Field,\n    }\n\n    #[abi(functions)]\n    pub struct is_consumable_abi {\n        parameters: is_consumable_parameters,\n        return_type: bool,\n    }\n\n    #[abi(functions)]\n    pub struct is_reject_all_abi {\n        parameters: is_reject_all_parameters,\n        return_type: bool,\n    }\n\n    #[abi(functions)]\n    pub struct set_authorized_abi {\n        parameters: set_authorized_parameters,\n    }\n\n    #[abi(functions)]\n    pub struct set_authorized_private_abi {\n        parameters: set_authorized_private_parameters,\n    }\n\n    #[abi(functions)]\n    pub struct set_reject_all_abi {\n        parameters: set_reject_all_parameters,\n    }\n\n    #[abi(functions)]\n    pub struct utility_is_consumable_abi {\n        parameters: utility_is_consumable_parameters,\n        return_type: bool,\n    }\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/authwit/auth.nr",
      "source": "use crate::context::{gas::GasOpts, PrivateContext, PublicContext};\nuse crate::protocol::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, DOM_SEP__AUTHWIT_INNER, DOM_SEP__AUTHWIT_NULLIFIER,\n        DOM_SEP__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/// Success indicator for authwit - 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\npub global IS_VALID_SELECTOR: Field = 0x47dacd73;\n\n/// Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n///\n/// @param on_behalf_of The address that has allegedly authorized the current call\npub fn assert_current_call_valid_authwit<let N: u32>(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n) {\n    let args_hash: Field = context.get_args_hash();\n\n    let inner_hash = compute_inner_authwit_hash([\n        context.maybe_msg_sender().unwrap().to_field(),\n        context.selector().to_field(),\n        args_hash,\n    ]);\n\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n\n/// Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n///\n/// @param on_behalf_of The address that has allegedly authorized the current call\n/// @param inner_hash The hash of the message to authorize\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier to prevent replay attacks\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/// Assert that `on_behalf_of` has authorized the current call in the authentication registry\n///\n/// @param on_behalf_of The address that has allegedly authorized the current call\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.maybe_msg_sender().unwrap().to_field(),\n        context.selector().to_field(),\n        context.get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n\n/// Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n///\n/// @param on_behalf_of The address that has allegedly authorized the `inner_hash`\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash],\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/// Computes the `inner_hash` of the authentication witness\n///\n/// @param args The arguments to hash\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, DOM_SEP__AUTHWIT_INNER)\n}\n\n/// Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n///\n/// @param on_behalf_of The address that has authorized the `inner_hash`\n/// @param inner_hash The hash of the message to authorize\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        DOM_SEP__AUTHWIT_NULLIFIER,\n    )\n}\n\n/// Computes the `message_hash` for the authentication witness\n///\n/// @param consumer The address of the contract that is consuming the message\n/// @param chain_id The chain id of the chain that the message is being consumed on\n/// @param version The version of the chain that the message is being consumed on\n/// @param inner_hash The hash of the \"inner\" message that is being consumed\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        DOM_SEP__AUTHWIT_OUTER,\n    )\n}\n\n/// Helper function to set the authorization status of a message hash\n///\n/// @param message_hash The hash of the message to authorize\n/// @param authorize True if the message should be authorized, false if it should be revoked\npub unconstrained fn set_authorized(context: PublicContext, message_hash: Field, authorize: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field],\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/// Helper function to reject all authwits\n///\n/// @param reject True if all authwits should be rejected, false otherwise\npub unconstrained fn set_reject_all(context: PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [reject as Field],\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "58": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, NullifierExistenceRequest, ReturnsHash},\n    hash::hash_args,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            is_side_effect_counter_revertible_oracle_wrapper, notify_enqueued_public_function_call,\n            notify_set_min_revertible_side_effect_counter,\n        },\n        execution_cache,\n        logs::notify_created_contract_class_log,\n        nullifiers::notify_created_nullifier,\n    },\n};\nuse crate::protocol::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_TX_LIFETIME, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::{Counted, scoped::Scoped},\n    traits::Empty,\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// Minimal PrivateContext for protocol contracts going to audit.\n/// Contains only the methods actually used by: fee_juice, auth_registry, contract_class_registry, contract_instance_registry\n#[derive(Eq)]\npub struct PrivateContext {\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub expiration_timestamp: u64,\n\n    pub nullifier_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    pub expected_non_revertible_side_effect_counter: u32,\n    pub expected_revertible_side_effect_counter: u32,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            expiration_timestamp: inputs.anchor_block_header.global_variables.timestamp\n            + MAX_TX_LIFETIME,\n            nullifier_read_requests: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call (similar to msg.sender in Solidity).\n    pub fn maybe_msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Returns the contract address of the current function being executed.\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the protocol version.\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Returns the anchor block header.\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Sets the hash of the return values for this private function.\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            expiration_timestamp: self.expiration_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::empty(), // Not used by protocol contracts\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_separators: ClaimedLengthArray::empty(), // Not used by protocol contracts\n            note_hashes: ClaimedLengthArray::empty(), // Not used by protocol contracts\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n            expected_non_revertible_side_effect_counter: self\n                .expected_non_revertible_side_effect_counter,\n            expected_revertible_side_effect_counter: self.expected_revertible_side_effect_counter,\n        }\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx. Used by fee_juice.\n    pub fn end_setup(&mut self) {\n        self.side_effect_counter += 1;\n        self.min_revertible_side_effect_counter = self.next_counter();\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    pub fn in_revertible_phase(&mut self) -> bool {\n        let current_counter = self.side_effect_counter;\n\n        // Safety: Kernel will validate that the claim is correct by validating the expected counters.\n        let is_revertible =\n            unsafe { is_side_effect_counter_revertible_oracle_wrapper(current_counter) };\n\n        if is_revertible {\n            if (self.expected_revertible_side_effect_counter == 0)\n                | (current_counter < self.expected_revertible_side_effect_counter) {\n                self.expected_revertible_side_effect_counter = current_counter;\n            }\n        } else if current_counter > self.expected_non_revertible_side_effect_counter {\n            self.expected_non_revertible_side_effect_counter = current_counter;\n        }\n\n        is_revertible\n    }\n\n    /// Sets a deadline for when this transaction must be included in a block.\n    pub fn set_expiration_timestamp(&mut self, expiration_timestamp: u64) {\n        self.expiration_timestamp = std::cmp::min(self.expiration_timestamp, expiration_timestamp);\n    }\n\n    /// Pushes a new nullifier. Used by class_registry and instance_registry.\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Asserts that a nullifier has been emitted. Used by instance_registry.\n    pub fn assert_nullifier_exists(\n        &mut self,\n        nullifier_existence_request: NullifierExistenceRequest,\n    ) {\n        let nullifier = nullifier_existence_request.nullifier();\n        let contract_address =\n            nullifier_existence_request.maybe_contract_address().unwrap_or(AztecAddress::zero());\n\n        let request = Scoped::new(\n            Counted::new(nullifier, self.next_counter()),\n            contract_address,\n        );\n\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2). Used by fee_juice.\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log. Used by instance_registry.\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    /// Emits a contract class log. Used by class_registry.\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond\n        // length are zero. However, it won't be able to check that we didn't add extra padding (trailing zeroes) or\n        // that we cut trailing zeroes from the end.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter\n        // bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be\n        // constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Makes a read-only call to a private function. Used by auth_registry for authwit.\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function with a calldata hash. Used by fee_juice and auth_registry.\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            expiration_timestamp: 0,\n            nullifier_read_requests: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n}\n"
    },
    "59": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/context/public_context.nr",
      "source": "use crate::{\n    context::gas::GasOpts,\n    hash::{\n        compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n        compute_siloed_nullifier,\n    },\n    oracle::avm,\n};\nuse crate::protocol::{\n    abis::function_selector::FunctionSelector,\n    address::{AztecAddress, EthAddress},\n    constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS},\n    traits::{Empty, FromField, Packable, Serialize, ToField},\n};\n\n/// Minimal PublicContext for protocol contracts going to audit.\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::emit_public_log(Serialize::serialize(log).as_vector()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular leaf_index.\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message tree at a particular leaf index.\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { avm::l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Returns `true` if an `unsiloed_nullifier` has been emitted by `contract_address`.\n    pub fn nullifier_exists_unsafe(\n        _self: Self,\n        unsiloed_nullifier: Field,\n        contract_address: AztecAddress,\n    ) -> bool {\n        let siloed_nullifier = compute_siloed_nullifier(contract_address, unsiloed_nullifier);\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::nullifier_exists(siloed_nullifier) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists_unsafe(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\".\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        avm::call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = avm::success_copy();\n\n        let result_data = avm::returndata_copy(0, avm::returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm::revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        avm::call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = avm::success_copy();\n\n        let result_data = avm::returndata_copy(0, avm::returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm::revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Note Hash Tree.\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Nullifier Tree.\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    pub fn maybe_msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { avm::sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { avm::calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::chain_id()\n        }\n    }\n\n    /// Returns the protocol version.\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::version()\n        }\n    }\n\n    /// Returns the current block number.\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas.\n    pub fn min_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::min_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA gas.\n    pub fn min_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::min_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available.\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA gas available.\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context.\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    pub fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe {\n                avm::storage_read(storage_slot + i as Field, self.this_address().to_field())\n            };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { avm::storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n"
    },
    "60": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args, oracle::execution_cache};\nuse crate::protocol::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args` handles empty arrays following the protocol rules (i.e. an empty args array is signaled with a\n        // zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "61": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse crate::protocol::{abis::block_header::BlockHeader, address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_header: BlockHeader,\n    contract_address: AztecAddress,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self { block_header: default_context.block_header, contract_address }\n    }\n\n    pub fn block_header(self) -> BlockHeader {\n        self.block_header\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_header.global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.block_header.global_variables.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.block_header.global_variables.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.block_header.global_variables.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.block_header, self.this_address(), storage_slot)\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/hash.nr",
      "source": "//! Aztec hash functions.\n\nuse crate::protocol::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        DOM_SEP__FUNCTION_ARGS, DOM_SEP__MESSAGE_NULLIFIER, DOM_SEP__PUBLIC_BYTECODE,\n        DOM_SEP__PUBLIC_CALLDATA, DOM_SEP__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    traits::ToField,\n};\n\npub use crate::protocol::hash::compute_siloed_nullifier;\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], DOM_SEP__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], DOM_SEP__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, DOM_SEP__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, DOM_SEP__PUBLIC_CALLDATA)\n}\n\n/// Computes the public bytecode commitment for a contract class. The commitment is `hash([(length | separator),\n/// ...bytecode])`.\n///\n/// @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n/// packed_bytecode is mutable so that we can avoid copying the array to construct one starting with first_field\n/// instead of length. @returns The public bytecode commitment.\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 = (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode. AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Append it to the separator before hashing.\n    let first_field = DOM_SEP__PUBLIC_BYTECODE.to_field() + (packed_public_bytecode[0] as u64 << 32) as Field;\n    packed_public_bytecode[0] = first_field;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored. +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n"
    },
    "72": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/avm.nr",
      "source": "//! AVM oracles.\n//!\n//! There are only available during public execution. Calling any of them from a private or utility function will\n//! result in runtime errors.\n\nuse crate::protocol::address::{AztecAddress, EthAddress};\n\npub unconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\npub unconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\npub unconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\npub unconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\npub unconstrained fn version() -> Field {\n    version_opcode()\n}\npub unconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\npub unconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\npub unconstrained fn min_fee_per_l2_gas() -> u128 {\n    min_fee_per_l2_gas_opcode()\n}\npub unconstrained fn min_fee_per_da_gas() -> u128 {\n    min_fee_per_da_gas_opcode()\n}\npub unconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\npub unconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\npub unconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\npub unconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\npub unconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\npub unconstrained fn nullifier_exists(siloed_nullifier: Field) -> u1 {\n    nullifier_exists_opcode(siloed_nullifier)\n}\npub unconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\npub unconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\npub unconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\npub unconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\npub unconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n/// `success_copy` is placed immediately after the CALL opcode to get the success value\npub unconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\npub unconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\npub unconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\n/// The additional prefix is to avoid clashing with the `return` Noir keyword.\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n/// This opcode reverts using the exact data given. In general it should only be used to do rethrows, where the revert\n/// data is the same as the original revert data. For normal reverts, use Noir's `assert` which, on top of reverting,\n/// will also add an error selector to the revert data.\npub unconstrained fn revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\npub unconstrained fn storage_read(storage_slot: Field, contract_address: Field) -> Field {\n    storage_read_opcode(storage_slot, contract_address)\n}\n\npub unconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeMinFeePerL2Gas)]\nunconstrained fn min_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeMinFeePerDaGas)]\nunconstrained fn min_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(siloed_nullifier: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitPublicLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take\n// that route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take\n// that route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field, contract_address: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/call_private_function.nr",
      "source": "use crate::protocol::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "75": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/enqueue_public_function_call.nr",
      "source": "use crate::protocol::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to\n    // process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to\n    // process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\npub unconstrained fn is_side_effect_counter_revertible_oracle_wrapper(counter: u32) -> bool {\n    is_side_effect_counter_revertible_oracle(counter)\n}\n\n#[oracle(privateIsSideEffectCounterRevertible)]\nunconstrained fn is_side_effect_counter_revertible_oracle(counter: u32) -> bool {}\n"
    },
    "76": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/execution.nr",
      "source": "use crate::context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "77": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store<let N: u32>(values: [Field; N], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper<let N: u32>(\n    values: [Field; N],\n    hash: Field,\n) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle<let N: u32>(_values: [Field; N], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "81": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/nullifiers.nr",
      "source": "//! Nullifier creation, existence checks, etc.\n\nuse crate::protocol::address::aztec_address::AztecAddress;\n\n/// Notifies the simulator that a nullifier has been created, so that its correct status (pending or settled) can be\n/// determined when reading nullifiers in subsequent private function calls. The first non-revertible nullifier emitted\n/// is also used to compute note nonces.\npub fn notify_created_nullifier(inner_nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle(inner_nullifier) };\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_inner_nullifier: Field) {}\n\n/// Returns true if the nullifier has been emitted in the same transaction, i.e. if [notify_created_nullifier] has been\n/// called for this inner nullifier from the contract with the specified address.\n///\n/// Note that despite sharing pending transaction information with the app, this is not a privacy leak: anyone in the\n/// network can always determine in which transaction a inner nullifier was emitted by a given contract by simply\n/// inspecting transaction effects. What _would_ constitute a leak would be to share the list of inner pending\n/// nullifiers, as that would reveal their preimages.\npub unconstrained fn is_nullifier_pending(\n    inner_nullifier: Field,\n    contract_address: AztecAddress,\n) -> bool {\n    is_nullifier_pending_oracle(inner_nullifier, contract_address)\n}\n\n#[oracle(privateIsNullifierPending)]\nunconstrained fn is_nullifier_pending_oracle(\n    _inner_nullifier: Field,\n    _contract_address: AztecAddress,\n) -> bool {}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before\n/// the current transaction is included in a block. While this might seem of little use at first, certain design\n/// patterns benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n"
    },
    "82": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/storage.nr",
      "source": "use crate::protocol::{\n    abis::block_header::BlockHeader,\n    address::AztecAddress,\n    traits::{Hash, Packable, ToField},\n};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    block_hash: Field,\n    address: Field,\n    storage_slot: Field,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    block_hash_to_read_from: Field,\n    address: AztecAddress,\n    storage_slot: Field,\n) -> [Field; N] {\n    storage_read_oracle(block_hash_to_read_from, address.to_field(), storage_slot, N)\n}\n\npub unconstrained fn storage_read<T>(\n    header_to_read_from: BlockHeader,\n    address: AztecAddress,\n    storage_slot: Field,\n) -> T\nwhere\n    T: Packable,\n{\n    let block_hash_to_read_from = header_to_read_from.hash();\n    T::unpack(\n        raw_storage_read(block_hash_to_read_from, address, storage_slot),\n    )\n}\n"
    },
    "84": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/state_vars/map.nr",
      "source": "use crate::protocol::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::StateVariable;\n\n/// A key-value container for state variables.\n///\n/// A key-value storage container that maps keys to state variables, similar to Solidity mappings.\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity.\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "86": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::protocol::traits::Packable;\nuse crate::state_vars::StateVariable;\n\n/// Mutable public values.\n///\n/// This is one of the most basic public state variables. It is equivalent to a non-`immutable` non-`constant` Solidity\n/// state variable.\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Returns the current value.\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Stores a new value.\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Returns the value at the anchor block.\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    }
  }
}
