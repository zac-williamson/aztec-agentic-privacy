{
  "transpiled": true,
  "noir_version": "1.0.0-beta.18+2db78f8894936db05c53430f364360ac9cc5c61f",
  "name": "FeeJuice",
  "functions": [
    {
      "name": "_increase_public_balance",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_only_self"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "8637882143979902881": {
            "error_kind": "string",
            "string": "Function _increase_public_balance can only be called by the same contract"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "pZnbbhs5DIbfxde5kCiKFPMqRVGkqVsEMJLATRZYBHn3JTWi5HQxQirfZD7TmX94EiXbb4cfx++vv749PP58+n24/fJ2+H5+OJ0efn07Pd3fvTw8Par17RDsTwQ+3KabQ0xwuM125e2KcbMjbdesr9mutF2pvSbZroztWg63MSiUpBANSgOhDSDovZEMqEHMDtIA0MEtyS3JLZgcuEEGB1cmfxbZI0SBgwM6lAYFHLiBuKU6r5CC3g7RIDeIbomlAahjwAZmsbuSpdHeqnmt4BbLbEoG1IDcYsmtYK6mYlAaWHo3UFcRFMxV1NIhqT9IBuohqhtYqIGoMhaDvEG2cFAM0EEaRLdEt4BbLK4K1jYbcAMLcANqkP0ROTu4IGkUWbslC29A1glZ00IQHNySzAIGuYGVOycDbkBusSpvYP+MBvrQrPmhgg6lgaQN2DpzA3U+aw45Rge3VMfYILd/hqbMCR3cgq6M7Vlcfa5ggloCtuJmMZAGVlwKBqWBNEsxDzegBtEtVqYKViaKBtIguSWZoKauVMfEgBtUxyq4xfpwA2pQs1rBlDW9xZJJml4J4EANbF1skB3sLs2h2ALZoDRIbkluQbegW7I9S1Mn1jbEBuoqaQ6FoUGxbIiBPpQ1GyLBwUZUNJANYgjYqdsiOwF06jbrvY3QdKFSdsrdZr5yqiTb82MwtxsVJ+42ZicbQ41s2qKRrdxG9jQb0dHWbqNui6lTcYJuS7GTKZORLdhG3Vbj4Eq5PTfWOCoRduq2GsdGxanGUSqxU41DKlGjuh80EicbPo26rVahko2dEiqxE3abxVGsRlB3rVIpO9l4bDRs4lT3sY2KU48DehxgcZRUKTeqW0OjbovdFrsNug3MU+uXZMOtwPv7zcE36W8v5+PR9uiLXVv38ue78/Hx5XD7+Ho63Rz+uTu91n/6/Xz3WK8vd2d9V/NwfPyhVxX8+XA6Gr3fjLvD/q1MhdrdzHEIZPigEPcVCG21VwVC5q5AH32AfYVku0MVSIT9fk6f90DAPciIex7gzIPcBFBXw0jCWhZlL4s0U0hdgPr9CJ/2QDeoLoB5z4MyyaKe3TyLEGAvi7KvAOwCILt1/GwWkfdimCnoxuQKAnG3myfNqAPFE2mrvUuUj80Q0yQPxRdkkjJqGfmjwqQfRed0k5DIoyFTKR818qSeIXlLUcDRU+kvvCi+sgUusvk/L3hfo+idTaMIyb7GpDNThp7P0RUg8vmiRvERo+Oa9ooKk9bKZWRzFKTwUmum3UELkyjETvVbORj2XIBJY+rRJvsKs2PO/rDGmUiI3EVC2p23kK8eNkBXTptZICIMIw4su05MWxO9LVKeuDEvCl4URXaTkSbdFXVxuYbENIaOlmepQWmvQdOkQaGvshQvxoV83oWM3QVOuy7g1eM75WvHd6Lrx3fia8f3Z5NZ9pMps7EZejL1SLs3cnDWmKEk7N1dJqezyQEvaiyuUULZ7e65I9pSw5GLQ9qfjkzXaqYxM3SI7YrMDpvEnpHEMS8clKKEMFZ73t0S5wOj74gCsiQhYzORzGsSHLtEgRUJ/VrRJSAwLklg8Fzo58o1LzANCQpLEjn0QDLQmkQOXSLHNQnEIQGLXlCX4HK1F6sSvcH1a+GlBgdC6BJ5rahEvSL6neSaRJ/jQCVcHciahH7z3A86+jXgosQ4x4eloiZJsUvQfjppsr3j2EywpNHh8S+86IctRV4LRMYhQ9YaPPZNQHFtsQfBIbG22GPsraXf6C0GQkPi+kAWJeKY4BF5TSJzlyBZlOibwOXJcTWQVYn+6Uy/kF3bimAUFWJZlAhDQq4NZFVifKAAuDhG/ylRYG3kfNVXd/cP5w8/176b1vnh7vvp2F7+fH28v3j35d9nf8d/7n0+P90ff7yej6Y0fvPVP19AT1kg4av9oKAvdZJzsRfR3tNZqVvT13dz5T8="
    },
    {
      "name": "balance_of_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15860392472534760515": {
            "error_kind": "string",
            "string": "Function balance_of_public can only be called statically"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABEYlAAAARScCAgQBJwIDBAAfCgACAAMARC0IRAElAAAARi0CAUUnAgIERScCAwQBOw4AAwACJiUAAAFAHgIAAgknAgMBASQCAAIAAABiJQAAAWYpAgACAO9SU00nAgMAASsCAAQAAAAAAAAAAAMAAAAAAAAAAC0IAQUnAgYEBQAIAQYBJwMFBAEAIgUCBi0KBgctDgIHACIHAgctDgMHACIHAgctDgEHACIHAgctDgQHLQsFAQAiAQIBLQ4BBS0IAQEnAgIEBQAIAQIBJwMBBAEAIgUCAgAiAQIDPw8AAgADJwICBAEAKgECBC0LBAMnAgEAAAoqAwECJwIBAQAKKgIBBCQCAAQAAAEfJQAAAXgeAgABAC8qAAMAAQACHAoCAwYcCgMBABwKAQIGLQoCASYoAAAEBHhGDAAABAMkAAADAAABZSoBAAEF2sX11rRKMm08BAIBJioBAAEF3Btu6/u2vEM8BAIBJioBAAEFursh14IzGGQ8BAIBJg==",
      "debug_symbols": "nZbdbvIwDIbvJcc9SJxfcysTQgXKVKkqqINP+oR673O6OKWTEk2ckDdO+9SOHZOnOHfHx+ehHy/XL7H7eIrj1A9D/3kYrqf23l9Hsj6FjD/eip1uRKCJocEuA+qfIYidUo1Q0iehIAmtWfCS4SXDFssWyxanWNgkvGRhWGASgT8R2A1kILofAVKxiEAdBSahDAu2AFuALZotJrphorBJWLbY+IyLApNwbHFs8WwJwIJCBiARfQbiaElAcFHYJNRimedGcFoO96nrYlZe8kTZu7VTN97FbnwMQyP+tcNjeejr1o7LeG8nWpWN6MYzjQS89EMX1dysb8vyq0oqadLrpMkpRljYMFSZgS4GtSDQGZ8JbusF1LwI2QkquUzw+t04QimOKgNMyAxwvsSwFQbVESMAbSYEuyG4MgECp1PjGoVRfgPwlXSovJkIoDJCh7BBhDIiYKzgBRHQYRGBZYS2kMNYNxIQt1VVSQfQ8U8IOsnuPcaaDoCgy4xKcRqPzDBBQ2aov7uhEdekvmT1txu1wlKIXFhaulJhqQrCBp0ITq6tIvg3z4fHYq+oVafxXJweSk6oUPXCuhcviv1GYQ0ilc8QqU2xaVX2w60F6kBCEVFpneBziaMptb1aIEi7uMZhQtEJXTuqhgtD24ob9aSYl6RgeTNqJU69hhmo1sNqKD3znqbtqZ82F5k5wqa+PQ5dml4e4+ll9f7/xit8EbpN11N3fkxdJK23ofiX/OFU49w+3nZo4mXjYT/HT38D"
    },
    {
      "name": "check_balance",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public",
        "abi_view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "fee_limit",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "1080336462466469436": {
            "error_kind": "string",
            "string": "Function check_balance can only be called statically"
          },
          "9543832133280402246": {
            "error_kind": "string",
            "string": "Balance too low"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUlAAAARicCAgQBJwIDBAAfCgACAAMARBwAREQGLQhEASUAAABsJwIBBEUnAgIEADsOAAIAASwAAEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAmJQAAAaceAgACCScCAwEBJAIAAgAAAIglAAABzR4CAAIBCiICQwMWCgMEHAoEBQAEKgUCBCcCAgEACioDAgUkAgAFAAAAuycCBgQAPAYGASkCAAMA71JTTScCBQABKwIABgAAAAAAAAAAAwAAAAAAAAAALQgBBycCCAQFAAgBCAEnAwcEAQAiBwIILQoICS0OAwkAIgkCCS0OBQkAIgkCCS0OBAkAIgkCCS0OBgktCwcDACIDAgMtDgMHLQgBAycCBAQFAAgBBAEnAwMEAQAiBwIEACIDAgU/DwAEAAUnAgQEAQAqAwQGLQsGBScCAwAACioFAwQKKgQCAyQCAAMAAAFzJQAAAd8eAgADAC8qAAUAAwAEHAoEBQYcCgUDABwKAwQGDCoEAQMKKgMCASQCAAEAAAGmJQAAAfEmKAAABAR4RQwAAAQDJAAAAwAAAcwqAQABBdrF9da0SjJtPAQCASYqAQABBQ7+IEnrN048PAQCASYqAQABBbq7IdeCMxhkPAQCASYqAQABBYRygMKEIwtGPAQCASY=",
      "debug_symbols": "nZZLbuMwDIbv4nUWEqkHmasUReGmbmHAcAI3GWBQ5O5D1aIfM5DQySb8TcVfKIpk9NW8da+3j5d+fD9/Nsenr+Z16oeh/3gZzqf22p9H8X41Jn1Yi80RD2KpOTqxgLNFm21ojlGsk2dONszWm9nv/WyDPFubhM8iqidSFoQqoggSwWEWYGwWACp0CXUJ1ePU49STopmFU8FZBFRBWUT9iZjDAFIg+SxYgSxAMEnQLNCgCvVY9Vj1gHpAwgDZMqJToR6XvoNJUBZePV49IWQRJULgJMSD6XUSIKYl4ixYPZw8cnjOOBXqsTGJ+/3QaC28XKeuS6WwKQ4pmUs7deO1OY63YTg0v9rh9v2lz0s7fttrO8mqbLEb38QK8L0fuqTuh/VtU36V2If8NnGkBeBhR7BlAgdQAgcXF0LYxwBlgjXkMsFasxIiPrQLMqVdVAhsrcbAFot58GVCcEEJkoZiHkKZgI4zAIMrZaEaAYNG4J0rRUC1CHwGOBktaxIeyuKmFv6upgoiBsyEGMMCcD8/SMNrCBaLIdTqEZY0WGC/IGifB4tlBJD2JPJaTNL3e4KrpXJpCgawCwOJ9gxfawuApS0Clxm1ovSw7GQ9UGDeE2IlF5YoI0D+ah5jrEcCQFhmcJnhIi/VTQgLw/48DJnp67luDvafMGrVZVnb3KIJpeqCCsKT9kgwa5dSfKhHvC/1CNTK00UlRCiFAL429GGZ2aLLAxNCDWJsXCAGizMPKoca1voMYKCIqMxNiEuFc3Fy1zbCksV1H45KQaCpdarTskBfCaN+KG5zKFxMBtYKXGaNMngzgd33jef/CzTu/8+f5ak99dPuGn1PrKlvX4cuP77fxtNm9fr7oit6Db9M51P3dpu6RNrcxeXzKbpD5Od0IZcH6Tbyz/f0038A"
    },
    {
      "name": "claim",
      "is_unconstrained": false,
      "custom_attributes": [
        "abi_private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "expiration_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_separators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_separator::KeyValidationRequestAndSeparator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "key_type_domain_separator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log",
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 16,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "6609888949476313245": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "11019205087382408538": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 4 limbs"
          },
          "12370419938245003393": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 36 limbs"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15835548349546956319": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 32 limbs"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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0rVncGw5d+nanLt0bc5dujbnLl2bc5euzblL1+bcpWtz7tK1OXfp2py7dG3SL7xy7tK1OXfp2py7dG3OXbo25y5dm3OXrs25S9fm3KVrc+7StTl36dqcu3Rtzl26NucuXZtzl67NuUvX5tyla3Pu0rU5d+nanLt0bc5duvZKji3nLl2bc5euzblL1+bcpWtz7tK1OXfp2py7dG3OXbo25y5dm3OXrs25S9fm3KVrc+7StTl36dqcu3Rtzl26NucuXZtzl67NuUvX5tyla3Pu0rU5d+nanLt07QMcW85dujbnLl2bc5euzblL1+bcpWtz7tK1OXfp2ic4tpy7dG3OXbo25y5dm3OXrs25S9fm3KVrc+7StTl36dqcu3Rtzl26NucuXZtzl67NuUvXw7lL18O5S9fDuUvXw7lL18O5S9fDuUvXw7lL18O5S9fDuUvXw7lL18O5S9fDuUvXw7lL18O5S9fDuUvXk8SxzcOxzcuxzcex5dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6ynHseXcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+t5hGPLuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1lObY8u5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9aTyrHl3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+vh3H/r4dx/6+Hcf+uB7r+t3qRVm9ROVVq3aN+r1mZP09I33nTzLbfeVqZsudvvuPOuu++5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",
      "debug_symbols": "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/O23Qv+2E3efyfp5o3Hb8Pn1wrtOra9w6m/sy5tbPT38/Xequvvh/bdf/r35XPbyo4BiXO9TMd98F3NM6x+ff/ruLz/8/Mtn6Z3PPTsev1aHro6Ht+3tXNvjMVrH3aPjKVrn1vbWj6/pv12PZer7uUy5H8yU68lMxw208/l5bT2b6diez887H9S1t7a3vrext31vc293Pd/1fNeLXS92vdj1YteLXS92vdj1YteLXS92vb7r9V2v73p91+u7Xt/1+q7Xd72+6/VdL3e93PVy1zue1XX88PjxqK5z2/f2qPe0yPGcrnM79naubT32tq1/fzzG69zueufj4I6/73u769WuV7te7Xpj1xu73tj1xq439v6NvX9j1xu73tj1xq43d73jKV7n1vbW93bv39z1jsfDndva27G3c23bYxdsj6ZgCq4QCl0hFUphKKjy8RDAFZqCKbiCKjdVbqrcVLmpcttzsB46GXrqZOixk6HnTroePOl68qTr0ZOuZ0+6Hj4Zevpk6PGToedPhh5AGXoCZexHUK6gfXbts6uyDwXNRmg2QrMRqhyqHKocqhyqHJqN0D6H9rlrn7sqd81z12x0zUbXbHRV7qrcVbmrcqpyajZS+5za59Q+q8Naap5Ts5GajdRsqM1aqXKpcqmyWq2p15qaranbmtrtfKTmWXlontVxTS3X1HPnIzXPVw1VVts19V1T4zV1XlPrNfVeU/Odj908K0/Ns/qvqQGbOvB87OZ61a5s6kFTD5p60NSDph409aCpB88HcR6VzwdxrrBnw9SDph60pspNldWDph409aCpB009aOpBUw+eD+s8K5spuEIodAVVNlVWD5p60NSDph409aCpB009eD6+86zsqaDZUA+aetBClUOV1YOmHjT1oKkHTT1o6kFTD1qoctc8qwdNPWjqQeuq3FVZPWjqQVMPmnrQ1IOmHjT1oOk9zvQmZ+pBUw+aetD0Rmd6pzP1oKkHTT1o6kFTD5p60NSD6wGorieguh6B6noGqushqK6noIYegxp6DmroQaihJ6GGHoUaehZq6GGosZ+GuoIqT82zetDUg6YePJ+Rul6lyupBUw+6etDVg64edPWgqwfPh6kelf2RCqUwFPZseFPlpsrqQVcPunrQ1YOuHnT1oKsHz2ewnpXtodAUTMEVVNlUWT3o6kFXD7p60NWDrh509aC7Knso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4rjEuS5Z616P325ia93r+Tz2te51xyB2YhKLOIhTca173bERjejEIHZiEos4iNAatAatQWvQGrQGrUFr0Bq0Bs2gGTSDZtAMmkEzaAbtdMl67u/pkhVPl+x40uKMRnRiEDsxqVBEaKdL1r89XbIjtIAW0AJaQAtoAS2gBWPrjK1D69A6tA6tQztdsmMRB5GxJbTTJTsa0YlBhJbQElpCS2jFTBZjK8ZWjK2gnS7ZkZksZrKYyYI2oA1oA9qANpjJwdgGYxuMbUAbHLfJTE5mcjKTE9qENqFNaBPaZCbnNba17nXHRrxoa93rjkHsxCQWFQYRWoPWoDUjOjGInQitFXEQr5lc6153hGbQDJpBM2iWRMZmjM0YGy5Z6153ZCadmXRmEpesda87QnNouKTjko5LOi7puGSte91PHee44ZKOSzouWeteV4UODZd0XNJxScclHZd0XNJxyVr3umid44ZLOi7puGSte10VEhou6bik45KOSzou6bik45K17nXRiuOGSzou6bhkrXvdFaDhko5LOi7puKTjko5LOi5Z614XbXDccEnHJR2XrHWvq8KEhks6Lum4pOOSjks6Lum4ZK17PWlr3euORnRiEDsVkljEQYSGSxKXJC5JXLLWvS5a68QkFnEQoRk0XJK4JHFJ4pLEJYlLEpck1yXJdUniksQliUuS65LkuiRxSeKSxCWJSxKXJC5JXLLWvS5acNxwSeKSxCVr3euuAA2XJC5JXJK4JHFJ4pLEJWvd66J1jhsuSVySuGSte10VEhouSVySuCRxSeKSxCWJS9a610UrjhsuSVySuGSte90VoOGSxCWJSxKXJC5JXJK4ZK17XbTBccMliUsSl6x1r6vChIZLEpckLklckrgkcUnikrXuddHmddwKlxQuKVyy1r2eFda61x07MYlFHMRrbIVLCpesda+L1pwYxE5MIrQGDZcULilcUrikcEnhksIla93rolkRB5GZxCXFZ5ziM07hksIlhUsKlxQuKVxSuGSte1204LjhksIlhUuKzzhr3euO0HBJ4ZLCJYVLCpcULlnrXhetc9xwSeGSwiXFZ5y17nVHaLikcEnhksIlhUsKl6x1r4uWHDdcUrikcEnxGWete90RGi4pXFK4pHBJ4ZLCJWvd66INjhsuKVxSuKT4jLPWve4IDZcULilcUrikcEnhkrXuddEmxw2XFC4ZuGTwGWete93RiUHsxCQWcRCvsa11r4vWGtGITgwitAYNlwxcMnDJwCUDlwxcMnDJWve6aNaJSSziIELDJYPrksF1ycAlg884a93rjtBwycAlA5cMrkvWutfjNyzYWvd6/KIAW+tedwxiJyaxiIM4r7hcsmIjQuvQOrQOrUPr0Dq0Di2hJbSEltASWkJLaAktoSW0glbQClpBK2gFraAVtNMlxzM1ba17XfF0yY4H7Xigpq11rzs6MYidmFQoIrTTJevfni7ZEdqENqFNaBPahDahTWjzGtta97rjRVvrXnd0YhA7MYlFHMRrbGvd66KdLtnRiE4MIrQGrUFr0Bo0exAZmzE2Y2wG7XTJjkks4iBCc2gOzaE5NGcmnbE5Y3PG5tCc4xbMZDCTwUwGtIAW0AJaQAtmMhhbZ2ydsXVonePWmcnOTHZmskPr0Dq0hJbQkplMxpaMLRlbQkuOWzKTyUwWM1nQClpBK2gFrZjJYmzF2Iqx4ZK17nVHZnIwk4OZxCVr3euO0AY0XDJxycQlE5dMXLLWvS7a5LjhkolLJi5Z616PCr7Wve7YiEZ0YhA7MYlFFM3XutcVL5f443KJPy6X+Fr3uio0aA1ag9agXS7xR2NsxtiMsRk0c2IQOzGJ0AyaQXNoDs2ZSWdszticsTk0LyIz6cxkMJMBLaAFtIAW0IKZDMYWjC0YW4fWOW6dmezMZGcmO7QOrUPr0Dq0ZCaTsSVjS8aW0JLjlsxkMpPJTCa0glbQClpBK2ayGFsxtmJsBa04boOZHMzkYCYHtAFtQBvQBrTBTA7GNhnbZGwT2uS4TWZyMpOTmZzQJjRc0nBJwyUNlzRc0nBJwyVr3etJW+tedxzEayYbLlnrXleFBg2XNFzScEnDJQ2XNFzScMla97po1ohGdGIQoRk0XNJwScMlDZc0XNJwScMla93ronknMpO4pOGSte51VQhouKThkoZLGi5puKThkoZL1rrXRQuOGy5puKThktahdWi4pOGShksaLmm4pOGShktaQkuOGy5puKThkrXudVeAhksaLmm4pOGShksaLmm4ZK17XbTiuOGShksaLmkD2oCGSxouabik4ZKGSxouabhkrXtdtMlxwyUNlzRc0ia0CQ2XNFzScInhEsMlhksMl6x1rydtrXvdMYlFHERoDRouMVxiuMRwieESwyWGS9a610Vr13EzXGK4xHCJGTSDhksMlxguMVxiuMRwieGSte510dyJzCQuMVxiDs2h4RLDJYZLDJcYLjFcYrhkrXtdtOC44RLDJYZLrEPr0HCJ4RLDJYZLDJcYLjFcsta9Llpy3HCJ4RLDJZbQEhouMVxiuMRwieESwyWGS9a610UrjhsuMVxiuMQKGi4xrkuM6xLDJTagDWgDGi4xXGK4xLguWetej99y4mvda9YZnRjETkxiEQdxKq51rzs2ohGdGMROTGIRBxFag9agNWgNWoPWoDVoDVqD1qAZNINm0AyaQTNoBs2gLZfMM84rLpeseNDqcUYjOjGInZhUKCK00yXr354u2RFaQAtoAS2gBbSAFtCCsXXG1qF1aB1ah9ahnS7ZsYiDyNgS2nLJikZ0YhChJbSEltASWjGTxdiKsRVjK2jLJSsyk8VMFjNZ0Aa0AW1AG9AGMzkY22Bsg7ENaIPjNpnJyUxOZnJCm9AmtAltQpvM5LzGtta97tiIF22te90xiJ2YxKLCIEJr0Bq0ZkQnBrETobUiDuI1k2vd647QDJpBM2gGzZLI2IyxGWPDJWvd647MpDOTzkzikrXudUdoDg2XBC4JXBK4JHDJWve6aMFxwyWBSwKXrHWvq0KHhksClwQuCVwSuCRwSeCSte510TrHDZcELglcsta9rgoJDZcELglcErgkcEngksAla93rohXHDZcELglcsta97grQcEngksAlgUsClwQuCVyy1r0u2uC44ZLAJYFL1rrXVWFCwyWBSwKXBC4JXBK4JHDJWvd60ta61x2N6MQgdioksYiDCA2XdFzScUnHJWvd66K1TkxiEQcRmkHDJR2XdFzScUnHJR2XdFzSuS7pXJd0XNJxScclneuSznVJxyUdl3Rc0nFJxyUdl3Rcsta9Llpw3HBJxyUdl6x1r7sCNFzScUnHJR2XdFzScUnHJWvd66J1jhsu6bik45K17nVVSGi4pOOSjks6Lum4pOOSjkvWutdFK44bLum4pOOSte51V4CGSzou6bik45KOSzou6bhkrXtdtMFxwyUdl3Rcsta9rgoTGi7puKTjko5LOi7puKTjkrXuddHmddwSlyQuSVyy1r2eFda61x07MYlFHMRrbIlLEpesda+L1pwYxE5MIrQGDZckLklckrgkcUniksQla93rolkRB5GZxCXJZ5zkM07iksQliUsSlyQuSVySuGSte1204LjhksQliUuSzzhr3euO0HBJ4pLEJYlLEpckLlnrXhetc9xwSeKSxCXJZ5y17nVHaLgkcUniksQliUsSl6x1r4uWHDdckrgkcUnyGWete90RGi5JXJK4JHFJ4pLEJWvd66INjhsuSVySuCT5jLPWve4IDZckLklckrgkcUnikrXuddEmxw2XJC4pXFJ8xlnrXnd0YhA7MYlFHMRrbGvd66K1RjSiE4MIrUHDJYVLCpcULilcUrikcMla97po1olJLOIgQsMlxXVJcV1SuKT4jLPWve4IDZcULilcUlyXrHWvZWc8x3ZWWJ9xVgxiJyaxiIM4r7hcsuJBG+2MRnRiEDsxiUUcxHnF0yU7QktoCS2hJbSEdrrk+O25vta97sjYirGtzzgrMpPFTBYzWcxkMZPFTBYzWdAGtAFtQBvQBrQBbTC2wUwOZnIwk5OZnMzkZCYnMzmZyclMTmgT2oQ2L9pa97pjI5pmfa17PUex1r3u2IlJLOIgXjO51r3u2IhGhNagNWgNWoPWoDVoxtiMsZkRnRjETkxiEQeRmXRoDs2hOTSH5tBOl6xZP10yxhkHcV7xdMmOjWhEJwaxEw/a8eunfa173XEQ5xVPl+zYiEZ0YhA7EVqH1qF1aAktoR0ued5gPKMT44h1xk5MYhEHcV7xcIliIxrRidAKWkEraAWtoA1oA9qANqANaAPagDagDWgD2oQ2oU1oE9qENqFNaBPahDYv2rnuVbERjejEIHZiEos4iNAatAbtcMnzru0ZD5r1MwaxE5NYxEGcVzxcotiIRoRm0AyaQTNoBs2gOTSH5tAcmkNzaA7NoTk0hxbQAlpAC2gBLaAFtIAW0AJah3a45HlP+4xGdGIQOzGJRRzEecXDJYrQElpCS2gJLaEltISW0ApaQStoBa2gFbSCVtAKWkEb0Aa0AW1AG9AGtAFtQBvQBrQJbUKb0Ca0CW1Cm9AmtAltihbnulfFRjSiE4PYiUks4iBCa9AatAatQWvQGrQGrUFr0Bo0g2bQDJpBM2gGzaAZNINm0ByaQ3NoDs2hOTSH5tAcmkMLaAEtoAW0gBbQAlpAC2gBrUPr0Dq0Dq1D69A6tA6tQ+vQElpCS2gJLaEltISW0BJaQitoBa2gFbSCVtAKWkEraAVtQBvQBrQBbUAb0Aa0AW1AG9AmtAltQpvQJrQJbUKb0CY0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZc0XNJwScMlDZe05ZI840GL9X+dGMROPGgxz3jQjqdKxbnuVfGg5RlPl+zYiEY8aNnPGMSDluOMB63Wvy3iQSv/17ff/O93P//w3Z9//P5/vvnDP59//K9//PSXv//w15/2H//+//6mv/nzzz/8+OMP//2nv/381798/5//+Pn7P/34178cf/fN4/jPcT7/R8tvrf3x+Y/b/v//Yb2+tco/Pt+3j79/9G+fp/DzT+c/N5/fPifl+GM7/hjjW+uP4/Wm1z+P9Lfhtl9/DPo5Ar3+eQn37fMNWq9/Ov/5xzxe78frj1f48XL9++f8xzz+Ov59j7te8bzm9GsP4/Ft9OOv83rF81ODPRn/+tcf//X/AQ==",
      "verification_key": "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"
    },
    {
      "name": "claim_and_end_setup",
      "is_unconstrained": false,
      "custom_attributes": [
        "abi_private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "expiration_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_non_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "expected_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::scoped::Scoped",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::side_effect::counted::Counted",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_separators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_separator::KeyValidationRequestAndSeparator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "key_type_domain_separator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log",
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 16,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::claimed_length_array::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "6609888949476313245": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "11019205087382408538": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 4 limbs"
          },
          "12370419938245003393": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 36 limbs"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15835548349546956319": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 32 limbs"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+z9B5xURdf1DXNODz1MoIeooCKjEo2AOYuCJAmiiAGFIaMkB1AwggkMwPQQJeecM4KYA9hFzjkjOZtQ/KqB5hxmprvWFLXuy+d7+/697++pa1ysXbVr1/53n+6p8aT7+81s1DKlRav6Ka0b128i//92Tdp3aCvylt2cf3aXaY+2TGn0yqNtOj7eoXWjx1Jatuwyunb5GpUqpncZW7dF+9ZN2rWzkwGRxwJEeRGn/I8AoisCnQHVlZDqGmRWRRDRtYioKCJKhmZ+HaS6HlLdAKmKIZMvIa0mPpraomXLFs2Cgt450tJ6paV9n5wj8v9ZXSaUb9euSWr755uktumV5k//PrlM4xqpO8oOKz2vVsU5Xbo8+2Kp23+t3Gl+W/9jO073Oib/ifD0jGy75pZdr+jYhp9tztAgi0zMqtWmXZMWjdu0LlerSWqrDu1T2rdo0zq998XMyOleHBd38uX672m9hccvPOnC00t4el86817p6hSWBDQyApSDPkqrHNmfYClogunQBPsCE9TZpD6ucV/XuJdr3FtuVD/h6S88nwvPgEvzkA6ssRi0woHAoVEfSOmTnP0Z5odmOEhhZD3ZGZrhoEcu7Rm5enUZ81SL1s1aNjl/ZFWzLQ7UwkVDdS9KzobYyuHvMrp8ampKp805koVnsPAMEZ6hwjNMeIYLzwjhGSk8o4RntPCMEZ6xwjNOeMYLzwThmSg8k4RnsvBMEZ6pwjNNeKYLzwzhmSk8s4RntvDMEZ65wjNPeOYLzxfCs0B4FmKNFMn44FyQbAgmG4rJhmGy4ZhsBCYbiclGYbLRmGwMJhuLycZhsvGYbAImm4jJJmGyyZhsCiabismmYbLpmGwGJpuJyWZhstmYbA4mm4vJ5mGy+ZjsC0y2AJMtzHUpzHqHB1XaBVDJlxSjw6ra+B3VmHCqeW1dqrEIGpNWZ/f1U4aFzM7CVgaffomqwpysVTPcqpoVw6hmQgtZn92FbM5RBEE29AJjsEJ19N9/5UKGKFXB5Q5Vqc4lZVhkVfr51A2PqDp1IcEjIqm2h7ZhZATVoxc3a1QYVcdLtnRc1qpKl278+CxV+zKUx4SsVOUyFtHELFQlM5XapMyqepkLcnImVd0synZKRlXnrIp7agZV5yyPwDSXam6tcAdllqMqNS+savZF1dDS4VVzQqoywyKo5l5QbS8bSTXvvOrVHRFV88+pqqdGVn0RVDWqoVAtkKrbGqtUC5G3eUmrIRXSfi557xDnz957BzldZY9Zcc6zVduWTYTny+w/zfD3gqYhvdPV/W5FUIb4LVI3WL1ZLvJDs1yU3Z2LT9fYOYVoebbeyqU72/yVM/za3NuurzDZ17my/2zl/LFTw/IrCLxfA5nNfvEskuGxx09f8Y/9AmW2BruO/TesYy/f138DHPvBQRni9y3l2MtZfuuHZvkt/9gvUIoG6R7775zh9+aO/XeY7HutY78AOvbfQcfueyCzmZ4lqm2x4D9onC+1q+w536ZjwIRm+WM23w9h5+sHaew3Fv8yO+MXyoKa6eqMP7E6o3zo+RPQGWcGZYjfz5TOKGf5sx+a5c8alQPV948m63txdt/vYy3gZ0i1BCiky4THF0rRDF14/OIMA+bg8QsmC2jB4wsIHr9AmxcAMqtROVhwQWlBi2VJYm15KQULQhpz4oPJXwqpllGSH+psQA+EVMuz21yyT875ytPU00XOFSxyyk8MVwDk7BmUIX4rKeSUs1zph2a5kkLOZbIkTJ6CVdn9kgsWfCWkWs0n53ylqIcuOdc4w7XmyLkGk63VIud8iJxroM1bC2RWo3Kw4OsoLWiVLEmMXOsp5FwnjTnxweSvh1QbKMkPdTa1EutsG/nvOecpT1Oyi5ybWOScJ70BciYHZYjfZgo55Sw3+6FZbqaQc4MsCZOnYAuHnJsh1VY+OecpRUV1ybnNGW43R85tmGy7FjnnQeTcBm3ediCzGpWDBd9BaUFbZEli5NpJIecOacyJDyZ/J6TaRUl+qLOplVhn280n51zlaVruIuceFjnnSm+AnMuDMsRvL4WccpZ7/dAs91LIuUuWhMlTsI9Dzr2Q6lc+OecqRct0ybnfGR4wR879mOyAFjnnQuTcD23eASCzGpWDBT9IaUH7ZEli5DpEIedBacyJDyb/EKQ6TEl+qLOplVhnO8In5xzlaUpxkfMoi5xzpDdAzpSgDPE7RiGnnOUxPzTLYxRyHpYlYfIUHOeQ8xikOsEn5xylqIEuOU86w1PmyHkSk53SIucciJwnoc07BWRWo3Kw4KcpLei4LEmMXL9RyHlaGnPig8n/DVL9Tkl+qLOplVhn+4NPztnK07TeRc4/WeScLb0Bcq4PyhC/vyjklLP8yw/N8i8KOX+XJWHyFJzhkPMvSPU3n5yzlaJ1uuT8xxmeNUfOfzDZWS1yzobI+Q+0eWeBzGpUDhb8X0oLOiNLEiJXTA4KOf+Vxpz4WPJjckAqi5L8UGdTK6HOFmPzyTlLeZqqOOSM8bDIOUt6A+SsEpQBfjExFHLKWcb4oVnGMMgZIxdmmzwFOSnkjImBVF4+OWcpRZU1yRkT6wxzGSNnTCwmy6VFzlkIOWNioc3LBWRWo3Kw4HGMFhSTU5YkRq54Bjlj4qQxJz6Y/HhIlUBJfqizqZVYZ0vkk3Om8jRNd5EzN4ucM6U3QM7pQRmSXx+FnHKWPj80Sx+FnAmyJEyegiQOOX2QKg+fnDOVomm65MzrDPOZI2deTJZPi5wzIXLmhTYvH5BZjcrBguenNO8kWZIYuQpQyJlfGnPig8kvAKkKUpIf6mxqJdbZruCTc4byNC10kfNKFjlnSG+AnAuDMiS/hSjklLMs5IdmWYhCzoKyJEyegsIcchaCVFfxyTlDKVqgS86rneE15sh5NSa7RoucMyByXg1t3jVAZjUqBwtehNK8C8uSxMh1LYWcRaQxJz6Y/GshVVFK8kOdTa3EOlsyn5zTlaepmouc17HIKd+mXQeQs1pQhuT3ego55Syv90OzvJ5CzqKyJEyeghs45LweUhXjk3O6UlRVl5zFnWEJc+QsjslKaJFzOkRO6NrKmBJAZjUqBwtektK8b5AliZGrFIWcJaUxJz6Y/FKQqjQl+aHOplZine1GPjmnKU9TZxc5b2KRc5r0BsjZOShD8nszhZxyljf7oVneTCFnaVkSJk/BLRxy3gypbuWTc5pS9K4uOW9zhmXMkfM2TFZGi5zTIHLeBm1eGSCzGpWDBS9Lad63yJLEyFWOQs6y0pgTH0x+OUh1OyX5oc6mVmKd7Q4+Oadmi5x3ssg5VXpj5LwTyu9dFHLKWd6FkfMuCjlvlyVh8hTczSHnXZDqHj45p/LIea8zvM8cOe/FZPdpkXMqRM57oc27j0NOLPj9lOZ9tyxJjFwPUMh5vzTmxAeT/wCkepCS/FBnUyuxzvYQn5xTlKdpvIucD7PIOUV6A+QcH5Qh+X2EQk45y0f80CwfoZDzQVkSJk9BeQ45H4FUj/LJOUUpGqdLzsecYQVz5HwMk1XQIucUiJyPQZtXAcisRuVgwStSmnd5WZIYuR6nkLOiNObEB5P/OKSqREl+qLOplVhnq8wn52TlaRrlImcVFjknS2+AnKOCMiS/VSnklLOs6odmWZVCzkqyJEyegmocclaFVE/wyTlZKRqpS87qzrCGOXJWx2Q1tMg5GSJndWjzagCZ1agcLHhNSvOuJksSI1ctCjlrSmNOfDD5tSDVk5TkhzqbWol1ttp8ck5SnqYNLnI+xSLnJOkNkHNDUIbk92kKOeUsn/ZDs3yaQs4nZUmYPAV1OOR8GlI9wyfnJKVovS456zrDZ82Rsy4me1aLnJMgctaFNu9ZILMalYMFf47SvOvIksTI9TyFnM9JY058MPnPQ6oXKMkPdTa1Euts9fjknKg8TUtd5HyRRc6J0hsg59KgDMnvSxRyylm+5Idm+RKFnC/IkjB5CupzyPkSpGrAJ+dEpUjokjPFGTY0R84UTNZQi5wTIXKmQJvXEMisRuVgwRtRmnd9WZIYuRpTyNlIGnPig8lvDKmaUJIf6mxqJdbZmvLJOUF5mgq7yNmMRc4J0hsgZ+GgDMlvcwo55Syb+6FZNqeQU+5AU5OnoAWHnM0h1ct8ck5QigrpkvMVZ9jSHDlfwWQttcg5ASLnK9DmtQQyq1E5WPBWlObdQpYkRq7WFHK2ksac+GDyW0OqNpTkhzqbWol1trZ8co5Xnqb5LnK+yiLneOkNkHN+UIbkN5VCTjnLVD80y1QKOdvIkjB5CtpxyJkKqdrzyTleKZqnS84OzvA1c+TsgMle0yLneIicHaDNew3IrEblYMFfpzRvmdf2GLk6Usj5ujTmxAeT3xFSdaIkP9TZ1Eqss73BJ+c45Wnq5iLnmyxyjpPeADm7BWVIft+ikFPO8i0/NMu3KOTsJEvC5Cl4m0POtyDVO3xyjlOKuuqS811n2NkcOd/FZJ21yDkOIue70OZ1BjKrUTlY8C6U5v22LEmMXO9RyNlFGnPig8l/D1K9T0l+qLOplVhn+4BPzrHK01TZRc4PWeQcK70BclYOypD8fkQhp5zlR35olh9RyPm+LAmTp6Arh5wfQapufHKOVYoq6ZLzY2f4iTlyfozJPtEi51iInB9Dm/cJkFmNysGCf0pp3l1lSWLk+oxCzk+lMSc+mPzPIFV3SvJDnU2txDpbDz45xyhPk99Fzp4sco6R3gA5/UEZkt80CjnlLNP80CzTKOTsLkvC5Cnwc8iZBqnS+eQcoxSl6ZKzlzPsbY6cvTBZby1yjoHI2QvavN5AZjUqBwveh9K85alNx8jVl0LOPtKYEx9Mfl9I1Y+S/FBnUyuxztafT87RytPU1kXOz1nkHC29AXK2DcqQ/A6gkFPOcoAfmuUACjn7yZIweQoGcsg5AFIN4pNztFLURpecg53hEHPkHIzJhmiRczREzsHQ5g0BMqtROVjwoZTmPVCWJEauYRRyDpXGnPhg8odBquGU5Ic6m1qJdbYRfHKOUp6mRS5yjmSRc5T0Bsi5KChD8juKQk45y1F+aJajKOQcLkvC5CkYzSHnKEg1hk9O9S58qUvOsc5wnDlyjsVk47TIOQoi51ho88YBmdWoHCz4eErzli+Lx2DkmkAh53hpzIkPJn8CpJpISX6os6mVWGebxCfnSOVpSnaRczKLnCOlN0DO5KAMye8UCjnlLKf4oVlOoZBzoiwJk6dgKoecUyDVND45RypFRXXJOd0ZzjBHzumYbIYWOUdC5JwObd4MILMalYMFn0lp3lNlSWLkmkUh50xpzIkPJn8WpJpNSX6os6mVWGebwyfnCOVpSnSRcy6LnCOkN0DOxKAMye88CjnlLOf5oVnOo5BztiwJk6dgPoec8yDVF3xyqp/ZJOiSc4EzXGiOnAsw2UItco6AyLkA2ryFQGY1KgcL/iWlec+XJYmRaxGFnF9KY058MPmLINVXlOSHOptaiXW2r/nkHK48Ta1d5PyGRU75bv0bgJytgzIkv99SyCln+a0fmuW3FHJ+JUvC5Cn4jkPObyHV93xyqj+TaaVLzh+c4Y/myPkDJvtRi5zDIXL+AG3ej0BmNSoHC/4TpXl/J0sSI9fPFHL+JI058cHk/wypFlOSH+psaiXW2ZbwyTlMeZryusj5C4ucw6Q3QM68QRmS3wCFnHKWAT80ywCFnItlSZg8BYJDzgCkWsonp/qrFHl0ybnMGS43R85lmGy5FjmHQeRcBm3eciCzGpWDBV9Bad5CliRGrpUUcq6Qxpz4YPJXQqpVlOSHOptaiXW21Xxyqr+nlsNFzjUscg6V3tCEY9ZSmCjjr+X8JskquY0mK3cdh3ZrIdV6jc0HliSN0/ilPiRbpb6BVepDpDdW6hsppS7jb9QpdaVzcB83+g0V8WXv9mD1PFy7vYm124OlN3YCN0E1sZlSE3KWm7Gd20xpkrJyNmPgXAfNcgujvoNZ2pLGedWyBVJtpbxqCRFKrcQItY3SXLZKY6xtbgGOyCXNJVev7DWXEsAC8TdkOZKz9e7N32V0+dTUlE6bcySLmO0iZoeI2SlidomY3SJmj4jZK2L2iZhfRcx+EXNAxBwUMYdEzGERc0TEHBUxx0TMcRFzQsScFDGnRMxpEfObiPldxPwhYv4UMX+JmDMi5m8R84+IOSti/jX3jnB7Lki2A5PtxGS7MNluTLYHk+3FZPsw2a+YbD8mO4DJDmKyQ5jsMCY7gsmOYrJjmOw4JjuByU5islOY7DQm+w2T/Y7J/sBkf2KyvzDZGUz2Nyb7B5OdxWT/ZnhG1Ts8AdMuwEUS6NewqjZ+R7U/nGpeW5fqAMLcpF3ZfVmSYSGzs7CVwU9doqowJ2vVabeqZsUwqt+ghezL7kI25yiCIBt65bIdera4Q6kKLnenSnUuKbsiq9LPp253RNWpCwneE0m1PbQNeyOoHr24WfvCqDpesqUHs1ZVunTjD2Wp2pehPA5npSqXsYiOZKEqmanUjmZW1ctckMcyqepmUbbHM6o6Z1XcJzKoOmd5BE66VHNrhTsovzuqUvPCqv64qBpaOrzqz5CqzLAIqr8uqLaXjaQ6c1716o6Iqr/PqaqnRlb9E1Q1qqFQnZWq2xqrVP8i7wqSdkGqffQHEzH/KnvMCufBRM4cpAcTMf9Kb+CzyhVBGeCX02I8mAjO0vJDs7Syu3PZ/iAuuHMK0XLND+Jy2s7QY+xtV04bk3l0Pog7d+yUsMxpI+DN6QEym+3iyRkMDz3Vymnzj/1ZZbYGu459DOvYn5XewLEfHJQhOc5JOfZyljn90Cxz8o/9WaVokO6x9zrDWHPH3ovJYrWO/Vno2HuhYxcLZDb7D1PB4LkYn2UFe07OdAyY0CzjGA9Tc+aSxn5j8S+zM/6jLKiZrs4Yz+qM/0hvoDPODMqQHCdQOqOcZYIfmmUC45OaYH3HmazvRMrnKTkTIFVu+pe3gsWtEM3QhYfPGSaZg4cPkyVpweMfCB4+aPOSgMxqVA4WPA+jBeVMlCWJteW8FCzkkcac+GDy80KqfJTkhzob0AMhVf7sNpfsk/Nv5Wnq6SJnARY5/5beADl7BmXIThSkkFPOsqAfmmVBCjnzyZIweQquoHwRLGdBSHUln5x/K0U9dMlZyBkWNkfOQpissBY5/4bIWQjavMJAZjUqBwt+FaV5XyFLEiPX1RRyXiWNOfHB5F8Nqa6hJD/U2dRKrLMV4b/nPKM8Ta7rnXJeyyLnGekNXe8kZUh+i1LIKWdZFLreKRhfYadDzmtkSZg8BckcchaFVNfxyXlGKdK93inn9c7wBnPkvB6T3aBFzjMQOa+HNu8GILMalYMFL0Zp3vLUXoeRqziFnMWkMSc+mPzikKoEJfmhzqZWYp2tJJ+cfylP03IXOUuxyPmX9AbIuTwoQ/JbmkJOOcvSfmiWpSnkLCFLwuQpuJFDztKQ6iY+Of9SipbpkvNmZ3iLOXLejMlu0SLnXxA5b4Y27xYgsxqVgwW/ldK8b5QliZHrNgo5b5XGnPhg8m+DVGUoyQ91NrUS62xl+eT8U3maUlzkLMci55/SGyBnSlCG5Pd2CjnlLG/3Q7O8nULOMrIkTJ6COzjkvB1S3ckn559KUQNdct7lDO82R867MNndWuT8EyLnXdDm3Q1kVqNysOD3UJr3HbIkMXLdSyHnPdKYEx9M/r2Q6j5K8kOdTa3EOtv9fHL+oTxN613kfIBFzj+kN0DO9UEZkt8HKeSUs3zQD83yQQo575MlYfIUPMQh54OQ6mE+Of9QitbpkvMRZ1jeHDkfwWTltcj5B0TOR6DNKw9kVqNysOCPUpr3Q7IkMXI9RiHno9KYEx9M/mOQqgIl+aHOplZina0in5y/K09TFRc5H2eR83fpDZCzSlCG5LcShZxylpX80CwrUchZQZaEyVNQmUPOSpCqCp+cvytFlXXJWdUZVjNHzqqYrJoWOX+HyFkV2rxqQGY1KgcL/gSleVeWJYmRqzqFnE9IY058MPnVIVUNSvJDnU2txDpbTT45f1OepukuctZikfM36Q2Qc3pQhuT3SQo55Syf9EOzfJJCzhqyJEyegtoccj4JqZ7ik/M3pWiaLjmfdoZ1zJHzaUxWR4ucv0HkfBravDpAZjUqBwv+DKV515YliZGrLoWcz0hjTnww+XUh1bOU5Ic6m1qJdbbn+OQ8rTxNC13kfJ5FztPSGyDnwqAMye8LFHLKWb7gh2b5AoWcz8qSMHkK6nHI+QKkepFPztNK0QJdcr7kDOubI+dLmKy+FjlPQ+R8Cdq8+kBmNSoHC96A0rzryZLEyJVCIWcDacyJDyY/BVI1pCQ/1NnUSqyzNeKT85TyNFVzkbMxi5ynpDdAzmpBGZLfJhRyylk28UOzbEIhZ0NZEiZPQVMOOZtAqmZ8cp5SiqrqkrO5M2xhjpzNMVkLLXKegsjZHNq8FkBmNSoHC/4ypXk3lSWJkesVCjlflsac+GDyX4FULSnJD3U2tRLrbK345DypPE2dXeRszSLnSekNkLNzUIbktw2FnHKWbfzQLNtQyNlSloTJU9CWQ842kOpVPjlPKkXv6pIz1Rm2M0fOVEzWToucJyFypkKb1w7IrEblYMHbU5p3W1mSGLk6UMjZXhpz4oPJ7wCpXqMkP9TZ1Eqss73OJ+eJbJGzI4ucJ6Q3Rs6OUH47UcgpZ9kJI2cnCjlfkyVh8hS8wSFnJ0j1Jp+cJ3jkfMsZvm2OnG9hsre1yHkCIudb0Oa9zSEnFvwdSvN+Q5YkRq53KeR8Rxpz4oPJfxdSdaYkP9TZ1Eqss3Xhk/O48jSNd5HzPRY5j0tvgJzjgzIkv+9TyCln+b4fmuX7FHJKJHcxeQo+4JDzfUj1IZ+cx5Wicbrk/MgZdjVHzo8wWVctch6HyPkRtHldgcxqVA4WvBuleX8gSxIj18cUcnaTxpz4YPI/hlSfUJIf6mxqJdbZPuWT85jyNI1ykfMzFjmPSW+AnKOCMiS/3SnklLPs7odm2Z1Czk9kSZg8BT045OwOqXryyXlMKRqpS840Z+g3R840TObXIucxiJxp0Ob5gcxqVA4WPJ3SvHvIksTI1YtCznRpzIkPJr8XpOpNSX6os6mVWGfrwyfnUeVp2uAiZ18WOY9Kb4CcG4IyJL/9KOSUs+znh2bZj0LO3rIkTJ6C/hxy9oNUn/PJeVQpWq9LzgHOcKA5cg7AZAO1yHkUIucAaPMGApnVqBws+CBK8+4vSxIj12AKOQdJY058MPmDIdUQSvJDnU2txDrbUD45jyhP01IXOYexyHlEegPkXBqUIfkdTiGnnOVwPzTL4RRyDpElYfIUjOCQczikGskn5xGlSOiSc5QzHG2OnKMw2Wgtch6ByDkK2rzRQGY1KgcLPobSvEfIksTINZZCzjHSmBMfTP5YSDWOkvxQZ1Mrsc42nk/Ow8rTVNhFzgksch6W3gA5CwdlSH4nUsgpZznRD81yIoWc42RJmDwFkzjknAipJvPJeVgpKqRLzinOcKo5ck7BZFO1yHkYIucUaPOmApnVqBws+DRK854kSxIj13QKOadJY058MPnTIdUMSvJDnU2txDrbTD45DylP03wXOWexyHlIegPknB+UIfmdTSGnnOVsPzTL2RRyzpAlYfIUzOGQczakmssn5yGlaJ4uOec5w/nmyDkPk83XIuchiJzzoM2bD2RWo3Kw4F9QmvccWZIYuRZQyPmFNObEB5O/AFItpCQ/1NnUSqyzfckn50HlaermIuciFjkPSm+AnN2CMiS/X1HIKWf5lR+a5VcUci6UJWHyFHzNIedXkOobPjkPKkVddcn5rTP8zhw5v8Vk32mR8yBEzm+hzfsOyKxG5WDBv6c0769lSWLk+oFCzu+lMSc+mPwfINWPlOSHOptaiXW2n/jkPKA8TZVd5PyZRc4D0hsgZ+WgDMnvYgo55SwX+6FZLqaQ80dZEiZPwRIOORdDql/45DygFFXSJWfAGQpz5AxgMqFFzgMQOQPQ5gkgsxqVgwVfSmneS2RJYuRaRiHnUmnMiQ8mfxmkWk5JfqizqZVYZ1vBJ+d+5Wnyu8i5kkXO/dIbIKc/KEPyu4pCTjnLVX5olqso5FwuS8LkKVjNIecqSLWGT879SlGaLjnXOsN15si5FpOt0yLnfoica6HNWwdkVqNysODrKc17tSxJjFwbKORcL4058cHkb4BUGynJD3U2tRLrbJv45PxVeZrausi5mUXOX6U3QM62QRmS3y0UcspZbvFDs9xCIedGWRImT8FWDjm3QKptfHL+qhS10SXndme4wxw5t2OyHVrk/BUi53Zo83YAmdWoHCz4Tkrz3ipLEiPXLgo5d0pjTnww+bsg1W5K8kOdTa3EOtsePjn3KU/TIhc597LIuU96A+RcFJQh+d1HIaec5T4/NMt9FHLuliVh8hT8yiHnPki1n09O9S58qUvOA87woDlyHsBkB7XIuQ8i5wFo8w4CmdWoHCz4IUrzli+L92PkOkwh5yFpzIkPJv8wpDpCSX6os6mVWGc7yifnXuVpSnaR8xiLnHulN0DO5KAMye9xCjnlLI/7oVkep5DziCwJk6fgBIecxyHVST459ypFRXXJecoZnjZHzlOY7LQWOfdC5DwFbd5pILMalYMF/43SvE/IksTI9TuFnL9JY058MPm/Q6o/KMkPdTa1Eutsf/LJuUd5mhJd5PyLRc490hsgZ2JQhuT3DIWccpZn/NAsz1DI+YcsCZOn4G8OOc9Aqn/45FQ/s0nQJedZZ/ivOXKexWT/apFzD0TOs9Dm/QtkVqNyoODeHJTm/bcsSYhcXotBTm/QmBMfS77XglQ2JfmhzqZWQp3N6+GTc7fyNLV2yOmNYZFzt/QGyNk6KEPKMCeFnHKWOf3QLHMyyOm1ZUmYPAVeCjm9OSFVLJ+c6s9kWmmS05vLGcYZI6c3FyaL0yLnboSc3lzQ5sUBmdWoHCx4PKMFeb2yJDFyJVDIGS+NOfHB5CdAqkRK8kOdTa3EOltuPjl3KU9TXhc5fSxy7pLeADnzBmVIfpMo5JSzTPJDs0yikDNRloTJU5CHQ84kSJWXT071Vyny6JIznzPMb46c+TBZfi1y7oLImQ/avPxAZjUqBwtegNK888iSxMhVkELOAtKYEx9MfkFIdQUl+aHOplZine1KPjnV31PL4SJnIRY5d0pvaMLewhQmyviF0yi0u0Juo8nKvYpDu8KQ6mqNzQeWJI3T+KW+I1ulfg2r1HdIb6zUi1BKXcYvolPqSufgPhbxGyriy97t7ep5uHb7WtZub5fe2Am8FqqJopSakLMsiu1cUUqTlJVTFAPnVdAskxn1HcxSchrnVUsypLqO8qolRCi1EiPU9ZTmcp00xtpmMnBELmkuVq8uo8unpqZ02pyjAtIHGiGiU4ioCiJqDrY8j/p6rxyo1QJzVl+Ys5pvzmqeOau55qzmmLOabc5qljmrmeasZpizmm7Oapo5q6nmrKaYs5pszmqSOauJ5qwmmLMab85qnDmrseasxpizGm3OapQ5q5HmrEaYsxpuzmqYOauh5qyGmLMabMwq5l9zVmfNWf1jzupvc1ZnzFn9Zc7qT3NWf5iz+t2c1W/mrE6bszplzuqkOasT5qyOm7M6Zs7qqDmrI+asDpuzOmTO6qA5qwPmrPabs/rVnNU+c1Z7zVntMWe125zVLnNWO81Z7TBntV1tlY1vJ+SokB2xfIIfenAnP/e+QXiLCW9x4S0hvCWFt5TwlhbeG4X3JuG9WXhvEd5bhfc24S0jvGWFt5y5rzsUS4ZkxTFZCUxWEpOVwmSlMdmNmOwmTHYzJrsFk92KyW7DZGUwWVlMVi750s8EsOfYN0R+jv1ZwpzPL7Xtgzye98xHvkDj+UKpOveYWKU6/1waWm4xoJFoLHc2tNw50HLnQsudBy23eHaX2wsKDv2JJW8Jqbrm8NWnZ3gK9ClhH9rw8Lf/vFAopuLNpyuPadI4rdTUQU2arRdJ6zk7MhnakSnQjkyFkjINSkpJznLHQ8udAC13IrTcSdByS3EKcBwUvLRUFVv7RezvE3rGzFh/rM3rp2/staRS90UTH0gXtzzU+aldfY9UF0mrOTsyHNqREdCOjISSMgpKyo2c5Q6GljsEWu5QaLnQ3xb33kRZbszfyHJj/kGWG3MWWW7Mv9Byb+Ys9w9ouX9Cy/0LWu4ZaLm3UNpLzO9Q8Fshvu3j7MgxaEeOQztyAkrKSSgpt3GWC/1pOuBPv557zAQt9yi03DKcAjwIBS8L8W0XZ0egXy4Dfnk7B3I5yvknQlBSymV3udhX0m6PbNvoVJXmOrZ3RLZ9OW5vMx3bOyPbLmg25UMd27si2z7Q+mSqju3dkW1H1zx9n47tPZFtn/TVflfH9t7ItgNzNv9Mx/a+yLZF398wUcf2/si2L2wXhbN4ujD9qeYp5e6867E2rdqmyocLLdq07iWffrkeNtzufjTlfv7kfsjkfpLkflzkfibkfvDjfrrjfoTjfk7jfhjjfuLifqzifnbifkDS3/U/7nCN73SN73KN73aN73GN73WN73ON7+8vvA8I74PC+5DwPiy8jwhveeF9VHgfi34VUGEV/Spg9KuAF62iXwWMfhXwolX0q4DRrwJetIp+FTD6VcCLVtGvAka/CnjRKvpVwOhXAS9aRb8KGP0q4EWr6FcBo18FvGgV/Spg9KuAl/xftr4K+MglXwWsILwVhfdx4a0kvJWFt4rwVhXeasL7hPBWF94awltTeGsJ75PCW1t4nzL3VcAKyTqf16j+otj5z2t2QJ/X7IQ+r9kFfV5TAdhPje+1VeTYPs6xrcSxrcyxrcKxrcqxrcaxfYJjW51jW4NjW5NjW4tj+yTHtjbH9ikdW/UHgk9Htu2saVuHM9tnVLZ2ss7HlxVc46dd4zr/4fEz7o8vH3CNH3SNH3KNH3aNH3GNy7vGj7rGj8mPL+sK77PC+5zwPi+8LwhvPeF9UXhfuvTjy1y9snlNkreu2ddsMdm6iTL0mq238NYX3gbCmyK8Dc29GqufC5I1wGQpmKxhrswvAVWrkdsAHbn6yAtFbwPkhaI3BXmh6G0IlMdlVuCz/5EKbCS8jYW3ifA2NVeBjbCaaYzJmmCyploV+CxUgY2gCmwMVWATqAKb8ivwuf9IBTYT3ubC20J4XzZXgc2wmmmOyVpgspe1KvA5qAKbQRXYHKrAFlAFvsyvwOf/IxX4ivC2FN5WwtvaXAW+gtVMS0zWCpO11qrA56EKfAWqwJZQBbaCKrA1vwJf+I9UYBvhbSu8rwpvqrkKbIPVTFtM9iomS9WqwBegCmwDVWBbqAJfhSowlV+B9f4jFSj3rr3wdhDe18xVYDusZtpjsg6Y7DWtCqwHVWA7qALbQxXYAarA1/gV+OJ/pAJfF96OwttJeN8wV4GvYzXTEZN1wmRvaFXgi1AFvg5VYEeoAjtBFfgGvwJf+o9U4JvC+5bwvi2875irwDexmnkLk72Nyd7RqsCXoAp8E6rAt6AKfBuqwHc4T3LfjWz715NDqurYdg5ra1+cbeY9nFWrTbsmLRq3aV2uVpPUVh3ap7SXz4jTe7v29N2L45Jhnsd2liXcRXjfE973hfeDyzuUV5k9kslaR3JzjmTh/VB4PxLersLbTXg/Ft5PhPdT4f1MeLsLbw/h7Sm8acLrF9504e0lvDIDfYS3r/D2E1758Phz4R0gvAOFd5DwDhbeIcI7VHiHCe9w4R0hvCOFd5S5g/4hdjQ/wmRdMVk3TPYxJvsEk32KyT7DZN0xWQ9M1hOTpWEyPyZLx2S9MFlvTNYHk/XFZP0wWX9M9jkmG4DJBmKyQZhsMCYbgsmGYrJhmGw4JhuByUZislEZXiz0Do+5tAuYk1DuHlbVxu+oeoRTzWvrUvVEwJrHm92XARkWMjsLWxn880tUFeZkrRrgVtWsGEY1EFpIfHYXsjlHEQTZ0MuTD6GXbx9BL9+6Qi/fukVWpZ9P3ccRVacuJPiTSKrtoW34NILq0Yub9VkYVcdLtjQta1WlSzc+65eG+zKUR5Z/FKVcxiLK6kKGkplKLYtTWi9zQWb+Jl7dLMq2b0ZV56yKu18GVecsj0B/l2purXAHZZCjKjUvrMq5wmdo6fCqi1f4lBkWQRW6wmd72UiqYedVr+6IqDp/k1L11MiqczcpNaqhUAVvUrqtsUoF3aSUxwup4rP7hj4uu3+FyjtK2WNWuP4K1WjSX6HyjpLewB+mXRGUIX5j1A1Wb5Zj/NAsx2R357L9V1e96t8cXK77V1fHOsNx5t52jcVk43T+6uq5Y6eG5VgIvOOAzGa/eMbI8NhzibH8Yz9Sma3BrmM/nnXs5fv68cCxHxyUIX4TKMdeznKCH5rlBP6xV/+W7yDdYz/RGU4yd+wnYrJJWsd+JHTsJ0LHbhKQWY2/nIcFn6xxvtSusudMwP5y3hholsDdDBrna7I09huLf5mdcYSyoGa6OuNUVmeUDz2nAp1xZlCG+E2jdEY5y2l+aJbTNCoHqu8pJut7ejZnCbaAaZBqBlBIlwkP9b0OM3ThMdMZzjIHj5mYbJYWPEZA8JgJbd4sILMalYMFn01pQdNlSWJteQ4FC7OlMSc+mPw5kGouJfmhzgb0QEg1L7vNJfvkHK48TT1d5JzPIudw6Q2Qs2dQhvh9QSGnnOUXfmiWX1DIOVeWhMlTsCCbewkewS8g1UI+OdXXGPXQJeeXznCROXJ+ickWaZETuqDe+yW0eYuAzGpUDhb8K0oLWiBLEiPX1xRyfiWNOfHB5H8Nqb6hJD/U2dRKrLN9y3/POUx5mpJd5PyORc5h0hsgZ3JQhvh9TyGnnOX3fmiW31PI+Y0sCZOn4AcOOb+HVD/yyam+ta+oLjl/coY/myPnT5jsZy1yDoPI+RO0eT8DmdWoHCz4YkoL+kGWJEauJRRyLpbGnPhg8pdAql8oyQ91NrUS62wBPjmHKk/Tchc5BYucQ6U3QM7lQRnit5RCTjnLpX5olksp5PxFloTJU7CMQ86lkGo5n5zqS2qX6ZJzhTNcaY6cKzDZSi1yDoXIuQLavJVAZjUqBwu+itKClsmSxMi1mkLOVdKYEx9M/mpItYaS/FBnUyuxzraWT84hytOU4iLnOhY5h0hvgJwpQRnit55CTjnL9X5olusp5FwjS8LkKdjAIed6SLWRT071newNdMm5yRluNkfOTZhssxY5h0Dk3ARt3mYgsxqVgwXfQmlBG2RJYuTaSiHnFmnMiQ8mfyuk2kZJfqizqZVYZ9vOJ+dg5Wla7yLnDhY5B0tvgJzrgzLEbyeFnHKWO/3QLHdSyLlNloTJU7CLQ86dkGo3n5zqP0GyTpece5zhXnPk3IPJ9mqRE/rL1N490ObtBTKrUTlY8H2UFrRLliRGrl8p5NwnjTnxweT/Cqn2U5If6mxqJdbZDvDJOUh5mqq4yHmQRc5B0hsgZ5WgDPE7RCGnnOUhPzTLQxRy7pclYfIUHOaQ8xCkOsIn5yClqLIuOY86w2PmyHkUkx3TIucgiJxHoc07BmRWo3Kw4McpLeiwLEmMXCco5DwujTnxweSfgFQnKckPdTa1Eutsp/jkHKg8TdNd5DzNIudA6Q2Qc3pQhvj9RiGnnOVvfmiWv1HIeVKWhMlT8DuHnL9Bqj/45ByoFE3TJeefzvAvc+T8E5P9pUXOgRA5/4Q27y8gsxqVgwU/Q2lBv8uSxMj1N4WcZ6QxJz6Y/L8h1T+U5Ic6m1qJdbazfHIOUJ6mhS5y/ssi5wDpDZBzYVAG+MXmoJBzgDT2I7MMxlfY6ZDzH1kSBk9BrEUhZ2wOSGXzyTlAKVqgSc5YjzOMMUbOWA8mi9Ei5wCEnLEeaPNigMxqVA4WPCejBcXK/8+GyBXrZZAzNqc05sQHk++FVLGU/h/qbGol1tly8cn5ufI0VXPIGRvHIufn0hsgZ7WgDCnDeAo55Szj/dAs4xnkjI2VJWHyFCRwyBkPqRL55PxcKaqqS87cztBnjpy5MZlPi5yfQ+TMDW2eD8isRuVgwZMo5EyQJYmRKw+FnEnSmBMfTH4eSJWXkvxQZ1Mrsc6Wj0/O/srT1NlFzvwscvaX3gA5OwdlSH4LUMgpZ1nAD82yAIWceWVJmDwFBTnkLACpruCTs79S9K4uOa90hoXMkfNKTFZIi5z9IXJeCW1eISCzGpWDBS9Mad4FZUli5LqKQs7C0pgTH0w+dNV37NWU5Ic6m1qJdbZr+OTsly1yFmGRs5/0xshZBMrvtRRyyllei5HzWgo5r5YlYfIUFOWQ81pIlcwnZz8eOa9zhtebI+d1mOx6LXL2g8h5HbR513PIiQW/gdK8i8qSxMhVjELOG6QxJz6Y/GKQqjgl+aHOplZina0En5x9ladpvIucJVnk7Cu9AXKOD8qQ/JaikFPOspQfmmUpCjmLy5IweQpKc8hZClLdyCdnX6VonC45b3KGN5sj502Y7GYtcvaFyHkTtHk3A5nVqBws+C2U5l1aliRGrlsp5LxFGnPig8m/FVLdRkl+qLOplVhnK8MnZx/laRrlImdZFjn7SG+AnKOCMiS/5SjklLMs54dmWY5CzttkSZg8BbdzyFkOUt3BJ2cfpWikLjnvdIZ3mSPnnZjsLi1y9oHIeSe0eXcBmdWoHCz43ZTmfbssSYxc91DIebc05sQHk38PpLqXkvxQZ1Mrsc52H5+cvZWnaYOLnPezyNlbegPk3BCUIfl9gEJOOcsH/NAsH6CQ815ZEiZPwYMccj4AqR7ik7O3UrRel5wPO8NHzJHzYUz2iBY5e0PkfBjavEeAzGpUDha8PKV5PyhLEiPXoxRylpfGnPhg8h+FVI9Rkh/qbGol1tkq8MnZS3malrrIWZFFzl7SGyDn0qAMye/jFHLKWT7uh2b5OIWcj8mSMHkKKnHI+Tikqswnp3pThS45qzjDqubIWQWTVdUiZy+InFWgzasKZFajcrDg1SjNu5IsSYxcT1DIWU0ac+KDyX8CUlWnJD/U2dRKrLPV4JNTfZoKu8hZk0XOdOkNkLNwUIbktxaFnHKWtfzQLGtRyFldloTJU/Akh5y1IFVtPjnVokK65HzKGT5tjpxPYbKntciZDpHzKWjzngYyq1E5WPA6lOb9pCxJjFzPUMhZRxpz4oPJfwZS1aUkP9TZ1Eqssz3LJ6dfeZrmu8j5HIucfukNnOz5QRmS3+cp5JSzfN4PzfJ5CjnrypIweQpe4JDzeUhVj09Ov1I0T5ecLzrDl8yR80VM9pIWOf0QOV+ENu8lILMalYMFr09p3i/IksTI1YBCzvrSmBMfTH4DSJVCSX6os6mVWGdryCdnmvI0dXORsxGLnGnSGyBnt6AMyW9jCjnlLBv7oVk2ppAzRZaEyVPQhEPOxpCqKZ+c6lrtqkvOZs6wuTlyNsNkzbXImQaRsxm0ec2BzGpUDha8BaV5y51sipHrZQo5W0hjTnww+S9DqlcoyQ91NrUS62wt+eTsqTxNlV3kbMUiZ0/pDZCzclCG5Lc1hZxylq390CxbU8j5iiwJk6egDYecrSFVWz45eypFlXTJ+aozTDVHzlcxWaoWOXtC5HwV2rxUILMalYMFb0dp3m1kSWLkak8hp9zX9pz4YPLbQ6oOlOSHOptaiXW21/jk7KE8TX4XOV9nkbOH9AbI6Q/KkPx2pJBTzrKjH5plRwo5O8iSMHkKOnHI2RFSvcEnZw+lKE2XnG86w7fMkfNNTPaWFjl7QOR8E9q8t4DMalQOFvxtSvPuJEsSI9c7FHK+LY058cHkvwOp3qUkP9TZ1Eqss3Xmk7O78jS1dZGzC4uc3aU3QM62QRmS3/co5JSzfM8PzfI9CjnflSVh8hS8zyHne5DqAz45uytFbXTJ+aEz/MgcOT/EZB9pkbM7RM4Poc37CMisRuVgwbtSmvf7siQxcnWjkLOrNObEB5PfDVJ9TEl+qLOplVhn+4RPzs+Up2mRi5yfssj5mfQGyLkoKEPy+xmFnHKWn/mhWX5GIefHsiRMnoLuHHJ+Bql68Mmp3oUvdcnZ0xmmmSNnT0yWpkXOzyBy9oQ2Lw3IrEblYMH9lOYtXxb3wMiVTiGnfFKVzokPJh9T9aIkP9TZ1Eqss/Xmk/NT5WlKdpGzD4ucn0pvgJzJQRmS374UcspZ9vVDs+xLIWcvWRImT0E/Djn7Qqr+fHJ+qhQV1SXn585wgDlyfo7JBmiR81OInJ9DmzcAyKxG5WDBB1Kadz9Zkhi5BlHIOVAac+KDyR8EqQZTkh/qbGoltpYhfHJ+ojxNiS5yDmWR8xPpDZAzMShD8juMQk45y2F+aJbDKOQcLEvC5CkYziHnMEg1gk9O9TObBF1yjnSGo8yRcyQmG6VFzk8gco6ENm8UkFmNysGCj6Y07+GyJDFyjaGQc7Q05sQHkz8GUo2lJD/U2dRKrLON45PzY+Vpau0i53gWOeW79fEAOVsHZUh+J1DIKWc5wQ/NcgKFnGNlSZg8BRM55JwAqSbxyan+TKaVLjknO8Mp5sg5GZNN0SLnxxA5J0ObNwXIrEblYMGnUpr3RFmSGLmmUcg5VRpz4oPJnwapplOSH+psaiXW2WbwydlNeZryusg5k0XObtIbIGfeoAzJ7ywKOeUsZ/mhWc6ikHO6LAmTp2A2h5yzINUcPjnVX6XIo0vOuc5wnjlyzsVk87TI2Q0i51xo8+YBmdWoHCz4fErzni1LEiPXFxRyzpfGnPhg8r+AVAsoyQ91NrUS62wL+eRUf08th4ucX7LI2VV6QxOOXURhooy/KI1CuwVyG01W7lcc2i2CVF9rbD6wJGmcxi/1j7JV6t+wSv0j6Y2V+reUUpfxv9UpdaVzcB+/9Rsq4sve7Q/V83Dt9nes3f5QemMn8DuoJr6n1ISc5ffYzn1PaZKycr7HwPkVNMsfGPUdzNIPaZxXLT9Aqh8pr1pChFIrMUL9RGkuP0pjrG3+AByRS5pLrl7Zay4WsED8DVmO5Gy9e/N3GV0+NTWl0+YcySL2ZxG7WMQuEbG/iNiAiBUidqmIXSZil4vYFSJ2pYhdJWJXi9g1InatiF0nYteL2A0idqOI3SRiN4vYLSJ2q4jdJmK3i9gdInaniN0lYneL2D0idq+I3WfuHeHPuSDZYky2BJP9gskCmExgsqWYbBkmW47JVmCylZhsFSZbjcnWYLK1mGwdJluPyTZgso2YbBMm24zJtmCyrZhsGybbjsl2YLKdmGwXJtuNyfZgsr2YbF+GZ1QR/mpS2gW4SAItD6tq43dUK8Kp5rV1qVYizM1TMLsvSzIsZHYWtjL45ktUFeZkrdriVtWsGEa1FVpI4ewuZHOOIgiyoVcuP0PPFhcrVcHlLlGpziXll8iq9POpC0RUnbqQYBFJtT20DUsjqB69uFnLwqg6XrKlq7JWVbp041dnqdqXoTzWZKUql7GI1mahKpmp1NZlVtXLXJDrM6nqZlG2GzKqOmdV3BszqDpneQQ2uVRza4U7KNscVal5YVXbL6qGlg6v2hFSlRkWQbXzgmp72UiqXedVr+6IqNp9TlU9NbJqT1DVqIZCtVeqbmusUu1D3hXkKQipCtMfTMTuU/aYFa4HE7+SHkzE7pPewGeVK4IyxG8/48FEcJb7/dAs92d357L9QVxw5xSi5bofxB1whgfNve06gMkO6nwQd+7YqWF5AALvQSCz2S+e/TI89lTrAP/Y71Vma7Dr2B9iHXv5vv4QcOwHB2WI32HKsZezPOyHZnmYf+z3KkWDdI/9EWd41NyxP4LJjmod+73QsT8CHbujQGY1HqZiwY9RPsuSPecw9jB1PzTL45SHqceksd9Y/MvsjHuUBTXT1RlPsDqjfOh5AuiMM4MyxO8kpTPKWZ70Q7M8SfmkRtb3cZP1fYrzecpJSHWa/uWtYHErRDN04fGbM/zdHDx+w2S/a8FjDwSP36DN+x3IrEblYMH/oLSgU7Iksbb8JwULf0hjTnww+X9Cqr8oyQ91NqAHQqoz2W0u2SfnbuVp6uki598scspPDP8GyNkzKEP8/qGQU87yHz80y38o5PxLloTJU3CW80WwfyDVv3xy7laKemiSM1cOZ2gZI2cuUGZpkXM3Qs5cOZDNy2UBmc1+5YDBbUoLOitLEiJXLg+DnLlsacyJDybfA6liKMkPdTa1EupsuXLy33PuUp4m1/VOubwscu6S3tD1Trm8yLJyxVLIKWcZC13vFIyvsNMgZ64YWRImT0EuCjlzxUKqOD45dylFutc75Yp3hgnmyBmPyRK0yLkLImc8tHkJQGY1KgcLnshoQblyyZLEyJWbQs5EacyJDyY/N6TyUZIf6mxqJdbZkvjk3Kk8Tctd5MzDIudO6Q2Qc3lQhuQ3L4WccpZ5/dAs81LI6ZMlYfIU5OOQMy+kys8n506laJkuOQs4w4LmyFkAkxXUIudOiJwFoM0rCGRWo3Kw4FdQmnc+WZIYua6kkPMKacyJDyb/SkhViJL8UGdTK7HO9n/wxa8dytOU4iLnVSxy7pDeADlTgjIkv1dTyClnebUfmuXVFHIWkiVh8hRcwyHn1ZCqCJ+cO5SiBrrkvNYZFjVHzmsxWVEtcu6AyHkttHlFgcxqVA4WPJnSvK+RJYmR6zoKOeWTqus48cHkXweprqckP9TZ1Eqss93AJ+d25Wla7yJnMRY5t0tvgJzrgzIkv8Up5JSzLO6HZlmcQs7rZUmYPAUlOOQsDqlK8sm5XSlap0vOUs6wtDlylsJkpbXIuR0iZylo80oDmdWoHCz4jZTmXUKWJEaumyjkvFEac+KDyb8JUt1MSX6os6mVWGe7hU/ObcrTVMVFzltZ5NwmvQFyVgnKkPzeRiGnnOVtfmiWt1HIebMsCZOnoAyHnLdBqrJ8cm5TiirrkrOcM7zdHDnLYbLbtci5DSJnOWjzbgcyq1E5WPA7KM27jCxJjFx3Ush5hzTmxAeTfyekuouS/FBnUyuxznY3n5xbladpuouc97DIuVV6A+ScHpQh+b2XQk45y3v90CzvpZDzLlkSJk/BfRxy3gup7ueTc6tSNE2XnA84wwfNkfMBTPagFjm3QuR8ANq8B4HMalQOFvwhSvO+T5YkRq6HKeR8SBpz4oPJfxhSPUJJfqizqZVYZyvPJ+cW5Wla6CLnoyxybpHeADkXBmVIfh+jkFPO8jE/NMvHKOR8RJaEyVNQgUPOxyBVRT45tyhFC3TJ+bgzrGSOnI9jskpa5NwCkfNxaPMqAZnVqBwseGVK864gSxIjVxUKOStLY058MPlVIFVVSvJDnU2txDpbNT45NytPUzUXOZ9gkXOz9AbIWS0oQ/JbnUJOOcvqfmiW1SnkrCpLwuQpqMEhZ3VIVZNPzs1KUVVdctZyhk+aI2ctTPakFjk3Q+SsBW3ek0BmNSoHC16b0rxryJLEyPUUhZy1pTEnPpj8pyDV05TkhzqbWol1tjp8cm5SnqbOLnI+wyLnJukNkLNzUIbkty6FnHKWdf3QLOtSyPm0LAmTp+BZDjnrQqrn+OTcpBS9q0vO553hC+bI+Twme0GLnJsgcj4Pbd4LQGY1KgcLXo/SvJ+VJYmR60UKOetJY058MPkvQqqXKMkPdTa1Euts9fnk3JgtcjZgkXOj9MbI2QDKbwqFnHKWKRg5UyjkfEmWhMlT0JBDzhRI1YhPzo08cjZ2hk3MkbMxJmuiRc6NEDkbQ5vXhENOLHhTSvNuKEsSI1czCjmbSmNOfDD5zSBVc0ryQ51NrcQ6Wws+OTcoT9N4FzlfZpFzg/QGyDk+KEPy+wqFnHKWr/ihWb5CIWdzWRImT0FLDjlfgVSt+OTcoBSN0yVna2fYxhw5W2OyNlrk3ACRszW0eW2AzGpUDha8LaV5t5QliZHrVQo520pjTnww+a9CqlRK8kOdTa3EOls7PjnXK0/TKBc527PIuV56A+QcFZQh+e1AIaecZQc/NMsOFHKmypIweQpe45CzA6R6nU/O9UrRSF1ydnSGncyRsyMm66RFzvUQOTtCm9cJyKxG5WDB36A079dkSWLkepNCzjekMSc+mPw3IdVblOSHOptaiXW2t/nkXKc8TRtc5HyHRc510hsg54agDMnvuxRyylm+64dm+S6FnG/JkjB5CjpzyPkupOrCJ+c6pWi9Ljnfc4bvmyPne5jsfS1yroPI+R60ee8DmdWoHCz4B5Tm3VmWJEauDynk/EAac+KDyf8QUn1ESX6os6mVWGfryifnWuVpWuoiZzcWOddKb4CcS4MyJL8fU8gpZ/mxH5rlxxRyfiRLwuQp+IRDzo8h1ad8cq5VioQuOT9zht3NkfMzTNZdi5xrIXJ+Bm1edyCzGpWDBe9Bad6fyJLEyNWTQs4e0pgTH0x+T0hF6f8XO5taiXU2P5+ca5SnqbCLnOkscq6R3gA5CwdlSH57UcgpZ9nLD82yF4WcabIkTJ6C3hxy9oJUffjkXKMUFdIlZ19n2M8cOftisn5a5FwDkbMvtHn9gMxqVA4WvD+lefeWJYmR63MKOftLY058MPmfQ6oBlOSHOptaiXW2gXxyrlaepvkucg5ikXO19AbIOT8oQ/I7mEJOOcvBfmiWgynkHCBLwuQpGMIh52BINZRPztVK0Txdcg5zhsPNkXMYJhuuRc7VEDmHQZs3HMisRuVgwUdQmvcQWZIYuUZSyDlCGnPig8kfCalGUZIf6mxqJdbZRvPJuUp5mrq5yDmGRc5V0hsgZ7egDMnvWAo55SzH+qFZjqWQc5QsCZOnYByHnGMh1Xg+OVcpRV11yTnBGU40R84JmGyiFjlXQeScAG3eRCCzGpWDBZ9Ead7jZEli5JpMIeckacyJDyZ/MqSaQkl+qLOplVhnm8on50rlaarsIuc0FjlXSm+AnJWDMiS/0ynklLOc7odmOZ1CzimyJEyeghkcck6HVDP55FypFFXSJecsZzjbHDlnYbLZWuRcCZFzFrR5s4HMalQOFnwOpXnPkCWJkWsuhZxzpDEnPpj8uZBqHiX5oc6mVmKdbT6fnCuUp8nvIucXLHKukN4AOf1BGZLfBRRyylku8EOzXEAh5zxZEiZPwUIOORdAqi/55FyhFKXpknORM/zKHDkXYbKvtMi5AiLnImjzvgIyq1E5WPCvKc17oSxJjFzfUMj5tTTmxAeT/w2k+paS/FBnUyuxzvYdn5zLlaeprYuc37PIuVx6A+RsG5Qh+f2BQk45yx/80Cx/oJDzW1kSJk/Bjxxy/gCpfuKTc7lS1EaXnD87w8XmyPkzJlusRc7lEDl/hjZvMZBZjcrBgi+hNO8fZUli5PqFQs4l0pgTH0z+L5AqQEl+qLOplVhnE3xyLlOepkUuci5lkXOZ9AbIuSgoQ/K7jEJOOctlfmiWyyjkDMiSMHkKlnPIuQxSreCTU70LX+qSc6UzXGWOnCsx2Sotci6DyLkS2rxVQGY1KgcLvprSvOXL4hUYudZQyLlaGnPig8lfA6nWUpIf6mxqJdbZ1vHJuVR5mpJd5FzPIudS6Q2QMzkoQ/K7gUJOOcsNfmiWGyjkXCtLwuQp2Mgh5wZItYlPzqVKUVFdcm52hlvMkXMzJtuiRc6lEDk3Q5u3BcisRuVgwbdSmvdGWZIYubZRyLlVGnPig8nfBqm2U5If6mxqJdbZdvDJKZSnKdFFzp0scgrpDZAzMShD8ruLQk45y11+aJa7KOTcLkvC5CnYzSHnLki1h09O9TObBF1y7nWG+8yRcy8m26dFTgGRcy+0efuAzGpUDhb8V0rz3i1LEiPXfgo5f5XGnPhg8vdDqgOU5Ic6m1qJdbaDfHIGlKeptYuch1jklO/WDwHkbB2UIfk9TCGnnOVhPzTLwxRyHpAlYfIUHOGQ8zCkOsonp/ozmVa65DzmDI+bI+cxTHZci5wBiJzHoM07DmRWo3Kw4CcozfuILEmMXCcp5DwhjTnxweSfhFSnKMkPdTa1Eutsp/nk/EV5mvK6yPkbi5y/SG+AnHmDMiS/v1PIKWf5ux+a5e8Ucp6SJWHyFPzBIefvkOpPPjnVX6XIo0vOv5zhGXPk/AuTndEi5y8QOf+CNu8MkFmNysGC/01p3n/IksTI9Q+FnH9LY058MPn/QKqzlOSHOptaiXW2f/nkVH9PLYdDzrgcLHIukd7QhOMsChNlfCuNQruzchsNVm6cTaFdnAWpPBqbDyxJGqfxS31xtko9hlXqi6U3Vuo5KaUu4+fUKXWlc3Afc/oNFfFl7/bP6nm4dtvL2u2fpTd2Ar1QTcRSakLOMhbbuVhGkwxWTiwEzjgbmmUuRn0Hs5QrjfKqJS4XpIqjvGoJEUqtxAgVT2kucdIYa5u5gCNySXPJ1St7zeVqYIH4G7Icydl69+bvMrp8ampKp805kkVcgohLFHG5RZxPxCWJuDwiLq+Iyyfi8ou4AiKuoIi7QsRdKeIKibjCIu4qEXe1iLtGxBURcdeKuKIiTjpcJ+KuF3E3iLhiIq64iCsh4kqKuFIirrSIu9HYO8K4hFyQLBGT5cZkPkyWhMnyYLK8mCwfJsuPyQpgsoKY7ApMdiUmK4TJCmOyqzDZ1ZjsGkxWBJNdi8mKYrJkTHYdJrsek92AyYphsuKYrAQmK4nJSmGy0pjsxgzPqHqHJ2DaBbhIAuUPq2rjd1QFwqnmtXWpCiLMzVMsuy9LMixkdha2MnjRS1QV5mStSnaralYMo7oOWkip7C5kc44iCLKhVy4JyLPFuESlKrjc3CrVuaT4IqvSz6cuKaLq1IUE54mk2h7ahrwRVI9e3Kx8YVQdL9nSK7JWVbp046/MUrUvQ3kUykpVLmMRFc5CVTJTqV2VWVUvc0Fmrom6WZTtNRlVnbMq7iIZVJ2zPALXulRza4U7KNc7qlLzwqpuuKgaWjq8qlhIVWZYBFXxC6rtZSOpSpxXvbojoqrkOVX11MiqUkFVoxoKVWmpuq2xSnUj8q4gTzFIVYr+YCLuRmWPWeF6MHET6cFE3I3SG/isckVQhvjdzHgwEZzlzX5oljdnd+ey/UFccOcUouWaH8TF3eIMbzX3tusWTHarzgdx546dGpa3QOC9Fchs9ovnZhkee6p1C//Yl1Zma7Dr2N/GOvbyff1twLEfHJQhfmUox17OsowfmmUZ/rEvrRQN0j32ZZ1hOXPHviwmK6d17EtDx74sdOzKAZnVeJiKBb+d8lmW7DllsCfZN0OzvIPyMPV2aew3Fv8yO2MpZUHNdHXGO1mdUT70vBPojDODMsTvLkpnlLO8yw/N8i7KJzWyvu8wWd93cz5PuQtS3UP/8lac+g3FDF143OsM7zMHj3sx2X1a8CgFweNeaPPuAzKrUTlY8PspLehuWZJYW36AgoX7pTEnPpj8ByDVg5Tkhzob0AMh1UPZbS7ZJ2dJ5Wnq6SLnwyxyyk8MHwbI2TMoQ/weoZBTzvIRPzTLRyjkfFCWhMlTUJ7zRbBHINWjfHKWVIp66JLzMWdYwRw5H8NkFbTIWRIi52PQ5lUAMqtROVjwipQWVF6WJEauxynkrCiNOfHB5D8OqSpRkh/qbGol1tkq899zllCeJtf1TnFVWOQsIb2h652kDPGrSiGnnGVV6HqnYHyFnQ45K8mSMHkKqnHIWRVSPcEnZwmlSPd6p7jqzrCGOXJWx2Q1tMhZAiJndWjzagCZ1agcLHhNSguqJksSI1ctCjlrSmNOfDD5tSDVk5TkhzqbWol1ttp8chZXnqblLnI+xSJncekNkHN5UIb4PU0hp5zl035olk9TyPmkLAmTp6AOh5xPQ6pn+OQsrhQt0yVnXWf4rDly1sVkz2qRszhEzrrQ5j0LZFajcrDgz1FaUB1Zkhi5nqeQ8zlpzIkPJv95SPUCJfmhzqZWYp2tHp+cxZSnKcVFzhdZ5CwmvQFypgRliN9LFHLKWb7kh2b5EoWcL8iSMHkK6nPI+RKkasAnp/oL6A10yZniDBuaI2cKJmuoRc5iEDlToM1rCGRWo3Kw4I0oLai+LEmMXI0p5GwkjTnxweQ3hlRNKMkPdTa1EutsTfnkvEF5mta7yNmMRc4bpDdAzvVBGeLXnEJOOcvmfmiWzSnklDvQ1OQpaMEhZ3NI9TKfnDcoRet0yfmKM2xpjpyvYLKWWuS8ASLnK9DmtQQyq1E5WPBWlBbUQpYkRq7WFHK2ksac+GDyW0OqNpTkhzqbWol1trZ8cl6vPE1VXOR8lUXO66U3QM4qQRnil0ohp5xlqh+aZSqFnG1kSZg8Be045EyFVO355LxeKaqsS84OzvA1c+TsgMle0yLn9RA5O0Cb9xqQWY3KwYK/TmlBMq/tMXJ1pJDzdWnMiQ8mvyOk6kRJfqizqZVYZ3uDT87rlKdpuoucb7LIeZ30Bsg5PShD/N6ikFPO8i0/NMu3KOTsJEvC5Cl4m0POtyDVO3xyXqcUTdMl57vOsLM5cr6LyTprkfM6iJzvQpvXGcisRuVgwbtQWtDbsiQxcr1HIWcXacyJDyb/PUj1PiX5oc6mVmKd7QM+OZOVp2mhi5wfssiZLL0Bci4MyhC/jyjklLP8yA/N8iMKOd+XJWHyFHTlkPMjSNWNT85kpWiBLjk/doafmCPnx5jsEy1yJkPk/BjavE+AzGpUDhb8U0oL6ipLEiPXZxRyfiqNOfHB5H8GqbpTkh/qbGol1tl68MlZVHmaqrnI2ZNFzqLSGyBntaAM8UujkFPOMs0PzZJysX9cd1kSJk+Bn0PONEiVzidnUaWoqi45eznD3ubI2QuT9dYiZ1GInL2gzesNZFajcrDgfSgtyC9LEiNXXwo5+0hjTnww+X0hVT9K8kOdTa3EOlt/PjmvVZ6mzi5yfs4i57XSGyBn56AM8RtAIaec5QA/NMsBFHL2kyVh8hQM5JBzAKQaxCfntUrRu7rkHOwMh5gj52BMNkSLnNdC5BwMbd4QILMalYMFH0ppQQNlSWLkGkYh51BpzIkPJn8YpBpOSX6os6mVWGcbwSdnkWyRcySLnEWkN0bOkdCyRlHIKWc5CiPnKAo5h8uSMHkKRnPIOQpSjeGTswiPnGOd4Thz5ByLycZpkbMIRM6x0OaN45ATCz6e0oJGy5LEyDWBQs7x0pgTH0z+BEg1kZL8UGdTK7HONolPzmuUp2m8i5yTWeS8RnoD5BwflCF+UyjklLOc4odmOYVCzomyJEyegqkcck6BVNP45LxGKRqnS87pznCGOXJOx2QztMh5DUTO6dDmzQAyq1E5WPCZlBY0VZYkRq5ZFHLOlMac+GDyZ0Gq2ZTkhzqbWol1tjl8cl6tPE2jXOScyyLn1dIbIOeooAzxm0chp5zlPD80y3kUcs6WJWHyFMznkHMepPqCT071X4cdqUvOBc5woTlyLsBkC7XIeTVEzgXQ5i0EMqtROVjwLyktaL4sSYxciyjk/FIac+KDyV8Eqb6iJD/U2dRKrLN9zSfnVcrTtMFFzm9Y5LxKegPk3BCUIX7fUsgpZ/mtH5rltxRyfiVLwuQp+I5Dzm8h1fd8cl6lFK3XJecPzvBHc+T8AZP9qEXOqyBy/gBt3o9AZjUqBwv+E6UFfSdLEiPXzxRy/iSNOfHB5P8MqRZTkh/qbGol1tmW8MlZWHmalrrI+QuLnIWlN0DOpUEZ4hegkFPOMuCHZhmgkHOxLAmTp0BwyBmAVEv55CysFAldci5zhsvNkXMZJluuRc7CEDmXQZu3HMisRuVgwVdQWpCQJYmRayWFnCukMSc+mPyVkGoVJfmhzqZWYp1tNZ+chZSnqbCLnGtY5CwkvQFyFg7KEL+1FHLKWa71Q7NcSyHnKlkSJk/BOg4510Kq9XxyFlKKCumSc4Mz3GiOnBsw2UYtchaCyLkB2ryNQGY1KgcLvonSgtbJksTItZlCzk3SmBMfTP5mSLWFkvxQZ1Mrsc62lU/OK5Wnab6LnNtY5LxSegPknB+UIX7bKeSUs9zuh2a5nULOLbIkTJ6CHRxybodUO/nkvFIpmqdLzl3OcLc5cu7CZLu1yHklRM5d0ObtBjKrUTlY8D2UFrRDliRGrr0Ucu6Rxpz4YPL3Qqp9lOSHOptaiXW2X/nkvEJ5mrq5yLmfRc4rpDdAzm5BGeJ3gEJOOcsDfmiWByjk3CdLwuQpOMgh5wFIdYhPziuUoq665DzsDI+YI+dhTHZEi5xXQOQ8DG3eESCzGpWDBT9KaUEHZUli5DpGIedRacyJDyb/GKQ6Tkl+qLOplVhnO8EnZ0HlaarsIudJFjkLSm+AnJWDMsTvFIWccpan/NAsT1HIeVyWhMlTcJpDzlOQ6jc+OQsqRZV0yfm7M/zDHDl/x2R/aJGzIETO36HN+wPIrEblYMH/pLSg07IkMXL9RSHnn9KYEx9M/l+Q6gwl+aHOplZine1vPjkLKE+T30XOf1jkLCC9AXL6gzLE7yyFnHKWZ/3QLM9SyHlGloTJU/Avh5xnEVV8Dj45CyhFaZrkjLecoW2MnPEWJrO1yFkAIWe8BW2eDWQ2+5UDBvdQWtC/siQhcsXHMMgZ75HGnPhg8mMgVU5K8kOdTa2EOlu8l0/O/MrT1NYhZ3wsi5z5pTdAzrZBGVKGuSjklLPM5YdmmYtBzvicsiRMnoI4Cjnjc0GqeD458ytFbXTJmeAME82RMwGTJWqRMz9EzgRo8xKBzGpUDhY8N6MFxcfJksTI5aOQM7c05sQHk++DVEmU5Ic6m1qJdbY8fHLmU56mRS5y5mWRM5/0Bsi5KChD8puPQk45y3x+aJb5KORMkiVh8hTk55AzH6QqwCenehe+1CVnQWd4hTlyFsRkV2iRMx9EzoLQ5l0BZFajcrDgV1Kat3xZXAAjVyEKOa+Uxpz4YPILQarClOSHOptaiXW2q/jkzKs8Tckucl7NImde6Q2QMzkoQ/J7DYWccpbX+KFZXkMhZ2FZEiZPQREOOa+BVNfyyZlXKSqqS86izjDZHDmLYrJkLXLmhchZFNq8ZCCzGpWDBb+O0ryLyJLEyHU9hZzXSWNOfDD510OqGyjJD3U2tRLrbMX45MyjPE2JLnIWZ5Ezj/QGyJkYlCH5LUEhp5xlCT80yxIUct4gS8LkKSjJIWcJSFWKT071M5sEXXKWdoY3miNnaUx2oxY580DkLA1t3o1AZjUqBwt+E6V5l5QliZHrZgo5b5LGnPhg8m+GVLdQkh/qbGol1tlu5ZMzSXmaWrvIeRuLnPLd+m0AOVsHZUh+y1DIKWdZxg/NsgyFnLfIkjB5CspyyFkGUpXjk1P9mUwrXXLe7gzvMEfO2zHZHVrkTILIeTu0eXcAmdWoHCz4nZTmXVaWJEauuyjkvFMac+KDyb8LUt1NSX6os6mVWGe7h09On/I05XWR814WOX3SGyBn3qAMye99FHLKWd7nh2Z5H4Wcd8uSMHkK7ueQ8z5I9QCfnOqvUuTRJeeDzvAhc+R8EJM9pEVOH0TOB6HNewjIrEblYMEfpjTv+2VJYuR6hELOh6UxJz6Y/EcgVXlK8kOdTa3EOtujfHKqv6eWw0XOx1jkzC29oQnHV6AwUcavkEahXXm5jSYrtyKHdhUg1eMamw8sSRqn8Us9MVulXolV6vJZfiWs1CtTSl3Gr6xT6krn4D5W9hsq4sve7QT1PFy7XYW12wnSGzuBVaCaqEqpCTnLqtjOVaU0SVk5VTFwVoRmWY1R38EsVUvjvGqpBqmeoLxqCRFKrcQIVZ3SXJ6QxljbrAYckUuaS65eTnPZnKPohSBWhCjCW/+8KpJIqhqcU0UUSVVKUBVZJFUNXYu3wqoaOSorvFfjiyorQsQmIZUVaV5NM2yKlaWq2aUqK2uv5peorDARW7hVVrh5vZxFsViZVK9kVlmZvVpmUllZRGyVUWVlNa/WYYrYukTVJmuVdalX2yxVVoaIr2alsjLOKzXC4bIuqtqFV1mOV/uwKssVsUM4leWe12uKQ2+dU70eWWWd9+oYUWVdiNgpksoKzesNpBl531KqLOn1tkplBSO+AzRW/EFQjuRsPTXydxldPjU1pdPmHMkivoaIrynia4n4J0V8bRH/lIh/WsTXEfHPiPi6Iv5ZEf+ciH9exL8g4uuJ+BdF/Esivr6IbyDiU0R8QxHfSMQ3FvHyZVdTEd9MxDcX8S1E/Msi/hUR31LEtzL3JKpGLkhWE5PVwmRPYrLamOwpTPY0JquDyZ7BZHUx2bOY7DlM9jwmewGT1cNkL2KylzBZfUzWAJOlYLKGmKwRJmuMyZpgsqaYrBkma47JWmCylzHZK5isJSZrleHZeO/wr7zTLryola98nwmrauN3VHXDqea1dameRV7r53kwu2+HMixkdha2MnjDS1QV5mStauRW1awYRtUYWkj57C5kc477o28ULqiibxRCqugbhZAq+kYhNK//wRsF6DlNDeiT1JpKVbDJ1lKpzrXiJyOr0s837NoRVacutPWnIqm2h5r/0xFUj15ERJ0wqo6XgOS5rFWVLsXN81mq9mWA0gtZqcplRFe9LFQlMwHuxcyqepkx+FImVd0sYFk/o6pzVkhtkEHVOUvwprhUc2uFw3MTR1VqXlhV04uqoaXDq5qFVGWGRVA1v6DaXjaSqsV51as7IqpePqeqnhpZFWRHmUY1FKogO25rrFK1QrpJngchFfKi5/I+holvpewxK1wfw7QmfQwT30p6A9/MWhGUIX5tGB/DBGfZxg/Nsk12dy7bXzsK7pxCtFz3a0dtneGr5h72tMVkr+p87ejcsVPDsi0E3leBzGa/eNrI8NhneG35x76lMluDXcc+lXXs5dPEVODYDw7KEL92lGMvZ9nOD82yHf/Yt1SKBuke+/bOsIO5Y98ek3XQOvYtoWPfHjp2HYDManx0jAV/TeN8qV1lz2mHfXTcBprl65SPjl+Txn5j8S+zM76iLKiZrs7YkdUZ5UctHYHOODMoQ/w6UTqjnGUnPzTLTpTvpcj6ft1kfb/B+fZIJ0j1JlBIlwmPV5SiGbrweMsZvm0OHm9hsre14PEKBI+3oM17G8isRuVgwd+htKA3ZElibfldChbekcac+GDy34VUnSnJD3U2oAdCqi7ZbS7ZJ+fLytPU00XO91jkfFl6A+TsGZQhfu9TyCln+b4fmuX7FHJ2liVh8hR8kM29BI/g+5DqQz45X1aKeuiS8yNn2NUcOT/CZF21yPkyRM6PoM3rCmRWo3Kw4N0oLegDWZIYuT6mkLObNObEB5P/MaT6hJL8UGdTK7HO9in/PWcL5WlyX2b5GYucLaQ3dpnlZ9CyulPIKWfZHbvMsjuFnJ/IkjB5CnpwyNkdUvXkk7OFUqR9mWWaM/SbI2caJvNrkbMFRM40aPP8QGY1KgcLnk5pQT1kSWLk6kUhZ7o05sQHk98LUvWmJD/U2dRKrLP14ZOzufI0LXeRsy+LnM2lN0DO5UEZ4tePQk45y35+aJb9KOTsLUvC5CnozyFnP0j1OZ+czZWiZbrkHOAMB5oj5wBMNlCLnM0hcg6ANm8gkFmNysGCD6K0oP6yJDFyDaaQc5A05sQHkz8YUg2hJD/U2dRKrLMN5ZOzmfI0pbjIOYxFzmbSGyBnSlCG+A2nkFPOcrgfmuVwCjmHyJIweQpGcMg5HFKN5JOzmVLUQJeco5zhaHPkHIXJRmuRsxlEzlHQ5o0GMqtROVjwMZQWNEKWJEausRRyjpHGnPhg8sdCqnGU5Ic6m1qJdbbxfHI2VZ6m9S5yTmCRs6n0Bsi5PihD/CZSyClnOdEPzXIihZzjZEmYPAWTOOScCKkm88nZVClap0vOKc5wqjlyTsFkU7XI2RQi5xRo86YCmdWoHCz4NEoLmiRLEiPXdAo5p0ljTnww+dMh1QxK8kOdTa3EOttMPjmbKE9TFRc5Z7HIGfQGyFklKEP8ZlPIKWc52w/NcjaFnDNkSZg8BXM45JwNqebyydlEKaqsS855znC+OXLOw2TztcjZBCLnPGjz5gOZ1agcLPgXlBY0R5YkRq4FFHJ+IY058cHkL4BUCynJD3U2tRLrbF/yydlYeZqmu8i5iEXOxtIbIOf0oAzx+4pCTjnLr/zQLL+ikHOhLAmTp+BrDjm/glTf8MnZWCmapkvOb53hd+bI+S0m+06LnI0hcn4Lbd53QGY1KgcL/j2lBX0tSxIj1w8Ucn4vjTnxweT/AKl+pCQ/1NnUSqyz/cQnZyPlaVroIufPLHI2kt4AORcGZYjfYgo55SwX+6FZLqaQ80dZEiZPwRIOORdDql/45GykFC3QJWfAGQpz5AxgMqFFzkYQOQPQ5gkgsxqVgwVfSmlBS2RJYuRaRiHnUmnMiQ8mfxmkWk5JfqizqZVYZ1vBJ2dD5Wmq5iLnShY5G0pvgJzVgjLEbxWFnHKWq/zQLFdRyLlcloTJU7CaQ85VkGoNn5wNlaKquuRc6wzXmSPnWky2ToucDSFyroU2bx2QWY3KwYKvp7Sg1bIkMXJtoJBzvTTmxAeTvwFSbaQkP9TZ1Eqss23ikzNFeZo6u8i5mUXOFOkNkLNzUIb4baGQU85yix+a5RYKOTfKkjB5CrZyyLkFUm3jkzNFKXpXl5zbneEOc+Tcjsl2aJEzBSLndmjzdgCZ1agcLPhOSgvaKksSI9cuCjl3SmNOfDD5uyDVbkryQ51NrcQ62x4+ORtki5x7WeRsIL0xcu6FlrWPQk45y30YOfdRyLlbloTJU/Arh5z7INV+Pjkb8Mh5wBkeNEfOA5jsoBY5G0DkPABt3kEOObHghygt6FdZkhi5DlPIeUgac+KDyT8MqY5Qkh/qbGol1tmO8slZX3maxrvIeYxFzvrSGyDn+KAM8TtOIaec5XE/NMvjFHIekSVh8hSc4JDzOKQ6ySdnfaVonC45TznD0+bIeQqTndYiZ32InKegzTsNZFajcrDgv1Fa0AlZkhi5fqeQ8zdpzIkPJv93SPUHJfmhzqZWYp3tTz45X1KeplEucv7FIudL0hsg56igDPE7QyGnnOUZPzTLMxRy/iFLwuQp+JtDzjOQ6h8+OV9SikbqkvOsM/zXHDnPYrJ/tcj5EkTOs9Dm/QtkVqNyoOAJOSgt6G9ZkhC5EiwGOROCxpz4WPITLEhlU5If6mxqJdTZEjx8cr6oPE0bHHImxLDI+aL0Bsi5IShDyjAnhZxyljn90CxzMsiZYMuSMHkKvBRyJuSEVLF8cr6oFK3XJGdCLmcYZ4ycCbkwWZwWOV9EyJmQC9q8OCCzGpWDBY9ntKAEryxJjFwJFHLGS2NOfDD5CZAqkZL8UGdTK7HOlptPznrK07TURU4fi5z1pDdAzqVBGZLfJAo55SyT/NAskyjkTJQlYfIU5OGQMwlS5eWTs55SJHTJmc8Z5jdHznyYLL8WOetB5MwHbV5+ILMalYMFL0Bp3nlkSWLkKkghZwFpzIkPJr8gpLqCkvxQZ1Mrsc52JZ+cLyhPU2EXOQuxyPmC9AbIWTgoQ/JbmEJOOcvCfmiWhSnkvEKWhMlTcBWHnIUh1dV8cr6gFBXSJec1zrCIOXJeg8mKaJHzBYic10CbVwTIrEblYMGvpTTvq2RJYuQqSiHntdKYEx9MflFIlUxJfqizqZVYZ7uOT87nladpvouc17PI+bz0Bsg5PyhD8nsDhZxyljf4oVneQCFnsiwJk6egGIecN0Cq4nxyPq8UzdMlZwlnWNIcOUtgspJa5HweImcJaPNKApnVqBwseClK8y4mSxIjV2kKOUtJY058MPmlIdWNlOSHOptaiXW2m/jkfE55mrq5yHkzi5zPSW+AnN2CMiS/t1DIKWd5ix+a5S0Uct4oS8LkKbiVQ85bINVtfHI+pxR11SVnGWdY1hw5y2CyslrkfA4iZxlo88oCmdWoHCx4OUrzvlWWJEau2ynkLCeNOfHB5N8Oqe6gJD/U2dRKrLPdySfns8rTVNlFzrtY5HxWegPkrByUIfm9m0JOOcu7/dAs76aQ8w5ZEiZPwT0cct4Nqe7lk/NZpaiSLjnvc4b3myPnfZjsfi1yPguR8z5o8+4HMqtROVjwByjN+x5Zkhi5HqSQ8wFpzIkPJv9BSPUQJfmhzqZWYp3tYT456ypPk99FzkdY5KwrvQFy+oMyJL/lKeSUsyzvh2ZZnkLOh2RJmDwFj3LIWR5SPcYnZ12lKE2XnBWcYUVz5KyAySpqkbMuRM4K0OZVBDKrUTlY8McpzftRWZIYuSpRyPm4NObEB5NfCVJVpiQ/1NnUSqyzVeGT8xnlaWrrImdVFjmfkd4AOdsGZUh+q1HIKWdZzQ/NshqFnPLNbBWTp+AJDjmrQarqfHI+oxS10SVnDWdY0xw5a2CymlrkfAYiZw1o82oCmdWoHCx4LUrzfkKWJEauJynkrCWNOfHB5D8JqWpTkh/qbGol1tme4pOzjvI0LXKR82kWOetIb4Cci4IyJL91KOSUs6zjh2ZZh0LO2rIkTJ6CZzjkrAOp6vLJqd6FL3XJ+awzfM4cOZ/FZM9pkbMORM5noc17DsisRuVgwZ+nNG/5srguRq4XKOR8Xhpz4oPJfwFS1aMkP9TZ1Eqss73IJ+fTytOU7CLnSyxyPi29AXImB2VIfutTyClnWd8PzbI+hZz1ZEmYPAUNOOSsD6lS+OR8WikqqkvOhs6wkTlyNsRkjbTI+TREzobQ5jUCMqtROVjwxpTm3UCWJEauJhRyNpbGnPhg8ptAqqaU5Ic6m1qJdbZmfHI+pTxNiS5yNmeR8ynpDZAzMShD8tuCQk45yxZ+aJYtKORsKkvC5Cl4mUPOFpDqFT451c9sEnTJ2dIZtjJHzpaYrJUWOZ+CyNkS2rxWQGY1KgcL3prSvF+WJYmRqw2FnK2lMSc+mPw2kKotJfmhzqZWYp3tVT45aytPU2sXOVNZ5JTv1lMBcrYOypD8tqOQU86ynR+aZTsKOeUHqK+aPAXtOeRsB6k68Mmp/kymlS45X3OGr5sj52uY7HUtctaGyPkatHmvA5nVqBwseEdK824vSxIjVycKOTtKY058MPmdINUblOSHOptaiXW2N/nkfFJ5mvK6yPkWi5xPSm+AnHmDMiS/b1PIKWf5th+a5dsUcr4hS8LkKXiHQ863IdW7fHKqv0qRR5ecnZ1hF3Pk7IzJumiR80mInJ2hzesCZFajcrDg71Ga9zuyJDFyvU8h53vSmBMfTP77kOoDSvJDnU2txDrbh3xyqr+nlsNFzo9Y5KwlvaEJJ3SlMFHG75pGod0HchtNVm43Du26QqqPNTYfWJI0TuOXes1slfonrFKvKb2xUv+UUuoy/qc6pa50Du7jp35DRXzZu11DPQ/Xbn/G2u0a0hs7gZ9BNdGdUhNylt2xnetOaZKycrpj4OwGzbIHo76DWeqRxnnV0gNS9aS8agkRSq3ECMVpLj2lMdY2ewBH5JLmkqtXNpuLtwuwRPwtWY7kbL1/83cZXT41NaXT5hzJIsEvEtJFQi+R0Fsk9BEJfUVCP5HQXyR8LhIGiISBImGQSBgsEoaIhKEiYZhIGC4SRoiEkSJhlEgYLRLGiISxImGcSBgvEiaIhIkiYZJImCwSpoiEqSJhmrn3hP5ckCwdk/XCZL0xWR9M1heT9cNk/THZ55hsACYbiMkGYbLBmGwIJhuKyYZhsuGYbAQmG4nJRmGy0ZhsDCYbi8nGYbLxmGwCJpuIySZhssmYbAomm4rJpmV4StU7PAPTLuBFMujzsKo2fkc1IJxqXluXaiBC3TzZ/oWrDAuZnYWtDD76ElWFOVmrxrhVNSuGUY2FFpLdX65J25yjCAZt6NUL8GRcLkX9lD+44F4q1bm09I6sSj+fvD4RVacupLhvJNX20Eb0i6B69OJ29Q+j6njJpg7KWlXp0q0fnKVqX4YCGZKVqlzGMhqahapkpmIblllVL3NJDs+kqptF4Y7IqOqcVXmPzKDqnOUhGOVSza0V7qiMc1Sl5oVVjb+oGlo6vGpCSFVmWATVxAuq7WUjqSadV726I6Jq8jlV9dTIqilBVaMaCtVUqbqtsUo1DekAeZ6EVHXoDycSpil7zArXw4nppIcTCdOkN/B55YqgDPGbwXg4EZzlDD80yxnZ3blsfxgX3DmFaLnuh3EzneEsc2+8ZmKyWTofxp07dmpYzoTAOwvIbPaLZ4YMjz3Zmsk/9lOV2RrsOvazWcdevrOfDRz7wUEZ4jeHcuzlLOf4oVnO4R/7qUrRIN1jP9cZzjN37Odisnlax34qdOznQsduHpBZjQeqWPD5lM+zZM+Zgz1QnQHN8gvKA9X50thvLP5ldsYpyoKa6eqMC1idUT72XAB0xplBGeK3kNIZ5SwX+qFZLqR8WiPr+wuT9f0l5zOVhZBqEf0LXMHiVohm6MLjK2f4tTl4fIXJvtaCxxQIHl9Bm/c1kFmNysGCf0NpQV/KksTa8rcULHwjjTnxweR/C6m+oyQ/1NmAHgipvs9uc8k+OScrT1NPFzl/YJFTfmb4A0DOnkEZ4vcjhZxylj/6oVn+SCHnd7IkTJ6CnzhfBvsRUv3MJ+dkpaiHLjkXO8Ml5si5GJMt0SLnZIici6HNWwJkVqNysOC/UFrQT7IkMXIFKOT8RRpz4oPJD0AqQUl+qLOplVhnW8p/zzlJeZrcVzwtY5FzkvTGrnhaBi1rOYWccpbLsSuellPIKWRJmDwFKzjkXA6pVvLJOUkp0r7iaZUzXG2OnKsw2Wotck6CyLkK2rzVQGY1KgcLvobSguRHZysxcq2lkHONNObEB5O/FlKtoyQ/1NnUSqyzreeTc6LyNC13kXMDi5wTpTdAzuVBGeK3kUJOOcuNfmiWGynkXCdLwuQp2MQh50ZItZlPzolK0TJdcm5xhlvNkXMLJtuqRc6JEDm3QJu3FcisRuVgwbdRWtAmWZIYubZTyLlNGnPig8nfDql2UJIf6mxqJdbZdvLJOUF5mlJc5NzFIucE6Q2QMyUoQ/x2U8gpZ7nbD81yN4WcO2RJmDwFezjk3A2p9vLJOUEpaqBLzn3O8Fdz5NyHyX7VIucEiJz7oM37FcisRuVgwfdTWtAeWZIYuQ5QyLlfGnPig8k/AKkOUpIf6mxqJdbZDvHJOV55mta7yHmYRc7x0hsg5/qgDPE7QiGnnOURPzTLIxRyHpQlYfIUHOWQ8wikOsYn53ilaJ0uOY87wxPmyHkck53QIud4iJzHoc07AWRWo3Kw4CcpLeioLEmMXKco5DwpjTnxweSfglSnKckPdTa1Eutsv/HJOU55mqq4yPk7i5zjpDdAzipBGeL3B4WccpZ/+KFZ/kEh52lZEiZPwZ8ccv4Bqf7ik3OcUlRZl5xnnOHf5sh5BpP9rUXOcRA5z0Cb9zeQWY3KwYL/Q2lBf8qSxMh1lkLOf6QxJz6Y/LOQ6l9K8kOdTa2EOltiDj45xypP03SHnIkWi5xjpTdAzulBGeCXaFPIKWdp+6FZ2hRy/itLwuApSPRQyJloQ6oYPjnHKkXTNMmZmNMZeo2RMzEnJvNqkXMsQs7EnNDmeYHMalQOFjyW0YISPbIkIXIl5mKQMzFWGnPig8nPBaniKP0/1NnUSqyzxfPJOUZ5mha6yJnAIucY6Q2Qc2FQhpRhIoWccpaJfmiWiQxyJsbJkjB5CnJzyJkIqXx8co5RihbokjPJGeYxR84kTJZHi5xj0hFyJkGblwfIrEblYMHzUsiZW5YkRq58FHLmlcac+GDy80Gq/JTkhzqbWol1tgJ8co5WnqZqLnIWZJFztPQGyFktKEPyewWFnHKWV/ihWV5BIWd+WRImT8GVHHJeAakK8ck5WimqqkvOws7wKnPkLIzJrtIi52iInIWhzbsKyKxG5WDBr6Y07ytlSWLkuoZCzqulMSc+mPxrIFURSvJDnU2txDrbtXxyjlKeps4uchZlkXOU9AbI2TkoQ/KbTCGnnGWyH5plMoWcRWRJmDwF13HImQyprueTc5RS9K4uOW9whsXMkfMGTFZMi5yjIHLeAG1eMSCzGpWDBS9Oad7XyZLEyFWCQs7i0pgTH0x+CUhVkpL8UGdTK7HOVopPzpHZImdpFjlHSm+MnKWh/N5IIaec5Y0YOW+kkLOkLAmTp+AmDjlvhFQ388k5kkfOW5zhrebIeQsmu1WLnCMhct4Cbd6tHHJiwW+jNO+bZEli5CpDIedt0pgTH0x+GUhVlpL8UGdTK7HOVo5PzhHK0zTeRc7bWeQcIb0Bco4PypD83kEhp5zlHX5olndQyFlWloTJU3Anh5x3QKq7+OQcoRSN0yXn3c7wHnPkvBuT3aNFzhEQOe+GNu8eILMalYMFv5fSvO+UJYmR6z4KOe+Vxpz4YPLvg1T3U5If6mxqJdbZHuCTc7jyNI1ykfNBFjmHS2+AnKOCMiS/D1HIKWf5kB+a5UMUct4vS8LkKXiYQ86HINUjfHIOV4pG6pKzvDN81Bw5y2OyR7XIORwiZ3lo8x4FMqtROVjwxyjN+2FZkhi5KlDI+Zg05sQHk18BUlWkJD/U2dRKrLM9zifnMOVp2uAiZyUWOYdJb4CcG4IyJL+VKeSUs6zsh2ZZmULOirIkTJ6CKhxyVoZUVfnkHKYUrdclZzVn+IQ5clbDZE9okXMYRM5q0OY9AWRWo3Kw4NUpzbuKLEmMXDUo5KwujTnxweTXgFQ1KckPdTa1EutstfjkHKo8TUtd5HySRc6h0hsg59KgDMlvbQo55Sxr+6FZ1qaQs6YsCZOn4CkOOWtDqqf55ByqFAldctZxhs+YI2cdTPaMFjmHQuSsA23eM0BmNSoHC16X0ryfkiWJketZCjnrSmNOfDD5z0Kq5yjJD3U2tRLrbM/zyTlEeZoKu8j5AoucQ6Q3QM7CQRmS33oUcspZ1vNDs6xHIedzsiRMnoIXOeSsB6le4pNziFJUSJec9Z1hA3PkrI/JGmiRcwhEzvrQ5jUAMqtROVjwFErzflGWJEauhhRypkhjTnww+Q0hVSNK8kOdTa3EOltjPjkHK0/TfBc5m7DIOVh6A+ScH5Qh+W1KIaecZVM/NMumFHI2kiVh8hQ045CzKaRqzifnYKVoni45WzjDl82RswUme1mLnIMhcraANu9lILMalYMFf4XSvJvJksTI1ZJCzlekMSc+mPyWkKoVJfmhzqZWYp2tNZ+cg5SnqZuLnG1Y5BwkvQFydgvKkPy2pZBTzrKtH5plWwo5W8mSMHkKXuWQsy2kSuWTc5BS1FWXnO2cYXtz5GyHydprkXMQRM520Oa1BzKrUTlY8A6U5v2qLEmMXK9RyNlBGnPig8l/DVK9Tkl+qLOplVhn68gn50DlaarsImcnFjkHSm+AnJWDMiS/b1DIKWf5hh+a5RsUcr4uS8LkKXiTQ843INVbfHIOVIoq6ZLzbWf4jjlyvo3J3tEi50CInG9Dm/cOkFmNysGCv0tp3m/KksTI1ZlCznelMSc+mPzOkKoLJfmhzqZWYp3tPT45ByhPk99FzvdZ5BwgvQFy+oMyJL8fUMgpZ/mBH5rlBxRydpElYfIUfMgh5weQ6iM+OQcoRWm65OzqDLuZI2dXTNZNi5wDIHJ2hTavG5BZjcrBgn9Mad4fypLEyPUJhZwfS2NOfDD5n0CqTynJD3U2tRLrbJ/xyfm58jS1dZGzO4ucn0tvgJxtgzIkvz0o5JSz7OGHZtmDQs5PZUmYPAU9OeTsAanS+OT8XClqo0tO16FIN0dOPyZL1yLn5xA5seadDmRWo3Kw4L0ozbunLEksfm8KOXtJY058MPm9IVUfSvJDnU2txDpbXz45+ytP0yJXk+jHImd/6Q2Qc1FQhuS3P4Wccpb9/dAs+1PI2UeWhMlT8DmHnP0h1QA+OdW78KUuOQc6w0HmyDkQkw3SImd/iJwDoc0bBGRWo3Kw4IMpzVu+LB6AkWsIhZyDpTEnPpj8IZBqKCX5oc6mVmKdbRifnP2UpynZRc7hLHL2k94AOZODMiS/IyjklLMc4YdmOYJCzqGyJEyegpEcco6AVKP45OynFBXVJedoZzjGHDlHY7IxWuTsB5FzNLR5Y4DMalQOFnwspXmPlCWJkWschZxjpTEnPpj8cZBqPCX5oc6mVmKdbQKfnH2Vp8n9YGoii5x9pTdAzsSgDMnvJAo55Swn+aFZTqKQc7wsCZOnYDKHnJMg1RQ+OdXPbBJ0yTnVGU4zR86pmGyaFjn7QuScCm3eNCCzGpWDBZ9Oad6TZUli5JpBIed0acyJDyZ/BqSaSUl+qLOplVhnm8UnZx/laWrtIudsFjnlu/XZADlbB2VIfudQyClnOccPzXIOhZwzZUmYPAVzOeScA6nm8cmp/kymlS455zvDL8yRcz4m+0KLnH0gcs6HNu8LILMalYMFX0Bp3nNlSWLkWkgh5wJpzIkPJn8hpPqSkvxQZ1Mrsc62iE/O3srTlNdFzq9Y5OwtvQFy5g3KkPx+TSGnnOXXfmiWX1PI+aUsCZOn4BsOOb+GVN9+rw5+meRUf5Uijy45v3OG35sj53eY7HstcvaGyPkdtHnfA5nVqBws+A+U5v2NLEmMXD9SyPmDNObEB5P/I6T6iZL8UGdTK7HO9jOfnOp15XCRczGLnL2kNzThxCUUJsr4S9IotPtJbqPJyv2FQ7slkCqgsfnAkqRxGr/U07NV6oJV6unSGyv1pZRSl/GX6pS60jm4j0v9hor4snfbr56Ha7eXsXbbL72xE7gMqonllJqQs1yO7dxySpOUlbMcA+cv0CxXMOo7mKUVaZxXLSsg1UrKq5YQodRKjFCrKM1lpTTG2uYK4Ihc0lxy9cpec0H+bDr+hixHcrbevfm7jC6fmprSaXOOZJG4WiSuEYlrReI6kbheJG4QiRtF4iaRuFkkbhGJW0XiNpG4XSTuEIk7ReIukbhbJO4RiXtF4j6R+KtI3C8SD4jEgyLxkEg8LBKPiMSjIvGYSDwuEk+IxJPm3hGuzgXJ1mCytZhsHSZbj8k2YLKNmGwTJtuMybZgsq2YbBsm247JdmCynZhsFybbjcn2YLK9mGwfJvsVk+3HZAcw2UFMdgiTHcZkRzDZUUx2DJMdx2QnMNnJDM+oIjx9SrsAF0mgzWFVbfyOaks41by2LtVWhLl5GmT3ZUmGhczOwlYG//USVYU5Wav2u1U1K4ZRHYAW0ji7C9mcowiCbOiVy2ro2eIapSq43LUq1bmkrIusSj+fuvURVacuJHhDJNX20DZsjKB69OJmbQqj6njJlm7LWlXp0o3fnqVqX4by2JGVqlzGItqZhapkplLblVlVL3NB7s6kqptF2e7JqOqcVXHvzaDqnOUR2OdSza0V7qAcdFSl5oVVHbqoGlo6vOpwSFVmWATVkQuq7WUjqY6eV726I6Lq2DlV9dTIquNBVaMaCtUJqbqtsUp1EnlXkKcBpOLf2p54UtljVrgeTJwiPZhIPCm9gc8qVwRliN9pxoOJ4CxP+6FZns7uzmX7g7jgzilEy3U/iPvNGf5u7m3Xb5jsd50P4s4dOzUsf4PA+zuQ2ewXz2kZHnuq9Rv/2J9QZmuw69j/wTr28n39H8CxHxyUIX5/Uo69nOWffmiWf/KP/QmlaJDusf/LGZ4xd+z/wmRntI79CejY/wUduzNAZjUepmLB/6Z8liV7zp/Yw9TT0Cz/oTxM/Vsa+43Fv8zOeFxZUDNdnfEsqzPKh55ngc44MyhD/P6ldEY5y3/90Cz/pXxSI+v7H4P1nTsH5/OUf6HgFv3LW8HiVohmaMIjt+0MPcbgkdvGZB4teBxH4JHbhjbPA2Q2+5UDBo9htKDcwZKE2nLunAws5I6Rxpz4YPJzQiovpf+HOhvQA6FZxma3uWSfnMeUp6mnQ87cuVjkPCa9AXL2DMqQMoyjkFPOMs4PzTKOQc7cXlkSJk9BPOWLYLnjIFUCn5zHlKIeuuRMdIa5zZEzEZPl1iLnMYicidDm5QYyq1E5WHAfhZzxsiQxciVRyOmTxpz4YPKTIFUeSvJDnU2txDpbXv57zqPK0+S63il3PhY5j0pv6HonKUPym59CTjnL/ND1TsH4CjsdcuaRJWHyFBTgkDM/pCrIJ+dRpUj3eqfcVzjDK82R8wpMdqUWOY9C5LwC2rwrgcxqVA4WvBCleReQJYmRqzCFnIWkMSc+mPzCkOoqSvJDnU2txDrb1XxyHlGepuUucl7DIucR6Q2Qc3lQhuS3CIWccpZF/NAsi1DIeZUsCZOn4FoOOYtAqqJ8ch5RipbpkjPZGV5njpzJmOw6LXIegciZDG3edUBmNSoHC349pXlfK0sSI9cNFHJeL4058cHk3wCpilGSH+psaiXW2YrzyXlYeZpSXOQswSLnYekNkDMlKEPyW5JCTjnLkn5oliUp5CwmS8LkKSjFIWdJSFWaT87DSlEDXXLe6AxvMkfOGzHZTVrkPAyR80Zo824CMqtROVjwmynNu5QsSYxct1DIebM05sQHk38LpLqVkvxQZ1Mrsc52G5+ch5Snab2LnGVY5DwkvQFyrg/KkPyWpZBTzrKsH5plWQo5b5UlYfIUlOOQsyykup1PzkNK0Tpdct7hDO80R847MNmdWuQ8BJHzDmjz7gQyq1E5WPC7KM27nCxJjFx3U8h5lzTmxAeTfzekuoeS/FBnUyuxznYvn5wHlaepiouc97HIeVB6A+SsEpQh+b2fQk45y/v90Czvp5DzHlkSJk/BAxxy3g+pHuST86BSVFmXnA85w4fNkfMhTPawFjkPQuR8CNq8h4HMalQOFvwRSvN+QJYkRq7yFHI+Io058cHkl4dUj1KSH+psaiXW2R7jk/OA8jRNd5GzAoucB6Q3QM7pQRmS34oUcspZVvRDs6xIIeejsiRMnoLHOeSsCKkq8cl5QCmapkvOys6wijlyVsZkVbTIeQAiZ2Vo86oAmdWoHCx4VUrzflyWJEauahRyVpXGnPhg8qtBqicoyQ91NrUS62zV+eTcrzxNC13krMEi537pDZBzYVCG5LcmhZxyljX90CxrUsj5hCwJk6egFoecNSHVk3xy7leKFuiSs7YzfMocOWtjsqe0yLkfImdtaPOeAjKrUTlY8KcpzbuWLEmMXHUo5HxaGnPig8mvA6meoSQ/1NnUSqyz1eWT81flaarmIuezLHL+Kr0BclYLypD8Pkchp5zlc35ols9RyPmMLAmTp+B5Djmfg1Qv8Mn5q1JUVZec9Zzhi+bIWQ+TvahFzl8hctaDNu9FILMalYMFf4nSvJ+XJYmRqz6FnC9JY058MPn1IVUDSvJDnU2txDpbCp+c+5SnqbOLnA1Z5NwnvQFydg7KkPw2opBTzrKRH5plIwo5G8iSMHkKGnPI2QhSNeGTc59S9K4uOZs6w2bmyNkUkzXTIuc+iJxNoc1rBmRWo3Kw4M0pzbuxLEmMXC0o5GwujTnxweS3gFQvU5If6mxqJdbZXuGTc2+2yNmSRc690hsjZ0sov60o5JSzbIWRsxWFnC/LkjB5ClpzyNkKUrXhk3Mvj5xtneGr5sjZFpO9qkXOvRA520Kb9yqHnFjwVErzbi1LEiNXOwo5U6UxJz6Y/HaQqj0l+aHOplZina0Dn5x7lKdpvIucr7HIuUd6A+QcH5Qh+X2dQk45y9f90Cxfp5CzvSwJk6egI4ecr0OqTnxy7lGKxumS8w1n+KY5cr6Byd7UIuceiJxvQJv3JpBZjcrBgr9Fad4dZUli5HqbQs63pDEnPpj8tyHVO5TkhzqbWol1tnf55NytPE2jXOTszCLnbukNkHNUUIbktwuFnHKWXfzQLLtQyPmOLAmTp+A9Djm7QKr3+eTcrRSN1CXnB87wQ3Pk/ACTfahFzt0QOT+ANu9DILMalYMF/4jSvN+TJYmRqyuFnB9JY058MPldIVU3SvJDnU2txDrbx3xy7lKepg0ucn7CIucu6Q2Qc0NQhuT3Uwo55Sw/9UOz/JRCzm6yJEyegs845PwUUnXnk3OXUrRel5w9nGFPc+Tsgcl6apFzF0TOHtDm9QQyq1E5WHBKC8r9mSxJjFx+CjnTpDEnPph8LHg6JfmhzqZWYp2tF5+cO5WnaamLnL1Z5NwpvQFyLg3KkPz2oZBTzrKPH5plHwo502VJmDwFfTnk7AOp+vHJuVMpErrk7O8MPzdHzv6Y7HMtcu6EyNkf2rzPgcxqVA4WfAClefeVJYkdm4EUcg6Qxpz4YPIHQqpBlOSHOptaiaVoMJ+cO5SnqbCLnENY5NwhvQFyFg7KkPwOpZBTznKoH5rlUAo5B8mSMHkKhnHIORRSDeeTc4dSVEiXnCOc4Uhz5ByByUZqkXMHRM4R0OaNBDKrUTlY8FGU5j1MliTWlkdTyCk/4xnNiQ8mfzSkGkNJfqizqZVYZxvLJ+d25Wma7yLnOBY5t0tvgJzzgzIkv+Mp5JSzHO+HZjmeQs4xsiRMnoIJHHKOh1QT+eTcrhTN0yXnJGc42Rw5J2GyyVrk3A6RcxK0eZOBzGpUDhZ8CqV5T5AliZFrKoWcU6QxJz6Y/KmQahol+aHOplZinW06n5zblKepm4ucM1jk3Ca9AXJ2C8qQ/M6kkFPOcqYfmuVMCjmnyZIweQpmccg5E1LN5pNzm1LUVZecc5zhXHPknIPJ5mqRcxtEzjnQ5s0FMqtROVjweZTmPUuWJEau+RRyzpPGnPhg8udDqi8oyQ91NrUS62wL+OTcqjxNlV3kXMgi51bpDZCzclCG5PdLCjnlLL/0Q7P8kkLOL2RJmDwFizjk/BJSfcUn51alqJIuOb92ht+YI+fXmOwbLXJuhcj5NbR53wCZ1agcLPi3lOa9SJYkRq7vKOT8Vhpz4oPJ/w5SfU9JfqizqZVYZ/uBT84tytPkd5HzRxY5t0hvgJz+oAzJ708UcspZ/uSHZvkThZzfy5IweQp+5pDzJ0i1mE/OLUpRmi45lzjDX8yRcwkm+0WLnFsgci6BNu8XILMalYMFD1Ca98+yJDFyCQo5A9KYEx9MvoBUSynJD3U2tRLrbMv45NysPE1tXeRcziLnZukNkLNtUIbkdwWFnHKWK/zQLFdQyLlUloTJU7CSQ84VkGoVn5yblaI2uuRc7QzXmCPnaky2RoucmyFyroY2bw2QWY3KwYKvpTTvlbIkMXKto5BzrTTmxAeTvw5SrackP9TZ1Eqss23gk3OT8jQtcpFzI4ucm6Q3QM5FQRmS300UcspZbvJDs9xEIed6WRImT8FmDjk3QaotfHKqd+FLXXJudYbbzJFzKybbpkXOTRA5t0Kbtw3IrEblYMG3U5q3fFm8BSPXDgo5t0tjTnww+Tsg1U5K8kOdTa3EOtsuPjk3Kk9Tsoucu1nk3Ci9AXImB2VIfvdQyClnuccPzXIPhZw7ZUmYPAV7OeTcA6n28cm5USkqqkvOX53hfnPk/BWT7dci50aInL9Cm7cfyKxG5WDBD1Ca915Zkhi5DlLIeUAac+KDyT8IqQ5Rkh/qbGol1tkO88m5QXmaEl3kPMIi5wbpDZAzMShD8nuUQk45y6N+aJZHKeQ8JEvC5Ck4xiHnUUh1nE9O9TObBF1ynnCGJ82R8wQmO6lFzg0QOU9Am3cSyKxG5WDBT1Ga9zFZkhi5TlPIeUoac+KDyT8NqX6jJD/U2dRKrLP9zifneuVpau0i5x8scsp3638A5GwdlCH5/ZNCTjnLP/3QLP+kkPM3WRImT8FfHHL+CanO8Mmp/kymlS45/3aG/5gj59+Y7B8tcq6HyPk3tHn/AJnVqBws+FlK8/5LliRGrn8p5DwrjTnxweT/i6h8OSjJD3U2tRLqbD6LT851ytOU1yGnz2aRc530BsiZNygD/HweCjnlLD1+aJYeBjl9wZIweQpiKOT0eSBVTj451V+lyKNJTp/XGcYaI6fPi8litci5DiGnzwttXiyQWY3KwYLnYrQgX4wsSYhcvjgGOX25pDEnPpj8OEgVT0l+qLMplWBnS+CTU/09tRwuciayyLlWekMT9uWmMFHGBy6S1qFdvNxGk5Xr49AuN6RK0th8YEnSOI1f6muyVep5WKW+RnpjpZ6XUuoyfl6dUlc6B/cxr99QEV/2bq9Wz8O12/lYu71aemMnMB9UE/kpNSFnmR/bufyUJikrJz8ETp8PmmUBRn0Hs1QgjfOqpQCkKkh51RIilFqJEeoKSnMpKI2xtlkAOCKXNBe7V5fR5VNTUzptzrEd6QM5oqKoKCqKiv7vRTnBlz/eUUg8zGqkOasR5qyGm7MaZs5qqDmrIeasBpuzGmTOaqA5qwHmrD43Z9XfnFU/c1Z9zVn1MWfV25xVL3NW6eas/Oas0sxZ9TRn1cOcVXdzVp+Zs/rUnNUn5qw+NmfVzZxVV3NWH5mz+tCYVew+c1Z7zVntMWe125zVLnNWO81Z7TBntd2c1TZzVlvNWW0xZ7XZnNUmc1YbzVltMGe13pzVOnNWa81ZrTFntdqc1SpzVivNWa0wZ7XcnNUyc1ZLzVkJc1YBc1a/mLNaYs5qsTmrn41Zxd1ozqq0OatS5qxKmrMqYc6quDmrYuasbjBndb05q+vMWSWbsypqzupac1ZFzFldY87qanNWV5mzKmzOqpA5qyvNWV1hzqqgOasC5qzym7PKZ84qrzmrPOasksxZ+cxZ5TZnlWjOKsGYVXwrc1YtzVm9Ys7qZXNWLcxZNTdn1cycVVNzVk3MWTU2Z9XInFVDc1Yp5qwamLOqb87qJXNWL5qzqmfO6gVzVs+bs3rOnNWz5qzqmrN6xpxVHXNWT5uzesqcVW1zVk+as6plzqqmOasaxqwSppmzmmrOaoo5q8nmrCaZs5pozmqCOavx5qzGmbMaa85qjDmr0easzH0HMsHcdyATzH0HMsHcdyATzH0HMsHcdyATzH0HMsHcdyATzH0HMsHcdyATzH0HMsHcdyATzH0HMsHcdyATzH0HMsHcdyATzH0HMsHcdyAT0s1ZmfsOZOJJc1YnzFkdN2d1zJzVUXNWR8xZHTZndcic1UFzVgfMWe03Z/WrOStz34FMNPcdyERz34FMNPcdyERz34FMNPcdyERz34FMNPcdyERz34FMNPcdyERz34FMNPcdyERz34FMNPcdyERz34FMNPcdyERz34FMNPcdyERz34FMBL4DmY2bonJsz444h//iL1HnEb4rha+Q8BUWvquE72rhu0b4igjftcJXVPiShe864bte+G4QvmLCV1z4Spi7eqpoMiRLxmTXYbLrMdkNmKwYJiuOyUokX3odAVRIPuDLHjq2hTi2hTm2V3Fsr+bYXsOxLcKxvVZ5idvfl9r2SQeunvAOTwcuh/OOUKpyBH/tWaUKLsQ7Clpu0exmEVvuYGi5Q6DlDoWWOwxabnJ2l9sLCj4ICn6dVF1z+OrTMzwF+pSwD214+Nt/XigUU/Hm05XHNGmcVmrqoCbN1os88Zwd6QPtSF9oR/pBSekPJeV6znL90HLToeViNdAbWu4NnAJMg4IXk6pia7+I/X1Cz5gZ64+1ef30jb2WVOq+aOID6eKWhzo/tavvkeoij5ezIx9DO/IJtCOfQkn5DEpKcc5yP4SW+xG03K7QcrtByy2hg0311UrqXxrImcWrwulPNU8pd+ddj7Vp1TZVvihs0aZ1L/ki3XmR6K1jfuwr6X5V7n7p7X597X4R7X6l7H457H7N635h298V+A7X+E7X+C7X+G7X+B7X+F7X+D7X+P7+wldK+EoL343Cd5Pw3Sx8twjfrcJ3W/T2qKgoKoqK/p8TRW+PCllFb4/CraK3R+FW0dujcKvo7VG4VfT2KNwqensUbhW9PQq3it4ehVtFb4/CraK3R+FW0dujcKvo7VG4VfT2KNwqensUbhW9PQq3it4ehVtFb4/CraK3R+FW0dujcKvo7VG4VfT2KNwqensUbhW9PQq3it4ehVtFb4/CraK3R+FW0dujcKvo7VG4VfT2KNwqensUblXbnFX09ijYKnp7VDasordH4VbR26Nwq+jtUbhV9PYo3Cp6exRuFb09CreK3h4FW0Vvj8qGVfT2KNwqensUbhW9PQq3it4ehVtFb4/CraK3R+FW0dujiLdHPXLJ7VFlhK+s8JUTvtuF7w7hu1P47hK+u4XvHuG7V/juE777he8B4XtQ+B4SvofN3R5VBrtTqSwmK4fJbsdkd2CyOzHZXZjsbkx2Dya7F5Pdh8nux2QPYLIHMdlDmOzhZI3LLGJ3pwOXWcTuSQcus4jdmw5cZhG7D2kMvjJAY9BY7nZouTug5e6ElrsLWm7Z7C4XujwmdhsUvFw6cntRYc6OrId2ZAO0IxuhpGyCknI7Z7mroeWugZa7FlruOmi5d3AKcBUU/M505PaigpwdCUA7IqAdWQolZRmUlLs4y/0ZWu5iaLlLoOX+Ai33bspy40oiy40rhSw3rjSy3LgboeXew1nuDdByi0HLLQ4ttwS03Hsp7SXueij4fRDfSnF25GpoR66BdqQIlJRroaTcz1nuldByC0HLLQwt9ypouQ9wCvAKKPiDEN+KcXYkCdqRPNCO5IWSkg9KykOc5SZAy02ElpsbWq4PWu7DwHKzf42er4z7GYH7QYD73b77Lb37fbv7zbn7Hbj7bbb7vbT7DbP7XbH7ra/7/a37Taz7narrGj1fKde4tGt8o2t8k2t8s2t8i2t8q2t8W3/he0T4ygvfo8L3mPBVEL6Kwve48FWKXqMXFUVFUdH/c6LoNXohq+g1erhV9Bo93Cp6jR5uFb1GD7eKXqOHW0Wv0cOtotfo4VbRa/Rwq+g1erhV9Bo93Cp6jR5uFb1GD7eKXqOHW0Wv0cOtotfo4VbRa/Rwq+g1erhV9Bo93Cp6jR5uFb1GD7eKXqOHW0Wv0cOtotfo4VbRa/Rwq+g1erhV9Bo93Cp6jR5uFb1GD7eKXqOHW0Wv0cOtapuzil6jB1tFr9HLhlX0Gj3cKnqNHm4VvUYPt4peo4dbRa/Rw62i1+jhVtFr9GCr6DV62bCKXqOHW0Wv0cOtotfo4VbRa/Rwq+g1erhV9Bo93Cp6jR7xGr3Ol1yjV1n4qghfVeGrJnxPCF914ashfDWFr5bwPSl8tYXvKeF7WvjqCN8zwlfX3DV6lbFL0qpgsqqYrBomewKTVcdkNTBZTUxWC5M9iclqY7KnMNnTmKwOJnsGk9XVuUYv/uV04NaJ+FfSgVsn4lumA7dOxLdCGoOvMtAYNJbbFFpuM2i5zaHltoCWWyW7y4VueYlvAgWvmo5cM1SesyMvQTtSH9qRBlBSUqCkVOMs93louS9Ay60HLfdFaLlPcArwOSh49XTkmqEHOTtSG9qRp6AdeRpKSh0oKTU4y60BLbcmtNxa0HKfhJZbk7LchMnIchOmIMtNmIosN2EatNxanOWOh5Y7AVruRGi5k6DlPklpLwnjoOC1Ib7V4ezIcGhHRkA7MhJKyigoKU9xljsYWu4QaLlDoeUOg5b7NKcAB0HB60B8e5KzI32gHekL7Ug/KCn9oaQ8w1muH1puOrRcrAZ6Q8sFvkymc41eZfczAveDAPe7ffdbevf7dvebc/c7cPfbbPd7afcbZve7YvdbX/f7W/ebWPc7Vfc1eo+4xuVd40dd48dc4wqucUXX+HHXuFJ/4XtW+J4TvueF7wXhqyd8LwrfS8JXP3qNXlQUFUVF/8+Jotfohayi1+jhVtFr9HCr6DV6uFX0Gj3cKnqNHm4VvUYPt4peo4dbRa/Rw62i1+jhVtFr9HCr6DV6uFX0Gj3cKnqNHm4VvUYPt4peo4dbRa/Rw62i1+jhVtFr9HCr6DV6uFX0Gj3cKnqNHm4VvUYPt4peo4dbRa/Rw62i1+jhVtFr9HCr6DV6uFX0Gj3cKnqNHm4VvUYPt6ptzip6jR5sFb1GLxtW0Wv0cKvoNXq4VfQaPdwqeo0ebhW9Rg+3il6jh1tFr9GDraLX6GXDKnqNHm4VvUYPt4peo4dbRa/Rw62i1+jhVtFr9HCr6DV6xGv0vr7kGr0GwpcifA2Fr5HwNRa+JsLXVPiaCV9z4WshfC8L3yvC11L4Wglfa+FrY+4avQbYJWkpmKwhJmuEyRpjsiaYrCkma6ZzHVzisXTg9oTE4+nA7QmJJ9KB2xMSTyIF7gM+5tJZ7iFouYeh5R6BlnsUWm5KdpcL3VSReBAK3jAduS6nMWdHdkM7sgfakb1QUvZBSWnEWe52aLk7oOXuhJa7C1puY04BboOCB28tVF+XQ2oJ66Ed2QDtyEYoKZugpDTlLHc1tNw10HLXQstdBy23WXaXC71Q8jXn2Lbg2L7MsX2FY9uSY9uKY9uaY9tGx1Z5TH1tVbaxWrdHNXC/NHa//nW/yHW/knW/XHW/JnW/8HTGXtdtUN46Zsa+tu7bo551jZ9zjZ93jV9wjeu5xi+6xi+5xvX7C9+rwpcqfPJ/tBe+DsL3mvC9LnwdL709Klcv520SVhyvmn2bFpMNsZUj9Datt/B1Er43hO9N4XvL3BuwTrkg2RuY7E1M9lauzMxTrUZuA3TkOiFk9L2BkNH3JkJG31tAeVxmBab+RyrwbeF7R/jeFb7O5irwbaxm3sFk72KyzloVmApV4NtQBb4DVeC7UAV25ldgu/9IBXYRvveE733h+8BcBXbBauY9TPY+JvtAqwLbQRXYBarA96AKfB+qwA/4Fdj+P1KBHwrfR8LXVfi6mavAD7Ga+QiTdcVk3bQqsD1UgR9CFfgRVIFdoQrsxq/ADv+RCvxY+D4Rvk+F7zNzFfgxVjOfYLJPMdlnWhXYAarAj6EK/ASqwE+hCvyMX4Gv/UcqsLvw9RC+nsKXZq4Cu2M10wOT9cRkaVoV+BpUgd2hCuwBVWBPqALT+BX4+n+kAv3Cly58vYSvt7kK9GM1k47JemGy3loV+DpUgX6oAqFL1X3QJwW+3vwK7PgfqcA+wtdX+PoJX39zFdgHq5m+mKwfJuuvVYEdoQqE/oqBD/orBj7orxj4+me3Aj3ZrEArO/W3OUfRC5ZWBP35p1YKUY7zT60Uohznn1opRFL1lmupVljV247KCu/1zkWVFSHiuyGVFWlenTNsgZWlqsulKitrr/cuUVlhIr7vVlnh5vVBFqVhZVJ9mFllZfb6KJPKyiJi14wqK6t5dQtTstYlqo+zVlmXen2SpcrKEPHTrFRWxnl9FuEoWRdV3cOrLMerR1iV5YrYM5zKcs8rTXHErRwhcipEOc6TUyHKcZ6cCpFUYX+OpK9SZeU43ykVohxYp8xWZwSuyEoPOrZq27KJ8H1+8ftnxYRvgPANFL5BwjdY+IYI31DhGyZ8w4VvhPCNFL5Rwjda+MYI31jhGyd844VvgvBNFL5JwjdZ+KYI31ThmyZ804VvhvDNFL5Zwjdb+OYI31zhmyd884XvC+FbIHwLhe9LDNaX9RqlVHYSq55NseyIbb87rYuE7yvh+1r4vhG+b4XvO+H7Xvh+EL4fhe8n4ftZ+BYL3xLh+0X4AsInhG+p8C0TvuXCt0L4VgrfKuFbLXxrhG+t8K0TvvXCt0H4NgrfJuHbLHxbhG+r8G0Tvu3Ct8Pca6BFmOwrTPY1JvsGk32Lyb7DZN9jsh8w2Y+Y7CdM9jMmW4zJlmCyXzBZAJMJTLYUky3DZMsx2QpMthKTrcJkqzHZGky2FpOtw2TrMdkGTLYRk23CZJsx2RZMthWTbcNk2zHZDuvS93ibcxRHQAa9x1ukfo/3r+zXatU/sl2rVX/Kbq1WHZfNWq3aIXu1WiXh+b1aJT+Z/AF6t/ujUnVWqn5Sqv6Wqp+Vqj+karFSdUyqlihV26XqF6Xqa6kKKFWdpUpA7/uXqlRng6plKtXfQdVyleqPoGqFSnUsqFqpUm0PqlapVF8HVcrvc3YOqpTf5zz3HkH1fc4j51TrFKpD51Sqr9X+ek6l+lrt9nMq1ddql59TbVKopp1TbVao2p5TbYmsSj92TrU1ssp/XrUtsqrneZXii+GfnlcBv8Z3Sbv29zrvuj18H7bOfT1sEfS1xDzj9eK/uiNi/Dfg+BOyGT+t9//kIZp6IYu1FvJ//mxOvZAlujvyf/vIT72QX/QXEjY24UmieiGBy1xIlnMw/4BSvRBx2Qv5P3nuqV7IUhM7wn+cql7IMjMLuSQ24SmteiHLDS7k4hzMP/xVL2SF0YXQnimrF7Iymwvpde6VRfXUyK8s3pSvLILCRjUUwrcuCC/Mc25Y4dvwa5XVWis651oq/ETfcU90aIQVvesSlom09M7witbor+ica+cs43e5NPVSODvrib6XUVghzIreh1e09nJWVDNcRj/ItKJzwpKZhB9mKayX2fEjeEXrLnOPunSpm8WKumYx0c5ZLb1b1ksPCjteIvwYXtH6y17ROddKl070k3AT3ZdhRZ+GEZbLuPTP4BVtMLOic66PXozfPXzqpTDNmWiPSMI2rhX1hFe00dSK5rkzmhZxRa4HF36l8MI79nR4RZsM7tFjO05dWFEvxUS3h5beW730889Q+8Ir2mx0RaFnkv2APTr3MK7/eaFiBta5T3TBFW3J7oufzTkKYR9wI+F9O5EXSXnGQ6oJkGoxpFoCqX6BVAFIJSDVUki1DFIth1QrINVKSLUaUq2BVGshFfSL83nWQ6oNkGojpILuL8izGVJl+wgPgd6ZDIAO8C7smSf2ZBJ7T4C9zsZeu2KvB7HXWNjrFuy1AMZXjFnGOJD5s85Ztdq0a9KicZvW5Wo1SW3VoX1K+xZtWqf3dn32udM13hXmN9U7S1LvFr49wrdX+PZlevidQ1mqA+UnnBjuDmXzrPihFxBfyflj8Q9n96xiTxF2Q2f1V6idHIJUpIUMhBayH9trYzuiU/i/usb7IxT+AeE7KHyHhO+wRuEPkh/aY4V3hFL4X8v5Y/GPcurlAFQvR6CSxlSkhQyCFnIU22tjO6JT+Edc46MRCv+Y8B0XvhPCd1Kj8AcL3zdY4R2jFP43cv5Y/OOcejkG1cspqKSPQSrSQgZDCzmN7bWxHdEp/FOu8ekIhf+b8P0ufH8I358ahT9E+L7FCu8EpfC/lfPH4p/k1MtvUL38BZX0CUhFWsgQaCFnsL02tiM6hf+Xa3wmQuH/LXz/CN9Z4ftXo/CHCt93WOGdohT+d3L+WPzTnHr5GwmelAMqaYwLpIUMhRZiYXttbEc0Cj8ph2tshS/8JFskeURSjEjKqVH4w4Tve6zwfqMU/vdy/lj83yn1kmRD9eKFSvo3SMVZiG8YtJBYbK+N7YhO4Xtd49gIhZ9LJMWJpHiRlKBR+MOF7wes8P6gFP4Pcv5Y/D85hZ8LqpdEqKT/gFSchfiGQwvJje21sR3RKfxE1zh3hML3iaQkkZRHJOXVKPwRwvcjVnh/UQr/Rzl/LP4ZTuH7oHrJB5U09k6AsxDfCGgh+bG9NrYjOoWfzzXOH6HwC4ikgiLpCpF0pUbhjxS+n7DC+5tS+D/J+WPx/+EUfgGoXgpBJf03pOIsxDcSWkhhbK+N7YhO4RdyjQtHKPyrRNLVIukakVREo/BHCd/PWOGdpRT+z3L+WPx/OYV/FVQv10IlfRZScRbiGwUtpCi218Z2RKfwr3WNi0Yo/GSRdJ1Iul4k3aBR+KOFbzFUeHlzUAp/sZw/Ft/iFH4yVC/FEK+80LMf0kJ8o6GFFMf22tiO6BR+Mde4eITCLyGSSoqkUiKptEbhjxG+JVjh2ZTCXyLnj8X3cAq/BFQvN0IlbUMqzkJ8Y6CF3ITttbEd0Sn8G13jmyIU/s0i6RaRdKtIuk2j8McK3y9Y4cVQCv8XOX8sfk5O4d8M1UsZqKRjIBVnIb6x0ELKYnttbEd0Cr+Ma1w2QuGXE0m3i6Q7RNKdGoU/TvgCWOF5KYUfkPPH4sdyCr8cVC93QSUNPe0nLcQ3DlrI3dheG9sRncK/yzW+O0Lh3yOS7hVJ94mk+zUKf7zwCazwclEKX8j5Y/HjOIV/D1QvD0AlnQtScRbig77GnfQgttfGdkSn8B9wjR+MUPgPiaSHRdIjIqm8RuFPEL6lWOHFUwp/qZw/Fj+BU/gPQfXyKFTS8ZCKsxAf9JsJSY9he21sR3QK/1HX+LEIhV9BJFUUSY+LpEoahT9R+JZhhZdIKfxlcv5Y/Nycwq8A1UtlqKShz3dJC/FNhBZSBdtrYzuiU/iVXeMqEQq/qkiqJpKeEEnVNQp/kvAtxwrPRyn85XL+WPwkTuFXheqlBlTSPkjFWYhvErSQmtheG9sRncKv4RrXjFD4tUTSkyKptkh6SqPwJwvfCqzw8lAKf4WcPxY/L6fwa0H18jRU0nkgFWchvsnQQupge21sR3QK3/WHdJPqRCj8Z0RSXZH0rEh6TqPwpwjfSqzw8lEKf6WcPxY/P6fwn4Hq5XmopKFv9JAW4psCLeQFbK+N7YhO4bv+kHPSCxEKv55IelEkvSSS6msU/lThW4UVXgFK4a+S88fiF+QUfj2oXhpAJV0AUnEW4psKLSQF22tjO6JT+K4/zZ6UEqHwG4qkRiKpsUhqolH404RvNVZ4V1AKf7WcPxb/Sk7hN4TqpSlU0ldAKs5CfNOghTTD9trYjugUflPXuFmEwm8uklqIpJdF0isahT9d+NZghVeIUvhr5Pyx+IU5hd8cqpeWUElD3+EkLcQ3HVpIK2yvje2ITuG3dI1bRSj81iKpjUhqK5Je1Sj8GcK3Fiu8qyiFv1bOH4t/NafwW0P1kgqV9FWQirMQ3wxoIe2wvTa2IzqFn+oat4tQ+O1FUgeR9JpIel2j8GcK3zqs8K6hFP46OX8sfhFO4beH6qUjVNLXQCrOQnwzoYV0wvba2I7oFH5H17hThMJ/QyS9KZLeEklvaxT+LOFbjxXetZTCXy/nj8Uvyin8N6B6eQcqaehb+6SF+GZBC3kX22tjO6JT+O+4xu9GKPzOIqmLSHpPJL2vUfizhW8DVnjJlMLfIOePxb+OU/idoXr5ACrpZEjFWYhvNrSQD7G9NrYjOoX/gWv8YYTC/0gkdRVJ3UTSxxqFP0f4NmKFdz2l8DfK+WPxb+AU/kdQvXwClfT1kIqzEN8caCGfYnttbEd0Cv8T1/jTCIX/mUjqLpJ6iKSeGoU/V/g2YYVXjFL4m+T8sfjFOYX/GVQvaVBJY7+nxVmIby60EHCvje2ITuGnucb+CIWfLpJ6iSQ56KNR+POEbzOWjBKUwt8s54/FL8kp/HSoXvpCJV0CUnEW4psHLaQfttfGdkSn8Pu6xv0iFH5/kfS5SBogkgZqFP584duCFV4pSuFvkfPH4pfmFD70pwmSBkElXQpScRbimw8tZDC218Z2RKfwB7nGgyMU/hCRNFQkDRNJwzUK/wvh24oV3o2Uwt8q54/Fv4lT+NCVk0kjoJLGfjOXsxDfF9BCRmJ7bWxHdAp/hGs8MkLhjxJJo0XSGJE0VqPwFwjfNqzwbqYU/jY5fyz+LZzCx27lGAeV9M2QirMQ3wJoIeOxvTa2IzqFP841Hh+h8CeIpIkiaZJImqxR+AuFbztWeLdSCn+7nD8W/zZO4WO/uDQFKulbIRVnIb6F0EKmYnttbEd0Cn+Kazw1QuFPE0nTRdIMkTRTo/C/FL4dWOGVoRT+Djl/LH5ZTuFj3+2aBZU0dhcDZyG+L6GFzMb22tiO6BT+LNd4doTCnyOS5oqkeSJp/qX5Qp5XQPcCJM3J7lZBpZz0RWTbbYsrlrnUVvkWE/9LekkLkJVH//rdRZXRv37HqaeFYW09F211DuIXrvGCi+OSrp8ulMfwS5G0SCR9JZK+7jLx0dQWLVu2aBb07x3j7zLmqRatm7Vscn4dOVTpSfpSnZ60XmlpaqvM/UD1L4QH+otSSd8AwTOnenTt8jUqVUx3Je6bZJ2N/jZy9FFdxw3Usf0usu2+YxX/1bH9PqxtTGigVZbfusbfXRy7bmBL+l6W5Q8i6UeR9JNI+vnSufcCqgF6Sp30A5SFxSRKLnaNf3SNf3KNf5Z5WCKSfhFJAZEkLj2eOdO7jC6fmprSqZfySAULADvDwAc9mBHyUUo2u8uS/2F3SfoGqpWlhrrL0uRL99rbO3vJsv4n2c+u5TemLT3/ywpZClXIMkMVsixZZ47LoDkuNzTH5RmqODbbLyiW8TZUlQbkjtVsf9qDBLaAwDcyAiOXa97ECOwBAt+sE1hlegtyHDz9dF70q0LfykgkckvkbYzAOYHAZRiBkccAZRmBY4HA5RiBkXvhbmcEjgMC38EIjFwIdicjcAIQ+C5GYOQmqLsZgXMDge9hBEauALqXETgJCHwfIzBy98v9jMB5gcAPMAIjl348yAicHwj8ECMwctvDw4zABYHAjzACI7/mX54R+Eog8KOMwMjvdz/GCFwYCFyBERj5xd6KjMBXA4EfZwRGfqOzEiNwESBwZUZg5Ff5qjACFwUCV2UERn6Hqxoj8HVA4CcYgZFf3qnOCHwDELgG4/0+dIsj8tAp++/3azHW8yT0/GIQYw+RX4CpzVjzU4YeYWrs4dMM0zoM02cYpnUZps8yTJ9jmD7PMH2BYVqPYfoiw/Qlhml9hmkDhmkKw7Qhw7QRw7Qxw7QJw7Qpw7QZw7Q5w7QFw/RlhukrDNOWDNNWDNPWDNM2DNO2DNNXGaapDNN2DNP2DNMODNPXGKavM0w7Mkw7MUzfYJi+yTB9i2H6NsP0HYbpuwzTQGeKaxeK63sU1/cprh9QXD+kuH5Ece1Kce1Gcf2Y4voJxfVTiutnFNfuFNceFNeeFNc0iquf4ppOce1Fce1Nce1Dce1LcaV8vzDQn+L6OcV1AMV1IMV1EMV1MMV1CMV1KMV1GMV1OMV1BMV1JMV1FMV1NMV1DMV1LMV1HMV1PMV1AsV1IsV1EsV1MsV1CsV1KsV1GsV1OsV1BsV1JsV1FsV1NsV1DsV1LsV1HsV1PsX1C4rrAorrQorrlxTXRRTXryiuX1Ncv6G4fktx/Y7i+j3F9QeK648U158orj9TXBdTXJdQXH+huAYoroLiupTiSvn+bIDyjc7ACorrSorrKorraorrGorrWorrOorreorrBorrRorrJorrZorrForrVorrNorrdorrDorrTorrLorrborrHorrXorrPorrrxTX/RTXAxTXgxTXQxTXwxTXIxTXoxTXYxTX4xTXExTXkxTXUxTX0xTX3yiuv1Nc/6C4/klx/Yvieobi+jfF9R+K61mK678MV2Hl4NhaHFubY+vh2MZwbHNybL0c21iObS6ObRzHNp5jm8CxTeTY5ubY+ji2SRzbPBzbvBzbfBzb/BzbAhzbghzbKzi2V3JsC3FsC3Nsr+LYXs2xvYZjW4Rjey3HtijHNpljex3H9nqO7Q0c22Ic2+Ic2xIc25Ic21Ic29Ic2xs5tjdxbG/m2N7Csb2VY3sbx7YMx7Ysx7Ycx/Z2ju0dHNs7ObZ3cWzv5tjew7G9l2N7H8f2fo7tAxzbBzm2D3FsH+bYPsKxLc+xfZRj+xjHtgLHtiLH9nGObSWObWWOLeV2XQsKXfV/F5pyw64HCq11x67atno6cl/pEk7wGlDwbzgVXJNjW4tj+yTHtjbH9imO7dMc2zoc22c4tnU5ts9ybJ/j2D7PsX2BY1uPY/six/Yljm19jm0Djm0Kx7Yhx7YRx7Yxx7YJx7Ypx7YZx7Y5x7YFx/Zlju0rHNuWHNtWHNvWHNs2HNu2HNtXObapHNt2HNv2HNsOHNvXOLavc2w7cmw7cWzf4Ni+ybF9i2P7Nsf2HY7tuxzbzhzbLhzb9zi273NsP+DYfsix/Yhj25Vj241j+zHH9hOO7acc2884tt05tj04tj05tmkcWz/HNp1j24tj25tj24dj25dj249j259j+znHdgDHdiDHdhDHdjDHdgjHdijHdhjHdjjHdgTHdiTHdhTHdjTHdgzHdizHdhzHdjzHdgLHdiLHdhLHdjLHdgrHdirHdhrHdjrHdgbHdibHdhbHdjbHdg7Hdi7Hdh7Hdj7H9guO7QKO7UKO7Zcc20Uc2684tl9zbElfivuWY/sdx/Z7ju0PHNsfObY/cWx/5tgu5tgu4dj+wrENcGwFx3Ypx3YZx3Y5x3YFx3Ylx3YVx3Y1x3YNx3Ytx3Ydx3Y9x3YDx3Yjx3YTx3Yzx3YLx3Yrx3Ybx3Y7x3YHx3Ynx3YXx3Y3x3YPx3Yvx3Yfx/ZXju1+ju0B9S9K6dge5Mz2EMf2MMf2CMf2KMf2GMf2OMf2BMf2JMf2FMf2NMf2N47t7xzbPzi2f3Js/+LYnuHY/s2x/Ydje5Zjy7m31+bc22tz7u21Off22px7e23Ovb02595em3Nvr825t9fm3Ntrc+7ttTn39tqce3ttzr29NufeXptzb6+d7Xt7oTsh7DzpyJ0QnI8W7bycNeVD1uThfHnR5twBbHPuALY5dwDbnDuAbc4dwDbnDmCbcwewzbkD2ObcAWxz7gC2OXcA25w7gG3OHcA25w5gm3MHsM25A9jm3AFsc+4Atjl3ANucO4Btzh3ANucOYJtzB7DNuQPY5twBbHPuALY5dwDbnDuAbc4dwDbnDmCbcwewXY5jy7kD2ObcAWxz7gC2OXcA25w7gG3OHcA25w5gm3MHsM25A9jm3AFsc+4Atjl3ANucO4DtRyifwtqcO4Btzh3ANucOYJtzB7DNuQPY5twBbHPuALY5dwDbVTi2VTm21Ti2T3Bsq3Nsa3BsOXfp2py7dG3OXbp2bY4t5y5dm3OXrs25S9fm3KVrc+7StTl36dqcu3Rtzl26NucuXZtzl67NuUvX5tyla3Pu0rU5d+nanLt0bc5dujbnLl2bc5euzblL1+bcpWtz7tK1OXfp2py7dG3OXbo25y5dm3OXrs25S9fm3KVrc+7StTl36dqcu3TtVI4t5y5dm3OXrs25S9fm3KVrc+7StTl36dqcu3Rtzl26NucuXZtzl67NuUvX5tyla3Pu0rU5d+nanLt0bc5dujbnLl2bc5euzblL1+bcpWtz7tK1OXfp2py7dG3OXbo25y5dm3OXrs25S9fm3KVrc+7StTl36dqcu3TtdI4t5y5dm3OXrs25S9fm3KVrc+7StTl36dqcu3Rtzl26Nunr6Jy7dG3OXbo25y5dm3OXrs25S9fm3KVrc+7StTl36dqcu3Rtzl26NucuXZtzl67NuUvX5tyla3Pu0rU5d+nanLt0bc5dujbnLl2bc5euzblL1+bcpWvP4Nhy7tK1OXfp2py7dG3OXbo25y5dm3OXrs25S9fm3KVrc+7StTl36dqkX3jl3KVrc+7StTl36dqcu3Rtzl26NucuXZtzl67NuUvX5tyla3Pu0rU5d+nanLt0bc5dujbnLl2bc5euzblL1+bcpWtz7tK1OXfp2py7dO2VHFvOXbo25y5dm3OXrs25S9fm3KVrc+7StTl36dqcu3Rtzl26NucuXZtzl67NuUvX5tyla3Pu0rU5d+nanLt0bc5dujbnLl2bc5euzblL1+bcpWtz7tK1OXfp2gc4tpy7dG3OXbo25y5dm3OXrs25S9fm3KVrc+7StU9wbDl36dqcu3Rtzl26NucuXZtzl67NuUvX5tyla3Pu0rU5d+nanLt0bc5dujbnLl2bc5euh3OXrodzl66Hc5euh3OXrodzl66Hc5euh3OXrodzl66Hc5euh3OXrodzl66Hc5euh3OXrodzl66Hc5euJ4ljm4djm5djm49jy7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1lOOY8u5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bzCMeWc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rac2x5Zz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/62Hc/+th3P/rYdz/60nlWPLuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9bDuf/Ww7n/1sO5/9YD3X9bvUmrNqmdqrRu0b5Xrc2epqVvvOnmW269rUzZcrffceddd99z7333P/DgQw8/Uv7RxypUfLxS5SpVqz1RvUbNWk/WfurpOs/Uffa551+o9+JL9RukNGzUuEnTZs1bvPxKy1at27R9NbVd+w6vvd6x0xtvvvX2O+8GOge6BN4LvB/4IPBh4KNA10C3wMeBTwKfBj4LdA/0CPQMpAX8gfRAr0DvQJ9A30C/QP/A54EBgYGBQYHBgSGBoYFhgeGBEYGRgVGB0YExgbGBcYHxgQmBiYFJgcmBKYGpgWmB6YEZgZmBWYHZgTmBuYF5gfmBLwILAgsDXwYWBb4KfB34JvBt4LvA94EfAj8Gfgr8HFgcWBL4JRAIiMDSwLLA8sCKwMrAqsDqwJrA2sC6wPrAhsDGwKbA5sCWwNbAtsD2wI7AzsCuwO7AnsDewL7Ar4H9gQOBg4FDgcOBI4GjgWOB44ETgZOBU4HTgd8Cvwf+CPwZ+CtwJvB34J/A2cC/wsohLEtYtrA8wooRVk5heYUVK6xcwooTVrywEoSVKKzcwvIJK0lYeYSVV1j5hJVfWAWEVVBYVwjrSmEVElZhYV0lrKuFdY2wigjrWmEVFVaysK4T1vXCukFYxYRVXFglhFVSWKWEVVpYNwrrJmHdLKxbhHWrsG4TVhlhlRVWOWHdLqw7hHWnsO4S1t3CukdY9wrrPmHdL6wHhPWgsB4S1sPCekRY5YX1qLAeE1YFYVUU1uPCqiSsysKqIqyqwqomrCeEVV1YNYRVU1i1hPWksGoL6ylhPS2sOsJ6Rlh1hfWssJ4T1vPCekFY9YT1orBeElZ9YTUQVoqwGgqrkbAaC6uJsJoKq5mwmgurhbBeFtYrwmoprFbCai2sNsJqK6xXhZUqrHbCai+sDsJ6TVivC6ujsDoJ6w1hvSmst4T1trDeEda7wuosrC7Cek9Y7wvrA2F9KKyPhNVVWN2E9bGwPhHWp8L6TFjdhdVDWD2FlSYsv7DShdVLWL2F1UdYfYXVT1j9hfW5sAYIa6CwBglrsLCGCGuosIYJa7iwRghrpLBGCWu0sMYIa6ywxglrvLAmCGuisCYJa7KwpghrqrCmCWu6sGYIa6awZglrtrDmCGuusOYJa76wvhDWAmEtFNaXwlokrK+E9bWwvhHWt8L6TljfC+sHYf0orJ+E9bOwFgtribB+EVZAWEJYS4W1TFjLhbVCWCuFtUpYq4W1RlhrhbVOWOuFtUFYG4W1SVibhbVFWFuFtU1Y24W1Q1g7hbVLWLuFtUdYe4W1T1i/Cmu/sA4I66CwDgnrsLCOCOuosI4J67iwTgjrpLBOCeu0sH4T1u/C+kNYfwrrL2GdEdbfwvpHWGeF9a+wcwjbErYtbI+wY4SdU9heYccKO5ew44QdL+wEYScKO7ewfcJOEnYeYecVdj5h5xd2AWEXFPYVwr5S2IWEXVjYVwn7amFfI+wiwr5W2EWFnSzs64R9vbBvEHYxYRcXdglhlxR2KWGXFvaNwr5J2DcL+xZh3yrs24RdRthlhV1O2LcL+w5h3ynsu4R9t7DvEfa9wr5P2PcL+wFhPyjsh4T9sLAfEXZ5YT8q7MeEXUHYFYX9uLArCbuysKsIu6qwqwn7CWFXF3YNYdcUdi1hPyns2sJ+SthPC7uOsJ8Rdl1hPyvs54T9vLBfEHY9Yb8o7JeEXV/YDYSdIuyGwm4k7MbCbiLspsJuJuzmwm4h7JeF/YqwWwq7lbBbC7uNsNsK+1Vhpwq7nbDbC7uDsF8T9uvC7ijsTsJ+Q9hvCvstYb8t7HeE/a6wOwu7i7DfE/b7wv5A2B8K+yNhdxV2N2F/LOxPhP2psD8Tdndh9xB2T2GnCdsv7HRh9xJ2b2H3EXZfYfcTdn9hfy7sAcIeKOxBwh4s7CHCHirsYcIeLuwRwh4p7FHCHi3sMcIeK+xxwh4v7AnCnijsScKeLOwpwp4q7GnCni7sGcKeKexZwp4t7DnCnivsecKeL+wvhL1A2AuF/aWwFwn7K2F/LexvhP2tsL8T9vfC/kHYPwr7J2H/LOzFwl4i7F+EHRC2EPZSYS8T9nJhrxD2SmGvEvZqYa8R9lphrxP2emFvEPZGYW8S9mZhbxH2VmFvE/Z2Ye8Q9k5h7xL2bmHvEfZeYe8T9q/C3i/sA8I+KOxDwj4s7CPCPirsY8I+LuwTwj4p7FPCPi3s34T9u7D/EPafwv5L2GeE/bew/xH2WWH/Kzw5hEci2RYej/DECE9O4fEKT6zw5BKeOOGJF54E4UkUntzC4xOeJOHJIzx5hSef8OQXngLCU1B4rhCeK4WnkPAUFp6rhOdq4blGeIoIz7XCU1R4koXnOuG5XnhuEJ5iwlNceEoIT0nhKSU8pYXnRuG5SXhuFp5bhOdW4blNeMoIT1nhKSc8twvPHcJzp/DcJTx3C889wnOv8NwnPPcLzwPC86DwPCQ8DwvPI8JTXngeFZ7HhKeC8FQUnseFp5LwVJYf7cuP4eVH5vLjbflRtPzYWH7EKz+OlR+dyo855UeS8uND+VGf/FhOfoQmP+6SH03Jj5HkRz7y4xn5UYr82EN+RCE/TpCP/uVjevlIXT7+lo+q5WNl+QhYPq6Vj1blY1D5yFI+XpSPAuVjO/mITT4Ok4+u5GMm+UhIPr6Rj1rkYxH5CEM+bpCPBuTbePmWW749lm9l5dtO+RZRvp2Tb73k2yT5lka+/ZBvFeTLevkSXL5cli9t5ctQ+ZJRvryTL8Xky6YJtZu075DaukJK+5TNOUrnsGxPTE5vbK64+ITE3L6kPHnz5S9Q8IorCxW+6uprilxbNPm6628oVrxEyVJpaZtzlEnvMqp8oxaphdKXLY89eOqXH5ulpV340VWZf/RA+rJN391Ue21Fb9HQjx7M/KOHMv9INtWsfvhvFj+0c2TxQ8/u9GX9DxUYnTgw9/PODw9k9cNjWf3wt6x++HcWP4yxs/phrqx+6Mvqh7dnMfmYO7L64Z1Z/DDn6ax++FtWP/w9ix/Gzs3qh/Oy+uH8LH4Y1ymrH76R1Q/fzOKHCfdn9cMHsvphFkUjEv/J6odZlU1iVmWTVCSL7Ui6Iasfls7qh7dl9cM7s/rh/Vn9sHxWP6yU1Q9bpy+bOKln47c7/9zl4g/z3J2+7IUF8X/1rfXzYOeHD2U+gCJPpax+WDWrHz7h+uHA9A2lUs69H6vfqE2rtintWzRs2aR+m9SURvL/ea1JarsWbVrXfz01pW3bJqmbc1zRZfRjbVq3a9+ry5gKLVKbNGpvdxlbpXX7Js2apI6sc3s59Vu5jP/eyta/71wh47/Pkb34FbqMeiylZUt/wkWfcbWbtJSLfq1J9mYi329mcrCz6zApOJfGsjc/1qZtp4tLquCek8v8/MxzX/bMKxiY+ain2rdp608PM9MMe/TY6MdbNGmp/iA4ccx5Wl1YaZ4uEx9vk9qkRbPWwf/ZZ0OxDu1btGzRvtP5pwePXSzWmudq9ZnzpZqW5u8y+fyDgPKNG6c2adfu4iz8XcY81aJV25ZNzk8nFCzDZGOylYqOFbpMfLRF65TgY4f2Ndv2Cbl4xj0hQz/dPKV10MUp1otBxlTt0KptlabpF/9BwS6Tq7RufH6mYU/IXRG+nb/xh9NrZ1Ut16rLqKflafWnO/8+dFQvrDh9TsMOLVo2rt+qXbP6DVu2afRK/eZNWgZPt1Xwf3y6B17m6R54oXKaZq7w7G1rjsczO+Q0c7oruufkMpczdy28ojMIRR1R554MosedQXhRJWcQXlTZGYQXVXEG4UVVnUF4UTVnEF70hDMIL6ruDMKLajiD8KKaziC8qJYzCC960hmEF9V2BuFFTzmD8KKnnUF4UR1nEF70jDMIL6rrDMKLnnUG4UXPOYPwouedQXjRC84gvKieMwgvetEZhBe95AzCi+o7g/CiBs4gvCjFGYQXNXQG4UWNnEF4UWNnEF7UxBmEFzV1BuFFzZxBeFFzZxBe1MIZhBe97AzCi15xBuFFLZ1BeFErZxBe1NoZhBe1cQbhRW2dQXjRq84gvCjVGYQXtXMG4UXtnUF4UQdnEF70mjMIL3rdGYQXdXQG4UWdnEF40RvOILzoTWcQXvSWMwgvetsZhBe94wzCi951BuFFgc6uUQRZF9coguw91yiC7H3XKILsA9coguxD1yiC7CPXKIKsq2sUQdbNNYog+9g1cr+6zKj7xDW6RHe57wUrXvbr3ApdRlZv81q6+1Xthblamb292Z1dlm+urJHyrZ37fZXljpDxbdQ4zbcAVobgToiL4TOv2b6QjQv/0+PemEv+S4x7ypf8l5wZ3hXI9zMtMubYcofO8N9sV01l+E8eVxmdd24fbpF25kU6byQzb6wne7n99LLfoOUJm2g7bKI9YRMdczHRl/to5NPLzk2ezA9XbLdZxocr2XN/JOO/r5C9fx8TemyS5cmMzXgyPU6yL8l9Lkdwyc/jnG3LMkD8mIqvdkhp2c4d46JXbKanKvHtuox6ok1K44s/8Dr/aLTMcmqTzJG9WUfOlXFpuZzjkOU/iMv4D+KcfzAqOE9/y0ufdwWOGnjokOHEeyM049jseefNfjOODd+MvYaacWzmPuWN0KdyZfcshgmbK3PYXO51Z9iGOPd/C2MZPyX0yNBV4lm5xzll7vxj+VIpVNBZRc0ZLmpc5oVkqtN3Mi4n1tlrtCacLck4y1j3zoVD7qWPU7NujJmz4g0MuLAEyUJ8Jz1Obw2XtYh75XFvW+ZZxQW6h0786bAB1AvO2jo9tOC0sK3gsZCkf/icPNWhYYRMX25W7Cyn3jeUlT8yT9216ouTz/S606W/IBoUQZTTEWm80KsQNncRk3DJJDMnIVdgmFMal9u8rPBnPtP2XpLhy21Q3iwb1Ghne8Pmu0KL18L0oiw+tIrLbi/P5BDvem9WNhufblw0SLjsT94S3W8PdT50zJ29KeTK/HYh84mYHG6HfOq2lNXm+wIzQtbTQi/IxmXxXiY29IIowxyTTPImCaBinpHVO7TMuETVyc+XuXzzKP9R3jFZHaZ8kXtl3sAXocN0JmOufFns58Kw0cPsp8+Zd1bRl4WMv8q0mz53ojP+xyTgZVAedYll9QIoT+D7UErOhn1rmHR5H/bKl8DnQwjLypj2PM4bnXC5zkyTPOHeQrhqKtM/yuvOSabqzufeikivtcK+tPVlDnnJq47w/cOn7B/5ssqB69+H+Wf5I5Inj3v1mSsjf2CV8uVW/jBFl+8S8mdhvT605LUZ85LX3eMviHaHjZ/Vi1DXLML8swLoC678WUy+QGCzMi/5wuQlvxuBma3zBbY5hzHc3CM+YArzjwpm/kcF3LPK2HBc+1cwwgblczYogkNS+N17qnnLsIWTO/QwN6v/mPfSx7l468h/2eWR3z2LrMrjoOulaASI5s3GrH0RGonPbXkRXJf37ZyBpr6dEzj1f/b1nMsNFPpmHz3Q1QubLH9484HN9EA5Y67+PHlqgyfogXbnqlXRnv1ZUXWgME8VPWEei2bx1NL1lCpjtcUKK/TSTVixGR9aXwwVUhQIo8j2i+UY8EGmx/kHl0SOD/NQNyHca6MLP07MIj3xrqemGdKTKKz8GTYgl/PPMjzWTXAkWT9Qzri4eMVj3YSM/yAh4+MyYSWGK8RsPs61lN/Ym/6//cZel7sv7xt71t0XX1Hbl/2R0M7od/ai39mLfmcv+p296Hf2ot/Zi35nL/qdveh39qLf2Wvyf/KdvSxkWX1lLwvZp65RBNlnrlEEWXfXKIKsh2sUQdbTNYogS3ONIsj8rlEEWbprFEHmHkWQ9XaNIsj6uEYRZH1dowiyfq5RBFl/1yiC7HPXKIJsgGsUQTbQNYogG+QaRZANdo0iyIa4RhFkQ12jCLJhrlEE2XDXKIJshGsUQTbSNYogG+UaRZCNdo0iyMa4RhFkY12jCLJxrlEE2XjXKIJsgmsUQTbRNYogm+QaRZBNdo0iyKa4RhFkU12jCLJprlEE2XTXKIJshmsUQTbTNYogm+UaRZDNdo0iyOa4RhFkc12jCLJ5rlEE2XzXKILsC9cogmyBaxRBttA1iiD70jWKIFvkGkWQfeUaRZB97RpFkH3jGkWQfesaRZB95xpFkH3vGkWQ/eAaRZD96BpFkP3kGkWQ/ewaRZAtdo0iyJa4RhFkv7hGEWQB1yiCTLhGEWRLXaMIsmWuUQTZctcogmyFaxRBttI1iiBb5RpFkK12jSLI1rhGEWRrXaMIsnWuUQTZetcogmyDaxRBttE1iiDb5BpFkG12jSLItrhGEWRbXaMIsm2uUQTZdtcogmyHaxRBttM1iiDb5RpFkO12jSLI9rhGEWR7XaMIsn2uUQTZr65RBNl+1yiC7IBrFEF20DWKIDvkGkWQHXaNIsiOuEYRZEddowiyY65RBNlx1yiC7IRrFEF20jWKIDvlGkWQnXaNIsh+c40iyH53jSLI/nCNIsj+dI0iyP5yjSLIzrhGEWR/u0YRZP+4RhFkZ12jCLJ/XaPwMmHlcA8jCS33MJLQdg8jCT3uYSRhjHsYSZjTPYwk9LqHkYSx7mEkYS73MJIwzj2MJIx3DyMJE9zDSMJE9zCSMLd7GEnocw8jCZPcw0jCPO5hJGFe9zCSMJ97GEmY3z2MJCzgHkYSFnQPIwmvcA8jCa90DyMJC7mHkYSF3cNIwqvcw0jCq93DSMJr3MNIwiLuYSThte5hJGFR9zCSMNk9jCS8zj2MJLzePYwkvME9jCQs5h5GEhZ3D0PCLH6HX1gl3MNLlP/73+LfTvwt/h3R3+K/8B2nnFq/xx8srHC/yB8spZB7nv/J7/JbJf+jv8sfTPdl/jZ/VmuL/jZ/k//Zb/MHX+j8h3+fX75MvfQ3+oX1afRX+sP9X/RX+t1mWfzGbPBlFO13+oMvOP9f/a1+Yd11cRXF/0O/1y+s0hcPvt/0b/YL69aLi75Z+bv9wrrjP/XL/cIqdzE1vYFf7w/OX/37/cK6B/gF/6Dqv/Mb/sJ6wFUk///1O/7CKu/a5f+v/pb/9v83fstfWFVM/5q/sGpcNH8i+ov+Bn7RX1jPXDxR/YBf9RfWs2Z/119Yr1y0fuG/89v+wmpwMS8D/g9+339w9Pf9M/83n7qT/E9+4V9YbdSvw3R/5V9Y7S8uOxX4pX9hdf5P/da/sDqqk6P7e//CetN1LP8f+s3/4C5Ff/XfqZGu7teo/5tf/g+i7LLad6e7Tf32v7DSor/+n/H/or/+n+khpLFf/x9+8QyMVP76/7T/7/36/9T/9q//jzP96/9fNWvSvn7LsvXbt6nfslz9Vk1aNWyS2q55i7b1X2/RvrXsZZtzlPsf/+Welpf5l3taXuDNFZf9YZKHdgtABfecXOaZPtO7qA/3iV7FsJ/nPX4hD1deeoQque3DENeT1ev48I/Ns5nWyped1mJh36Z5wn7KF6P8UPW6y/6ErtJl56Z45s/4XKuLufQzoUzPbnNG+DzHm92JmPykPaehR5FZPGTN6eqyl/yNt+su/I23Sk3aP1H26TZPlKt+sdnVPd/r0jP+eTfXro2v3CSlbfnU1JRO7qfLxdIv/cNvXUafl2T4e3DFeoV1tsL+Fzvsf/H0yhA10v/K1tcCnCz+v/Xp7U3/5c9ui5n5c4AtTb3lKPt/9+cANxRv3aZ9i6ad6jdKbZLSvknj+q07tGzZommLJqmhPwPaNrVNx07/+z/+WfEyX2RUvNCCEy/7rzxYl00d4EWGnZmQWb3IGGXoz4JWZP9Z0Ih/3fPLtqktXpPVV+NcKT52vhJrhAoxi7/q6YSg/F3Piv8P/l3PDSXbBdto/Rat6zfp2KSRRGmb1vUbpTRqfvHv+V78O763/o+PcuXLPMqVL1RRocs+iDGX/fIPOMrul4OMv9+b7fdI4d5/WJf9Mj8m+69Bc4Z/Deox9Bo0Z4Rvg+h82zOn8uuHhSO8qPOEfWdY6cK/LnbZVVL5/6qd//+6u5qVhoEgnJ9q24hCxSqoNw96UMG7t7aiB1HsAwTbbiFQY5s2xccopQc9exME8Sg+ig/jJtlks5vduiGxJL2J7GYnOzPfN98k2eaj+DzIcvG5T1LjUQyJL3OU1DfiU/fersyGzwc1hw6cn4JnaiVV5SudKUc3qf9Bv5dp0e/JAun3GNXRwBzYwIaFdN9u9Yy23rXNNuLiXg9z8N6ScHAlBc5I2vkQ4OCV8MXJbzMYh3K68UWOYp7KeZZy+4/3GYZPDJv5IQbP4CrV4TkkCv0GSpVbN1MuUKI4IyeTWbr9GH7faCbSqSEjg/4nDISMAd/uAoHvHAHfED6meIDqwwJjYI2MFlQcQ6MDdNDtwvF6+9GGC1sRMbKzJH2F9Rz2FUiIq+M/iHD/q/uwkbfuQ4VCpVMClZpgdG2Yd0EUN2EQN9wYrnkhLNaPIOzPWFtie3Hw8OktA7fGeYBp3XeMpx+pQm9E7Id01PzVhJhRjCuh2XkmhTSIf2NkjslslKLtifnesyaow8p49XdvgstyN/3gpET1Da1bN8aRu1J4swrOi7QRsTdneNNuMeKUp8UKcaUV9TmmhE1jizpmApX5grJUTOwwH64inpl+4IwxTAeEXujFqgmjfSsdVpGwPcGFaS73yiiBJXjxiJQ+IxYjqFaKVAKCq3OzQXoNpYGMbaCcFxxfUJ1+hZ3nbrE+sCGtAHP0TJunxXODQs9fS9mNGr4wZz+UeejA3UU5jA6KwHAWOsiclFZoZwSv5Gi/8kva55clCwA=",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "abi_public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "1080336462466469436": {
            "error_kind": "string",
            "string": "Function check_balance can only be called statically"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "8637882143979902881": {
            "error_kind": "string",
            "string": "Function _increase_public_balance can only be called by the same contract"
          },
          "9543832133280402246": {
            "error_kind": "string",
            "string": "Balance too low"
          },
          "12511970388699677811": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15860392472534760515": {
            "error_kind": "string",
            "string": "Function balance_of_public can only be called statically"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZzRjh0nD4DfZa9zgQEDzqtUVbVNNtVKq020TX7pV5R3r23APkkFnZ1JbjLf+JwxtvGAgZP9evf+4c8vf/3x+Pzh4993b3/7evfny+PT0+Nffzx9fHf/+fHjM0u/3gX5BwrevYU3d1D5NsoV+7WN+zbvqV8pj2u/jyGPa+tXSONa+zXGfkX+fuZrSePa+rWO+zru27gnuHvb5Fr0mgLbAyCAE1gjsOoEecKURJEUAZHI4ylPaOOjnCaI5YEB04ACE8oAjU4SkHCwfUnjo9AGkDxOArVDDnHClMCUwJREmIADUpiQJ9AAsTlFgTYA44QyoIQJOKBOSc0T5HG2OUu0O0yJxFsAAxuWgwBLMj+FEucsH0mcFeKUSJwzBxPF5g5TkusAMRVBoAyQOHdgUxEZxFRsAvIddhklzh1wAmsu8pSkYofWoUjAO9QBMCWRPS3sRcncaMkCOADDhCkpU1KmRNK0VIE2oInmJlAH0JRIAlRuq4o9ldOmQpjACitHo0aRNAGcQOMjiWEHljTugprzAIlhhzpAYthQAAdIDDtMSZuSZhIaIEnboXVoYnOHOgCkiSZQBojxHfKENiClCVOS4wR+nNjmhjBhSkqewIYR+94kV0mekjhDkM8k0J3IZKQy7mAK0chkEu1OsQ9nFPO49uGLxFwISahNytGoTBKTB5msaDucHdS0nSJEkyQ7B00Zm5wdXSqDAUAQlOFyojQEWTBJ64CKZJh13NPvyngwUEaxiS4tLi0urdGxGDZwREMKjtpwUqSJbJpjNQRwLIbRpREdVZn4BjpeD3RprobyJkACRZEm1aCzWdIvyGswUaUSap3WJrqUXKq+DaSJOstNdKnMdROboXbhwGqYXJqKYdaGmyI6kqH25sBmWFxa1bKqSIbNpc2l5FIyaQrZ0aXgUnBpdGl0aXJpcml2qaZnx+5QR5cWlxaXanoOLIaangPRsHdhR2/Y3cwhOVoTOiFPrIYRHK1hnZgnoqM34R5n9zi7xxm9ieINF2+iesPVm2jesHds9o7N5E2QNYwhOlrDCOBoDWMMjuhoTaD3MSZvIidHbwK9YfQmijdcvInqDXsqo6cyNm+iecPkTZA1XAI4WsNFJl+QUoYRDaUgmNgM9TUdWA2zS3VK6Cgl7UCZvya6tLq0ehPNlTVXJvXuRJPWAI5menWHKmRHa7hqlmQt6zVLslbw/bGOqiwpkqG+3VLPQeshUdQpcqBLs0uzS7XnBxZD7fmBaKg9P9Ab1p7v2LwJnfqzDObUQ6LYTZeBlLrpHV2qSZurIhl2y2T0pG5ZR5d2czrqYySo5mBQbIaaiAPrwBi0szpq1KXKZUTD6FI1HXUNpab3x1JybIbZpdlbw+hYDIs2kQQ1+zDrMi05qgYU7F50NCl0LxS7Fx1dqu/QQG2i6AowObpU3yGsinXaAFpXDSyGxaWaMB01YQZmw+5QU9TWSFad+vp37KZ3zI5kqF7IIiH2CbujjgQDXZpdml2KLtVJrUgHRK0Piy6CdVwvSbEY6vQly4vYZ+kikeyz9EBVJuFLOn0NdCm4VOesgcUwuVTfgI46UckqhpEM0aXdCwlqn5rVnNQdUtSpeaBLdWoeWAx1ai6kiI7ScJVAZa1ABrpU5+OOWlINdKlOwh21jqqgiIboUvVN1mSMNG3I3beOzbC6tPumqMP2QPFNlnNcqYGjNiy9ibpZMdCl2lkDm2F0qXbWQG1CwocZHF3afSuKOG1A9a2jTkkDXaq+DWyG6ttA8w3dN+y+NUWaWHq/dXQpuBRcGl2qdVStiiqt3769uZt7U398fnl4kK2pm80q3sL6dP/y8Pz57u3zl6enN3f/u3/6ol/6+9P9s14/37/wp5wMD8/v+coKPzw+PQh9e+NPh/WjsnLK43Hm2kwFxsM6eDKEqYOnwHRGRyixmB0tlZWOtNbBKTpd4QRD01DTcU+C7DgNTwLBygpc66AS61BBpXk8uTj+TkVZqyhNNu1UBddN5Crw+36tu1jgDEWpNzbU46HghZyFgt+5VSho4wev26cfAcPSDwhXHTlqRFkbsY8FBYsFT3GrWMAmOyvXvUNH5Vp2qSJvXMllJnjhQdpUlB/CucnOlGcwUsmrN2RvA820KJjz0oa6s2F2aYabrMCToaRlKGmnIpkG7878iu6sEU1DxpUNETahhGavOVfBq1DKa7h8O+rUwAXUsjuPhjLXU4nNm5BTBcXlkBk3WQn+lvMmjQezfZ8TcTNmxjbf0EQ3gy58P07ETVoS2CxGXGCZDj7r+F5H2w42yQab7ImVXmGFTWIUb6L5oxVpM17xTvHskUaF1jo2yZkwWjw9LXgH7Xin8tpwdmoKZdWpaZNavA1i0fQOafVcbqbloJt283m26bzGlQ2p7EqbiF7axPW4nepOSYBqSkJaDrypXR5wEl0ccHaO8H5BdD9yWxmRt7mZZ14k3Jix75R80ym0DEbeZBcfD5sOAi97+QzzZIYuK4u8ydBo71mCmwGDXmEDZrOhLsv3XC+P4LldHcEzXR/BMVwdwQ9Hsy2jiXG7DrFo8knEatTBXW7yIsoXdm1dqeGm2AP2ZepooS0TfG8I55QbclOu/WjI9nXF4sMGj2NLJbu6s9QZkcRH0qfWh7H6Sje2UytdOf+60bF85ctGCR9f2fQcbtZFr3ElgZuRbvLjNa4k8jUixqWO8otX7TX4qp0r+6UZeH2tWsrVtephK84uVmutHg1a5xftKkgrWRqtN4Vq2O6DFNsHycuip8J2DMu+G7PM8sOOtHAmFqQ/RxizSlrH4vrCvV5duNfrC/d6deF+OJTr1Wa9unDf2hDIbYDlWNHgcrHT4tVip6XrxU7LV4udvRXHlqutXF+utnp1ubrt1GPL1UYXl6uHcxOXm0oEF5erFH/CcpXST1iuUr68XCW8uFzdOXJ0uUr18nL1Pzrl2HKV6Ppy9XCG1nDutOim8Gy43kwP8dcWwK25HQTnTr6oWEj5yH3jC/7SCjj6HoD80g7WdtTrJ1dcll0/u4JAv/L0ig+xmwUEwzogsK0/9Yeu462DzbkPxMuFMEC6XAm/ypt2MiYxNx+JyvrIAMrlCgp2x0jHSiiAdr2GAqDLO0Z7O45VUbA7TjpaRsHuQOlYHbXv22OFFMR8deP/FXla16eEu1OlQ9UUxPoTyinYnSsdrqcg0uWCCnZnS8dOHHe+HC2pIMXLNdV/dc2xogpSvl5VbWcrtDwD+eHSmVIkIngpgjfZ+q+j3PpLy6qIlMyOsj5zg90xU/Ud9JuAHraBQvAuweUwFra9aoMY3ZQxr1HhW0+M9ZwK326mFs+oiKFMFTHUfEpFtu1V+VHiORXJVdzsa75GBQbwKrmcU4HBVCCcU5G9Vsd40opiKm72Vs9acVaFJbj8YvGUimKDRSx4rlNLCV7pn7TCjttiaeGyI+dUpFZtPmotn1ThtVc41amJEpiKsg4n7M6Wsh/65ZY8xeEVZtiUyFjPeUJe3dO5DAebBRjPve2+28Eqzr3tujYcKmI46UhxFdcdOakCfAi/3bt/lQqspqLQSRU2C9yu2M46claFFdIR6NxcFL1TI7STKoKroKuOnFVxs1lzeyL+rzFnd7K0G3N+57v7d48v3/0dh2+i6+Xx/s+nh3H74cvzu5tPP///0/xk/h2ITy8f3z28//LyIJr8j0HwP78hzyFY0+9v7pLccYnMFTnfyf+i+S3xeT0ffcktyKe8ruRC4vdvYto/"
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "FeeJuice"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "FeeJuice::_increase_public_balance_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FeeJuice::_increase_public_balance_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FeeJuice::balance_of_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "FeeJuice::balance_of_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_fee_limit",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "FeeJuice::check_balance_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FeeJuice::check_balance_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FeeJuice::claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FeeJuice::claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "_message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FeeJuice::claim_and_end_setup_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FeeJuice::claim_and_end_setup_abi"
        }
      ]
    }
  },
  "file_map": {
    "0": {
      "path": "std/aes128.nr",
      "source": "// docs:start:aes128\n// Given a plaintext as an array of bytes, returns the corresponding aes128 ciphertext (CBC mode). Input padding is performed using PKCS#7, so that the output length is `input.len() + (16 - input.len() % 16)`.\npub fn aes128_encrypt<let N: u32>(\n    input: [u8; N],\n    iv: [u8; 16],\n    key: [u8; 16],\n) -> [u8; N + 16 - N % 16] {\n    let padding_length = (16 - N % 16) as u8;\n    let mut padded_input: [u8; N + 16 - N % 16] = [0; N + 16 - N % 16];\n    for i in 0..N {\n        padded_input[i] = input[i];\n    }\n    for i in N..N + 16 - N % 16 {\n        padded_input[i] = padding_length;\n    }\n    let output = aes128_encrypt_padded_input(padded_input, iv, key);\n    output\n}\n\n#[foreign(aes128_encrypt)]\nfn aes128_encrypt_padded_input<let N: u32>(input: [u8; N], iv: [u8; 16], key: [u8; 16]) -> [u8; N] {}\n\n// docs:end:aes128\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    crate::assert_constant(separator);\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "231": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called\n/// and if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 12;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "299": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.2.3/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let num_extra_fields = in_len % RATE;\n            if num_extra_fields != 0 {\n                let remainder_start = in_len - num_extra_fields;\n                state[0] += input[remainder_start];\n                if num_extra_fields > 1 {\n                    state[1] += input[remainder_start + 1]\n                }\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4)\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a vector.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let vector = array.as_vector();\n    /// assert_eq(vector, [1, 2].as_vector());\n    /// ```\n    #[builtin(as_vector)]\n    pub fn as_vector(self) -> [T] {}\n\n    /// Returns this array as a vector.\n    /// This method is deprecated in favor of `as_vector`.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let vector = array.as_slice();\n    /// assert_eq(vector, [1, 2].as_vector());\n    /// ```\n    #[builtin(as_vector)]\n    #[deprecated(\"This method has been renamed to `as_vector`\")]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "388": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector, nullifier::Nullifier, private_log::PrivateLog,\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, DOM_SEP__NOTE_HASH_NONCE,\n        DOM_SEP__PRIVATE_LOG_FIRST_FIELD, DOM_SEP__SILOED_NOTE_HASH, DOM_SEP__SILOED_NULLIFIER,\n        DOM_SEP__UNIQUE_NOTE_HASH, FUNCTION_TREE_HEIGHT, NULL_MSG_SENDER_CONTRACT_ADDRESS,\n        TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\n// TODO: refactor these into their own files: sha256, poseidon2, some protocol-specific hash computations, some merkle computations.\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn compute_siloed_note_hash(contract_address: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address.to_field(), note_hash],\n        DOM_SEP__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique, siloed note hashes from siloed note hashes.\n///\n/// The protocol injects uniqueness into every note_hash, so that every single note_hash in the\n/// tree is unique. This prevents faerie gold attacks, where a malicious sender could create\n/// two identical note_hashes for a recipient (meaning only one would be nullifiable in future).\n///\n/// Most privacy protocols will inject the note's leaf_index (its position in the Note Hashes Tree)\n/// into the note, but this requires the creator of a note to wait until their tx is included in\n/// a block to know the note's final note hash (the unique, siloed note hash), because inserting\n/// leaves into trees is the job of a block producer.\n///\n/// We took a different approach so that the creator of a note will know each note's unique, siloed\n/// note hash before broadcasting their tx to the network.\n/// (There was also a historical requirement relating to \"chained transactions\" -- a feature that\n/// Aztec Connect had to enable notes to be spent from distinct txs earlier in the same block,\n/// and hence before an archive block root had been established for that block -- but that feature\n/// was abandoned for the Aztec Network for having too many bad tradeoffs).\n///\n/// (\n///   Edit: it is no longer true that all final note_hashes will be known by the creator of a tx\n///   before they send it to the network. If a tx makes public function calls, then _revertible_\n///   note_hashes that are created in private will not be made unique in private by the Reset circuit,\n///   but will instead be made unique by the AVM, because the `note_index_in_tx` will not be known\n///   until the AVM has executed the public functions of the tx. (See an explanation in\n///   reset_output_composer.nr for why).\n///   For some such txs, the `note_index_in_tx` might still be predictable through simulation, but\n///   for txs whose public functions create a varying number of non-revertible notes (determined at\n///   runtime), the `note_index_in_tx` will not be deterministically derivable before submitting the\n///   tx to the network.\n/// )\n///\n/// We use the `first_nullifier` of a tx as a seed of uniqueness. We have a guarantee that there will\n/// always be at least one nullifier per tx, because the init circuit will create one if one isn't\n/// created naturally by any functions of the tx. (Search \"protocol_nullifier\").\n/// We combine the `first_nullifier` with the note's index (its position within this tx's new\n/// note_hashes array) (`note_index_in_tx`) to get a truly unique value to inject into a note, which\n/// we call a `note_nonce`.\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, DOM_SEP__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        DOM_SEP__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_note_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier(contract_address: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address.to_field(), nullifier],\n        DOM_SEP__SILOED_NULLIFIER,\n    )\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    // The protocol nullifier is ascribed a special side-effect counter of 1. No other side-effect\n    // can have counter 1 (see `validate_as_first_call` for that assertion).\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_first_field(\n    contract_address: AztecAddress,\n    field: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [contract_address.to_field(), field],\n        DOM_SEP__PRIVATE_LOG_FIRST_FIELD,\n    )\n}\n\npub fn compute_siloed_private_log(contract_address: AztecAddress, log: PrivateLog) -> PrivateLog {\n    let mut fields = log.fields;\n    fields[0] = compute_siloed_private_log_first_field(contract_address, fields[0]);\n    PrivateLog::new(fields, log.length)\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_siloed_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    key_type_domain_separator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        key_type_domain_separator,\n    )\n}\n\npub fn compute_l2_to_l1_message_hash(\n    message: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = message.contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = message.inner.recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = message.inner.content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\n// TODO: consider a variant that enables domain separation with a u32 (we seem to have standardised u32s for domain separators)\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn subarray_hash_matches_fixed() {\n    let mut values_to_hash = [3; 17];\n    let mut padded = values_to_hash.concat([0; 11]);\n    let subarray_hash = poseidon2_hash_subarray(padded, values_to_hash.len());\n\n    // Hash the entire values_to_hash.\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(values_to_hash, values_to_hash.len());\n\n    assert_eq(subarray_hash, fixed_len_hash);\n}\n\n#[test]\nfn subarray_hash_matches_variable() {\n    let mut values_to_hash = [3; 17];\n    let mut padded = values_to_hash.concat([0; 11]);\n    let subarray_hash = poseidon2_hash_subarray(padded, values_to_hash.len());\n\n    // Hash up to values_to_hash.len() fields of the padded array.\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(padded, values_to_hash.len());\n\n    assert_eq(subarray_hash, variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn unique_siloed_note_hash_matches_typescript() {\n    let inner_note_hash = 1;\n    let contract_address = AztecAddress::from_field(2);\n    let first_nullifier = 3;\n    let note_index_in_tx = 4;\n\n    let siloed_note_hash = compute_siloed_note_hash(contract_address, inner_note_hash);\n    let siloed_note_hash_from_ts =\n        0x1986a4bea3eddb1fff917d629a13e10f63f514f401bdd61838c6b475db949169;\n    assert_eq(siloed_note_hash, siloed_note_hash_from_ts);\n\n    let nonce: Field = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    let note_hash_nonce_from_ts =\n        0x28e7799791bf066a57bb51fdd0fbcaf3f0926414314c7db515ea343f44f5d58b;\n    assert_eq(nonce, note_hash_nonce_from_ts);\n\n    let unique_siloed_note_hash_from_nonce = compute_unique_note_hash(nonce, siloed_note_hash);\n    let unique_siloed_note_hash = compute_note_nonce_and_unique_note_hash(\n        siloed_note_hash,\n        first_nullifier,\n        note_index_in_tx,\n    );\n    assert_eq(unique_siloed_note_hash_from_nonce, unique_siloed_note_hash);\n\n    let unique_siloed_note_hash_from_ts =\n        0x29949aef207b715303b24639737c17fbfeb375c1d965ecfa85c7e4f0febb7d16;\n    assert_eq(unique_siloed_note_hash, unique_siloed_note_hash_from_ts);\n}\n\n#[test]\nfn siloed_nullifier_matches_typescript() {\n    let contract_address = AztecAddress::from_field(123);\n    let nullifier = 456;\n\n    let res = compute_siloed_nullifier(contract_address, nullifier);\n\n    let siloed_nullifier_from_ts =\n        0x169b50336c1f29afdb8a03d955a81e485f5ac7d5f0b8065673d1e407e5877813;\n\n    assert_eq(res, siloed_nullifier_from_ts);\n}\n\n#[test]\nfn siloed_private_log_first_field_matches_typescript() {\n    let contract_address = AztecAddress::from_field(123);\n    let field = 456;\n    let res = compute_siloed_private_log_first_field(contract_address, field);\n\n    let siloed_private_log_first_field_from_ts =\n        0x29480984f7b9257fded523d50addbcfc8d1d33adcf2db73ef3390a8fd5cdffaa;\n\n    assert_eq(res, siloed_private_log_first_field_from_ts);\n}\n\n#[test]\nfn empty_l2_to_l1_message_hash_matches_typescript() {\n    // All zeroes\n    let res = compute_l2_to_l1_message_hash(\n        L2ToL1Message { recipient: EthAddress::zero(), content: 0 }.scope(AztecAddress::from_field(\n            0,\n        )),\n        0,\n        0,\n    );\n\n    let empty_l2_to_l1_msg_hash_from_ts =\n        0x003b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992;\n\n    assert_eq(res, empty_l2_to_l1_msg_hash_from_ts);\n}\n\n#[test]\nfn l2_to_l1_message_hash_matches_typescript() {\n    let message = L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n        AztecAddress::from_field(3),\n    );\n    let version = 4;\n    let chainId = 5;\n\n    let hash = compute_l2_to_l1_message_hash(message, version, chainId);\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let l2_to_l1_message_hash_from_ts =\n        0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, l2_to_l1_message_hash_from_ts);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "39": {
      "path": "std/ops/arith.nr",
      "source": "use crate::convert::AsPrimitive;\n\n// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n// docs:start:wrapping-add-trait\npub trait WrappingAdd {\n    fn wrapping_add(self, y: Self) -> Self;\n}\n// docs:end:wrapping-add-trait\n\nimpl WrappingAdd for u1 {\n    fn wrapping_add(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingAdd for u8 {\n    fn wrapping_add(self: u8, y: u8) -> u8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u16 {\n    fn wrapping_add(self: u16, y: u16) -> u16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u32 {\n    fn wrapping_add(self: u32, y: u32) -> u32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u64 {\n    fn wrapping_add(self: u64, y: u64) -> u64 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u128 {\n    fn wrapping_add(self: u128, y: u128) -> u128 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i8 {\n    fn wrapping_add(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_add(y as u8) as i8\n    }\n}\n\nimpl WrappingAdd for i16 {\n    fn wrapping_add(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_add(y as u16) as i16\n    }\n}\n\nimpl WrappingAdd for i32 {\n    fn wrapping_add(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_add(y as u32) as i32\n    }\n}\n\nimpl WrappingAdd for i64 {\n    fn wrapping_add(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_add(y as u64) as i64\n    }\n}\nimpl WrappingAdd for Field {\n    fn wrapping_add(self: Field, y: Field) -> Field {\n        self + y\n    }\n}\n\n// docs:start:wrapping-sub-trait\npub trait WrappingSub {\n    fn wrapping_sub(self, y: Self) -> Self;\n}\n// docs:start:wrapping-sub-trait\n\nimpl WrappingSub for u1 {\n    fn wrapping_sub(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingSub for u8 {\n    fn wrapping_sub(self: u8, y: u8) -> u8 {\n        wrapping_sub_hlp(self, y) as u8\n    }\n}\n\nimpl WrappingSub for u16 {\n    fn wrapping_sub(self: u16, y: u16) -> u16 {\n        wrapping_sub_hlp(self, y) as u16\n    }\n}\n\nimpl WrappingSub for u32 {\n    fn wrapping_sub(self: u32, y: u32) -> u32 {\n        wrapping_sub_hlp(self, y) as u32\n    }\n}\nimpl WrappingSub for u64 {\n    fn wrapping_sub(self: u64, y: u64) -> u64 {\n        wrapping_sub_hlp(self, y) as u64\n    }\n}\nimpl WrappingSub for u128 {\n    fn wrapping_sub(self: u128, y: u128) -> u128 {\n        wrapping_sub_hlp(self, y) as u128\n    }\n}\n\nimpl WrappingSub for i8 {\n    fn wrapping_sub(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_sub(y as u8) as i8\n    }\n}\n\nimpl WrappingSub for i16 {\n    fn wrapping_sub(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_sub(y as u16) as i16\n    }\n}\n\nimpl WrappingSub for i32 {\n    fn wrapping_sub(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_sub(y as u32) as i32\n    }\n}\nimpl WrappingSub for i64 {\n    fn wrapping_sub(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_sub(y as u64) as i64\n    }\n}\nimpl WrappingSub for Field {\n    fn wrapping_sub(self: Field, y: Field) -> Field {\n        self - y\n    }\n}\n\n// docs:start:wrapping-mul-trait\npub trait WrappingMul {\n    fn wrapping_mul(self, y: Self) -> Self;\n}\n// docs:start:wrapping-mul-trait\n\nimpl WrappingMul for u1 {\n    fn wrapping_mul(self: u1, y: u1) -> u1 {\n        self & y\n    }\n}\n\nimpl WrappingMul for u8 {\n    fn wrapping_mul(self: u8, y: u8) -> u8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u16 {\n    fn wrapping_mul(self: u16, y: u16) -> u16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u32 {\n    fn wrapping_mul(self: u32, y: u32) -> u32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\nimpl WrappingMul for u64 {\n    fn wrapping_mul(self: u64, y: u64) -> u64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i8 {\n    fn wrapping_mul(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_mul(y as u8) as i8\n    }\n}\n\nimpl WrappingMul for i16 {\n    fn wrapping_mul(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_mul(y as u16) as i16\n    }\n}\n\nimpl WrappingMul for i32 {\n    fn wrapping_mul(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_mul(y as u32) as i32\n    }\n}\n\nimpl WrappingMul for i64 {\n    fn wrapping_mul(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_mul(y as u64) as i64\n    }\n}\n\nimpl WrappingMul for u128 {\n    fn wrapping_mul(self: u128, y: u128) -> u128 {\n        wrapping_mul128_hlp(self, y)\n    }\n}\nimpl WrappingMul for Field {\n    fn wrapping_mul(self: Field, y: Field) -> Field {\n        self * y\n    }\n}\n\nfn wrapping_add_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\nfn wrapping_sub_hlp<T>(x: T, y: T) -> Field\nwhere\n    T: AsPrimitive<Field>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    x.as_() + 340282366920938463463374607431768211456 - y.as_()\n}\n\nfn wrapping_mul_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\nglobal two_pow_64: u128 = 0x10000000000000000;\n/// Splits a 128 bits number into two 64 bits limbs\nunconstrained fn split64(x: u128) -> (u64, u64) {\n    let lo = x as u64;\n    let hi = (x / two_pow_64) as u64;\n    (lo, hi)\n}\n\n/// Split a 128 bits number into two 64 bits limbs\n/// It will fail if the number is more than 128 bits\nfn split_into_64_bit_limbs(x: u128) -> (u64, u64) {\n    // Safety: the limbs are constrained below\n    let (x_lo, x_hi) = unsafe { split64(x) };\n    assert(x as Field == x_lo as Field + x_hi as Field * two_pow_64 as Field);\n    (x_lo, x_hi)\n}\n\n#[field(bn254)]\nfn wrapping_mul128_hlp(x: u128, y: u128) -> u128 {\n    let (x_lo, x_hi) = split_into_64_bit_limbs(x);\n    let (y_lo, y_hi) = split_into_64_bit_limbs(y);\n    // Multiplication using the limbs:(x_lo + 2**64*x_hi)*(y_lo + 2**64*y_hi)=x_lo*y_lo+...\n    // and skipping the terms over 2**128\n    // Working with u64 limbs ensures that we cannot overflow the field modulus.\n    let low = x_lo as Field * y_lo as Field;\n    let lo = low as u64 as Field;\n    let carry = (low - lo) / two_pow_64 as Field;\n    let high = x_lo as Field * y_hi as Field + x_hi as Field * y_lo as Field + carry;\n    let hi = high as u64 as Field;\n    (lo + two_pow_64 as Field * hi) as u128\n}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        crate::static_assert(1 == 2, \"custom message\");\n    }\n\n    mod arithmetic {\n        use crate::ops::arith::{Add, Div, Mul, Neg, Rem, Sub};\n        #[test]\n        fn test_basic_arithmetic_traits() {\n            // add\n            assert_eq(5.add(3), 8);\n            assert_eq(0u8.add(255u8), 255u8);\n            assert_eq(42.add(58), 100);\n\n            // sub\n            assert_eq(10.sub(3), 7);\n            assert_eq(100.sub(42), 58);\n\n            // mul\n            assert_eq(6.mul(7), 42);\n\n            // div\n            assert_eq(15.div(3), 5);\n            assert_eq(10u8.div(3u8), 3u8);\n            assert_eq(15.div(3), 5);\n\n            // rem\n            assert_eq(17.rem(5), 2);\n            assert_eq(10u8.rem(3u8), 1u8);\n\n            // neg\n            assert_eq(42.neg(), -42);\n            assert_eq((-10).neg(), 10);\n            assert_eq(42.neg(), -42);\n        }\n\n        #[test]\n        fn test_division() {\n            // test division by one\n            assert_eq(42.div(1), 42);\n            assert_eq(0.div(1), 0);\n            assert_eq(255u8.div(1u8), 255u8);\n\n            // test division by self\n            assert_eq(42.div(42), 1);\n            assert_eq(1.div(1), 1);\n\n            // test remainder\n            assert_eq(42.rem(42), 0);\n            assert_eq(0.rem(42), 0);\n            assert_eq(1.rem(42), 1);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_sub_overflow_failure() {\n            let _ = 0u8.sub(1u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_add_overflow_failure() {\n            let _ = 255u8.add(1u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_mul_overflow_failure() {\n            let _ = 255u8.mul(2u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_sub_overflow_failure() {\n            let _ = 0u16.sub(1u16);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_add_overflow_failure() {\n            let _ = 65535u16.add(1u16);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_mul_overflow_failure() {\n            let _ = 65535u16.mul(2u16);\n        }\n\n        #[test(should_fail)]\n        fn test_signed_sub_overflow_failure() {\n            let val: i8 = -128;\n            let _ = val.sub(1i8);\n        }\n\n        #[test(should_fail)]\n        fn test_signed_overflow_failure() {\n            let _ = 127i8.add(1i8);\n        }\n\n        #[test]\n        fn test_field() {\n            let zero: Field = 0;\n            let one: Field = 1;\n\n            // test Field basic operations\n            assert_eq(zero.add(one), one);\n            assert_eq(one.add(zero), one);\n            assert_eq(one.sub(one), zero);\n            assert_eq(one.mul(one), one);\n            assert_eq(one.div(one), one);\n            assert_eq(zero.neg(), zero);\n            assert_eq(one.neg(), -one);\n        }\n\n    }\n\n    mod wrapping_arithmetic {\n        use crate::ops::arith::{Add, Div, Mul, Neg, Sub, WrappingAdd, WrappingMul, WrappingSub};\n        #[test]\n        fn test_wrapping_add() {\n            assert_eq(255u8.wrapping_add(1u8), 0u8);\n            assert_eq(255u8.wrapping_add(255u8), 254u8);\n            assert_eq(0u8.wrapping_add(0u8), 0u8);\n            assert_eq(128u8.wrapping_add(128u8), 0u8);\n\n            // test u16 wrapping add\n            assert_eq(65535u16.wrapping_add(1u16), 0u16);\n            assert_eq(65535u16.wrapping_add(65535u16), 65534u16);\n\n            // test u32 wrapping add\n            assert_eq(0xffffffffu32.wrapping_add(1u32), 0u32);\n            assert_eq(0xffffffffu32.wrapping_add(0xffffffffu32), 0xfffffffeu32);\n\n            // test u64 wrapping add\n            assert_eq(0xffffffffffffffffu64.wrapping_add(1u64), 0u64);\n            assert_eq(\n                0xffffffffffffffffu64.wrapping_add(0xffffffffffffffffu64),\n                0xfffffffffffffffeu64,\n            );\n\n            // test u128 wrapping add\n            assert_eq(0xffffffffffffffffffffffffffffffffu128.wrapping_add(1u128), 0u128);\n\n            // test signed types\n            assert_eq(127i8.wrapping_add(1i8), -128i8);\n            let val: i8 = -128;\n            assert_eq(val.wrapping_add(-1i8), 127i8);\n\n            // test Field wrapping add\n            let forty_two: Field = 42;\n            let fifty_eight: Field = 58;\n            let hundred: Field = 100;\n            let neg_two: Field = -2;\n            let two: Field = 2;\n            let zero: Field = 0;\n            let neg_two_hundred: Field = -200;\n            let neg_one_ninety_eight: Field = -198;\n            assert_eq(forty_two.wrapping_add(fifty_eight), hundred);\n            assert_eq(neg_two.wrapping_add(two), zero);\n            assert_eq(neg_two_hundred.wrapping_add(two), neg_one_ninety_eight);\n        }\n\n        #[test]\n        fn test_wrapping_sub() {\n            assert_eq(0u8.wrapping_sub(1u8), 255u8);\n            assert_eq(255u8.wrapping_sub(255u8), 0u8);\n            assert_eq(0u8.wrapping_sub(0u8), 0u8);\n            assert_eq(1u8.wrapping_sub(2u8), 255u8);\n\n            // test u16 wrapping sub\n            assert_eq(0u16.wrapping_sub(1u16), 65535u16);\n            assert_eq(65535u16.wrapping_sub(65535u16), 0u16);\n\n            // test u32 wrapping sub\n            assert_eq(0u32.wrapping_sub(1u32), 0xffffffffu32);\n            assert_eq(0xffffffffu32.wrapping_sub(0xffffffffu32), 0u32);\n\n            // test u64 wrapping sub\n            assert_eq(0u64.wrapping_sub(1u64), 0xffffffffffffffffu64);\n            assert_eq(0xffffffffffffffffu64.wrapping_sub(0xffffffffffffffffu64), 0u64);\n\n            // test u128 wrapping sub\n            assert_eq(0u128.wrapping_sub(1u128), 0xffffffffffffffffffffffffffffffffu128);\n\n            // test signed types\n            let val: i8 = -128;\n            assert_eq(val.wrapping_sub(1i8), 127i8);\n            assert_eq(127i8.wrapping_sub(-1i8), -128i8);\n\n            // test Field wrapping sub\n            let forty_two: Field = 42;\n            let fifty_eight: Field = 58;\n            let neg_sixteen: Field = -16;\n            assert_eq(forty_two.wrapping_sub(fifty_eight), neg_sixteen);\n        }\n\n        #[test]\n        fn test_wrapping_mul() {\n            let zero: u128 = 0;\n            let one: u128 = 1;\n            let two_pow_64: u128 = 0x10000000000000000;\n            let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n            assert_eq(zero, zero.wrapping_mul(one));\n            assert_eq(zero, one.wrapping_mul(zero));\n            assert_eq(one, one.wrapping_mul(one));\n            assert_eq(zero, zero.wrapping_mul(two_pow_64));\n            assert_eq(zero, two_pow_64.wrapping_mul(zero));\n            assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n            assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n            assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n            assert_eq(one, u128_max.wrapping_mul(u128_max));\n\n            // test u8 wrapping mul\n            assert_eq(255u8.wrapping_mul(2u8), 254u8);\n            assert_eq(255u8.wrapping_mul(255u8), 1u8);\n            assert_eq(128u8.wrapping_mul(2u8), 0u8);\n\n            // test u16 wrapping mul\n            assert_eq(65535u16.wrapping_mul(2u16), 65534u16);\n            assert_eq(65535u16.wrapping_mul(65535u16), 1u16);\n\n            // test u32 wrapping mul\n            assert_eq(0xffffffffu32.wrapping_mul(2u32), 0xfffffffeu32);\n            assert_eq(0xffffffffu32.wrapping_mul(0xffffffffu32), 1u32);\n\n            // test u64 wrapping mul\n            // 0xffffffffffffffffu64 is 2^64 - 1\n            assert_eq(0xffffffffffffffffu64.wrapping_mul(2u64), 0xfffffffffffffffeu64);\n            assert_eq(0xffffffffffffffffu64.wrapping_mul(0xffffffffffffffffu64), 1u64);\n\n            // test signed types\n            assert_eq(127i8.wrapping_mul(2i8), -2i8);\n            let val: i8 = -128;\n            assert_eq(val.wrapping_mul(-1i8), -128i8);\n\n            // test Field wrapping mul\n            let six: Field = 6;\n            let seven: Field = 7;\n            let forty_two: Field = 42;\n            let neg_two: Field = -2;\n            let two: Field = 2;\n            let neg_four: Field = -4;\n            assert_eq(six.wrapping_mul(seven), forty_two);\n            assert_eq(neg_two.wrapping_mul(two), neg_four);\n        }\n\n        #[test]\n        fn test_u1_behavior() {\n            // u1 wrapping add is XOR\n            assert_eq(0u1.wrapping_add(0u1), 0u1);\n            assert_eq(0u1.wrapping_add(1u1), 1u1);\n            assert_eq(1u1.wrapping_add(0u1), 1u1);\n            assert_eq(1u1.wrapping_add(1u1), 0u1);\n\n            // u1 wrapping sub is XOR\n            assert_eq(0u1.wrapping_sub(0u1), 0u1);\n            assert_eq(0u1.wrapping_sub(1u1), 1u1);\n            assert_eq(1u1.wrapping_sub(0u1), 1u1);\n            assert_eq(1u1.wrapping_sub(1u1), 0u1);\n\n            // u1 wrapping mul is AND\n            assert_eq(0u1.wrapping_mul(0u1), 0u1);\n            assert_eq(0u1.wrapping_mul(1u1), 0u1);\n            assert_eq(1u1.wrapping_mul(0u1), 0u1);\n            assert_eq(1u1.wrapping_mul(1u1), 1u1);\n        }\n\n        // test wrapping operations is the same as the regular operations\n        #[test]\n        fn test_wrapping_vs_regular() {\n            let u64_large = 0x123456789abcdef0u64;\n            let u128_large = 0x123456789abcdef0123456789abcdef0u128;\n\n            assert_eq(u64_large.wrapping_add(1u64), u64_large + 1u64);\n            assert_eq(u64_large.wrapping_sub(1u64), u64_large - 1u64);\n            assert_eq(u64_large.wrapping_mul(2u64), u64_large * 2u64);\n\n            assert_eq(u128_large.wrapping_add(1u128), u128_large + 1u128);\n            assert_eq(u128_large.wrapping_sub(1u128), u128_large - 1u128);\n            assert_eq(u128_large.wrapping_mul(2u128), u128_large * 2u128);\n        }\n\n        #[test]\n        fn test_field_wrapping_operations() {\n            let zero: Field = 0;\n            let one: Field = 1;\n            let large_val = 0xffffffffffffffff;\n\n            // test Field wrapping operations\n            assert_eq(zero.wrapping_add(one), one);\n            assert_eq(one.wrapping_add(large_val), one + large_val);\n            assert_eq(zero.wrapping_sub(one), -one);\n            assert_eq(one.wrapping_sub(large_val), one - large_val);\n            assert_eq(zero.wrapping_mul(one), zero);\n            assert_eq(one.wrapping_mul(large_val), large_val);\n\n            // test Field basic operations\n            assert_eq(zero.add(one), one);\n            assert_eq(one.add(zero), one);\n            assert_eq(one.sub(one), zero);\n            assert_eq(one.mul(one), one);\n            assert_eq(one.div(one), one);\n            assert_eq(zero.neg(), zero);\n            assert_eq(one.neg(), -one);\n        }\n\n    }\n\n    mod split_functions {\n\n        use crate::ops::arith::{split64, split_into_64_bit_limbs};\n\n        // test split64 and split_into_64_bit_limbs functions\n        #[test]\n        fn test_split_functions() {\n            let small_val = 0x123456789abcdefu128;\n            let large_val = 0x123456789abcdef0123456789abcdef0u128;\n            let max_val = 0xffffffffffffffffffffffffffffffffu128;\n\n            // test split64 (unconstrained)\n            // Safety: testing\n            unsafe {\n                let (lo, hi) = split64(small_val);\n                assert_eq(lo, 0x123456789abcdefu64);\n                assert_eq(hi, 0u64);\n\n                let (lo2, hi2) = split64(large_val);\n                assert_eq(lo2, 0x123456789abcdef0u64);\n                assert_eq(hi2, 0x123456789abcdef0u64);\n            }\n\n            // test split_into_64_bit_limbs (constrained)\n            let (lo3, hi3) = split_into_64_bit_limbs(small_val);\n            assert_eq(lo3, 0x123456789abcdefu64);\n            assert_eq(hi3, 0u64);\n\n            let (lo4, hi4) = split_into_64_bit_limbs(large_val);\n            assert_eq(lo4, 0x123456789abcdef0u64);\n            assert_eq(hi4, 0x123456789abcdef0u64);\n\n            let (lo5, hi5) = split_into_64_bit_limbs(max_val);\n            assert_eq(lo5, 0xffffffffffffffffu64);\n            assert_eq(hi5, 0xffffffffffffffffu64);\n        }\n    }\n}\n"
    },
    "396": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/merkle_tree.nr",
      "source": "use crate::{\n    hash::{accumulate_sha256, poseidon2_hash},\n    traits::Empty,\n    utils::math::is_power_of_2_u32,\n};\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn sha_merkle_hash(left: Field, right: Field) -> Field {\n    accumulate_sha256(left, right)\n}\n\n#[derive(Eq)]\npub struct MerkleTree<let N: u32> {\n    pub leaves: [Field; N],\n    pub nodes: [Field; N - 1],\n}\n\nimpl<let N: u32> Empty for MerkleTree<N> {\n    fn empty() -> Self {\n        MerkleTree { leaves: [0; N], nodes: [0; N - 1] }\n    }\n}\n\nimpl<let N: u32> MerkleTree<N> {\n    pub fn new(leaves: [Field; N]) -> Self {\n        let nodes = compute_merkle_tree_nodes(leaves, merkle_hash);\n        MerkleTree { leaves, nodes }\n    }\n\n    pub fn new_sha(leaves: [Field; N]) -> Self {\n        let nodes = compute_merkle_tree_nodes(leaves, sha_merkle_hash);\n        MerkleTree { leaves, nodes }\n    }\n\n    pub fn get_root(self) -> Field {\n        self.nodes[N - 2]\n    }\n\n    pub fn get_sibling_path<let K: u32>(self, leaf_index: u32) -> [Field; K] {\n        assert_eq(2.pow_32(K as Field), N as Field, \"Invalid path length\");\n\n        let mut path = [0; K];\n        let mut current_index = leaf_index;\n        let mut subtree_width = N;\n\n        let mut current_sibling_index = sibling_index(current_index);\n\n        path[0] = self.leaves[current_sibling_index];\n\n        let mut subtree_offset: u32 = 0;\n\n        for i in 1..K {\n            current_index = current_index / 2;\n            subtree_width = subtree_width / 2;\n\n            current_sibling_index = sibling_index(current_index);\n\n            path[i] = self.nodes[subtree_offset + current_sibling_index];\n\n            subtree_offset += subtree_width;\n        }\n\n        path\n    }\n}\n\npub fn sibling_index(index: u32) -> u32 {\n    if index % 2 == 0 {\n        index + 1\n    } else {\n        index - 1\n    }\n}\n\npub fn compute_merkle_tree_nodes<let N: u32>(\n    leaves: [Field; N],\n    hasher: fn(Field, Field) -> Field,\n) -> [Field; N - 1] {\n    // Note: `N` must be a power of 2.\n    std::static_assert(is_power_of_2_u32(N), \"N must be a power of 2\");\n    std::static_assert(N != 1, \"2 must divide N\");\n\n    let mut nodes = [0; N - 1];\n\n    let total_nodes = N - 1;\n    let half_size = N / 2;\n\n    // Hash base layer.\n    for i in 0..half_size {\n        nodes[i] = hasher(leaves[2 * i], leaves[2 * i + 1]);\n    }\n\n    // Hash the other layers.\n    for i in 0..(total_nodes - half_size) {\n        nodes[half_size + i] = hasher(nodes[2 * i], nodes[2 * i + 1]);\n    }\n\n    nodes\n}\n"
    },
    "398": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::merkle_tree::merkle_tree::{compute_merkle_tree_nodes, merkle_hash, sha_merkle_hash};\n\n/// Calculate the Merkle tree root from the sibling path and leaf, using the default merkle hash.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    root_from_sibling_path_with_hasher(leaf, leaf_index, sibling_path, merkle_hash)\n}\n\n/// Calculate the Merkle tree root from the sibling path and leaf, using a custom hasher.\n///\n/// The leaf is hashed with its sibling, the result is then hashed with the next sibling in the path. and so on.\n/// The last hash is the root.\npub fn root_from_sibling_path_with_hasher<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n    hasher: fn(Field, Field) -> Field,\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = hasher(hash_left, hash_right);\n    }\n    node\n}\n\npub fn compute_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    compute_tree_root_with_hasher(leaves, merkle_hash)\n}\n\npub fn compute_sha_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    compute_tree_root_with_hasher(leaves, sha_merkle_hash)\n}\n\nfn compute_tree_root_with_hasher<let N: u32>(\n    leaves: [Field; N],\n    hasher: fn(Field, Field) -> Field,\n) -> Field {\n    compute_merkle_tree_nodes(leaves, hasher)[N - 2]\n}\n\npub fn compute_empty_tree_root<let TreeHeight: u32>() -> Field {\n    compute_empty_tree_root_with_hasher::<TreeHeight>(merkle_hash)\n}\n\npub fn compute_empty_sha_tree_root<let TreeHeight: u32>() -> Field {\n    compute_empty_tree_root_with_hasher::<TreeHeight>(sha_merkle_hash)\n}\n\npub fn compute_empty_tree_root_with_hasher<let TreeHeight: u32>(\n    hasher: fn(Field, Field) -> Field,\n) -> Field {\n    let mut hashes = [0; TreeHeight + 1];\n    for i in 1..TreeHeight + 1 {\n        hashes[i] = hasher(hashes[i - 1], hashes[i - 1]);\n    }\n    hashes[TreeHeight]\n}\n\n#[test]\nfn test_merkle_roots_match_typescript() {\n    // The following hardcoded values are generated from yarn-project/foundation/src/trees/balanced_merkle_tree_root.test.ts\n\n    let root = compute_tree_root([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n    let expected_tree_root_from_ts =\n        0x1528946361c480e8dc1e9ae3f8c31c997625fa1ddeddc7db5ad0dce3ac58fc4c;\n    assert_eq(root, expected_tree_root_from_ts);\n\n    let empty_root = compute_tree_root([0; 16]);\n    let expected_empty_root_from_ts =\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e;\n    assert_eq(empty_root, expected_empty_root_from_ts);\n\n    let sha_root = compute_sha_tree_root([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\n    let expected_sha_root_from_ts =\n        0x00b007869b8a5e2a9b3b580a318e702cea04b2f5438f2e26743f545e4d1ecbdb;\n    assert_eq(sha_root, expected_sha_root_from_ts);\n}\n\n#[test]\nfn test_empty_tree_root() {\n    assert_eq(compute_empty_tree_root::<0>(), 0);\n\n    assert_eq(\n        compute_empty_tree_root::<1>(),\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1,\n    );\n\n    assert_eq(\n        compute_empty_tree_root::<2>(),\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290,\n    );\n\n    assert_eq(\n        compute_empty_tree_root::<6>(),\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76,\n    );\n\n    assert_eq(\n        compute_empty_tree_root::<10>(),\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686,\n    );\n}\n"
    },
    "417": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{\n    constants::DOM_SEP__PUBLIC_STORAGE_MAP_SLOT, hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n// TODO: Move this to src/public_data/storage/map.nr\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash_with_separator(\n        [storage_slot, key.to_field()],\n        DOM_SEP__PUBLIC_STORAGE_MAP_SLOT,\n    )\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x2d225f361108379adc2da91378b9702675c5546b57e78bafc1e74ec7fec55967;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U>(message: T) -> U\nwhere\n    T: StringLike,\n{\n    assert(false, message);\n    crate::mem::zeroed()\n}\n\ntrait StringLike {}\n\nimpl<let N: u32> StringLike for str<N> {}\nimpl<let N: u32, T> StringLike for fmtstr<N, T> {}\n"
    },
    "434": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "447": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/serde/src/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn peek_offset(&mut self, offset: u32) -> Field {\n        self.data[self.offset + offset]\n    }\n\n    pub fn advance_offset(&mut self, offset: u32) {\n        self.offset += offset;\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "448": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/serde/src/serialization.nr",
      "source": "use crate::{reader::Reader, writer::Writer};\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut writer: Writer<Self::N> = Writer::new();\n///         self.stream_serialize(&mut writer);\n///         writer.finish()\n///     }\n///\n///     fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n///         let bytes = self.as_bytes();\n///         for i in 0..bytes.len() {\n///             writer.write(bytes[i] as Field);\n///         }\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; Self::N];\n\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>);\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut writer: Writer<Self::N> = Writer::new();\n///         self.stream_serialize(&mut writer);\n///         writer.finish()\n///     }\n///\n///     #[inline_always]\n///     fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n///         Serialize::stream_serialize(self.fields, writer);\n///         Serialize::stream_serialize(self.length, writer);\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let params_len_quote = get_params_len_quote(params);\n\n    let function_body = params\n        .map(|(name, _typ): (Quoted, Type)| {\n            quote {\n                $crate::serialization::Serialize::stream_serialize(self.$name, writer);\n            }\n        })\n        .join(quote {});\n\n    quote {\n        impl$generics_declarations $crate::serialization::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n\n            fn serialize(self) -> [Field; Self::N] {\n                let mut writer: $crate::writer::Writer<Self::N> = $crate::writer::Writer::new();\n                $crate::serialization::Serialize::stream_serialize(self, &mut writer);\n                writer.finish()\n            }\n\n\n            #[inline_always]\n             fn stream_serialize<let K: u32>(self, writer: &mut $crate::writer::Writer<K>) {\n                $function_body\n            }\n        }\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         let mut reader = Reader::new(fields);\n///         let result = Self::stream_deserialize(&mut reader);\n///         reader.finish();\n///         result\n///     }\n///\n///     fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n///         let mut bytes = [0 as u8; M];\n///         for i in 0..M {\n///             bytes[i] = reader.read() as u8;\n///         }\n///         str::<M>::from(bytes)\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self;\n\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self;\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         let mut reader = Reader::new(fields);\n///         let result = Self::stream_deserialize(&mut reader);\n///         reader.finish();\n///         result\n///     }\n///\n///     #[inline_always]\n///     fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n///         let x = <AztecAddress as Deserialize>::stream_deserialize(reader);\n///         let y = <Field as Deserialize>::stream_deserialize(reader);\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::serialization::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let $param_name = <$param_type as Deserialize>::stream_deserialize(reader);\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::serialization::Deserialize::stream_deserialize(reader) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::serialization::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            fn deserialize(fields: [Field; Self::N]) -> Self {\n                let mut reader = $crate::reader::Reader::new(fields);\n                let result = Self::stream_deserialize(&mut reader);\n                reader.finish();\n                result\n            }\n\n            #[inline_always]\n            fn stream_deserialize<let K: u32>(reader: &mut $crate::reader::Reader<K>) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\ncomptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::serialization::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n"
    },
    "450": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/serde/src/type_impls.nr",
      "source": "use crate::{reader::Reader, serialization::{Deserialize, Serialize}, writer::Writer};\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> bool {\n        reader.read() != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as Field);\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self);\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read()\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u8 as Field);\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u16 as Field);\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u32 as Field);\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self as u64 as Field);\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        reader.read() as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        for i in 0..M {\n            self[i].stream_serialize(writer);\n        }\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        let mut result: [T; M] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = T::stream_deserialize(reader);\n        }\n        result\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write_bool(self.is_some());\n        if self.is_some() {\n            self.unwrap_unchecked().stream_serialize(writer);\n        } else {\n            writer.advance_offset(<T as Serialize>::N);\n        }\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        if reader.read_bool() {\n            Option::some(<T as Deserialize>::stream_deserialize(reader))\n        } else {\n            reader.advance_offset(<T as Deserialize>::N);\n            Option::none()\n        }\n    }\n}\n\nglobal SCALAR_SIZE: u32 = 2;\n\nimpl Serialize for EmbeddedCurveScalar {\n\n    let N: u32 = SCALAR_SIZE;\n\n    fn serialize(self) -> [Field; SCALAR_SIZE] {\n        [self.lo, self.hi]\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self.lo);\n        writer.write(self.hi);\n    }\n}\n\nimpl Deserialize for EmbeddedCurveScalar {\n    let N: u32 = SCALAR_SIZE;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        Self { lo: fields[0], hi: fields[1] }\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        Self { lo: reader.read(), hi: reader.read() }\n    }\n}\n\nglobal POINT_SIZE: u32 = 3;\n\nimpl Serialize for EmbeddedCurvePoint {\n    let N: u32 = POINT_SIZE;\n\n    fn serialize(self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        writer.write(self.x);\n        writer.write(self.y);\n        writer.write(self.is_infinite as Field);\n    }\n}\n\nimpl Deserialize for EmbeddedCurvePoint {\n    let N: u32 = POINT_SIZE;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        Self { x: fields[0], y: fields[1], is_infinite: fields[2] != 0 }\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        Self { x: reader.read(), y: reader.read(), is_infinite: reader.read_bool() }\n    }\n}\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        let u8_arr = <[u8; Self::N] as Deserialize>::stream_deserialize(reader);\n        str::<Self::N>::from(u8_arr)\n    }\n}\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        self.as_bytes().stream_serialize(writer);\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n        let payload_len = Self::N - 1;\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = reader.peek_offset(payload_len) as u32;\n\n        for i in 0..M {\n            if i < len {\n                new_bounded_vec.push(<T as Deserialize>::stream_deserialize(reader));\n            }\n        }\n\n        // +1 for the length of the BoundedVec\n        reader.advance_offset((M - len) * <T as Deserialize>::N + 1);\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(_reader: &mut Reader<K>) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: Writer<Self::N> = Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        self.storage().stream_serialize(writer);\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        writer.write_u32(self.len() as u32);\n    }\n}\n\n// Create a slice of the given length with each element made from `f(i)` where `i` is the current index\ncomptime fn make_slice<Env, T>(length: u32, f: fn[Env](u32) -> T) -> [T] {\n    let mut slice = @[];\n    for i in 0..length {\n        slice = slice.push_back(f(i));\n    }\n    slice\n}\n\n// Implements Serialize and Deserialize for an arbitrary tuple type\ncomptime fn impl_serialize_for_tuple(_m: Module, length: u32) -> Quoted {\n    // `T0`, `T1`, `T2`\n    let type_names = make_slice(length, |i| f\"T{i}\".quoted_contents());\n\n    // `result0`, `result1`, `result2`\n    let result_names = make_slice(length, |i| f\"result{i}\".quoted_contents());\n\n    // `T0, T1, T2`\n    let field_generics = type_names.join(quote [,]);\n\n    // `<T0 as Serialize>::N + <T1 as Serialize>::N + <T2 as Serialize>::N`\n    let full_size_serialize = type_names\n        .map(|type_name| quote {\n        <$type_name as Serialize>::N\n    })\n        .join(quote [+]);\n\n    // `<T0 as Deserialize>::N + <T1 as Deserialize>::N + <T2 as Deserialize>::N`\n    let full_size_deserialize = type_names\n        .map(|type_name| quote {\n        <$type_name as Deserialize>::N\n    })\n        .join(quote [+]);\n\n    // `T0: Serialize, T1: Serialize, T2: Serialize,`\n    let serialize_constraints = type_names\n        .map(|field_name| quote {\n        $field_name: Serialize,\n    })\n        .join(quote []);\n\n    // `T0: Deserialize, T1: Deserialize, T2: Deserialize,`\n    let deserialize_constraints = type_names\n        .map(|field_name| quote {\n        $field_name: Deserialize,\n    })\n        .join(quote []);\n\n    // Statements to serialize each field\n    let serialized_fields = type_names\n        .mapi(|i, _type_name| quote {\n            $crate::serialization::Serialize::stream_serialize(self.$i, writer);\n    })\n        .join(quote []);\n\n    // Statements to deserialize each field\n    let deserialized_fields = type_names\n        .mapi(|i, type_name| {\n            let result_name = result_names[i];\n            quote {\n            let $result_name = <$type_name as $crate::serialization::Deserialize>::stream_deserialize(reader);\n        }\n        })\n        .join(quote []);\n    let deserialize_results = result_names.join(quote [,]);\n\n    quote {\n        impl<$field_generics> Serialize for ($field_generics) where $serialize_constraints {\n            let N: u32 = $full_size_serialize;\n\n            fn serialize(self) -> [Field; Self::N] {\n                let mut writer: $crate::writer::Writer<Self::N> = $crate::writer::Writer::new();\n                self.stream_serialize(&mut writer);\n                writer.finish()\n            }\n\n            #[inline_always]\n            fn stream_serialize<let K: u32>(self, writer: &mut $crate::writer::Writer<K>) {\n\n                $serialized_fields\n            }\n        }\n\n        impl<$field_generics> Deserialize for ($field_generics) where $deserialize_constraints {\n            let N: u32 = $full_size_deserialize;\n\n            fn deserialize(fields: [Field; Self::N]) -> Self {\n                let mut reader = $crate::reader::Reader::new(fields);\n                let result = Self::stream_deserialize(&mut reader);\n                reader.finish();\n                result\n            }\n    \n            #[inline_always]\n            fn stream_deserialize<let K: u32>(reader: &mut $crate::reader::Reader<K>) -> Self {\n                $deserialized_fields\n                ($deserialize_results)\n            }\n        }\n    }\n}\n\n// Keeping these manual impls. They are more efficient since they do not\n// require copying sub-arrays from any serialized arrays.\nimpl<T1> Serialize for (T1,)\nwhere\n    T1: Serialize,\n{\n    let N: u32 = <T1 as Serialize>::N;\n\n    fn serialize(self) -> [Field; Self::N] {\n        let mut writer: crate::writer::Writer<Self::N> = crate::writer::Writer::new();\n        self.stream_serialize(&mut writer);\n        writer.finish()\n    }\n\n    #[inline_always]\n    fn stream_serialize<let K: u32>(self, writer: &mut Writer<K>) {\n        self.0.stream_serialize(writer);\n    }\n}\n\nimpl<T1> Deserialize for (T1,)\nwhere\n    T1: Deserialize,\n{\n    let N: u32 = <T1 as Deserialize>::N;\n\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::reader::Reader::new(fields);\n        let result = Self::stream_deserialize(&mut reader);\n        reader.finish();\n        result\n    }\n\n    #[inline_always]\n    fn stream_deserialize<let K: u32>(reader: &mut Reader<K>) -> Self {\n        (<T1 as Deserialize>::stream_deserialize(reader),)\n    }\n}\n\n#[impl_serialize_for_tuple(2)]\n#[impl_serialize_for_tuple(3)]\n#[impl_serialize_for_tuple(4)]\n#[impl_serialize_for_tuple(5)]\n#[impl_serialize_for_tuple(6)]\nmod impls {\n    use crate::serialization::{Deserialize, Serialize};\n}\n"
    },
    "460": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.3.0/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK_SIZE, INT_SIZE, INT_SIZE_PTR,\n    MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\nmod oracle_tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    assert(message_size <= N);\n\n    let (h, msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n    finalize_sha256_blocks(message_size, h, msg_block)\n}\n\n/// Returns the first partially filled message block along with the internal state prior to its compression.\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> (STATE, MSG_BLOCK) {\n    if std::runtime::is_unconstrained() {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = initial_state;\n        // Pointer into msg_block on a 64 byte scale\n        for i in 0..num_full_blocks {\n            let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n            h = sha256_compression(msg_block, h);\n        }\n\n        // We now build the final un-filled block.\n        let msg_byte_ptr = message_size % BLOCK_SIZE;\n        let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n            let num_full_blocks = message_size / BLOCK_SIZE;\n            let msg_start = BLOCK_SIZE * num_full_blocks;\n            build_msg_block(msg, message_size, msg_start)\n        } else {\n            // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n            // so we short-circuit in this case.\n            [0; 16]\n        };\n\n        (h, msg_block)\n    } else {\n        let num_blocks = N / BLOCK_SIZE;\n\n        // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n        // for the given message size with a lookup.\n        //\n        // These can be reasoned about as followed:\n        // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n        // - `states[i]` should then be the state after processing the first `i` blocks.\n        // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n        // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n        //\n        // In other words:\n        //\n        // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n        // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n        //\n        // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n        let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n        let mut states: [STATE; N / BLOCK_SIZE + 1] = [initial_state; N / BLOCK_SIZE + 1];\n\n        // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n        // no matter the value of `message_size`.\n        //\n        // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n        let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n            message_size / BLOCK_SIZE\n        } else {\n            0\n        };\n\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let new_msg_block = build_msg_block(msg, message_size, msg_start);\n\n            blocks[i] = new_msg_block;\n            states[i + 1] = sha256_compression(new_msg_block, states[i]);\n        }\n        // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n        if N % BLOCK_SIZE != 0 {\n            let new_msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks);\n\n            blocks[num_blocks] = new_msg_block;\n        }\n\n        (states[first_partially_filled_block_index], blocks[first_partially_filled_block_index])\n    }\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block_helper<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Build a message block from the input message starting at `msg_start`.\n//\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn build_msg_block<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> MSG_BLOCK {\n    let msg_block =\n        // Safety: We constrain the block below by reconstructing each `u32` word from the input bytes.\n        unsafe { build_msg_block_helper(msg, message_size, msg_start) };\n\n    if !is_unconstrained() {\n        let mut msg_end = msg_start + BLOCK_SIZE;\n\n        let max_read_index = std::cmp::min(message_size, msg_end);\n\n        // Reconstructed packed item\n        let mut msg_item: Field = 0;\n\n        // Inclusive at the end so that we can compare the last item.\n        for k in msg_start..=msg_end {\n            if (k != msg_start) & (k % INT_SIZE == 0) {\n                // If we consumed some input we can compare against the block.\n                let msg_block_index = (k - msg_start) / INT_SIZE - 1;\n                assert_eq(msg_block[msg_block_index] as Field, msg_item);\n\n                msg_item = 0;\n            }\n\n            // If we have input to consume, add it at the rightmost position.\n            let msg_byte = if k < max_read_index { msg[k] } else { 0 };\n            msg_item = msg_item * (TWO_POW_8 as Field) + msg_byte as Field;\n        }\n    }\n    msg_block\n}\n\n// Encode `8 * message_size` into two `u32` limbs.\nunconstrained fn encode_len(message_size: u32) -> (u32, u32) {\n    let len = 8 * message_size as u64;\n    let lo = len & 0xFFFFFFFF;\n    let hi = (len >> 32) & 0xFFFFFFFF;\n    (lo as u32, hi as u32)\n}\n\n// Write the length into the last 8 bytes of the block.\nfn attach_len_to_msg_block(mut msg_block: MSG_BLOCK, message_size: u32) -> MSG_BLOCK {\n    // Safety: We assert the correctness of the decomposition below.\n    // 2 `u32` limbs cannot overflow the field modulus so performing the check as `Field`s is safe.\n    let (lo, hi) = unsafe { encode_len(message_size) };\n    assert_eq(8 * (message_size as Field), lo as Field + hi as Field * TWO_POW_32);\n\n    msg_block[INT_SIZE_PTR] = hi;\n    msg_block[INT_SIZE_PTR + 1] = lo;\n    msg_block\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n/// Lookup table for the position of the padding bit within one of the `u32` words in the final message block.\nglobal PADDING_BIT_TABLE: [u32; 4] =\n    [(1 << 7) * TWO_POW_24, (1 << 7) * TWO_POW_16, (1 << 7) * TWO_POW_8, (1 << 7)];\n\n/// Add 1 bit padding to end of message and compress the block if there's not enough room for the 8-byte length.\n/// Returns the updated hash state and message block that will be used to write the message size.\n///\n/// # Assumptions:\n///\n/// - `msg_block[i] == 0` for all `i > msg_byte_ptr / INT_SIZE`\n/// - `msg_block[msg_byte_ptr / INT_SIZE] & ((1 << 7) * (msg_byte_ptr % INT_SIZE)) == 0`\nfn add_padding_byte_and_compress_if_needed(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n\n    // Lookup the position of the padding bit and insert it into the message block.\n    msg_block[index] += PADDING_BIT_TABLE[msg_byte_ptr % INT_SIZE];\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr >= MSG_SIZE_PTR {\n        let h = sha256_compression(msg_block, h);\n\n        // In this case, the final block consists of all zeros with the last 8 bytes containing the length.\n        // We set msg_block to all zeros and attach_len_to_msg_block will add the length to the last 8 bytes.\n        let msg_block = [0; INT_BLOCK_SIZE];\n        (h, msg_block)\n    } else {\n        (h, msg_block)\n    }\n}\n\npub(crate) fn finalize_sha256_blocks(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (h, msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\n// Helper function to finalize the message block with padding and length\nunconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // We now build the final un-filled block.\n    let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        build_msg_block(msg, message_size, msg_start)\n    } else {\n        // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n        // so we short-circuit in this case.\n        [0; 16]\n    };\n\n    // Once built, we need to add the necessary padding bytes and encoded length\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\nmod test_process_full_blocks {\n\n    /// Wrapper to force an unconstrained runtime on process_full_blocks.\n    unconstrained fn unconstrained_process_full_blocks<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n        h: super::STATE,\n    ) -> (super::STATE, super::MSG_BLOCK) {\n        super::process_full_blocks(msg, message_size, h)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_state =\n            unsafe { unconstrained_process_full_blocks(msg, message_size, super::INITIAL_STATE) };\n        let state = super::process_full_blocks(msg, message_size, super::INITIAL_STATE);\n        assert_eq(state, unconstrained_state);\n    }\n}\n\nmod test_sha256_var {\n\n    /// Wrapper to force an unconstrained runtime on sha256.\n    unconstrained fn unconstrained_sha256<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n    ) -> super::HASH {\n        super::sha256_var(msg, message_size)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { unconstrained_sha256(msg, message_size) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_vectors() {\n        let vector_1 = [0, 1, 2, 3].as_vector();\n        let vector_2 = [0, 1, 2].as_vector();\n        assert(!vector_1.eq(vector_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_vectors() {\n        assert(\n            [2_u32].as_vector().cmp([1_u32, 1_u32, 1_u32].as_vector())\n                == super::Ordering::greater(),\n        );\n        assert(\n            [1_u32, 2_u32].as_vector().cmp([1_u32, 2_u32, 3_u32].as_vector())\n                == super::Ordering::less(),\n        );\n    }\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/fee_juice_contract/src/lib.nr",
      "source": "use aztec::context::PublicContext;\nuse aztec::protocol::address::AztecAddress;\nuse aztec::protocol::hash::sha256_to_field;\nuse aztec::protocol::traits::ToField;\n\npub fn calculate_fee<TPublicContext>(context: PublicContext) -> Field {\n    context.transaction_fee()\n}\n\n/// Computes the content hash for an L1-to-L2 \"bridge gas\" message, matching the hash produced on L1 by\n/// `FeeJuicePortal.depositToAztecPublic`: `sha256ToField(abi.encodeWithSignature(\"claim(bytes32,uint256)\", to, amount))`.\n///\n/// The 68-byte buffer is: [4-byte selector of \"claim(bytes32,uint256)\"][32-byte recipient][32-byte amount], hashed\n/// with `sha256_to_field` to produce a single Field.\npub fn get_bridge_gas_msg_hash(owner: AztecAddress, amount: u128) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes: [u8; 32] = owner.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { keccak256::keccak256(\"claim(bytes32,uint256)\".as_bytes(), 22) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/fee_juice_contract/src/main.nr",
      "source": "/// Protocol contract that manages the native gas token (\"Fee Juice\") used to pay transaction fees.\n///\n/// Fee Juice is minted on L2 by bridging from L1: a user deposits ERC-20 tokens into the L1 FeeJuicePortal, which\n/// sends an L1-to-L2 message. On L2, `claim` or `claim_and_end_setup` consumes that message and credits the\n/// recipient's balance via an enqueued public call to `_increase_public_balance`.\n///\n/// The protocol's base rollup circuits read directly from this contract's `balances` storage map (at slot 1) to verify\n/// fee payers can cover their transaction costs. This storage layout is protocol-critical and must not change without\n/// updating the base rollup circuits.\n///\n/// There is no withdrawal mechanism -- Fee Juice can only be bridged in, not withdrawn or transferred by users. Tokens\n/// leave the L1 portal only via `distributeFees` called by the Rollup contract to pay sequencers.\n\nmod lib;\n\npub contract FeeJuice {\n    use crate::lib::get_bridge_gas_msg_hash;\n    use aztec::{\n        protocol::{\n            abis::function_selector::FunctionSelector,\n            address::{AztecAddress, EthAddress},\n            constants::FEE_JUICE_ADDRESS,\n            traits::{Deserialize, ToField},\n        },\n        state_vars::{Map, PublicMutable},\n    };\n    use std::ops::Add;\n\n    struct Storage<Context> {\n        // contract address --> public fee juice balance\n        balances: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n    }\n\n    global INCREASE_PUBLIC_BALANCE_SELECTOR: Field = comptime {\n        FunctionSelector::from_signature(\"_increase_public_balance((Field),u128)\").to_field()\n    };\n\n    global CHECK_BALANCE_SELECTOR: Field =\n        comptime { FunctionSelector::from_signature(\"check_balance(u128)\").to_field() };\n\n    global BALANCE_OF_PUBLIC_SELECTOR: Field =\n        comptime { FunctionSelector::from_signature(\"balance_of_public((Field))\").to_field() };\n\n    /// A helper implementing the core L1-to-L2 message claim logic shared by `claim` and `claim_and_end_setup`.\n    /// Computes the expected content hash, consumes the L1-to-L2 message (emitting a nullifier to prevent\n    /// double-claiming), and enqueues a public call to `_increase_public_balance` to credit the recipient.\n    #[contract_library_method]\n    fn claim_helper(\n        context: &mut aztec::context::PrivateContext,\n        to: AztecAddress,\n        amount: u128,\n        secret: Field,\n        message_leaf_index: Field,\n    ) {\n        let content_hash: Field = get_bridge_gas_msg_hash(to, amount);\n        let portal_address: EthAddress = EthAddress::from_field(FEE_JUICE_ADDRESS.to_field());\n        assert(!portal_address.is_zero());\n\n        // Consume the L1-to-L2 message (verifies existence + emits nullifier to prevent replay).\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address, message_leaf_index);\n\n        // Enqueue a public call to _increase_public_balance to credit the recipient.\n        let serialized_params: [Field; 2] = [to.to_field(), amount.to_field()];\n        let calldata: [Field; 1 + 2] = [INCREASE_PUBLIC_BALANCE_SELECTOR].concat(serialized_params);\n        let calldata_hash: Field = aztec::hash::hash_calldata_array(calldata);\n        aztec::oracle::execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            context.this_address(),\n            calldata_hash,\n            false,\n            false,\n        );\n    }\n\n    /// Claims Fee Juice by consuming an L1-to-L2 message from the FeeJuicePortal.\n    ///\n    /// Use this variant when the claimed Fee Juice is NOT intended to pay for the current transaction's fees (e.g.,\n    /// pre-funding an account for future transactions).\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n    fn claim(\n        inputs: aztec::context::inputs::PrivateContextInputs,\n        to: AztecAddress,\n        amount: u128,\n        secret: Field,\n        message_leaf_index: Field,\n    ) -> return_data aztec::protocol::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n        // MACRO CODE START\n        // Note: The macros initially inserted a phase check here, but since there is no phase change in this function\n        // nor in the claim helper function or the enqueued public function call, I have removed that check.\n        aztec::oracle::version::assert_compatible_oracle_version();\n        let serialized_params: [Field; 4] =\n            [to.to_field(), amount.to_field(), secret, message_leaf_index];\n        let args_hash: Field = aztec::hash::hash_args(serialized_params);\n        let mut context: aztec::context::PrivateContext =\n            aztec::context::PrivateContext::new(inputs, args_hash);\n        // MACRO CODE END\n\n        claim_helper(&mut context, to, amount, secret, message_leaf_index);\n\n        // MACRO CODE START\n        context.finish()\n        // MACRO CODE END\n    }\n\n    /// Claims Fee Juice and ends the transaction setup phase.\n    ///\n    /// Use this variant when the claimed Fee Juice is intended to pay for THIS transaction's fees. By ending setup\n    /// after the claim, the balance increase is placed in the non-revertible phase, ensuring the fee payer's balance\n    /// is credited even if the revertible portion of the transaction fails. This guarantees the sequencer can collect\n    /// fees.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_private]\n    fn claim_and_end_setup(\n        inputs: aztec::context::inputs::PrivateContextInputs,\n        to: AztecAddress,\n        amount: u128,\n        secret: Field,\n        message_leaf_index: Field,\n    ) -> return_data aztec::protocol::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs {\n        // MACRO CODE START\n        aztec::oracle::version::assert_compatible_oracle_version();\n        let serialized_params: [Field; 4] =\n            [to.to_field(), amount.to_field(), secret, message_leaf_index];\n        let args_hash: Field = aztec::hash::hash_args(serialized_params);\n        let mut context: aztec::context::PrivateContext =\n            aztec::context::PrivateContext::new(inputs, args_hash);\n        // MACRO CODE END\n\n        claim_helper(&mut context, to, amount, secret, message_leaf_index);\n\n        // MACRO CODE START\n        // End setup: everything before this point (including the enqueued _increase_public_balance\n        // call) is non-revertible. Everything after is revertible.\n        context.end_setup();\n        context.finish()\n        // MACRO CODE END\n    }\n\n    /// Internal function that credits a recipient's Fee Juice balance. Only callable by this contract itself\n    /// (`#[only_self]`), enqueued by `claim` / `claim_and_end_setup` after consuming an L1-to-L2 message.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_only_self]\n    unconstrained fn _increase_public_balance(to: AztecAddress, amount: u128) {\n        // MACRO CODE START\n        let context: aztec::context::PublicContext = aztec::context::PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 2] = aztec::oracle::avm::calldata_copy(\n                    1,\n                    <AztecAddress as aztec::protocol::traits::Serialize>::N\n                        + <u128 as aztec::protocol::traits::Serialize>::N,\n                );\n                aztec::hash::hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<aztec::context::PublicContext> =\n            Storage::<aztec::context::PublicContext>::init(context);\n\n        assert(\n            context.maybe_msg_sender().unwrap() == context.this_address(),\n            \"Function _increase_public_balance can only be called by the same contract\",\n        );\n        // MACRO CODE END\n\n        let new_balance = storage.balances.at(to).read().add(amount);\n        storage.balances.at(to).write(new_balance);\n    }\n\n    /// Asserts the caller has at least `fee_limit` Fee Juice. Used during transaction validation to verify the fee\n    /// payer can cover the transaction's fee limit.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_view]\n    unconstrained fn check_balance(fee_limit: u128) {\n        // MACRO CODE START\n        let context: aztec::context::PublicContext = aztec::context::PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 1] = aztec::oracle::avm::calldata_copy(\n                    1,\n                    <u128 as aztec::protocol::traits::Serialize>::N,\n                );\n                aztec::hash::hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<aztec::context::PublicContext> =\n            Storage::<aztec::context::PublicContext>::init(context);\n\n        assert(context.is_static_call(), \"Function check_balance can only be called statically\");\n        // MACRO CODE END\n\n        assert(\n            storage.balances.at(context.maybe_msg_sender().unwrap()).read() >= fee_limit,\n            \"Balance too low\",\n        );\n    }\n\n    /// Returns the Fee Juice balance of the given address.\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_view]\n    unconstrained fn balance_of_public(owner: AztecAddress) -> pub u128 {\n        // MACRO CODE START\n        let context: aztec::context::PublicContext = aztec::context::PublicContext::new(\n            || -> Field {\n                let serialized_args: [Field; 1] = aztec::oracle::avm::calldata_copy(\n                    1,\n                    <AztecAddress as aztec::protocol::traits::Serialize>::N,\n                );\n                aztec::hash::hash_args(serialized_args)\n            },\n        );\n        let storage: Storage<aztec::context::PublicContext> =\n            Storage::<aztec::context::PublicContext>::init(context);\n\n        assert(\n            context.is_static_call(),\n            \"Function balance_of_public can only be called statically\",\n        );\n        // MACRO CODE END\n\n        storage.balances.at(owner).read()\n    }\n\n    // THE REST OF THE CODE IN THIS CONTRACT WAS ORIGINALLY INJECTED BY THE #[aztec] MACRO.\n\n    #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n    pub unconstrained fn public_dispatch(selector: Field) {\n        if selector == INCREASE_PUBLIC_BALANCE_SELECTOR {\n            let input_calldata: [Field; 2] = aztec::oracle::avm::calldata_copy(\n                1,\n                <AztecAddress as aztec::protocol::traits::Serialize>::N\n                    + <u128 as aztec::protocol::traits::Serialize>::N,\n            );\n            let mut reader: aztec::protocol::utils::reader::Reader<2> =\n                aztec::protocol::utils::reader::Reader::<2>::new(input_calldata);\n            let arg0: AztecAddress = <AztecAddress as Deserialize>::stream_deserialize(&mut reader);\n            let arg1: u128 = <u128 as Deserialize>::stream_deserialize(&mut reader);\n            _increase_public_balance(arg0, arg1);\n            aztec::oracle::avm::avm_return([].as_vector());\n        };\n        if selector == CHECK_BALANCE_SELECTOR {\n            let input_calldata: [Field; 1] = aztec::oracle::avm::calldata_copy(\n                1,\n                <u128 as aztec::protocol::traits::Serialize>::N,\n            );\n            let mut reader: aztec::protocol::utils::reader::Reader<1> =\n                aztec::protocol::utils::reader::Reader::<1>::new(input_calldata);\n            let arg0: u128 = <u128 as Deserialize>::stream_deserialize(&mut reader);\n            check_balance(arg0);\n            aztec::oracle::avm::avm_return([].as_vector());\n        };\n        if selector == BALANCE_OF_PUBLIC_SELECTOR {\n            let input_calldata: [Field; 1] = aztec::oracle::avm::calldata_copy(\n                1,\n                <AztecAddress as aztec::protocol::traits::Serialize>::N,\n            );\n            let mut reader: aztec::protocol::utils::reader::Reader<1> =\n                aztec::protocol::utils::reader::Reader::<1>::new(input_calldata);\n            let arg0: AztecAddress = <AztecAddress as Deserialize>::stream_deserialize(&mut reader);\n            let return_value: [Field; 1] =\n                <u128 as aztec::protocol::traits::Serialize>::serialize(balance_of_public(arg0));\n            aztec::oracle::avm::avm_return(return_value.as_vector());\n        };\n        panic(f\"Unknown selector {selector}\")\n    }\n\n    pub struct StorageLayoutFields {\n        pub balances: aztec::state_vars::Storable,\n    }\n\n    pub struct StorageLayout<let N: u32> {\n        pub contract_name: str<N>,\n        pub fields: StorageLayoutFields,\n    }\n\n    #[abi(storage)]\n    pub global STORAGE_LAYOUT_FeeJuice: StorageLayout<8> = StorageLayout::<8> {\n        contract_name: \"FeeJuice\",\n        fields: StorageLayoutFields { balances: aztec::state_vars::Storable { slot: 1 } },\n    };\n\n    impl<Context> Storage<Context> {\n        fn init(context: Context) -> Self {\n            Self {\n                balances: <Map<AztecAddress, PublicMutable<u128, Context>, Context> as aztec::state_vars::StateVariable<1, Context>>::new(\n                    context,\n                    1,\n                ),\n            }\n        }\n    }\n\n    pub struct _increase_public_balance_parameters {\n        pub _to: AztecAddress,\n        pub _amount: u128,\n    }\n\n    pub struct balance_of_public_parameters {\n        pub _owner: AztecAddress,\n    }\n\n    pub struct check_balance_parameters {\n        pub _fee_limit: u128,\n    }\n\n    pub struct claim_and_end_setup_parameters {\n        pub _to: AztecAddress,\n        pub _amount: u128,\n        pub _secret: Field,\n        pub _message_leaf_index: Field,\n    }\n\n    pub struct claim_parameters {\n        pub _to: AztecAddress,\n        pub _amount: u128,\n        pub _secret: Field,\n        pub _message_leaf_index: Field,\n    }\n\n    #[abi(functions)]\n    pub struct _increase_public_balance_abi {\n        parameters: _increase_public_balance_parameters,\n    }\n\n    #[abi(functions)]\n    pub struct balance_of_public_abi {\n        parameters: balance_of_public_parameters,\n        return_type: u128,\n    }\n\n    #[abi(functions)]\n    pub struct check_balance_abi {\n        parameters: check_balance_parameters,\n    }\n\n    #[abi(functions)]\n    pub struct claim_abi {\n        parameters: claim_parameters,\n    }\n\n    #[abi(functions)]\n    pub struct claim_and_end_setup_abi {\n        parameters: claim_and_end_setup_parameters,\n    }\n}\n"
    },
    "59": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, NullifierExistenceRequest, ReturnsHash},\n    hash::hash_args,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            is_side_effect_counter_revertible_oracle_wrapper, notify_enqueued_public_function_call,\n            notify_set_min_revertible_side_effect_counter,\n        },\n        execution_cache,\n        logs::notify_created_contract_class_log,\n        nullifiers::notify_created_nullifier,\n    },\n};\nuse crate::protocol::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_TX_LIFETIME, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::{Counted, scoped::Scoped},\n    traits::Empty,\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// Minimal PrivateContext for protocol contracts going to audit.\n/// Contains only the methods actually used by: fee_juice, auth_registry, contract_class_registry, contract_instance_registry\n#[derive(Eq)]\npub struct PrivateContext {\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub expiration_timestamp: u64,\n\n    pub nullifier_read_requests: BoundedVec<Scoped<Counted<Field>>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    pub expected_non_revertible_side_effect_counter: u32,\n    pub expected_revertible_side_effect_counter: u32,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            expiration_timestamp: inputs.anchor_block_header.global_variables.timestamp\n            + MAX_TX_LIFETIME,\n            nullifier_read_requests: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call (similar to msg.sender in Solidity).\n    pub fn maybe_msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Returns the contract address of the current function being executed.\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the protocol version.\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Returns the anchor block header.\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Sets the hash of the return values for this private function.\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            expiration_timestamp: self.expiration_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::empty(), // Not used by protocol contracts\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_separators: ClaimedLengthArray::empty(), // Not used by protocol contracts\n            note_hashes: ClaimedLengthArray::empty(), // Not used by protocol contracts\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n            expected_non_revertible_side_effect_counter: self\n                .expected_non_revertible_side_effect_counter,\n            expected_revertible_side_effect_counter: self.expected_revertible_side_effect_counter,\n        }\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx. Used by fee_juice.\n    pub fn end_setup(&mut self) {\n        self.side_effect_counter += 1;\n        self.min_revertible_side_effect_counter = self.next_counter();\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    pub fn in_revertible_phase(&mut self) -> bool {\n        let current_counter = self.side_effect_counter;\n\n        // Safety: Kernel will validate that the claim is correct by validating the expected counters.\n        let is_revertible =\n            unsafe { is_side_effect_counter_revertible_oracle_wrapper(current_counter) };\n\n        if is_revertible {\n            if (self.expected_revertible_side_effect_counter == 0)\n                | (current_counter < self.expected_revertible_side_effect_counter) {\n                self.expected_revertible_side_effect_counter = current_counter;\n            }\n        } else if current_counter > self.expected_non_revertible_side_effect_counter {\n            self.expected_non_revertible_side_effect_counter = current_counter;\n        }\n\n        is_revertible\n    }\n\n    /// Sets a deadline for when this transaction must be included in a block.\n    pub fn set_expiration_timestamp(&mut self, expiration_timestamp: u64) {\n        self.expiration_timestamp = std::cmp::min(self.expiration_timestamp, expiration_timestamp);\n    }\n\n    /// Pushes a new nullifier. Used by class_registry and instance_registry.\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Asserts that a nullifier has been emitted. Used by instance_registry.\n    pub fn assert_nullifier_exists(\n        &mut self,\n        nullifier_existence_request: NullifierExistenceRequest,\n    ) {\n        let nullifier = nullifier_existence_request.nullifier();\n        let contract_address =\n            nullifier_existence_request.maybe_contract_address().unwrap_or(AztecAddress::zero());\n\n        let request = Scoped::new(\n            Counted::new(nullifier, self.next_counter()),\n            contract_address,\n        );\n\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2). Used by fee_juice.\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log. Used by instance_registry.\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    /// Emits a contract class log. Used by class_registry.\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond\n        // length are zero. However, it won't be able to check that we didn't add extra padding (trailing zeroes) or\n        // that we cut trailing zeroes from the end.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter\n        // bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be\n        // constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Makes a read-only call to a private function. Used by auth_registry for authwit.\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function with a calldata hash. Used by fee_juice and auth_registry.\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            expiration_timestamp: 0,\n            nullifier_read_requests: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            expected_non_revertible_side_effect_counter: 0,\n            expected_revertible_side_effect_counter: 0,\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/context/public_context.nr",
      "source": "use crate::{\n    context::gas::GasOpts,\n    hash::{\n        compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n        compute_siloed_nullifier,\n    },\n    oracle::avm,\n};\nuse crate::protocol::{\n    abis::function_selector::FunctionSelector,\n    address::{AztecAddress, EthAddress},\n    constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS},\n    traits::{Empty, FromField, Packable, Serialize, ToField},\n};\n\n/// Minimal PublicContext for protocol contracts going to audit.\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::emit_public_log(Serialize::serialize(log).as_vector()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular leaf_index.\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message tree at a particular leaf index.\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { avm::l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Returns `true` if an `unsiloed_nullifier` has been emitted by `contract_address`.\n    pub fn nullifier_exists_unsafe(\n        _self: Self,\n        unsiloed_nullifier: Field,\n        contract_address: AztecAddress,\n    ) -> bool {\n        let siloed_nullifier = compute_siloed_nullifier(contract_address, unsiloed_nullifier);\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::nullifier_exists(siloed_nullifier) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists_unsafe(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\".\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        avm::call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = avm::success_copy();\n\n        let result_data = avm::returndata_copy(0, avm::returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm::revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        avm::call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = avm::success_copy();\n\n        let result_data = avm::returndata_copy(0, avm::returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm::revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Note Hash Tree.\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Nullifier Tree.\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    pub fn maybe_msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { avm::sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself.\n        let raw_selector: [Field; 1] = unsafe { avm::calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::chain_id()\n        }\n    }\n\n    /// Returns the protocol version.\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::version()\n        }\n    }\n\n    /// Returns the current block number.\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas.\n    pub fn min_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::min_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA gas.\n    pub fn min_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::min_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available.\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA gas available.\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            avm::da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context.\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { avm::is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    pub fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe {\n                avm::storage_read(storage_slot + i as Field, self.this_address().to_field())\n            };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { avm::storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n"
    },
    "63": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/hash.nr",
      "source": "//! Aztec hash functions.\n\nuse crate::protocol::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        DOM_SEP__FUNCTION_ARGS, DOM_SEP__MESSAGE_NULLIFIER, DOM_SEP__PUBLIC_BYTECODE,\n        DOM_SEP__PUBLIC_CALLDATA, DOM_SEP__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    traits::ToField,\n};\n\npub use crate::protocol::hash::compute_siloed_nullifier;\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], DOM_SEP__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], DOM_SEP__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, DOM_SEP__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, DOM_SEP__PUBLIC_CALLDATA)\n}\n\n/// Computes the public bytecode commitment for a contract class. The commitment is `hash([(length | separator),\n/// ...bytecode])`.\n///\n/// @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n/// packed_bytecode is mutable so that we can avoid copying the array to construct one starting with first_field\n/// instead of length. @returns The public bytecode commitment.\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 = (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode. AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Append it to the separator before hashing.\n    let first_field = DOM_SEP__PUBLIC_BYTECODE.to_field() + (packed_public_bytecode[0] as u64 << 32) as Field;\n    packed_public_bytecode[0] = first_field;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored. +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse crate::protocol::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/avm.nr",
      "source": "//! AVM oracles.\n//!\n//! There are only available during public execution. Calling any of them from a private or utility function will\n//! result in runtime errors.\n\nuse crate::protocol::address::{AztecAddress, EthAddress};\n\npub unconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\npub unconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\npub unconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\npub unconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\npub unconstrained fn version() -> Field {\n    version_opcode()\n}\npub unconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\npub unconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\npub unconstrained fn min_fee_per_l2_gas() -> u128 {\n    min_fee_per_l2_gas_opcode()\n}\npub unconstrained fn min_fee_per_da_gas() -> u128 {\n    min_fee_per_da_gas_opcode()\n}\npub unconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\npub unconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\npub unconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\npub unconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\npub unconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\npub unconstrained fn nullifier_exists(siloed_nullifier: Field) -> u1 {\n    nullifier_exists_opcode(siloed_nullifier)\n}\npub unconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\npub unconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\npub unconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\npub unconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\npub unconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n/// `success_copy` is placed immediately after the CALL opcode to get the success value\npub unconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\npub unconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\npub unconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\n/// The additional prefix is to avoid clashing with the `return` Noir keyword.\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n/// This opcode reverts using the exact data given. In general it should only be used to do rethrows, where the revert\n/// data is the same as the original revert data. For normal reverts, use Noir's `assert` which, on top of reverting,\n/// will also add an error selector to the revert data.\npub unconstrained fn revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\npub unconstrained fn storage_read(storage_slot: Field, contract_address: Field) -> Field {\n    storage_read_opcode(storage_slot, contract_address)\n}\n\npub unconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeMinFeePerL2Gas)]\nunconstrained fn min_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeMinFeePerDaGas)]\nunconstrained fn min_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(siloed_nullifier: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitPublicLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take\n// that route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take\n// that route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field, contract_address: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "76": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/enqueue_public_function_call.nr",
      "source": "use crate::protocol::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to\n    // process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to\n    // process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n\npub unconstrained fn is_side_effect_counter_revertible_oracle_wrapper(counter: u32) -> bool {\n    is_side_effect_counter_revertible_oracle(counter)\n}\n\n#[oracle(privateIsSideEffectCounterRevertible)]\nunconstrained fn is_side_effect_counter_revertible_oracle(counter: u32) -> bool {}\n"
    },
    "78": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store<let N: u32>(values: [Field; N], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper<let N: u32>(\n    values: [Field; N],\n    hash: Field,\n) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle<let N: u32>(_values: [Field; N], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "79": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use crate::protocol::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(utilityGetL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {}\n"
    },
    "82": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/oracle/nullifiers.nr",
      "source": "//! Nullifier creation, existence checks, etc.\n\nuse crate::protocol::address::aztec_address::AztecAddress;\n\n/// Notifies the simulator that a nullifier has been created, so that its correct status (pending or settled) can be\n/// determined when reading nullifiers in subsequent private function calls. The first non-revertible nullifier emitted\n/// is also used to compute note nonces.\npub fn notify_created_nullifier(inner_nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle(inner_nullifier) };\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_inner_nullifier: Field) {}\n\n/// Returns true if the nullifier has been emitted in the same transaction, i.e. if [notify_created_nullifier] has been\n/// called for this inner nullifier from the contract with the specified address.\n///\n/// Note that despite sharing pending transaction information with the app, this is not a privacy leak: anyone in the\n/// network can always determine in which transaction a inner nullifier was emitted by a given contract by simply\n/// inspecting transaction effects. What _would_ constitute a leak would be to share the list of inner pending\n/// nullifiers, as that would reveal their preimages.\npub unconstrained fn is_nullifier_pending(\n    inner_nullifier: Field,\n    contract_address: AztecAddress,\n) -> bool {\n    is_nullifier_pending_oracle(inner_nullifier, contract_address)\n}\n\n#[oracle(privateIsNullifierPending)]\nunconstrained fn is_nullifier_pending_oracle(\n    _inner_nullifier: Field,\n    _contract_address: AztecAddress,\n) -> bool {}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before\n/// the current transaction is included in a block. While this might seem of little use at first, certain design\n/// patterns benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n"
    },
    "85": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/state_vars/map.nr",
      "source": "use crate::protocol::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::StateVariable;\n\n/// A key-value container for state variables.\n///\n/// A key-value storage container that maps keys to state variables, similar to Solidity mappings.\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity.\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n"
    },
    "87": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/aztec_sublib/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::protocol::traits::Packable;\nuse crate::state_vars::StateVariable;\n\n/// Mutable public values.\n///\n/// This is one of the most basic public state variables. It is equivalent to a non-`immutable` non-`constant` Solidity\n/// state variable.\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Returns the current value.\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Stores a new value.\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Returns the value at the anchor block.\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    }
  }
}
