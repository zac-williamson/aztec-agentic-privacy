import { InboxContract } from '@aztec/ethereum/contracts';
import { createLogger } from '@aztec/foundation/log';
import { promiseWithResolvers } from '@aztec/foundation/promise';
import { DateProvider } from '@aztec/foundation/timer';
import { EventEmitter } from 'events';
/** Utility class that polls the chain on quick intervals and logs new L1 blocks, L2 blocks, and L2 proofs. */ export class ChainMonitor extends EventEmitter {
    rollup;
    dateProvider;
    logger;
    intervalMs;
    l1Client;
    inbox;
    handle;
    // eslint-disable-next-line aztec-custom/no-non-primitive-in-collections
    running;
    /** Current L1 block number */ l1BlockNumber;
    /** Current checkpoint number */ checkpointNumber;
    /** Current proven checkpoint number */ provenCheckpointNumber;
    /** L1 timestamp for the current checkpoint */ checkpointTimestamp;
    /** L1 timestamp for the proven checkpoint */ provenCheckpointTimestamp;
    /** Total number of L2 messages pushed into the Inbox */ totalL2Messages;
    /** Current L2 epoch number */ l2EpochNumber;
    /** Current L2 slot number */ l2SlotNumber;
    constructor(rollup, dateProvider = new DateProvider(), logger = createLogger('aztecjs:utils:chain_monitor'), intervalMs = 200){
        super(), this.rollup = rollup, this.dateProvider = dateProvider, this.logger = logger, this.intervalMs = intervalMs, this.running = new Set(), this.totalL2Messages = 0;
        this.l1Client = rollup.client;
    }
    start() {
        if (this.handle) {
            throw new Error('Chain monitor already started');
        }
        this.handle = setInterval(this.safeRun.bind(this), this.intervalMs);
        return this;
    }
    async stop() {
        try {
            this.removeAllListeners();
            if (this.handle) {
                clearInterval(this.handle);
                this.handle = undefined;
            }
            await Promise.allSettled([
                ...this.running
            ]);
        } catch (err) {
            this.logger.error('Error stopping chain monitor', err);
        }
    }
    async getInbox() {
        if (!this.inbox) {
            const { inboxAddress } = await this.rollup.getRollupAddresses();
            this.inbox = new InboxContract(this.l1Client, inboxAddress);
        }
        return this.inbox;
    }
    safeRun() {
        const running = promiseWithResolvers();
        this.running.add(running.promise);
        void this.run().catch((error)=>{
            this.logger.error('Error in chain monitor loop', error);
        }).finally(()=>{
            running.resolve();
            this.running.delete(running.promise);
        });
    }
    async run(force = false) {
        const newL1BlockNumber = Number(await this.l1Client.getBlockNumber({
            cacheTime: 0
        }));
        if (!force && this.l1BlockNumber === newL1BlockNumber) {
            return this;
        }
        this.l1BlockNumber = newL1BlockNumber;
        const [l2SlotNumber, l2Epoch, l1block] = await Promise.all([
            this.rollup.getSlotNumber(),
            this.rollup.getCurrentEpoch(),
            this.l1Client.getBlock({
                blockNumber: BigInt(newL1BlockNumber),
                includeTransactions: false
            })
        ]);
        const timestamp = l1block.timestamp;
        const timestampString = new Date(Number(timestamp) * 1000).toTimeString().split(' ')[0];
        this.emit('l1-block', {
            l1BlockNumber: newL1BlockNumber,
            timestamp
        });
        let msg = `L1 block ${newL1BlockNumber} mined at ${timestampString}`;
        const newCheckpointNumber = await this.rollup.getCheckpointNumber();
        if (this.checkpointNumber !== newCheckpointNumber) {
            const epochNumber = await this.rollup.getEpochNumberForCheckpoint(newCheckpointNumber);
            msg += ` with new checkpoint ${newCheckpointNumber} for epoch ${epochNumber}`;
            this.checkpointNumber = newCheckpointNumber;
            this.checkpointTimestamp = timestamp;
            this.emit('checkpoint', {
                checkpointNumber: newCheckpointNumber,
                l1BlockNumber: newL1BlockNumber,
                l2SlotNumber,
                timestamp
            });
        }
        const newProvenCheckpointNumber = await this.rollup.getProvenCheckpointNumber();
        if (this.provenCheckpointNumber !== newProvenCheckpointNumber) {
            const epochNumber = await this.rollup.getEpochNumberForCheckpoint(newProvenCheckpointNumber);
            msg += ` with proof up to checkpoint ${newProvenCheckpointNumber} for epoch ${epochNumber}`;
            this.provenCheckpointNumber = newProvenCheckpointNumber;
            this.provenCheckpointTimestamp = timestamp;
            this.emit('checkpoint-proven', {
                provenCheckpointNumber: newProvenCheckpointNumber,
                l1BlockNumber: newL1BlockNumber,
                timestamp
            });
        }
        const inbox = await this.getInbox();
        const newTotalL2Messages = await inbox.getState().then((s)=>Number(s.totalMessagesInserted));
        if (this.totalL2Messages !== newTotalL2Messages) {
            msg += ` with ${newTotalL2Messages - this.totalL2Messages} new L2 messages (total ${newTotalL2Messages})`;
            this.totalL2Messages = newTotalL2Messages;
            this.emit('l2-messages', {
                totalL2Messages: newTotalL2Messages,
                l1BlockNumber: newL1BlockNumber
            });
        }
        let committee;
        if (l2Epoch !== this.l2EpochNumber) {
            this.l2EpochNumber = l2Epoch;
            committee = await this.rollup.getCurrentEpochCommittee();
            this.emit('l2-epoch', {
                l2EpochNumber: l2Epoch,
                timestamp,
                committee
            });
            msg += ` starting new epoch ${this.l2EpochNumber} `;
        }
        if (l2SlotNumber !== this.l2SlotNumber) {
            this.l2SlotNumber = l2SlotNumber;
            this.emit('l2-slot', {
                l2SlotNumber,
                timestamp
            });
        }
        this.logger.info(msg, {
            currentTimestamp: this.dateProvider.nowInSeconds(),
            l1Timestamp: timestamp,
            l1BlockNumber: this.l1BlockNumber,
            l2SlotNumber,
            l2Epoch,
            checkpointNumber: this.checkpointNumber,
            provenCheckpointNumber: this.provenCheckpointNumber,
            totalL2Messages: this.totalL2Messages,
            committee
        });
        return this;
    }
    waitUntilL2Slot(slot) {
        if (this.l2SlotNumber >= slot) {
            return Promise.resolve();
        }
        return new Promise((resolve)=>{
            const listener = (data)=>{
                if (data.l2SlotNumber >= slot) {
                    this.off('l2-slot', listener);
                    resolve();
                }
            };
            this.on('l2-slot', listener);
        });
    }
    waitUntilL1Block(block) {
        const targetBlock = typeof block === 'bigint' ? block.valueOf() : block;
        if (this.l1BlockNumber >= targetBlock) {
            return Promise.resolve();
        }
        return new Promise((resolve)=>{
            const listener = (data)=>{
                if (data.l1BlockNumber >= targetBlock) {
                    this.off('l1-block', listener);
                    resolve();
                }
            };
            this.on('l1-block', listener);
        });
    }
    waitUntilL1Timestamp(timestamp) {
        const targetTimestamp = typeof timestamp === 'bigint' ? timestamp.valueOf() : timestamp;
        if (this.l1BlockNumber >= targetTimestamp) {
            return Promise.resolve();
        }
        return new Promise((resolve)=>{
            const listener = (data)=>{
                if (data.timestamp >= targetTimestamp) {
                    this.off('l1-block', listener);
                    resolve();
                }
            };
            this.on('l1-block', listener);
        });
    }
    waitUntilCheckpoint(checkpointNumber) {
        if (this.checkpointNumber >= checkpointNumber) {
            return Promise.resolve();
        }
        return new Promise((resolve)=>{
            const listener = (data)=>{
                if (data.checkpointNumber >= checkpointNumber) {
                    this.off('checkpoint', listener);
                    resolve();
                }
            };
            this.on('checkpoint', listener);
        });
    }
}
