import { EthAddress } from '@aztec/foundation/eth-address';
import type { DateProvider, TestDateProvider } from '@aztec/foundation/timer';
import { type Chain, type Hex, type Transaction } from 'viem';
import type { ViemPublicClient } from '../types.js';
/**
 * A class that provides utility functions for interacting with ethereum (L1).
 */
export declare class EthCheatCodes {
    /**
     * The RPC URL to use for interacting with the chain
     */
    rpcUrls: string[];
    /**
     * The date provider to use for time operations
     */
    dateProvider: DateProvider | TestDateProvider;
    /**
     * The logger to use for the eth cheatcodes
     */
    logger: import("@aztec/foundation/log").Logger;
    /**
     * The chain configuration provided to Anvil
     */
    chain: Chain;
    readonly publicClient: ViemPublicClient;
    constructor(
    /**
     * The RPC URL to use for interacting with the chain
     */
    rpcUrls: string[], 
    /**
     * The date provider to use for time operations
     */
    dateProvider: DateProvider | TestDateProvider, 
    /**
     * The logger to use for the eth cheatcodes
     */
    logger?: import("@aztec/foundation/log").Logger, 
    /**
     * The chain configuration provided to Anvil
     */
    chain?: Chain);
    rpcCall(method: string, params: any[]): Promise<any>;
    private doRpcCall;
    /**
     * Get the auto mine status of the underlying chain
     * @returns True if automine is on, false otherwise
     */
    isAutoMining(): Promise<boolean>;
    /**
     * Get the current blocknumber
     * @returns The current block number
     */
    blockNumber(): Promise<number>;
    /**
     * Get the current chainId
     * @returns The current chainId
     */
    chainId(): Promise<number>;
    /**
     * Get the current timestamp
     * @returns The current timestamp
     */
    timestamp(): Promise<number>;
    /**
     * Advance the chain by a number of blocks
     * @param numberOfBlocks - The number of blocks to mine
     */
    mine(numberOfBlocks?: number | bigint): Promise<void>;
    private doMine;
    /**
     * Mines a single block with evm_mine
     */
    evmMine(): Promise<void>;
    /**
     * Set the balance of an account
     * @param account - The account to set the balance for
     * @param balance - The balance to set
     */
    setBalance(account: EthAddress | Hex, balance: bigint): Promise<void>;
    getBalance(account: EthAddress | Hex): Promise<bigint>;
    /**
     * Set the interval between successive blocks (block time). This does NOT enable interval mining.
     * @param interval - The interval to use between blocks
     */
    setBlockInterval(interval: number): Promise<void>;
    /**
     * Set the next block base fee per gas
     * @param baseFee - The base fee to set
     */
    setNextBlockBaseFeePerGas(baseFee: bigint | number): Promise<void>;
    /**
     * Get interval mining if set.
     * @param seconds - The interval to use between blocks
     */
    getIntervalMining(): Promise<number | null>;
    /**
     * Enable interval mining at the given interval (block time)
     * @param seconds - The interval to use between blocks
     */
    setIntervalMining(seconds: number, opts?: {
        silent?: boolean;
    }): Promise<void>;
    /**
     * Set the automine status of the underlying anvil chain
     * @param automine - The automine status to set
     */
    setAutomine(automine: boolean, opts?: {
        silent?: boolean;
    }): Promise<void>;
    /**
     * Drop a transaction from the mempool
     * @param txHash - The transaction hash
     */
    dropTransaction(txHash: Hex): Promise<void>;
    /**
     * Set the next block timestamp
     * @param timestamp - The timestamp to set the next block to
     */
    setNextBlockTimestamp(timestamp: number | Date): Promise<void>;
    /**
     * Set the next block timestamp and mines the block.
     * Optionally resets interval mining so the next block is mined in `blockInterval` seconds from now.
     * Always updates the injected date provider to follow L1 time.
     * @param timestamp - The timestamp to set the next block to
     */
    warp(timestamp: number | bigint, opts?: {
        silent?: boolean;
        resetBlockInterval?: boolean;
    }): Promise<void>;
    /**
     * Load the value at a storage slot of a contract address on eth
     * @param contract - The contract address
     * @param slot - The storage slot
     * @returns - The value at the storage slot
     */
    load(contract: EthAddress, slot: bigint): Promise<bigint>;
    /**
     * Set the value at a storage slot of a contract address on eth
     * @param contract - The contract address
     * @param slot - The storage slot
     * @param value - The value to set the storage slot to
     */
    store(contract: EthAddress, slot: bigint, value: bigint, opts?: {
        silent?: boolean;
    }): Promise<void>;
    /**
     * Computes the slot value for a given map and key.
     * @param baseSlot - The base slot of the map (specified in Aztec.nr contract)
     * @param key - The key to lookup in the map
     * @returns The storage slot of the value in the map
     */
    keccak256(baseSlot: bigint, key: bigint): bigint;
    /**
     * Send transactions impersonating an externally owned account or contract.
     * @param who - The address to impersonate
     */
    startImpersonating(who: EthAddress | Hex): Promise<void>;
    /**
     * Stop impersonating an account that you are currently impersonating.
     * @param who - The address to stop impersonating
     */
    stopImpersonating(who: EthAddress | Hex): Promise<void>;
    /**
     * Set the bytecode for a contract
     * @param contract - The contract address
     * @param bytecode - The bytecode to set
     */
    etch(contract: EthAddress, bytecode: `0x${string}`): Promise<void>;
    /**
     * Get the bytecode for a contract
     * @param contract - The contract address
     * @returns The bytecode for the contract
     */
    getBytecode(contract: EthAddress): Promise<`0x${string}`>;
    /**
     * Get the raw transaction object for a given transaction hash
     * @param txHash - The transaction hash
     * @returns The raw transaction
     */
    getRawTransaction(txHash: Hex): Promise<`0x${string}`>;
    /**
     * Get the trace for a given transaction hash
     * @param txHash - The transaction hash
     * @returns The trace
     */
    debugTraceTransaction(txHash: Hex): Promise<any>;
    /**
     * Triggers a reorg of the given depth, removing those blocks from the chain.
     * @param depth - The depth of the reorg
     */
    reorg(depth: number): Promise<void>;
    /**
     * Causes Anvil to reorg until the given block number is the new tip
     * @param blockNumber - The block number that's going to be the new tip
     */
    reorgTo(blockNumber: number): Promise<void>;
    /**
     * Triggers a reorg of the given depth, optionally replacing it with new blocks.
     * The resulting block height will be the same as the original chain.
     * @param depth - The depth of the reorg
     * @param newBlocks - The blocks to replace the old ones with, each represented as a list of txs.
     */
    reorgWithReplacement(depth: number, newBlocks?: (Hex | {
        to: EthAddress | Hex;
        input?: Hex;
        from?: EthAddress | Hex;
        value?: number | bigint;
    })[][]): Promise<void>;
    traceTransaction(txHash: Hex): Promise<any>;
    getTxPoolStatus(): Promise<{
        pending: number;
        queued: number;
    }>;
    getTxPoolContents(): Promise<TxPoolTransaction[]>;
    /**
     * Mines an empty block by temporarily removing all pending transactions from the mempool,
     * mining a block, and then re-adding the transactions back to the pool.
     */
    mineEmptyBlock(blockCount?: number): Promise<void>;
    execWithPausedAnvil<T>(fn: () => Promise<T>): Promise<T>;
    syncDateProvider(): Promise<void>;
}
type TxPoolState = 'pending' | 'queued';
export type TxPoolTransaction = Transaction & {
    poolState: TxPoolState;
};
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXRoX2NoZWF0X2NvZGVzLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGVzdC9ldGhfY2hlYXRfY29kZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBSTNELE9BQU8sS0FBSyxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRTlFLE9BQU8sRUFBRSxLQUFLLEtBQUssRUFBRSxLQUFLLEdBQUcsRUFBRSxLQUFLLFdBQVcsRUFBbUQsTUFBTSxNQUFNLENBQUM7QUFHL0csT0FBTyxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFcEQ7O0dBRUc7QUFDSCxxQkFBYSxhQUFhO0lBR3RCOztPQUVHO0lBQ0ksT0FBTyxFQUFFLE1BQU0sRUFBRTtJQUN4Qjs7T0FFRztJQUNJLFlBQVksRUFBRSxZQUFZLEdBQUcsZ0JBQWdCO0lBQ3BEOztPQUVHO0lBQ0ksTUFBTTtJQUNiOztPQUVHO0lBQ0ksS0FBSyxFQUFFLEtBQUs7SUFqQnJCLFNBQWdCLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQztJQUMvQztJQUNFOztPQUVHO0lBQ0ksT0FBTyxFQUFFLE1BQU0sRUFBRTtJQUN4Qjs7T0FFRztJQUNJLFlBQVksRUFBRSxZQUFZLEdBQUcsZ0JBQWdCO0lBQ3BEOztPQUVHO0lBQ0ksTUFBTSx5Q0FBdUM7SUFDcEQ7O09BRUc7SUFDSSxLQUFLLEdBQUUsS0FBZSxFQU05QjtJQUVNLE9BQU8sQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsZ0JBRzNDO1lBRWEsU0FBUztJQU92Qjs7O09BR0c7SUFDVSxZQUFZLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQVE1QztJQUVEOzs7T0FHRztJQUNVLFdBQVcsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLENBRzFDO0lBRUQ7OztPQUdHO0lB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