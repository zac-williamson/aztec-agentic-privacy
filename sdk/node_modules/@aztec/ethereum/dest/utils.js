import { ErrorsAbi } from '@aztec/l1-artifacts/ErrorsAbi';
import { BaseError, ContractFunctionRevertedError, decodeErrorResult, decodeEventLog } from 'viem';
import { formatAbiItem, formatAbiParams } from 'viem/utils';
export class FormattedViemError extends Error {
    metaMessages;
    constructor(message, metaMessages){
        super(message);
        this.name = 'FormattedViemError';
        this.metaMessages = metaMessages;
    }
}
export function extractEvent(logs, address, abi, eventName, filter, logger) {
    const event = tryExtractEvent(logs, address, abi, eventName, filter, logger);
    if (!event) {
        throw new Error(`Failed to find matching event ${eventName} for contract ${address}`);
    }
    return event;
}
export function tryExtractEvent(logs, address, abi, eventName, filter, logger) {
    for (const log of logs){
        if (log.address.toLowerCase() === address.toLowerCase()) {
            try {
                const decodedEvent = decodeEventLog({
                    abi,
                    ...log
                });
                if (decodedEvent.eventName === eventName) {
                    const matchingEvent = decodedEvent;
                    if (!filter || filter(matchingEvent)) {
                        return matchingEvent;
                    }
                }
            } catch (err) {
                logger?.warn(`Failed to decode event log for contract ${address}: ${err}`);
            }
        }
    }
}
export function prettyLogViemErrorMsg(err) {
    if (err instanceof BaseError) {
        const revertError = err.walk((err)=>err instanceof ContractFunctionRevertedError);
        if (revertError instanceof ContractFunctionRevertedError) {
            const errorName = revertError.data?.errorName ?? '';
            const args = revertError.metaMessages && revertError.metaMessages?.length > 1 ? revertError.metaMessages[1].trimStart() : '';
            return `${errorName}${args}`;
        }
    }
    return err?.message ?? err;
}
export function mergeAbis(abis) {
    let merged = [];
    const seen = new Set();
    for (const abi of abis){
        for (const item of abi){
            const key = getAbiItemKey(item);
            if (!seen.has(key)) {
                seen.add(key);
                merged = [
                    ...merged,
                    item
                ];
            }
        }
    }
    return merged;
}
function getAbiItemKey(item) {
    if (item.type === 'function') {
        const signature = formatAbiItem(item);
        const outputs = formatAbiParams(item.outputs);
        const stateMutability = typeof item.stateMutability === 'string' ? item.stateMutability : '';
        return `function:${signature}:${outputs}:${stateMutability}`;
    }
    if (item.type === 'event') {
        const signature = formatAbiItem(item);
        const indexed = (item.inputs ?? []).map((input)=>input.indexed ? '1' : '0').join('');
        const anonymous = item.anonymous ? 'anonymous' : 'not-anonymous';
        return `event:${signature}:${indexed}:${anonymous}`;
    }
    if (item.type === 'error') {
        const signature = formatAbiItem(item);
        return `error:${signature}`;
    }
    if (item.type === 'constructor') {
        const inputs = formatAbiParams(item.inputs);
        const stateMutability = typeof item.stateMutability === 'string' ? item.stateMutability : '';
        return `constructor::${inputs}:${stateMutability}`;
    }
    if (item.type === 'fallback' || item.type === 'receive') {
        const stateMutability = typeof item.stateMutability === 'string' ? item.stateMutability : '';
        return `${item.type}:::${stateMutability}`;
    }
    return 'unknown';
}
function getNestedErrorData(error) {
    // If nothing, bail
    if (!error) {
        return undefined;
    }
    // If it's an object with a `data` property, return it
    // (Remember to check TS type-safely or cast as needed)
    if (typeof error === 'object' && error !== null && 'data' in error) {
        const possibleData = error.data;
        if (typeof possibleData === 'string' && possibleData.startsWith('0x')) {
            return possibleData;
        }
    }
    // If it has a `cause`, recurse
    if (typeof error === 'object' && error !== null && 'cause' in error) {
        return getNestedErrorData(error.cause);
    }
    // Not found
    return undefined;
}
/**
 * Formats a Viem error into a FormattedViemError instance.
 * @param error - The error to format.
 * @param abi - The ABI to use for decoding.
 * @returns A FormattedViemError instance.
 */ export function formatViemError(error, abi = ErrorsAbi) {
    // If error is already a FormattedViemError, return it as is
    if (error instanceof FormattedViemError) {
        return error;
    }
    // First try to decode as a custom error using the ABI
    try {
        const data = getNestedErrorData(error);
        if (data) {
            // Try to decode the error data using the ABI
            const decoded = decodeErrorResult({
                abi,
                data: data
            });
            if (decoded) {
                return new FormattedViemError(`${decoded.errorName}(${decoded.args?.join(', ') ?? ''})`, error?.metaMessages);
            }
        }
        // If it's a BaseError, try to get the custom error through ContractFunctionRevertedError
        if (error instanceof BaseError) {
            const revertError = error.walk((err)=>err instanceof ContractFunctionRevertedError);
            if (revertError instanceof ContractFunctionRevertedError) {
                let errorName = revertError.data?.errorName;
                if (!errorName) {
                    errorName = revertError.signature ?? '';
                }
                const args = revertError.metaMessages && revertError.metaMessages?.length > 1 ? revertError.metaMessages[1].trimStart() : '';
                return new FormattedViemError(`${errorName}${args}`, error?.metaMessages);
            }
        }
    } catch  {
    // If decoding fails, we fall back to the original formatting
    }
    // Strip ABI from the error object before formatting
    if (error && typeof error === 'object') {
        // Create a clone to avoid modifying the original
        const errorClone = structuredClone(error);
        // Helper function to recursively remove ABI properties
        // Strip ABIs from the clone
        stripAbis(errorClone);
        // Use the cleaned clone for further processing
        error = errorClone;
    }
    // If it's a regular Error instance, return it with its message
    if (error instanceof Error) {
        return new FormattedViemError(error.message, error?.metaMessages);
    }
    const body = String(error);
    const length = body.length;
    // LogExplorer can only render up to 2500 characters in it's summary view. Try to keep the whole message below this number
    // Limit the error to 2000 chacaters in order to allow code higher up to decorate this error with extra details (up to 500 characters)
    if (length > 2000) {
        const chunk = 950;
        const truncated = length - 2 * chunk;
        return new FormattedViemError(body.slice(0, chunk) + `...${truncated} characters truncated...` + body.slice(-1 * chunk));
    }
    return new FormattedViemError(body);
}
function stripAbis(obj) {
    if (!obj || typeof obj !== 'object') {
        return;
    }
    // Delete ABI property at current level
    if ('abi' in obj) {
        delete obj.abi;
    }
    // Process cause property
    if (obj.cause) {
        stripAbis(obj.cause);
    }
    // Process arrays and objects
    Object.values(obj).forEach((value)=>{
        if (value && typeof value === 'object') {
            stripAbis(value);
        }
    });
}
export function tryGetCustomErrorName(err) {
    try {
        // See https://viem.sh/docs/contract/simulateContract#handling-custom-errors
        if (err.name === 'ViemError' || err.name === 'ContractFunctionExecutionError') {
            const baseError = err;
            const revertError = baseError.walk((err)=>err.name === 'ContractFunctionRevertedError');
            if (revertError) {
                return revertError.data?.errorName;
            }
        }
    } catch  {
        return undefined;
    }
}
/**
 * Type guard to check if a transaction is a blob transaction (EIP-4844).
 * Blob transactions have maxFeePerBlobGas and blobVersionedHashes fields.
 */ export function isBlobTransaction(tx) {
    return 'maxFeePerBlobGas' in tx && tx.maxFeePerBlobGas !== undefined && 'blobVersionedHashes' in tx && tx.blobVersionedHashes !== undefined;
}
/**
 * Calculates a percentile from an array of bigints
 */ export function calculatePercentile(values, percentile) {
    if (values.length === 0) {
        return 0n;
    }
    const sorted = [
        ...values
    ].sort((a, b)=>a < b ? -1 : a > b ? 1 : 0);
    const index = Math.ceil((sorted.length - 1) * (percentile / 100));
    return sorted[index];
}
