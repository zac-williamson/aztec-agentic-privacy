import { type Logger, type LoggerBindings } from '@aztec/foundation/log';
import type { DateProvider } from '@aztec/foundation/timer';
import { type Client, type Hex } from 'viem';
import type { ViemClient } from '../types.js';
export declare function waitUntilBlock<T extends Client>(client: T, blockNumber: number | bigint, logger?: Logger, timeout?: number): Promise<boolean>;
export declare function waitUntilL1Timestamp<T extends Client>(client: T, timestamp: number | bigint, logger?: Logger, timeout?: number): Promise<boolean>;
/** Manages tx delaying for testing, intercepting sendRawTransaction calls to delay or cancel them. */
export declare class Delayer {
    dateProvider: DateProvider;
    private logger;
    maxInclusionTimeIntoSlot: number | undefined;
    ethereumSlotDuration: bigint;
    nextWait: {
        l1Timestamp: bigint;
    } | {
        l1BlockNumber: bigint;
    } | {
        indefinitely: true;
    } | undefined;
    sentTxHashes: Hex[];
    cancelledTxs: Hex[];
    constructor(dateProvider: DateProvider, opts: {
        ethereumSlotDuration: bigint | number;
    }, bindings: LoggerBindings);
    /** Returns the logger instance used by this delayer. */
    getLogger(): Logger;
    /** Returns the hashes of all effectively sent txs. */
    getSentTxHashes(): `0x${string}`[];
    /** Returns the raw hex for all cancelled txs. */
    getCancelledTxs(): Hex[];
    /** Delays the next tx to be sent so it lands on the given L1 block number. */
    pauseNextTxUntilBlock(l1BlockNumber: number | bigint): void;
    /** Delays the next tx to be sent so it lands on the given timestamp. */
    pauseNextTxUntilTimestamp(l1Timestamp: number | bigint): void;
    /** Delays the next tx to be sent indefinitely. */
    cancelNextTx(): void;
    /**
     * Sets max inclusion time into slot. If more than this many seconds have passed
     * since the last L1 block was mined, then any tx will not be mined in the current
     * L1 slot but will be deferred for the next one.
     */
    setMaxInclusionTimeIntoSlot(seconds: number | undefined): void;
}
/**
 * Creates a new Delayer instance. Exposed so callers can create a single shared delayer
 * and pass it to multiple `wrapClientWithDelayer` calls.
 */
export declare function createDelayer(dateProvider: DateProvider, opts: {
    ethereumSlotDuration: bigint | number;
}, bindings: LoggerBindings): Delayer;
/**
 * Wraps a viem client with tx delaying logic. Returns the wrapped client.
 * The delayer intercepts sendRawTransaction calls and delays them based on the delayer's state.
 */
export declare function wrapClientWithDelayer<T extends ViemClient>(client: T, delayer: Delayer): T;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHhfZGVsYXllci5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2wxX3R4X3V0aWxzL3R4X2RlbGF5ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLEtBQUssTUFBTSxFQUFFLEtBQUssY0FBYyxFQUFnQixNQUFNLHVCQUF1QixDQUFDO0FBRXZGLE9BQU8sS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRzVELE9BQU8sRUFDTCxLQUFLLE1BQU0sRUFDWCxLQUFLLEdBQUcsRUFVVCxNQUFNLE1BQU0sQ0FBQztBQUVkLE9BQU8sS0FBSyxFQUE0QixVQUFVLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFJeEUsd0JBQWdCLGNBQWMsQ0FBQyxDQUFDLFNBQVMsTUFBTSxFQUM3QyxNQUFNLEVBQUUsQ0FBQyxFQUNULFdBQVcsRUFBRSxNQUFNLEdBQUcsTUFBTSxFQUM1QixNQUFNLENBQUMsRUFBRSxNQUFNLEVBQ2YsT0FBTyxDQUFDLEVBQUUsTUFBTSxvQkFpQmpCO0FBRUQsd0JBQWdCLG9CQUFvQixDQUFDLENBQUMsU0FBUyxNQUFNLEVBQ25ELE1BQU0sRUFBRSxDQUFDLEVBQ1QsU0FBUyxFQUFFLE1BQU0sR0FBRyxNQUFNLEVBQzFCLE1BQU0sQ0FBQyxFQUFFLE1BQU0sRUFDZixPQUFPLENBQUMsRUFBRSxNQUFNLG9CQXdCakI7QUFFRCxzR0FBc0c7QUFDdEcscUJBQWEsT0FBTztJQVVULFlBQVksRUFBRSxZQUFZO0lBVG5DLE9BQU8sQ0FBQyxNQUFNLENBQVM7SUFFaEIsd0JBQXdCLEVBQUUsTUFBTSxHQUFHLFNBQVMsQ0FBYTtJQUN6RCxvQkFBb0IsRUFBRSxNQUFNLENBQUM7SUFDN0IsUUFBUSxFQUFFO1FBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQTtLQUFFLEdBQUc7UUFBRSxhQUFhLEVBQUUsTUFBTSxDQUFBO0tBQUUsR0FBRztRQUFFLFlBQVksRUFBRSxJQUFJLENBQUE7S0FBRSxHQUFHLFNBQVMsQ0FBYTtJQUMvRyxZQUFZLEVBQUUsR0FBRyxFQUFFLENBQU07SUFDekIsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFNO0lBRWhDLFlBQ1MsWUFBWSxFQUFFLFlBQVksRUFDakMsSUFBSSxFQUFFO1FBQUUsb0JBQW9CLEVBQUUsTUFBTSxHQUFHLE1BQU0sQ0FBQTtLQUFFLEVBQy9DLFFBQVEsRUFBRSxjQUFjLEVBSXpCO0lBRUQsd0RBQXdEO0lBQ3hELFNBQVMsSUFBSSxNQUFNLENBRWxCO0lBRUQsc0RBQXNEO0lBQ3RELGVBQWUsb0JBRWQ7SUFFRCxpREFBaUQ7SUFDakQsZUFBZSxJQUFJLEdBQUcsRUFBRSxDQUV2QjtJQUVELDhFQUE4RTtJQUM5RSxxQkFBcUIsQ0FBQyxhQUFhLEVBQUUsTUFBTSxHQUFHLE1BQU0sUUFFbkQ7SUFFRCx3RUFBd0U7SUFDeEUseUJBQXlCLENBQUMsV0FBVyxFQUFFLE1BQU0sR0FBRyxNQUFNLFFBRXJEO0lBRUQsa0RBQWtEO0lBQ2xELFlBQVksU0FFWDtJQUVEOzs7O09BSUc7SUFDSCwyQkFBMkIsQ0FBQyxPQUFPLEVBQUUsTUFBTSxHQUFHLFNBQVMsUUFFdEQ7Q0FDRjtBQUVEOzs7R0FHRztBQUNILHdCQUFnQixhQUFhLENBQzNCLFlBQVksRUFBRSxZQUFZLEVBQzFCLElBQUksRUFBRTtJQUFFLG9CQUFvQixFQUFFLE1BQU0sR0FBRyxNQUFNLENBQUE7Q0FBRSxFQUMvQyxRQUFRLEVBQUUsY0FBYyxHQUN2QixPQUFPLENBRVQ7QUFhRDs7O0dBR0c7QUFDSCx3QkFBZ0IscUJBQXFCLENBQUMsQ0FBQyxTQUFTLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxPQUFPLEdBQUcsQ0FBQyxDQWtIMUYifQ==