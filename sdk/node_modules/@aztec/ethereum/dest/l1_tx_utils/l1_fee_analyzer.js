import { createLogger } from '@aztec/foundation/log';
import { retryUntil } from '@aztec/foundation/retry';
import { DateProvider } from '@aztec/foundation/timer';
import { formatGwei } from 'viem';
import { calculatePercentile, isBlobTransaction } from '../utils.js';
import { BLOB_CAPACITY_SCHEDULE, GAS_PER_BLOB, WEI_CONST } from './constants.js';
import { DEFAULT_PRIORITY_FEE_STRATEGIES } from './fee-strategies/index.js';
/**
 * Gets the maximum blob capacity for a given block timestamp
 */ function getMaxBlobCapacity(blockTimestamp) {
    const timestamp = Number(blockTimestamp);
    // Find the applicable schedule entry (sorted by timestamp descending)
    for (const schedule of BLOB_CAPACITY_SCHEDULE){
        if (timestamp >= schedule.timestamp) {
            return schedule.max;
        }
    }
    // Fallback (should never hit)
    return BLOB_CAPACITY_SCHEDULE[BLOB_CAPACITY_SCHEDULE.length - 1].max;
}
/**
 * Processes a list of transactions to extract blob transaction info and priority fees.
 * Handles both pending and mined transactions.
 * Note: Only works with blocks fetched with includeTransactions: true
 */ function processTransactions(transactions) {
    const blobTxs = [];
    const allPriorityFees = [];
    const blobPriorityFees = [];
    let totalBlobCount = 0;
    if (!transactions) {
        return {
            blobTxs,
            allPriorityFees,
            blobPriorityFees,
            totalBlobCount
        };
    }
    for (const tx of transactions){
        const priorityFee = tx.maxPriorityFeePerGas || 0n;
        if (priorityFee > 0n) {
            allPriorityFees.push(priorityFee);
        }
        // Check if this is a blob transaction
        if (isBlobTransaction(tx)) {
            const blobCount = tx.blobVersionedHashes.length;
            totalBlobCount += blobCount;
            if (priorityFee > 0n) {
                blobPriorityFees.push(priorityFee);
            }
            blobTxs.push({
                hash: tx.hash,
                maxPriorityFeePerGas: priorityFee,
                maxFeePerGas: tx.maxFeePerGas || 0n,
                maxFeePerBlobGas: tx.maxFeePerBlobGas,
                blobCount,
                gas: tx.gas
            });
        }
    }
    return {
        blobTxs,
        allPriorityFees,
        blobPriorityFees,
        totalBlobCount
    };
}
/**
 * Analyzes L1 transaction fees in fisherman mode.
 * Captures pending block state, records gas calculations, and compares to what gets included.
 * Supports multiple priority fee calculation strategies for comparison.
 */ export class L1FeeAnalyzer {
    client;
    dateProvider;
    logger;
    maxCompletedAnalyses;
    gasConfig;
    pendingAnalyses;
    pendingCallbacks;
    completedAnalyses;
    analysisCounter;
    strategies;
    constructor(client, dateProvider = new DateProvider(), logger = createLogger('ethereum:l1-fee-analyzer'), maxCompletedAnalyses = 100, strategies = DEFAULT_PRIORITY_FEE_STRATEGIES, gasConfig = {}){
        this.client = client;
        this.dateProvider = dateProvider;
        this.logger = logger;
        this.maxCompletedAnalyses = maxCompletedAnalyses;
        this.gasConfig = gasConfig;
        this.pendingAnalyses = new Map();
        this.pendingCallbacks = new Map();
        this.completedAnalyses = [];
        this.analysisCounter = 0;
        this.strategies = strategies;
    }
    /**
   * Executes all configured strategies and returns their results.
   * Each strategy handles its own RPC calls internally.
   * @param isBlobTx - Whether this is a blob transaction
   * @returns Array of strategy results
   */ async executeAllStrategies(isBlobTx) {
        const results = [];
        const context = {
            gasConfig: this.gasConfig,
            isBlobTx,
            logger: this.logger
        };
        for (const strategy of this.strategies){
            try {
                const result = await strategy.execute(this.client, context);
                results.push({
                    strategyId: strategy.id,
                    strategyName: strategy.name,
                    calculatedPriorityFee: result.priorityFee,
                    debugInfo: result.debugInfo
                });
                this.logger.debug(`Strategy "${strategy.name}" calculated priority fee`, {
                    strategyId: strategy.id,
                    priorityFee: formatGwei(result.priorityFee),
                    ...result.debugInfo
                });
            } catch (err) {
                this.logger.error(`Error calculating priority fee for strategy "${strategy.name}"`, err, {
                    strategyId: strategy.id
                });
            }
        }
        return results;
    }
    /**
   * Captures a snapshot of the current pending block state
   */ async capturePendingSnapshot() {
        const timestamp = this.dateProvider.now();
        // Fetch data in parallel
        const [latestBlock, pendingBlock, blobBaseFee] = await Promise.all([
            this.client.getBlock({
                blockTag: 'latest'
            }),
            this.client.getBlock({
                blockTag: 'pending',
                includeTransactions: true
            }).catch(()=>null),
            this.client.getBlobBaseFee().catch(()=>0n)
        ]);
        const baseFeePerGas = latestBlock.baseFeePerGas || 0n;
        const latestBlockNumber = latestBlock.number;
        // Extract blob transaction info from pending block
        const { blobTxs: pendingBlobTxs, allPriorityFees: allPendingPriorityFees, blobPriorityFees: pendingBlobPriorityFees, totalBlobCount: pendingBlobCount } = processTransactions(pendingBlock?.transactions);
        // Calculate 75th percentile priority fees
        const pendingP75PriorityFee = calculatePercentile(allPendingPriorityFees, 75);
        const pendingBlobP75PriorityFee = calculatePercentile(pendingBlobPriorityFees, 75);
        const pendingTxCount = pendingBlock?.transactions?.length || 0;
        return {
            timestamp,
            latestBlockNumber,
            baseFeePerGas,
            blobBaseFee,
            pendingTxCount,
            pendingBlobTxCount: pendingBlobTxs.length,
            pendingBlobCount,
            pendingBlobTxs,
            pendingP75PriorityFee,
            pendingBlobP75PriorityFee
        };
    }
    /**
   * Starts a fee analysis for a transaction bundle
   * @param l2SlotNumber - The L2 slot this analysis is for
   * @param gasLimit - The estimated gas limit
   * @param requests - The transaction requests being analyzed
   * @param blobInputs - Blob inputs if this is a blob transaction
   * @param onComplete - Optional callback to invoke when analysis completes
   * @returns The analysis ID for tracking
   */ async startAnalysis(l2SlotNumber, gasLimit, requests, blobInputs, onComplete) {
        const id = `fee-analysis-${++this.analysisCounter}-${Date.now()}`;
        const blobCount = blobInputs?.blobs?.length || 0;
        const isBlobTx = blobCount > 0;
        // Execute all strategies and capture pending snapshot in parallel
        const [pendingSnapshot, strategyResults] = await Promise.all([
            this.capturePendingSnapshot(),
            this.executeAllStrategies(isBlobTx)
        ]);
        const analysis = {
            id,
            l2SlotNumber,
            pendingSnapshot,
            computedPrices: {
                gasLimit,
                blobCount,
                strategyResults
            },
            txInfo: {
                requestCount: requests.length,
                hasBlobData: isBlobTx,
                totalEstimatedGas: gasLimit
            }
        };
        this.pendingAnalyses.set(id, analysis);
        if (onComplete) {
            this.pendingCallbacks.set(id, onComplete);
        }
        // Log strategy calculations
        const strategyLogInfo = strategyResults.reduce((acc, s)=>{
            acc[`strategy_${s.strategyId}`] = formatGwei(s.calculatedPriorityFee);
            return acc;
        }, {});
        this.logger.debug('Started fee analysis with strategy calculations', {
            id,
            l2SlotNumber: l2SlotNumber.toString(),
            pendingBlobTxCount: pendingSnapshot.pendingBlobTxCount,
            pendingBlobCount: pendingSnapshot.pendingBlobCount,
            pendingBlobP75: formatGwei(pendingSnapshot.pendingBlobP75PriorityFee),
            strategiesAnalyzed: strategyResults.length,
            ...strategyLogInfo
        });
        // Start watching for the next block
        void this.watchForNextBlock(id, pendingSnapshot.latestBlockNumber);
        return id;
    }
    /**
   * Watches for the next block to be mined and completes the analysis
   */ async watchForNextBlock(analysisId, startBlockNumber) {
        const analysis = this.pendingAnalyses.get(analysisId);
        if (!analysis) {
            return;
        }
        try {
            // wait for next block
            await retryUntil(async ()=>{
                const currentBlockNumber = await this.client.getBlockNumber();
                if (currentBlockNumber > startBlockNumber) {
                    return true;
                }
                return false;
            }, 'Wait for next block', 13_000, 0.5);
            const minedBlock = await this.client.getBlock({
                includeTransactions: true
            });
            this.completeAnalysis(analysisId, minedBlock);
        } catch (err) {
            this.logger.error('Error waiting for next block in fee analysis', err, {
                analysisId
            });
        } finally{
            this.pendingAnalyses.delete(analysisId);
        }
    }
    /**
   * Completes the analysis once the next block is mined
   */ completeAnalysis(analysisId, minedBlock) {
        const analysis = this.pendingAnalyses.get(analysisId);
        if (!analysis) {
            return;
        }
        // Extract blob transaction info from mined block
        const { blobTxs: includedBlobTxs, allPriorityFees: includedPriorityFees, blobPriorityFees: includedBlobPriorityFees, totalBlobCount: includedBlobCount } = processTransactions(minedBlock.transactions);
        // Get minimum included fees
        const minIncludedPriorityFee = includedPriorityFees.length > 0 ? this.minBigInt(includedPriorityFees) : 0n;
        const minIncludedBlobPriorityFee = includedBlobPriorityFees.length > 0 ? this.minBigInt(includedBlobPriorityFees) : 0n;
        // Populate mined block info
        analysis.minedBlock = {
            blockNumber: minedBlock.number,
            blockHash: minedBlock.hash,
            blockTimestamp: minedBlock.timestamp,
            baseFeePerGas: minedBlock.baseFeePerGas || 0n,
            blobGasUsed: minedBlock.blobGasUsed || 0n,
            txCount: minedBlock.transactions?.length || 0,
            includedBlobTxCount: includedBlobTxs.length,
            includedBlobCount,
            includedBlobTxs,
            minIncludedPriorityFee,
            minIncludedBlobPriorityFee
        };
        // Calculate time before block mined
        const blockTimestampMs = Number(minedBlock.timestamp) * 1000;
        const timeBeforeBlockMs = blockTimestampMs - analysis.pendingSnapshot.timestamp;
        // Calculate how many blobs were actually in the mined block
        const blobsInBlock = minedBlock.blobGasUsed > 0n ? Number(minedBlock.blobGasUsed / GAS_PER_BLOB) : 0;
        const maxBlobCapacity = getMaxBlobCapacity(minedBlock.timestamp);
        const blockBlobsFull = blobsInBlock >= maxBlobCapacity;
        // Count how many pending blob txs actually got included
        const pendingBlobHashes = new Set(analysis.pendingSnapshot.pendingBlobTxs.map((tx)=>tx.hash));
        const includedBlobHashes = new Set(includedBlobTxs.map((tx)=>tx.hash));
        const pendingBlobTxsIncludedCount = [
            ...pendingBlobHashes
        ].filter((h)=>includedBlobHashes.has(h)).length;
        const pendingBlobTxsExcludedCount = analysis.pendingSnapshot.pendingBlobTxCount - pendingBlobTxsIncludedCount;
        analysis.analysis = {
            timeBeforeBlockMs,
            pendingBlobTxsIncludedCount,
            pendingBlobTxsExcludedCount,
            blobsInBlock,
            maxBlobCapacity,
            blockBlobsFull
        };
        // Evaluate each strategy against the mined block
        const isBlobTx = analysis.computedPrices.blobCount > 0;
        const minPriorityFeeToCompare = isBlobTx ? minIncludedBlobPriorityFee : minIncludedPriorityFee;
        const gasLimit = analysis.computedPrices.gasLimit;
        if (analysis.computedPrices.strategyResults) {
            for (const strategyResult of analysis.computedPrices.strategyResults){
                const strategyPriorityFee = strategyResult.calculatedPriorityFee;
                const strategyPriorityFeeDelta = strategyPriorityFee - minPriorityFeeToCompare;
                // Determine if this strategy would have resulted in inclusion
                let strategyWouldBeIncluded = true;
                let strategyExclusionReason;
                if (isBlobTx) {
                    // For blob txs, only consider priority fee if blob space was full
                    if (includedBlobPriorityFees.length > 0 && strategyPriorityFee < minIncludedBlobPriorityFee && blockBlobsFull) {
                        strategyWouldBeIncluded = false;
                        strategyExclusionReason = 'priority_fee_too_low';
                    }
                } else {
                    // For non-blob txs, use the old logic
                    if (includedPriorityFees.length > 0 && strategyPriorityFee < minIncludedPriorityFee) {
                        strategyWouldBeIncluded = false;
                        strategyExclusionReason = 'priority_fee_too_low';
                    }
                }
                // Calculate estimated cost in ETH for this strategy
                // Cost = gasLimit * (baseFee + priorityFee)
                const baseFee = analysis.minedBlock.baseFeePerGas;
                // Execution cost: gasLimit * (baseFee + priorityFee)
                const executionCostWei = gasLimit * (baseFee + strategyPriorityFee);
                const estimatedCostEth = Number(executionCostWei) / 1e18;
                // Calculate minimum cost needed for inclusion
                const minExecutionCostWei = gasLimit * (baseFee + minPriorityFeeToCompare);
                const minCostEth = Number(minExecutionCostWei) / 1e18;
                // Overpayment is the difference
                const estimatedOverpaymentEth = estimatedCostEth - minCostEth;
                // Update the strategy result with analysis data
                strategyResult.wouldBeIncluded = strategyWouldBeIncluded;
                strategyResult.exclusionReason = strategyExclusionReason;
                strategyResult.priorityFeeDelta = strategyPriorityFeeDelta;
                strategyResult.estimatedCostEth = estimatedCostEth;
                strategyResult.estimatedOverpaymentEth = estimatedOverpaymentEth;
                // Log per-strategy results
                this.logger.info(`Strategy "${strategyResult.strategyName}" analysis`, {
                    id: analysisId,
                    strategyId: strategyResult.strategyId,
                    strategyName: strategyResult.strategyName,
                    calculatedPriorityFee: formatGwei(strategyPriorityFee),
                    minIncludedPriorityFee: formatGwei(minPriorityFeeToCompare),
                    priorityFeeDelta: formatGwei(strategyPriorityFeeDelta),
                    wouldBeIncluded: strategyWouldBeIncluded,
                    exclusionReason: strategyExclusionReason,
                    estimatedCostEth: estimatedCostEth.toFixed(6),
                    estimatedOverpaymentEth: estimatedOverpaymentEth.toFixed(6)
                });
            }
            // Create cost ranking
            const costRanking = analysis.computedPrices.strategyResults.map((s)=>({
                    strategyId: s.strategyId,
                    strategyName: s.strategyName,
                    estimatedCostEth: s.estimatedCostEth,
                    wouldBeIncluded: s.wouldBeIncluded
                })).sort((a, b)=>a.estimatedCostEth - b.estimatedCostEth);
            analysis.analysis.costRanking = costRanking;
            // Log cost ranking summary
            this.logger.info('Strategy cost ranking', {
                id: analysisId,
                cheapestStrategy: costRanking[0]?.strategyName,
                cheapestCost: costRanking[0]?.estimatedCostEth.toFixed(6),
                cheapestWouldBeIncluded: costRanking[0]?.wouldBeIncluded,
                mostExpensiveStrategy: costRanking[costRanking.length - 1]?.strategyName,
                mostExpensiveCost: costRanking[costRanking.length - 1]?.estimatedCostEth.toFixed(6),
                mostExpensiveWouldBeIncluded: costRanking[costRanking.length - 1]?.wouldBeIncluded,
                costSpread: costRanking.length > 1 ? (costRanking[costRanking.length - 1].estimatedCostEth - costRanking[0].estimatedCostEth).toFixed(6) : '0'
            });
        }
        // Log the overall results
        this.logger.info('Fee analysis completed', {
            id: analysisId,
            l2SlotNumber: analysis.l2SlotNumber.toString(),
            timeBeforeBlockMs,
            pendingBlobTxCount: analysis.pendingSnapshot.pendingBlobTxCount,
            includedBlobTxCount: analysis.minedBlock.includedBlobTxCount,
            pendingBlobTxsIncludedCount,
            pendingBlobTxsExcludedCount,
            blobsInBlock,
            maxBlobCapacity,
            blockBlobsFull,
            minIncludedPriorityFee: formatGwei(minIncludedPriorityFee),
            minIncludedBlobPriorityFee: formatGwei(minIncludedBlobPriorityFee),
            strategiesAnalyzed: analysis.computedPrices.strategyResults?.length ?? 0
        });
        // Move to completed analyses
        this.pendingAnalyses.delete(analysisId);
        this.completedAnalyses.push(analysis);
        // Trim old completed analyses if needed
        while(this.completedAnalyses.length > this.maxCompletedAnalyses){
            this.completedAnalyses.shift();
        }
        // Invoke the callback for this specific analysis
        const callback = this.pendingCallbacks.get(analysisId);
        if (callback) {
            try {
                callback(analysis);
            } catch (err) {
                this.logger.error('Error in analysis complete callback', err);
            }
            this.pendingCallbacks.delete(analysisId);
        }
    }
    /**
   * Gets a specific analysis result by ID
   */ getAnalysis(id) {
        return this.pendingAnalyses.get(id) || this.completedAnalyses.find((a)=>a.id === id);
    }
    /**
   * Gets all completed analyses
   */ getCompletedAnalyses() {
        return [
            ...this.completedAnalyses
        ];
    }
    /**
   * Gets statistics about all completed analyses
   */ getAnalysisStats() {
        const completed = this.completedAnalyses.filter((a)=>a.analysis);
        if (completed.length === 0) {
            return {
                totalAnalyses: 0,
                avgTimeBeforeBlockMs: 0,
                avgBlobsInBlock: 0,
                blocksBlobsFull: 0
            };
        }
        const avgTimeBeforeBlockMs = completed.reduce((sum, a)=>sum + a.analysis.timeBeforeBlockMs, 0) / completed.length;
        const avgBlobsInBlock = completed.reduce((sum, a)=>sum + a.analysis.blobsInBlock, 0) / completed.length;
        const blocksBlobsFull = completed.filter((a)=>a.analysis.blockBlobsFull).length;
        return {
            totalAnalyses: completed.length,
            avgTimeBeforeBlockMs,
            avgBlobsInBlock,
            blocksBlobsFull
        };
    }
    /**
   * Gets comparative statistics for all strategies across completed analyses
   */ getStrategyComparison() {
        const completed = this.completedAnalyses.filter((a)=>a.analysis);
        if (completed.length === 0) {
            return [];
        }
        // Collect data by strategy ID
        const strategyData = new Map();
        for (const analysis of completed){
            if (!analysis.computedPrices.strategyResults) {
                continue;
            }
            for (const strategyResult of analysis.computedPrices.strategyResults){
                if (!strategyData.has(strategyResult.strategyId)) {
                    strategyData.set(strategyResult.strategyId, {
                        strategyName: strategyResult.strategyName,
                        analyses: 0,
                        inclusions: 0,
                        totalCostEth: 0,
                        totalOverpaymentEth: 0,
                        totalPriorityFeeDelta: 0
                    });
                }
                const data = strategyData.get(strategyResult.strategyId);
                data.analyses++;
                if (strategyResult.wouldBeIncluded) {
                    data.inclusions++;
                }
                if (strategyResult.estimatedCostEth !== undefined) {
                    data.totalCostEth += strategyResult.estimatedCostEth;
                }
                if (strategyResult.estimatedOverpaymentEth !== undefined) {
                    data.totalOverpaymentEth += strategyResult.estimatedOverpaymentEth;
                }
                if (strategyResult.priorityFeeDelta !== undefined) {
                    data.totalPriorityFeeDelta += Number(strategyResult.priorityFeeDelta);
                }
            }
        }
        // Convert to output format
        const results = Array.from(strategyData.entries()).map(([strategyId, data])=>({
                strategyId,
                strategyName: data.strategyName,
                totalAnalyses: data.analyses,
                inclusionCount: data.inclusions,
                inclusionRate: data.analyses > 0 ? data.inclusions / data.analyses : 0,
                avgEstimatedCostEth: data.analyses > 0 ? data.totalCostEth / data.analyses : 0,
                totalEstimatedCostEth: data.totalCostEth,
                avgOverpaymentEth: data.analyses > 0 ? data.totalOverpaymentEth / data.analyses : 0,
                totalOverpaymentEth: data.totalOverpaymentEth,
                avgPriorityFeeDeltaGwei: data.analyses > 0 ? data.totalPriorityFeeDelta / data.analyses / Number(WEI_CONST) : 0
            }));
        // Sort by inclusion rate descending, then by avg cost ascending
        return results.sort((a, b)=>{
            if (Math.abs(a.inclusionRate - b.inclusionRate) > 0.01) {
                return b.inclusionRate - a.inclusionRate;
            }
            return a.avgEstimatedCostEth - b.avgEstimatedCostEth;
        });
    }
    /**
   * Gets the minimum value from an array of bigints
   */ minBigInt(values) {
        if (values.length === 0) {
            return 0n;
        }
        return values.reduce((min, val)=>val < min ? val : min, values[0]);
    }
}
