function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
var _initProto, _initProto1;
import { memoize } from '@aztec/foundation/decorators';
import { EthAddress } from '@aztec/foundation/eth-address';
import { createLogger } from '@aztec/foundation/log';
import { encodeAbiParameters, getContract, keccak256, parseAbiParameters } from 'viem';
/** Maximum price modifier per checkpoint in basis points. ±100 bps = ±1% */ export const MAX_FEE_ASSET_PRICE_MODIFIER_BPS = 100n;
/**
 * Validates that a fee asset price modifier is within the allowed range.
 * Validators should call this before attesting to a checkpoint proposal.
 *
 * @param modifier - The fee asset price modifier in basis points
 * @returns true if the modifier is valid (between -100 and +100 bps)
 */ export function validateFeeAssetPriceModifier(modifier) {
    return modifier >= -MAX_FEE_ASSET_PRICE_MODIFIER_BPS && modifier <= MAX_FEE_ASSET_PRICE_MODIFIER_BPS;
}
/**
 * Oracle for computing fee asset price modifiers based on Uniswap V4 pool prices.
 * Only active on Ethereum mainnet - returns 0 on other chains.
 */ export class FeeAssetPriceOracle {
    client;
    rollupContract;
    log;
    static{
        ({ e: [_initProto] } = _apply_decs_2203_r(this, [
            [
                memoize,
                2,
                "getUniswapOracle"
            ]
        ], []));
    }
    constructor(client, rollupContract, log = createLogger('fee-asset-price-oracle')){
        this.client = client;
        this.rollupContract = rollupContract;
        this.log = log;
        _initProto(this);
    }
    async getUniswapOracle() {
        const code = await this.client.getCode({
            address: STATE_VIEW_ADDRESS.toString()
        });
        if (code === undefined || code === '0x') {
            this.log.warn('Uniswap V4 StateView contract not found, skipping fee asset price oracle');
            return undefined;
        }
        this.log.info('Uniswap V4 StateView contract found, initializing fee asset price oracle');
        const oracle = new UniswapPriceOracle(this.client, this.log);
        try {
            if (!await oracle.isPoolInitialized()) {
                this.log.warn('Uniswap V4 pool not initialized, skipping fee asset price oracle');
                return undefined;
            }
        } catch (err) {
            this.log.warn(`Failed to check if Uniswap V4 pool is initialized: ${err}`);
            return undefined;
        }
        return oracle;
    }
    /**
   * Computes the fee asset price modifier to be used in the next checkpoint proposal.
   *
   * The modifier adjusts the on-chain fee asset price toward the oracle price,
   * clamped to ±1% (±100 basis points) per checkpoint.
   *
   * Returns 0 if not on mainnet or if the oracle query fails.
   *
   * @returns The price modifier in basis points (positive to increase price, negative to decrease)
   */ async computePriceModifier() {
        const uniswapOracle = await this.getUniswapOracle();
        if (!uniswapOracle) {
            return 0n;
        }
        try {
            // Get current on-chain price (ETH per fee asset, E12)
            const currentPriceE12 = await this.rollupContract.getEthPerFeeAsset();
            // Get oracle price (median of last N blocks, ETH per fee asset, E12)
            const oraclePriceE12 = await uniswapOracle.getMeanEthPerFeeAssetE12();
            // Compute modifier in basis points
            const modifier = this.computePriceModifierBps(currentPriceE12, oraclePriceE12);
            this.log.debug('Computed price modifier', {
                currentPriceE12: currentPriceE12.toString(),
                oraclePriceE12: oraclePriceE12.toString(),
                modifierBps: modifier.toString()
            });
            return modifier;
        } catch (err) {
            this.log.warn(`Failed to compute price modifier, using 0: ${err}`);
            return 0n;
        }
    }
    /**
   * Gets the current oracle price (ETH per fee asset, scaled by 1e12).
   * Returns undefined if not on mainnet or if the oracle query fails.
   */ async getOraclePrice() {
        const uniswapOracle = await this.getUniswapOracle();
        if (!uniswapOracle) {
            return undefined;
        }
        try {
            return await uniswapOracle.getMeanEthPerFeeAssetE12();
        } catch (err) {
            this.log.warn(`Failed to get oracle price: ${err}`);
            return undefined;
        }
    }
    /**
   * Computes the basis points modifier needed to move from current price toward target price.
   *
   * @param currentPrice - Current ETH per fee asset (E12 scale)
   * @param targetPrice - Target ETH per fee asset (E12 scale)
   * @returns Basis points modifier clamped to ±100 (±1%)
   */ computePriceModifierBps(currentPrice, targetPrice) {
        if (currentPrice === 0n) {
            return MAX_FEE_ASSET_PRICE_MODIFIER_BPS;
        }
        // Calculate percentage difference in basis points
        // modifierBps = ((targetPrice - currentPrice) / currentPrice) * 10000
        const diff = targetPrice - currentPrice;
        const rawModifierBps = diff * 10_000n / currentPrice;
        // Clamp to ±MAX_FEE_ASSET_PRICE_MODIFIER_BPS
        if (rawModifierBps > MAX_FEE_ASSET_PRICE_MODIFIER_BPS) {
            return MAX_FEE_ASSET_PRICE_MODIFIER_BPS;
        }
        if (rawModifierBps < -MAX_FEE_ASSET_PRICE_MODIFIER_BPS) {
            return -MAX_FEE_ASSET_PRICE_MODIFIER_BPS;
        }
        return rawModifierBps;
    }
}
/** Mainnet Uniswap V4 StateView contract address */ export const STATE_VIEW_ADDRESS = EthAddress.fromString('0x7ffe42c4a5deea5b0fec41c94c136cf115597227');
const PRECISION_Q192 = 10n ** 12n * 2n ** 192n;
/**
 * Converts Uniswap's sqrtPriceX96 directly to ETH per FeeAsset (E12).
 *
 * For an ETH/FeeAsset pool where ETH is currency0 and FeeAsset is currency1:
 * - Uniswap's sqrtPriceX96 = sqrt(FeeAsset/ETH) * 2^96
 * - We need: ETH/FeeAsset with 1e12 precision
 *
 * Math:
 *   price = (sqrtPriceX96 / 2^96)^2 = sqrtPriceX96^2 / 2^192  (FeeAsset per ETH)
 *   ethPerFeeAsset = 1 / price = 2^192 / sqrtPriceX96^2
 *   ethPerFeeAssetE12 = ethPerFeeAsset * 1e12 = 1e12 * 2^192 / sqrtPriceX96^2
 */ export function sqrtPriceX96ToEthPerFeeAssetE12(sqrtPriceX96) {
    if (sqrtPriceX96 === 0n) {
        throw new Error('Cannot convert zero sqrtPriceX96');
    }
    return PRECISION_Q192 / (sqrtPriceX96 * sqrtPriceX96);
}
/**
 * Uniswap V4 StateView ABI - only the functions we need
 */ const StateViewAbi = [
    {
        type: 'function',
        name: 'getSlot0',
        inputs: [
            {
                name: 'poolId',
                type: 'bytes32',
                internalType: 'PoolId'
            }
        ],
        outputs: [
            {
                name: 'sqrtPriceX96',
                type: 'uint160',
                internalType: 'uint160'
            },
            {
                name: 'tick',
                type: 'int24',
                internalType: 'int24'
            },
            {
                name: 'protocolFee',
                type: 'uint24',
                internalType: 'uint24'
            },
            {
                name: 'lpFee',
                type: 'uint24',
                internalType: 'uint24'
            }
        ],
        stateMutability: 'view'
    }
];
/**
 * Client for querying the ETH/FeeAsset price from Uniswap V4.
 * Returns prices in ETH per FeeAsset format (E12) to match the rollup contract.
 */ class UniswapPriceOracle {
    client;
    static{
        ({ e: [_initProto1] } = _apply_decs_2203_r(this, [
            [
                memoize,
                2,
                "computePoolId"
            ]
        ], []));
    }
    stateView;
    poolId;
    log;
    constructor(client, log){
        this.client = client;
        _initProto1(this);
        this.log = log ?? createLogger('uniswap-price-oracle');
        this.stateView = getContract({
            address: STATE_VIEW_ADDRESS.toString(),
            abi: StateViewAbi,
            client
        });
        this.poolId = this.computePoolId();
        this.log.debug(`Initialized UniswapPriceOracle with poolId: ${this.poolId}`);
    }
    /**
   * Computes the PoolId from the pool configuration by hashing its components.
   * PoolId = keccak256(abi.encode(currency0, currency1, fee, tickSpacing, hooks))
   * For mainnet, the value is expected to be: 0xce2899b16743cfd5a954d8122d5e07f410305b1aebee39fd73d9f3b9ebf10c2f
   * Derived anyway to make it simpler to change if needed.
   */ computePoolId() {
        /** ETH/FeeAsset pool configuration (hardcoded for mainnet) */ const encoded = encodeAbiParameters(parseAbiParameters('address, address, uint24, int24, address'), [
            EthAddress.ZERO.toString(),
            EthAddress.fromString('0xA27EC0006e59f245217Ff08CD52A7E8b169E62D2').toString(),
            500,
            10,
            EthAddress.fromString('0xd53006d1e3110fD319a79AEEc4c527a0d265E080').toString()
        ]);
        return keccak256(encoded);
    }
    async isPoolInitialized() {
        const [sqrtPriceX96] = await this.stateView.read.getSlot0([
            this.poolId
        ], undefined);
        return sqrtPriceX96 !== 0n;
    }
    /**
   * Gets the price as ETH per FeeAsset, scaled by 1e12.
   * This is the format expected by the rollup contract.
   *
   * @param blockNumber - Optional block number to query at (defaults to latest)
   */ async getEthPerFeeAssetE12(blockNumber) {
        const [sqrtPriceX96] = await this.stateView.read.getSlot0([
            this.poolId
        ], blockNumber !== undefined ? {
            blockNumber
        } : undefined);
        return sqrtPriceX96ToEthPerFeeAssetE12(sqrtPriceX96);
    }
    /**
   * Gets the median price over the last N blocks as ETH per FeeAsset (E12).
   * Using median helps protect against single-block manipulation.
   *
   * @param numBlocks - Number of recent blocks to sample (default: 5)
   * @returns Median price as ETH per FeeAsset, scaled by 1e12
   */ async getMeanEthPerFeeAssetE12(numBlocks = 5) {
        const currentBlock = await this.client.getBlockNumber();
        const prices = [];
        for(let i = 0; i < numBlocks; i++){
            const blockNumber = currentBlock - BigInt(i);
            if (blockNumber < 0n) {
                break;
            }
            try {
                const price = await this.getEthPerFeeAssetE12(blockNumber);
                prices.push(price);
            } catch (err) {
                this.log.warn(`Failed to get price at block ${blockNumber}: ${err}`);
            // Continue with fewer samples
            }
        }
        const filteredPrices = prices.filter((price)=>price !== 0n);
        if (filteredPrices.length === 0) {
            throw new Error('Failed to get any price samples from Uniswap oracle');
        }
        const mean = filteredPrices.reduce((a, b)=>a + b, 0n) / BigInt(filteredPrices.length);
        return mean;
    }
}
