import { mergeAbis, tryExtractEvent } from '@aztec/ethereum/utils';
import { Buffer32 } from '@aztec/foundation/buffer';
import { EthAddress } from '@aztec/foundation/eth-address';
import { Signature } from '@aztec/foundation/eth-signature';
import { hexToBuffer } from '@aztec/foundation/string';
import { SlasherAbi } from '@aztec/l1-artifacts/SlasherAbi';
import { TallySlashingProposerAbi } from '@aztec/l1-artifacts/TallySlashingProposerAbi';
import { encodeFunctionData, getContract } from 'viem';
/**
 * Wrapper around the TallySlashingProposer contract that provides
 * a TypeScript interface for interacting with the consensus-based slashing system.
 */ export class TallySlashingProposerContract {
    client;
    contract;
    type;
    constructor(client, address){
        this.client = client;
        this.type = 'tally';
        this.contract = getContract({
            address: typeof address === 'string' ? address : address.toString(),
            abi: TallySlashingProposerAbi,
            client
        });
    }
    get address() {
        return EthAddress.fromString(this.contract.address);
    }
    getQuorumSize() {
        return this.contract.read.QUORUM();
    }
    getRoundSize() {
        return this.contract.read.ROUND_SIZE();
    }
    getCommitteeSize() {
        return this.contract.read.COMMITTEE_SIZE();
    }
    getRoundSizeInEpochs() {
        return this.contract.read.ROUND_SIZE_IN_EPOCHS();
    }
    getLifetimeInRounds() {
        return this.contract.read.LIFETIME_IN_ROUNDS();
    }
    getExecutionDelayInRounds() {
        return this.contract.read.EXECUTION_DELAY_IN_ROUNDS();
    }
    getSlashingAmounts() {
        return Promise.all([
            this.contract.read.SLASH_AMOUNT_SMALL(),
            this.contract.read.SLASH_AMOUNT_MEDIUM(),
            this.contract.read.SLASH_AMOUNT_LARGE()
        ]);
    }
    getSlashOffsetInRounds() {
        return this.contract.read.SLASH_OFFSET_IN_ROUNDS();
    }
    getCurrentRound() {
        return this.contract.read.getCurrentRound();
    }
    /**
   * Get round information
   * @param round - The round number to query
   * @returns Round status information
   */ async getRound(round) {
        const [isExecuted, voteCount] = await this.contract.read.getRound([
            round
        ]);
        return {
            isExecuted,
            voteCount
        };
    }
    /**
   * Check if a round is ready to execute at a given slot
   * @param round - The round number to check
   * @param slot - The slot number to check at
   * @returns Whether the round is ready to execute
   */ async isRoundReadyToExecute(round, slot) {
        return await this.contract.read.isRoundReadyToExecute([
            round,
            BigInt(slot)
        ]);
    }
    /** Returns the slash actions and payload address for a given round (zero if no slash actions) */ async getPayload(round) {
        const { result: committees } = await this.contract.simulate.getSlashTargetCommittees([
            round
        ]);
        const tally = await this.contract.read.getTally([
            round,
            committees
        ]);
        const address = await this.contract.read.getPayloadAddress([
            round,
            tally
        ]);
        const actions = this.mapSlashActions(tally);
        return {
            actions,
            address: EthAddress.fromString(address)
        };
    }
    /** Returns the slash actions to be executed for a given round based on votes */ async getTally(round) {
        const { result: committees } = await this.contract.simulate.getSlashTargetCommittees([
            round
        ]);
        const tally = await this.contract.read.getTally([
            round,
            committees
        ]);
        return {
            actions: this.mapSlashActions(tally),
            committees: committees.map((c)=>c.map(EthAddress.fromString))
        };
    }
    mapSlashActions(actions) {
        return actions.map(({ validator, slashAmount })=>({
                validator: EthAddress.fromString(validator),
                slashAmount
            }));
    }
    /** Tries to extract a VoteCast event from the given logs. */ tryExtractVoteCastEvent(logs) {
        return tryExtractEvent(logs, this.address.toString(), TallySlashingProposerAbi, 'VoteCast');
    }
    /** Tries to extract a RoundExecuted event from the given logs. */ tryExtractRoundExecutedEvent(logs) {
        return tryExtractEvent(logs, this.address.toString(), TallySlashingProposerAbi, 'RoundExecuted');
    }
    /**
   * Create a transaction to vote for slashing offenses
   * @param votes - The encoded votes for slashing
   * @param slot - The slot number for the vote
   * @param signer - The signer to produce the signature
   * @returns L1 transaction request
   */ async buildVoteRequestFromSigner(votes, slot, signer) {
        const typedData = this.buildVoteTypedData(votes, slot);
        const signature = Signature.fromString(await signer(typedData));
        return {
            to: this.contract.address,
            abi: TallySlashingProposerAbi,
            data: encodeFunctionData({
                abi: TallySlashingProposerAbi,
                functionName: 'vote',
                args: [
                    votes,
                    signature.toViemSignature()
                ]
            })
        };
    }
    /** Returns the typed data definition to EIP712-sign for voting */ buildVoteTypedData(votes, slot) {
        const domain = {
            name: 'TallySlashingProposer',
            version: '1',
            chainId: this.client.chain.id,
            verifyingContract: this.contract.address
        };
        const types = {
            EIP712Domain: [
                {
                    name: 'name',
                    type: 'string'
                },
                {
                    name: 'version',
                    type: 'string'
                },
                {
                    name: 'chainId',
                    type: 'uint256'
                },
                {
                    name: 'verifyingContract',
                    type: 'address'
                }
            ],
            Vote: [
                {
                    name: 'votes',
                    type: 'bytes'
                },
                {
                    name: 'slot',
                    type: 'uint256'
                }
            ]
        };
        return {
            domain,
            types,
            primaryType: 'Vote',
            message: {
                votes,
                slot: BigInt(slot)
            }
        };
    }
    /** Gets the digest to sign for voting directly from the contract */ async getVoteDataDigest(votes, slot) {
        return Buffer32.fromString(await this.contract.read.getVoteSignatureDigest([
            votes,
            BigInt(slot)
        ]));
    }
    /**
   * Create a transaction to vote for slashing offenses
   * @param votes - The encoded votes for slashing
   * @param signature - The signature from the current proposer
   * @returns L1 transaction request
   */ buildVoteRequestWithSignature(votes, signature) {
        return {
            to: this.contract.address,
            abi: TallySlashingProposerAbi,
            data: encodeFunctionData({
                abi: TallySlashingProposerAbi,
                functionName: 'vote',
                args: [
                    votes,
                    signature
                ]
            })
        };
    }
    /**
   * Create a transaction to execute a slashing round
   * @param round - The round number to execute
   * @param committees - The committees for each epoch in the round
   * @returns L1 transaction request
   */ buildExecuteRoundRequest(round, committees) {
        return {
            to: this.contract.address,
            abi: mergeAbis([
                TallySlashingProposerAbi,
                SlasherAbi
            ]),
            data: encodeFunctionData({
                abi: TallySlashingProposerAbi,
                functionName: 'executeRound',
                args: [
                    round,
                    committees.map((c)=>c.map((addr)=>addr.toString()))
                ]
            })
        };
    }
    /** Returns the last vote emitted for a given round  */ async getLastVote(round) {
        const { voteCount } = await this.getRound(round);
        const validators = (await this.contract.simulate.getSlashTargetCommittees([
            round
        ])).result.flat();
        const vote = await this.contract.read.getVotes([
            round,
            voteCount - 1n
        ]);
        const decoded = decodeSlashConsensusVotes(hexToBuffer(vote));
        const slashAmounts = await this.getSlashingAmounts();
        return decoded.map((units, i)=>({
                validator: EthAddress.fromString(validators[i]),
                slashAmount: slashAmounts[units - 1] ?? 0n
            })).filter((v)=>v.slashAmount > 0n);
    }
    /**
   * Listen for VoteCast events
   * @param callback - Callback function to handle vote cast events
   * @returns Unwatch function
   */ listenToVoteCast(callback) {
        return this.contract.watchEvent.VoteCast({}, {
            onLogs: (logs)=>{
                for (const log of logs){
                    const { round, proposer } = log.args;
                    if (round !== undefined && proposer) {
                        callback({
                            round,
                            proposer
                        });
                    }
                }
            }
        });
    }
    /**
   * Listen for RoundExecuted events
   * @param callback - Callback function to handle round executed events
   * @returns Unwatch function
   */ listenToRoundExecuted(callback) {
        return this.contract.watchEvent.RoundExecuted({}, {
            onLogs: (logs)=>{
                for (const log of logs){
                    const { round, slashCount } = log.args;
                    if (round !== undefined && slashCount !== undefined) {
                        callback({
                            round,
                            slashCount,
                            l1BlockHash: log.blockHash
                        });
                    }
                }
            }
        });
    }
}
/**
 * Decodes a Buffer containing slash votes back into an array of numbers.
 * Each vote is represented as a 2-bit value (0, 1, 2, or 3) representing slashing units.
 * @dev This should live in stdlib next to encodeSlashConsensusVotes but is here since we
 * do not have a dependency to stdlib from the ethereum package. We need a larger refactor to fix this.
 * @param buffer - The Buffer containing encoded slash votes
 * @returns An array of numbers representing the slash votes
 */ export function decodeSlashConsensusVotes(buffer) {
    const votes = [];
    for(let i = 0; i < buffer.length; i++){
        const voteByte = buffer.readUInt8(i);
        // Decode votes from Solidity's bit order (LSB to MSB)
        // Bits 0-1: validator at index i*4
        // Bits 2-3: validator at index i*4+1
        // Bits 4-5: validator at index i*4+2
        // Bits 6-7: validator at index i*4+3
        votes.push(voteByte >> 0 & 0x03);
        votes.push(voteByte >> 2 & 0x03);
        votes.push(voteByte >> 4 & 0x03);
        votes.push(voteByte >> 6 & 0x03);
    }
    return votes;
}
