function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
var _initProto;
import { CheckpointNumber, EpochNumber, SlotNumber } from '@aztec/foundation/branded-types';
import { Buffer32 } from '@aztec/foundation/buffer';
import { Fr } from '@aztec/foundation/curves/bn254';
import { memoize } from '@aztec/foundation/decorators';
import { EthAddress } from '@aztec/foundation/eth-address';
import { makeBackoff, retry } from '@aztec/foundation/retry';
import { EscapeHatchAbi } from '@aztec/l1-artifacts/EscapeHatchAbi';
import { RollupAbi } from '@aztec/l1-artifacts/RollupAbi';
import { RollupStorage } from '@aztec/l1-artifacts/RollupStorage';
import chunk from 'lodash.chunk';
import { encodeFunctionData, getContract, hexToBigInt, keccak256 } from 'viem';
import { getPublicClient } from '../client.js';
import { formatViemError } from '../utils.js';
import { EmpireSlashingProposerContract } from './empire_slashing_proposer.js';
import { GSEContract } from './gse.js';
import { SlasherContract } from './slasher_contract.js';
import { TallySlashingProposerContract } from './tally_slashing_proposer.js';
import { checkBlockTag } from './utils.js';
export var SlashingProposerType = /*#__PURE__*/ function(SlashingProposerType) {
    SlashingProposerType[SlashingProposerType["None"] = 0] = "None";
    SlashingProposerType[SlashingProposerType["Tally"] = 1] = "Tally";
    SlashingProposerType[SlashingProposerType["Empire"] = 2] = "Empire";
    return SlashingProposerType;
}({});
/**
 * Status of a validator/attester in the staking system.
 * Matches the Status enum in StakingLib.sol
 */ export var AttesterStatus = /*#__PURE__*/ function(AttesterStatus) {
    AttesterStatus[AttesterStatus["NONE"] = 0] = "NONE";
    AttesterStatus[AttesterStatus["VALIDATING"] = 1] = "VALIDATING";
    AttesterStatus[AttesterStatus["ZOMBIE"] = 2] = "ZOMBIE";
    AttesterStatus[AttesterStatus["EXITING"] = 3] = "EXITING";
    return AttesterStatus;
}({});
export class RollupContract {
    client;
    static{
        ({ e: [_initProto] } = _apply_decs_2203_r(this, [
            [
                memoize,
                2,
                "getL1StartBlock"
            ],
            [
                memoize,
                2,
                "getL1GenesisTime"
            ],
            [
                memoize,
                2,
                "getProofSubmissionEpochs"
            ],
            [
                memoize,
                2,
                "getEpochDuration"
            ],
            [
                memoize,
                2,
                "getSlotDuration"
            ],
            [
                memoize,
                2,
                "getTargetCommitteeSize"
            ],
            [
                memoize,
                2,
                "getEjectionThreshold"
            ],
            [
                memoize,
                2,
                "getLocalEjectionThreshold"
            ],
            [
                memoize,
                2,
                "getLagInEpochsForValidatorSet"
            ],
            [
                memoize,
                2,
                "getLagInEpochsForRandao"
            ],
            [
                memoize,
                2,
                "getActivationThreshold"
            ],
            [
                memoize,
                2,
                "getExitDelay"
            ],
            [
                memoize,
                2,
                "getManaTarget"
            ],
            [
                memoize,
                2,
                "getProvingCostPerMana"
            ],
            [
                memoize,
                2,
                "getProvingCostPerManaInFeeAsset"
            ],
            [
                memoize,
                2,
                "getManaLimit"
            ],
            [
                memoize,
                2,
                "getVersion"
            ],
            [
                memoize,
                2,
                "getGenesisArchiveTreeRoot"
            ],
            [
                memoize,
                2,
                "getRollupConstants"
            ]
        ], []));
    }
    rollup;
    static cachedStfStorageSlot;
    cachedEscapeHatch;
    static get checkBlobStorageSlot() {
        const asString = RollupStorage.find((storage)=>storage.label === 'checkBlob')?.slot;
        if (asString === undefined) {
            throw new Error('checkBlobStorageSlot not found');
        }
        return BigInt(asString);
    }
    static get stfStorageSlot() {
        return RollupContract.cachedStfStorageSlot ??= keccak256(Buffer.from('aztec.stf.storage', 'utf-8'));
    }
    static getFromL1ContractsValues(deployL1ContractsValues) {
        const { l1Client, l1ContractAddresses: { rollupAddress } } = deployL1ContractsValues;
        return new RollupContract(l1Client, rollupAddress.toString());
    }
    static getFromConfig(config) {
        const client = getPublicClient(config);
        const address = config.l1Contracts.rollupAddress.toString();
        return new RollupContract(client, address);
    }
    constructor(client, address){
        this.client = client;
        _initProto(this);
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        this.rollup = getContract({
            address,
            abi: RollupAbi,
            client
        });
    }
    async getGSE() {
        return EthAddress.fromString(await this.rollup.read.getGSE());
    }
    get address() {
        return this.rollup.address;
    }
    getContract() {
        return this.rollup;
    }
    async getSlashingProposer() {
        const slasher = await this.getSlasherContract();
        if (!slasher) {
            return undefined;
        }
        const proposerAddress = await slasher.getProposer();
        const proposerAbi = [
            {
                type: 'function',
                name: 'SLASHING_PROPOSER_TYPE',
                inputs: [],
                outputs: [
                    {
                        name: '',
                        type: 'uint8',
                        internalType: 'enum SlasherFlavor'
                    }
                ],
                stateMutability: 'view'
            }
        ];
        const proposer = getContract({
            address: proposerAddress.toString(),
            abi: proposerAbi,
            client: this.client
        });
        const proposerType = await proposer.read.SLASHING_PROPOSER_TYPE();
        if (proposerType === 1..valueOf()) {
            return new TallySlashingProposerContract(this.client, proposerAddress);
        } else if (proposerType === 2..valueOf()) {
            return new EmpireSlashingProposerContract(this.client, proposerAddress);
        } else {
            throw new Error(`Unknown slashing proposer type: ${proposerType}`);
        }
    }
    getL1StartBlock() {
        return this.rollup.read.L1_BLOCK_AT_GENESIS();
    }
    getL1GenesisTime() {
        return this.rollup.read.getGenesisTime();
    }
    async getProofSubmissionEpochs() {
        return Number(await this.rollup.read.getProofSubmissionEpochs());
    }
    async getEpochDuration() {
        return Number(await this.rollup.read.getEpochDuration());
    }
    async getSlotDuration() {
        return Number(await this.rollup.read.getSlotDuration());
    }
    async getTargetCommitteeSize() {
        return Number(await this.rollup.read.getTargetCommitteeSize());
    }
    getEjectionThreshold() {
        return this.rollup.read.getEjectionThreshold();
    }
    getLocalEjectionThreshold() {
        return this.rollup.read.getLocalEjectionThreshold();
    }
    async getLagInEpochsForValidatorSet() {
        return Number(await this.rollup.read.getLagInEpochsForValidatorSet());
    }
    async getLagInEpochsForRandao() {
        return Number(await this.rollup.read.getLagInEpochsForRandao());
    }
    getActivationThreshold() {
        return this.rollup.read.getActivationThreshold();
    }
    async getExitDelay() {
        return Number(await this.rollup.read.getExitDelay());
    }
    getManaTarget() {
        return this.rollup.read.getManaTarget();
    }
    getProvingCostPerMana() {
        return this.rollup.read.getProvingCostPerManaInEth();
    }
    getProvingCostPerManaInFeeAsset() {
        return this.rollup.read.getProvingCostPerManaInFeeAsset();
    }
    getManaLimit() {
        return this.rollup.read.getManaLimit();
    }
    getVersion() {
        return this.rollup.read.getVersion();
    }
    async getGenesisArchiveTreeRoot() {
        return Fr.fromString(await this.rollup.read.archiveAt([
            0n
        ]));
    }
    /**
   * Returns rollup constants used for epoch queries.
   * Return type is `L1RollupConstants` which is defined in stdlib,
   * so we cant reference it until we move this contract to that package.
   */ async getRollupConstants() {
        const [l1StartBlock, l1GenesisTime, slotDuration, epochDuration, proofSubmissionEpochs, targetCommitteeSize] = await Promise.all([
            this.getL1StartBlock(),
            this.getL1GenesisTime(),
            this.getSlotDuration(),
            this.getEpochDuration(),
            this.getProofSubmissionEpochs(),
            this.getTargetCommitteeSize()
        ]);
        return {
            l1StartBlock,
            l1GenesisTime,
            slotDuration,
            epochDuration: Number(epochDuration),
            proofSubmissionEpochs: Number(proofSubmissionEpochs),
            targetCommitteeSize
        };
    }
    async getSlasherAddress() {
        return EthAddress.fromString(await this.rollup.read.getSlasher());
    }
    /**
   * Returns the configured escape hatch contract address, or zero if disabled.
   */ async getEscapeHatchAddress() {
        return EthAddress.fromString(await this.rollup.read.getEscapeHatch());
    }
    async getEscapeHatchContract() {
        const escapeHatchAddress = await this.getEscapeHatchAddress();
        if (escapeHatchAddress.isZero()) {
            return undefined;
        }
        // Cache the viem contract wrapper since it will be used frequently.
        if (!this.cachedEscapeHatch || !this.cachedEscapeHatch.address.equals(escapeHatchAddress)) {
            this.cachedEscapeHatch = {
                address: escapeHatchAddress,
                contract: getContract({
                    address: escapeHatchAddress.toString(),
                    abi: EscapeHatchAbi,
                    client: this.client
                })
            };
        }
        return this.cachedEscapeHatch.contract;
    }
    /**
   * Returns whether the escape hatch is open for the given epoch.
   * If escape hatch is not configured, returns false.
   *
   * This function is intentionally defensive: any failure to query the escape hatch
   * (RPC issues, transient errors, etc.) is treated as "closed" to avoid callers
   * needing to sprinkle try/catch everywhere.
   */ async isEscapeHatchOpen(epoch) {
        try {
            const escapeHatch = await this.getEscapeHatchContract();
            if (!escapeHatch) {
                return false;
            }
            const [isOpen] = await escapeHatch.read.isHatchOpen([
                BigInt(epoch)
            ]);
            return isOpen;
        } catch  {
            return false;
        }
    }
    /**
   * Returns a SlasherContract instance for interacting with the slasher contract.
   */ async getSlasherContract() {
        const slasherAddress = await this.getSlasherAddress();
        if (slasherAddress.isZero()) {
            return undefined;
        }
        return new SlasherContract(this.client, slasherAddress);
    }
    async getOwner() {
        return EthAddress.fromString(await this.rollup.read.owner());
    }
    async getActiveAttesterCount() {
        return Number(await this.rollup.read.getActiveAttesterCount());
    }
    async getSlashingProposerAddress() {
        const slasher = await this.getSlasherContract();
        if (!slasher) {
            return EthAddress.ZERO;
        }
        return await slasher.getProposer();
    }
    getCheckpointReward() {
        return this.rollup.read.getCheckpointReward();
    }
    async getCheckpointNumber() {
        return CheckpointNumber.fromBigInt(await this.rollup.read.getPendingCheckpointNumber());
    }
    async getProvenCheckpointNumber() {
        return CheckpointNumber.fromBigInt(await this.rollup.read.getProvenCheckpointNumber());
    }
    async getSlotNumber() {
        return SlotNumber.fromBigInt(await this.rollup.read.getCurrentSlot());
    }
    async getL1FeesAt(timestamp) {
        const result = await this.rollup.read.getL1FeesAt([
            timestamp
        ]);
        return {
            baseFee: result.baseFee,
            blobFee: result.blobFee
        };
    }
    getEthPerFeeAsset() {
        return this.rollup.read.getEthPerFeeAsset();
    }
    async getCommitteeAt(timestamp) {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getCommitteeAt',
            args: [
                timestamp
            ]
        }).catch((e)=>{
            if (e instanceof Error && e.message.includes('ValidatorSelection__InsufficientValidatorSetSize')) {
                return {
                    result: undefined
                };
            }
            throw e;
        });
        return result ? result.map((addr)=>EthAddress.fromString(addr)) : undefined;
    }
    async getSampleSeedAt(timestamp) {
        return Buffer32.fromBigInt(await this.rollup.read.getSampleSeedAt([
            timestamp
        ]));
    }
    async getCurrentSampleSeed() {
        return Buffer32.fromBigInt(await this.rollup.read.getCurrentSampleSeed());
    }
    async getCurrentEpoch() {
        return EpochNumber.fromBigInt(await this.rollup.read.getCurrentEpoch());
    }
    async getCurrentEpochCommittee() {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getCurrentEpochCommittee',
            args: []
        }).catch((e)=>{
            if (e instanceof Error && e.message.includes('ValidatorSelection__InsufficientValidatorSetSize')) {
                return {
                    result: undefined
                };
            }
            throw e;
        });
        return result ? result.map((addr)=>EthAddress.fromString(addr)) : undefined;
    }
    async getCurrentProposer() {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getCurrentProposer',
            args: []
        });
        return EthAddress.fromString(result);
    }
    async getProposerAt(timestamp) {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getProposerAt',
            args: [
                timestamp
            ]
        });
        return EthAddress.fromString(result);
    }
    async getCheckpoint(checkpointNumber) {
        const result = await this.rollup.read.getCheckpoint([
            BigInt(checkpointNumber)
        ]);
        return {
            archive: Fr.fromString(result.archive),
            headerHash: Buffer32.fromString(result.headerHash),
            blobCommitmentsHash: Buffer32.fromString(result.blobCommitmentsHash),
            attestationsHash: Buffer32.fromString(result.attestationsHash),
            payloadDigest: Buffer32.fromString(result.payloadDigest),
            slotNumber: SlotNumber.fromBigInt(result.slotNumber),
            feeHeader: {
                excessMana: result.feeHeader.excessMana,
                manaUsed: result.feeHeader.manaUsed,
                ethPerFeeAsset: result.feeHeader.ethPerFeeAsset,
                congestionCost: result.feeHeader.congestionCost,
                proverCost: result.feeHeader.proverCost
            }
        };
    }
    /** Returns the pending checkpoint from the rollup contract */ getPendingCheckpoint() {
        // We retry because of race conditions during prunes: we may get a pending checkpoint number which is immediately
        // reorged out due to a prune happening, causing the subsequent getCheckpoint call to fail. So we try again in that case.
        return retry(async ()=>{
            const pendingCheckpointNumber = await this.getCheckpointNumber();
            const pendingCheckpoint = await this.getCheckpoint(pendingCheckpointNumber);
            return pendingCheckpoint;
        }, 'getting pending checkpoint', makeBackoff([
            0.5,
            0.5,
            0.5
        ]));
    }
    async getTips() {
        const { pending, proven } = await this.rollup.read.getTips();
        return {
            pending: CheckpointNumber.fromBigInt(pending),
            proven: CheckpointNumber.fromBigInt(proven)
        };
    }
    getTimestampForSlot(slot) {
        return this.rollup.read.getTimestampForSlot([
            BigInt(slot)
        ]);
    }
    async getEntryQueueLength() {
        return Number(await this.rollup.read.getEntryQueueLength());
    }
    async getAvailableValidatorFlushes() {
        return Number(await this.rollup.read.getAvailableValidatorFlushes());
    }
    async getNextFlushableEpoch() {
        return EpochNumber.fromBigInt(await this.rollup.read.getNextFlushableEpoch());
    }
    async getCurrentEpochNumber() {
        return EpochNumber.fromBigInt(await this.rollup.read.getCurrentEpoch());
    }
    async getEpochNumberForCheckpoint(checkpointNumber) {
        return EpochNumber.fromBigInt(await this.rollup.read.getEpochForCheckpoint([
            BigInt(checkpointNumber)
        ]));
    }
    async getRollupAddresses() {
        const [inboxAddress, outboxAddress, feeJuicePortalAddress, rewardDistributorAddress, feeJuiceAddress, stakingAssetAddress, gseAddress] = (await Promise.all([
            this.rollup.read.getInbox(),
            this.rollup.read.getOutbox(),
            this.rollup.read.getFeeAssetPortal(),
            this.rollup.read.getRewardDistributor(),
            this.rollup.read.getFeeAsset(),
            this.rollup.read.getStakingAsset(),
            this.rollup.read.getGSE()
        ])).map(EthAddress.fromString);
        return {
            rollupAddress: EthAddress.fromString(this.address),
            inboxAddress,
            outboxAddress,
            feeJuicePortalAddress,
            feeJuiceAddress,
            stakingAssetAddress,
            rewardDistributorAddress,
            gseAddress
        };
    }
    async getFeeJuicePortal() {
        return EthAddress.fromString(await this.rollup.read.getFeeAssetPortal());
    }
    async getEpochNumberForSlotNumber(slotNumber) {
        return EpochNumber.fromBigInt(await this.rollup.read.getEpochAtSlot([
            BigInt(slotNumber)
        ]));
    }
    async getEpochProofPublicInputs(args) {
        const result = await this.rollup.read.getEpochProofPublicInputs(args);
        return result.map(Fr.fromString);
    }
    async validateHeader(args, account) {
        try {
            await this.client.simulateContract({
                address: this.address,
                abi: RollupAbi,
                functionName: 'validateHeaderWithAttestations',
                args,
                account
            });
        } catch (error) {
            throw formatViemError(error);
        }
    }
    /**
   * @notice  Calls `canProposeAtTime` with the time of the next Ethereum block and the sender address
   *
   * @dev     Throws if unable to propose
   *
   * @param archive - The archive that we expect to be current state
   * @return [slot, checkpointNumber, timeOfNextL1Slot] - If you can propose, the L2 slot number, checkpoint number and
   * timestamp of the next L1 block
   * @throws otherwise
   */ async canProposeAtNextEthBlock(archive, account, slotDuration, opts = {}) {
        const latestBlock = await this.client.getBlock();
        const timeOfNextL1Slot = latestBlock.timestamp + BigInt(slotDuration);
        const who = typeof account === 'string' ? account : account.address;
        try {
            const { result: [slot, checkpointNumber] } = await this.client.simulateContract({
                address: this.address,
                abi: RollupAbi,
                functionName: 'canProposeAtTime',
                args: [
                    timeOfNextL1Slot,
                    `0x${archive.toString('hex')}`,
                    who
                ],
                account,
                stateOverride: await this.makePendingCheckpointNumberOverride(opts.forcePendingCheckpointNumber)
            });
            return {
                slot: SlotNumber.fromBigInt(slot),
                checkpointNumber: CheckpointNumber.fromBigInt(checkpointNumber),
                timeOfNextL1Slot
            };
        } catch (err) {
            throw formatViemError(err);
        }
    }
    /**
   * Returns a state override that sets the pending checkpoint number to the specified value. Useful for simulations.
   * Requires querying the current state of the contract to get the current proven checkpoint number, as they are both
   * stored in the same slot. If the argument is undefined, it returns an empty override.
   */ async makePendingCheckpointNumberOverride(forcePendingCheckpointNumber) {
        if (forcePendingCheckpointNumber === undefined) {
            return [];
        }
        const slot = RollupContract.stfStorageSlot;
        const currentValue = await this.client.getStorageAt({
            address: this.address,
            slot
        });
        const currentProvenCheckpointNumber = currentValue ? hexToBigInt(currentValue) & (1n << 128n) - 1n : 0n;
        const newValue = BigInt(forcePendingCheckpointNumber) << 128n | currentProvenCheckpointNumber;
        return [
            {
                address: this.address,
                stateDiff: [
                    {
                        slot,
                        value: `0x${newValue.toString(16).padStart(64, '0')}`
                    }
                ]
            }
        ];
    }
    /** Creates a request to Rollup#invalidateBadAttestation to be simulated or sent */ buildInvalidateBadAttestationRequest(checkpointNumber, attestationsAndSigners, committee, invalidIndex) {
        return {
            to: this.address,
            abi: RollupAbi,
            data: encodeFunctionData({
                abi: RollupAbi,
                functionName: 'invalidateBadAttestation',
                args: [
                    BigInt(checkpointNumber),
                    attestationsAndSigners,
                    committee.map((addr)=>addr.toString()),
                    BigInt(invalidIndex)
                ]
            })
        };
    }
    /** Creates a request to Rollup#invalidateInsufficientAttestations to be simulated or sent */ buildInvalidateInsufficientAttestationsRequest(checkpointNumber, attestationsAndSigners, committee) {
        return {
            to: this.address,
            abi: RollupAbi,
            data: encodeFunctionData({
                abi: RollupAbi,
                functionName: 'invalidateInsufficientAttestations',
                args: [
                    BigInt(checkpointNumber),
                    attestationsAndSigners,
                    committee.map((addr)=>addr.toString())
                ]
            })
        };
    }
    /** Calls getHasSubmitted directly. Returns whether the given prover has submitted a proof with the given length for the given epoch. */ getHasSubmittedProof(epochNumber, numberOfCheckpointsInEpoch, prover) {
        if (prover instanceof EthAddress) {
            prover = prover.toString();
        }
        return this.rollup.read.getHasSubmitted([
            BigInt(epochNumber),
            BigInt(numberOfCheckpointsInEpoch),
            prover
        ]);
    }
    getManaMinFeeAt(timestamp, inFeeAsset) {
        return this.rollup.read.getManaMinFeeAt([
            timestamp,
            inFeeAsset
        ]);
    }
    async getSlotAt(timestamp) {
        return SlotNumber.fromBigInt(await this.rollup.read.getSlotAt([
            timestamp
        ]));
    }
    async status(checkpointNumber, options) {
        await checkBlockTag(options?.blockNumber, this.client);
        const result = await this.rollup.read.status([
            BigInt(checkpointNumber)
        ], options);
        return {
            provenCheckpointNumber: CheckpointNumber.fromBigInt(result[0]),
            provenArchive: Fr.fromString(result[1]),
            pendingCheckpointNumber: CheckpointNumber.fromBigInt(result[2]),
            pendingArchive: Fr.fromString(result[3]),
            archiveOfMyCheckpoint: Fr.fromString(result[4])
        };
    }
    async canPruneAtTime(timestamp, options) {
        await checkBlockTag(options?.blockNumber, this.client);
        return this.rollup.read.canPruneAtTime([
            timestamp
        ], options);
    }
    async archive() {
        return Fr.fromString(await this.rollup.read.archive());
    }
    async archiveAt(checkpointNumber) {
        return Fr.fromString(await this.rollup.read.archiveAt([
            BigInt(checkpointNumber)
        ]));
    }
    getSequencerRewards(address) {
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        return this.rollup.read.getSequencerRewards([
            address
        ]);
    }
    getSpecificProverRewardsForEpoch(epoch, prover) {
        if (prover instanceof EthAddress) {
            prover = prover.toString();
        }
        return this.rollup.read.getSpecificProverRewardsForEpoch([
            epoch,
            prover
        ]);
    }
    async getAttesters() {
        const attesterSize = await this.getActiveAttesterCount();
        const gse = new GSEContract(this.client, await this.getGSE());
        const ts = (await this.client.getBlock()).timestamp;
        const indices = Array.from({
            length: attesterSize
        }, (_, i)=>BigInt(i));
        const chunks = chunk(indices, 1000);
        const results = await Promise.all(chunks.map((chunk)=>gse.getAttestersFromIndicesAtTime(this.address, ts, chunk)));
        return results.flat().map((addr)=>EthAddress.fromString(addr));
    }
    async getAttesterView(address) {
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        const result = await this.rollup.read.getAttesterView([
            address
        ]);
        return {
            status: result.status,
            effectiveBalance: result.effectiveBalance,
            exit: {
                withdrawalId: result.exit.withdrawalId,
                amount: result.exit.amount,
                exitableAt: result.exit.exitableAt,
                recipientOrWithdrawer: EthAddress.fromString(result.exit.recipientOrWithdrawer),
                isRecipient: result.exit.isRecipient,
                exists: result.exit.exists
            },
            config: {
                publicKey: {
                    x: result.config.publicKey.x,
                    y: result.config.publicKey.y
                },
                withdrawer: EthAddress.fromString(result.config.withdrawer)
            }
        };
    }
    async getStatus(address) {
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        return await this.rollup.read.getStatus([
            address
        ]);
    }
    async getBlobCommitmentsHash(checkpointNumber) {
        return Buffer32.fromString(await this.rollup.read.getBlobCommitmentsHash([
            BigInt(checkpointNumber)
        ]));
    }
    async getCurrentBlobCommitmentsHash() {
        return Buffer32.fromString(await this.rollup.read.getCurrentBlobCommitmentsHash());
    }
    async getStakingAsset() {
        return EthAddress.fromString(await this.rollup.read.getStakingAsset());
    }
    async getRewardConfig() {
        const result = await this.rollup.read.getRewardConfig();
        return {
            rewardDistributor: EthAddress.fromString(result.rewardDistributor),
            sequencerBps: BigInt(result.sequencerBps),
            booster: EthAddress.fromString(result.booster),
            checkpointReward: result.checkpointReward
        };
    }
    setupEpoch(l1TxUtils) {
        return l1TxUtils.sendAndMonitorTransaction({
            to: this.address,
            abi: RollupAbi,
            data: encodeFunctionData({
                abi: RollupAbi,
                functionName: 'setupEpoch',
                args: []
            })
        });
    }
    vote(l1TxUtils, proposalId) {
        return l1TxUtils.sendAndMonitorTransaction({
            to: this.address,
            abi: RollupAbi,
            data: encodeFunctionData({
                abi: RollupAbi,
                functionName: 'vote',
                args: [
                    proposalId
                ]
            })
        });
    }
    listenToSlasherChanged(callback) {
        return this.rollup.watchEvent.SlasherUpdated({}, {
            onLogs: (logs)=>{
                for (const log of logs){
                    const args = log.args;
                    if (args.oldSlasher && args.newSlasher) {
                        callback(args);
                    }
                }
            }
        });
    }
    listenToCheckpointInvalidated(callback) {
        return this.rollup.watchEvent.CheckpointInvalidated({}, {
            onLogs: (logs)=>{
                for (const log of logs){
                    const args = log.args;
                    if (args.checkpointNumber !== undefined) {
                        callback({
                            checkpointNumber: CheckpointNumber.fromBigInt(args.checkpointNumber)
                        });
                    }
                }
            }
        });
    }
    async getSlashEvents(l1BlockHash) {
        const events = await this.rollup.getEvents.Slashed({}, {
            blockHash: l1BlockHash,
            strict: true
        });
        return events.map((event)=>({
                amount: event.args.amount,
                attester: EthAddress.fromString(event.args.attester)
            }));
    }
    listenToSlash(callback) {
        return this.rollup.watchEvent.Slashed({}, {
            strict: true,
            onLogs: (logs)=>{
                for (const log of logs){
                    const args = log.args;
                    callback({
                        amount: args.amount,
                        attester: EthAddress.fromString(args.attester)
                    });
                }
            }
        });
    }
    /** Fetches CheckpointProposed events within the given block range. */ async getCheckpointProposedEvents(fromBlock, toBlock) {
        const logs = await this.rollup.getEvents.CheckpointProposed({}, {
            fromBlock,
            toBlock
        });
        return logs.filter((log)=>log.blockNumber >= fromBlock && log.blockNumber <= toBlock).map((log)=>({
                l1BlockNumber: log.blockNumber,
                l1BlockHash: Buffer32.fromString(log.blockHash),
                l1TransactionHash: log.transactionHash,
                args: {
                    checkpointNumber: CheckpointNumber.fromBigInt(log.args.checkpointNumber),
                    archive: Fr.fromString(log.args.archive),
                    versionedBlobHashes: log.args.versionedBlobHashes.map((h)=>Buffer.from(h.slice(2), 'hex')),
                    attestationsHash: log.args.attestationsHash ? Buffer32.fromString(log.args.attestationsHash) : undefined,
                    payloadDigest: log.args.payloadDigest ? Buffer32.fromString(log.args.payloadDigest) : undefined
                }
            }));
    }
}
