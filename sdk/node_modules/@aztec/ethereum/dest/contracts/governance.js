import { EthAddress } from '@aztec/foundation/eth-address';
import { sleep } from '@aztec/foundation/sleep';
import { GovernanceAbi } from '@aztec/l1-artifacts/GovernanceAbi';
import { encodeFunctionData, getContract, parseEventLogs } from 'viem';
import { createL1TxUtils } from '../l1_tx_utils/index.js';
import { isExtendedClient } from '../types.js';
// NOTE: Must be kept in sync with DataStructures.ProposalState in l1-contracts
export var ProposalState = /*#__PURE__*/ function(ProposalState) {
    ProposalState[ProposalState["Pending"] = 0] = "Pending";
    ProposalState[ProposalState["Active"] = 1] = "Active";
    ProposalState[ProposalState["Queued"] = 2] = "Queued";
    ProposalState[ProposalState["Executable"] = 3] = "Executable";
    ProposalState[ProposalState["Rejected"] = 4] = "Rejected";
    ProposalState[ProposalState["Executed"] = 5] = "Executed";
    ProposalState[ProposalState["Dropped"] = 6] = "Dropped";
    ProposalState[ProposalState["Expired"] = 7] = "Expired";
    return ProposalState;
}({});
export function extractProposalIdFromLogs(logs) {
    const parsedLogs = parseEventLogs({
        abi: GovernanceAbi,
        logs: logs,
        eventName: 'Proposed'
    });
    if (parsedLogs.length === 0) {
        throw new Error('Proposal log not found');
    }
    return parsedLogs[0].args.proposalId;
}
export class ReadOnlyGovernanceContract {
    client;
    governanceContract;
    constructor(address, client){
        this.client = client;
        this.governanceContract = getContract({
            address,
            abi: GovernanceAbi,
            client: client
        });
    }
    get address() {
        return EthAddress.fromString(this.governanceContract.address);
    }
    async getGovernanceProposerAddress() {
        return EthAddress.fromString(await this.governanceContract.read.governanceProposer());
    }
    getConfiguration() {
        return this.governanceContract.read.getConfiguration();
    }
    getProposal(proposalId) {
        return this.governanceContract.read.getProposal([
            proposalId
        ]);
    }
    async getProposalState(proposalId) {
        const state = await this.governanceContract.read.getProposalState([
            proposalId
        ]);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        if (state < 0 || state > 7) {
            throw new Error(`Invalid proposal state: ${state}`);
        }
        return state;
    }
    async awaitProposalActive({ proposalId, logger }) {
        const state = await this.getProposalState(proposalId);
        if (state === 1) {
            return;
        } else if (state !== 0) {
            throw new Error(`Proposal ${proposalId} is in state [${state}]: it will never be active`);
        } else {
            const proposal = await this.getProposal(proposalId);
            const startOfActive = proposal.creation + proposal.config.votingDelay;
            const block = await this.client.getBlock();
            // Add 12 seconds to the time to make sure we don't vote too early
            const secondsToActive = Number(startOfActive - block.timestamp) + 12;
            const now = new Date();
            logger.info(`
        The time is ${now.toISOString()}.
        The proposal will be active at ${new Date(Number(startOfActive) * 1000).toISOString()}.
        Waiting ${secondsToActive} seconds for proposal to be active.
        `);
            await sleep(secondsToActive * 1000);
        }
    }
    async awaitProposalExecutable({ proposalId, logger }) {
        const state = await this.getProposalState(proposalId);
        if (state === 3) {
            return;
        } else if (![
            0,
            1,
            2,
            3
        ].includes(state)) {
            throw new Error(`Proposal ${proposalId} is in state [${state}]: it will never be executable`);
        } else {
            const proposal = await this.getProposal(proposalId);
            const startOfExecutable = proposal.creation + proposal.config.votingDelay + proposal.config.votingDuration + proposal.config.executionDelay;
            const block = await this.client.getBlock();
            const secondsToExecutable = Number(startOfExecutable - block.timestamp) + 12;
            const now = new Date();
            logger.info(`
        The time is ${now.toISOString()}.
        The proposal will be executable at ${new Date(Number(startOfExecutable) * 1000).toISOString()}.
        Waiting ${secondsToExecutable} seconds for proposal to be executable.
        `);
            await sleep(secondsToExecutable * 1000);
        }
    }
}
export class GovernanceContract extends ReadOnlyGovernanceContract {
    client;
    governanceContract;
    constructor(address, client){
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        super(address, client), this.client = client;
        if (!isExtendedClient(client)) {
            throw new Error('GovernanceContract has to be instantiated with a wallet client.');
        }
        this.governanceContract = getContract({
            address,
            abi: GovernanceAbi,
            client
        });
    }
    async deposit(onBehalfOf, amount) {
        const depositTx = await this.governanceContract.write.deposit([
            onBehalfOf,
            amount
        ]);
        await this.client.waitForTransactionReceipt({
            hash: depositTx
        });
    }
    async proposeWithLock({ payloadAddress, withdrawAddress }) {
        const proposeTx = await this.governanceContract.write.proposeWithLock([
            payloadAddress,
            withdrawAddress
        ]);
        const receipt = await this.client.waitForTransactionReceipt({
            hash: proposeTx
        });
        if (receipt.status !== 'success') {
            throw new Error(`Proposal failed: ${receipt.status}`);
        }
        return extractProposalIdFromLogs(receipt.logs);
    }
    async getPower() {
        const now = await this.client.getBlock();
        return this.governanceContract.read.powerAt([
            this.client.account.address,
            now.timestamp
        ]);
    }
    /** Returns the user's voting power for a specific proposal, checked at pendingThrough timestamp. */ async getPowerForProposal(proposalId) {
        const proposal = await this.getProposal(proposalId);
        const pendingThrough = proposal.creation + proposal.config.votingDelay;
        return this.governanceContract.read.powerAt([
            this.client.account.address,
            pendingThrough
        ]);
    }
    async vote({ proposalId, voteAmount, inFavor, retries = 10, logger }) {
        const l1TxUtils = createL1TxUtils(this.client, {
            logger
        });
        const retryDelaySeconds = 12;
        voteAmount = voteAmount ?? await this.getPowerForProposal(proposalId);
        let success = false;
        for(let i = 0; i < retries; i++){
            try {
                const voteFunctionData = {
                    abi: GovernanceAbi,
                    functionName: 'vote',
                    args: [
                        proposalId,
                        voteAmount,
                        inFavor
                    ]
                };
                const encodedVoteData = encodeFunctionData(voteFunctionData);
                const { receipt } = await l1TxUtils.sendAndMonitorTransaction({
                    to: this.governanceContract.address,
                    abi: GovernanceAbi,
                    data: encodedVoteData
                });
                if (receipt.status === 'success') {
                    success = true;
                    break;
                } else {
                    const args = {
                        ...voteFunctionData,
                        address: this.governanceContract.address
                    };
                    const errorMsg = await l1TxUtils.tryGetErrorFromRevertedTx(encodedVoteData, args, undefined, []);
                    logger.error(`Error voting on proposal ${proposalId}: ${errorMsg}`);
                }
            } catch (error) {
                logger.error(`Error voting on proposal ${proposalId}: ${error}`);
            }
            logger.info(`Retrying vote on proposal ${proposalId} in ${retryDelaySeconds} seconds`);
            await sleep(retryDelaySeconds * 1000);
        }
        if (!success) {
            throw new Error(`Failed to vote on proposal ${proposalId} after ${retries} retries`);
        }
        logger.info(`Voted [${inFavor ? 'yea' : 'nay'}] on proposal [${proposalId}]`);
        const proposal = await this.getProposal(proposalId);
        logger.info(`Proposal [${proposalId}] has cached state [${proposal.cachedState}]`);
        logger.info(`Proposal [${proposalId}] has summedBallot yea [${proposal.summedBallot.yea}]`);
        logger.info(`Proposal [${proposalId}] has summedBallot nay [${proposal.summedBallot.nay}]`);
    }
    async executeProposal({ proposalId, retries = 10, logger }) {
        const l1TxUtils = createL1TxUtils(this.client, {
            logger
        });
        const retryDelaySeconds = 12;
        let success = false;
        for(let i = 0; i < retries; i++){
            try {
                const executeFunctionData = {
                    abi: GovernanceAbi,
                    functionName: 'execute',
                    args: [
                        proposalId
                    ]
                };
                const encodedExecuteData = encodeFunctionData(executeFunctionData);
                const { receipt } = await l1TxUtils.sendAndMonitorTransaction({
                    to: this.governanceContract.address,
                    abi: GovernanceAbi,
                    data: encodedExecuteData
                });
                if (receipt.status === 'success') {
                    success = true;
                    break;
                } else {
                    const args = {
                        ...executeFunctionData,
                        address: this.governanceContract.address
                    };
                    const errorMsg = await l1TxUtils.tryGetErrorFromRevertedTx(encodedExecuteData, args, undefined, []);
                    logger.error(`Error executing proposal ${proposalId}: ${errorMsg}`);
                }
            } catch (error) {
                logger.error(`Error executing proposal ${proposalId}: ${error}`);
            }
            logger.info(`Retrying execute proposal ${proposalId} in ${retryDelaySeconds} seconds`);
            await sleep(retryDelaySeconds * 1000);
        }
        if (!success) {
            throw new Error(`Failed to execute proposal ${proposalId} after ${retries} retries`);
        } else {
            logger.info(`Executed proposal ${proposalId}`);
        }
    }
}
