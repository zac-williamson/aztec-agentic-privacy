# L1 Contract Wrappers

This folder contains TypeScript wrappers for L1 contracts defined in `l1-contracts/`. These wrappers are used by the node client to interact with the rollup and related contracts on Ethereum.

## Purpose

The goal of wrapping is to shield consumers from L1-specific and viem-specific details. Clients using these wrappers interact with domain types and branded types native to the Aztec codebase, without needing to understand viem's ABI type system or deal with raw types like `Hex` and `bigint`.

## Type Safety

### Explicit Return Types

Every function in the contract wrappers must declare its return type explicitly. This is critical because viem's type inference over ABI types is slow and significantly impacts IDE performance.

```typescript
// Good: Explicit return type
async getSlotNumber(): Promise<SlotNumber> {
  return SlotNumber.fromBigInt(await this.rollup.read.getCurrentSlot());
}

// Bad: Inferred return type (slow)
async getSlotNumber() {
  return SlotNumber.fromBigInt(await this.rollup.read.getCurrentSlot());
}
```

### Branded and Domain Types

Use branded types and domain-specific types instead of viem's autogenerated types for both arguments and return values:

- `CheckpointNumber`, `EpochNumber`, `SlotNumber` instead of `bigint`
- `EthAddress` instead of `` `0x${string}` `` or `Hex`
- `Fr`, `Buffer32` instead of `Hex` for hashes and field elements
- Custom domain types (e.g., `CheckpointLog`, `AttesterView`) instead of raw tuples

Type conversions happen inside wrapper methods, not at the call site:

```typescript
async getCheckpoint(checkpointNumber: CheckpointNumber): Promise<CheckpointLog> {
  const result = await this.rollup.read.getCheckpoint([BigInt(checkpointNumber)]);
  return {
    archive: Fr.fromString(result.archive),
    headerHash: Buffer32.fromString(result.headerHash),
    blockCount: result.blockCount,
  };
}
```

## Wrapper Pattern

### Basic Structure

Each wrapper follows a consistent structure:

```typescript
export class FooContract {
  private readonly foo: GetContractReturnType<typeof FooAbi, ViemClient>;

  constructor(
    public readonly client: ViemClient,
    address: Hex | EthAddress,
  ) {
    if (address instanceof EthAddress) {
      address = address.toString();
    }
    this.foo = getContract({ address, abi: FooAbi, client });
  }

  public get address(): Hex {
    return this.foo.address;
  }

  public getContract(): GetContractReturnType<typeof FooAbi, ViemClient> {
    return this.foo;
  }
}
```

The raw contract is exposed via `getContract()` for cases where direct access is needed, but most consumers should use the typed wrapper methods. Relying on `getContract()` is a code smell and should be avoided.

### Static Factory Methods

Wrappers may provide static factory methods for common initialization patterns:

- `getFromConfig(config)` - construct from configuration object
- `getFromL1ContractsValues(deployResult)` - construct from deployment result

### Wallet Assertions

For write operations that require a wallet, use an assertion helper:

```typescript
private assertWallet(): GetContractReturnType<typeof FooAbi, ExtendedViemWalletClient> {
  if (!isExtendedClient(this.client)) {
    throw new Error('Wallet client is required for this operation');
  }
  return this.foo as GetContractReturnType<typeof FooAbi, ExtendedViemWalletClient>;
}
```

## Event Handling

### Event Log Types

Event logs are wrapped in `L1EventLog<T>` to include L1 block context:

```typescript
type L1EventLog<T> = {
  l1BlockNumber: bigint;
  l1BlockHash: Buffer32;
  l1TransactionHash: Hex;
  args: T;
};
```

### Event Fetching

Methods that fetch events convert viem's raw logs to domain types:

```typescript
async getCheckpointProposedEvents(fromBlock: bigint, toBlock: bigint): Promise<CheckpointProposedLog[]> {
  const logs = await this.rollup.getEvents.CheckpointProposed({}, { fromBlock, toBlock });
  return logs.map(log => ({
    l1BlockNumber: log.blockNumber!,
    l1BlockHash: Buffer32.fromString(log.blockHash!),
    l1TransactionHash: log.transactionHash!,
    args: {
      checkpointNumber: CheckpointNumber.fromBigInt(log.args.checkpointNumber!),
      // ... convert other fields
    },
  }));
}
```

### Event Listeners

For reactive event handling, wrapper methods convert arguments before invoking callbacks:

```typescript
public listenToCheckpointInvalidated(
  callback: (args: { checkpointNumber: CheckpointNumber }) => unknown,
): WatchContractEventReturnType {
  return this.rollup.watchEvent.CheckpointInvalidated({}, {
    onLogs: logs => {
      for (const log of logs) {
        if (log.args.checkpointNumber !== undefined) {
          callback({ checkpointNumber: CheckpointNumber.fromBigInt(log.args.checkpointNumber) });
        }
      }
    },
  });
}
```

## Error Handling

Custom error classes in `errors.ts` extend `Error` and set `this.name` for proper error identification. Include relevant context as public readonly properties.
