import type { Listener } from './interface/listener.js';
/**
 * Keeps track of clients, providing a broadcast, and request/response api with multiplexing.
 */
export declare class TransportServer<Payload> {
    private listener;
    private msgHandlerFn;
    private sockets;
    constructor(listener: Listener, msgHandlerFn: (msg: Payload) => Promise<any>);
    /**
     * Starts the TransportServer, allowing it to accept new connections and handle incoming messages.
     * The server will listen for 'new_socket' events from the underlying listener and invoke the provided message handler function
     * for each received message. The server remains active until the 'stop' method is called.
     */
    start(): void;
    /**
     * Stops accepting new connections. It doesn't close existing sockets.
     * It's expected the clients will gracefully complete by closing their end, sending an `undefined` message.
     */
    stop(): void;
    /**
     * Sends a broadcast message to all connected clients.
     * The given payload will be sent to all the clients currently connected to the TransportServer.
     * It waits for all the messages to be sent and resolves when they are all sent successfully.
     *
     * @param msg - The payload to broadcast to all connected clients.
     * @returns A Promise that resolves when all messages have been sent successfully.
     */
    broadcast(msg: Payload): Promise<void>;
    /**
     * Handles the addition of a new socket to the server by registering a message handler for the client
     * and adding the socket to the list of active sockets. The message handler processes incoming messages
     * from the client, including detecting client disconnection and removing the closed socket.
     *
     * @param socket - The new Socket instance that has connected to the server.
     */
    private handleNewSocket;
    /**
     * Detect the 'transferables' argument to our socket from our message
     * handler return type.
     * @param data - The compound payload data.
     * @returns The split data and transferables.
     */
    private getPayloadAndTransfers;
    private handleSocketMessage;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNwb3J0X3NlcnZlci5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RyYW5zcG9ydC90cmFuc3BvcnRfc2VydmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBSXhEOztHQUVHO0FBQ0gscUJBQWEsZUFBZSxDQUFDLE9BQU87SUFJaEMsT0FBTyxDQUFDLFFBQVE7SUFDaEIsT0FBTyxDQUFDLFlBQVk7SUFKdEIsT0FBTyxDQUFDLE9BQU8sQ0FBZ0I7SUFFL0IsWUFDVSxRQUFRLEVBQUUsUUFBUSxFQUNsQixZQUFZLEVBQUUsQ0FBQyxHQUFHLEVBQUUsT0FBTyxLQUFLLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFDbEQ7SUFFSjs7OztPQUlHO0lBQ0gsS0FBSyxTQUdKO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSSxTQUVIO0lBRUQ7Ozs7Ozs7T0FPRztJQUNHLFNBQVMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxpQkFFM0I7SUFFRDs7Ozs7O09BTUc7SUFDSCxPQUFPLENBQUMsZUFBZTtJQWN2Qjs7Ozs7T0FLRztJQUNILE9BQU8sQ0FBQyxzQkFBc0I7WUF3QmhCLG1CQUFtQjtDQWFsQyJ9