import { Fq } from '../curves/bn254/field.js';
/**
 * The FieldReader class provides a utility for reading various data types from a field array.
 *
 * Usage:
 * Create a new instance of FieldReader with an array of fields and an optional offset.
 * Use the provided methods to read desired data types from the field array.
 * The reading methods automatically advance the internal index.
 */ export class FieldReader {
    fields;
    index;
    length;
    constructor(fields, offset = 0){
        this.fields = fields;
        this.index = offset;
        this.length = fields.length;
        if (offset > this.length) {
            throw new Error('Offset out of bounds.');
        }
    }
    /**
   * Creates a FieldReader instance from either a field array or an existing FieldReader.
   *
   * @param fields - A field array or FieldReader to initialize the FieldReader.
   * @returns An instance of FieldReader.
   */ static asReader(fields) {
        if (fields instanceof FieldReader) {
            return fields;
        }
        return new FieldReader(fields);
    }
    /**
   * Returns the current cursor position.
   *
   * @returns The current cursor position.
   */ get cursor() {
        return this.index;
    }
    remainingFields() {
        return this.length - this.index;
    }
    /**
   * Skips the next n fields.
   *
   * @param n - The number of fields to skip.
   */ skip(n) {
        if (this.index + n > this.length) {
            throw new Error('Not enough fields to be consumed.');
        }
        this.index += n;
    }
    /**
   * Reads a single field from the array.
   *
   * @returns A field.
   */ readField() {
        if (this.index === this.length) {
            throw new Error('Not enough fields to be consumed.');
        }
        return this.fields[this.index++];
    }
    /**
   * Peeks at the next field without advancing the cursor.
   *
   * @returns A field.
   */ peekField() {
        if (this.index === this.length) {
            throw new Error('Not enough fields to be consumed.');
        }
        return this.fields[this.index];
    }
    /**
   * Reads a Fq from the array.
   *
   * @returns An Fq.
   */ readFq() {
        return Fq.fromHighLow(this.readField(), this.readField());
    }
    /**
   * Reads and returns the next boolean value from the field array.
   * Advances the internal index by 1, treating the field at the current index as a boolean value.
   * Returns true if the field is non-zero, false otherwise.
   * Throw if the value is not 0 or 1.
   *
   * @returns A boolean value representing the field at the current index.
   */ readBoolean() {
        const field = this.readField();
        const value = field.toBigInt();
        if (value > 1n) {
            throw new Error('Field is not a boolean.');
        }
        return value == 1n;
    }
    /**
   * Reads a 32-bit unsigned integer from the field array at the current index position.
   * Updates the index position by 1 after reading the number.
   * Throw if the value is greater than 2 ** 32.
   *
   * @returns The read 32-bit unsigned integer value.
   */ readU32() {
        const field = this.readField();
        const value = field.toBigInt();
        if (value >= 1n << 32n) {
            throw new Error('Field is not a u32.');
        }
        return Number(value);
    }
    /**
   * Reads a 64-bit unsigned integer from the field array at the current index position.
   * Updates the index position by 1 after reading the number.
   * Throw if the value is greater than 2 ** 64.
   *
   * @returns The read 64-bit unsigned integer value as a bigint.
   */ readU64() {
        const field = this.readField();
        const value = field.toBigInt();
        if (value >= 1n << 64n) {
            throw new Error('Field is not a u64.');
        }
        return value;
    }
    /**
   * Read an array of a fixed size field array.
   *
   * @param size - The fixed number of fields in the array.
   * @returns An array of fields.
   */ readFieldArray(size) {
        const result = [];
        for(let i = 0; i < size; ++i){
            result.push(this.readField());
        }
        return result;
    }
    /**
   * Read an array of a fixed size with elements of type T from the field array.
   * The 'itemDeserializer' object should have a 'fromFields' method that takes a FieldReader instance as input,
   * and returns an instance of the desired deserialized data type T.
   * This method will call the 'fromFields' method for each element in the array and return the resulting array.
   *
   * @param size - The fixed number of elements in the array.
   * @param itemDeserializer - An object with a 'fromFields' method to deserialize individual elements of type T.
   * @returns An array of instances of type T.
   */ readArray(size, itemDeserializer) {
        const result = Array.from({
            length: size
        }, ()=>itemDeserializer.fromFields(this));
        return result;
    }
    /**
   * Reads a serialized object from a field array and returns the deserialized object using the given deserializer.
   *
   * @typeparam T - The type of the deserialized object.
   * @param deserializer - An object with a 'fromFields' method that takes a FieldReader instance and returns an instance of the deserialized object.
   * @returns The deserialized object of type T.
   */ readObject(deserializer) {
        return deserializer.fromFields(this);
    }
    /**
   * Returns whether the reader has finished reading all fields.
   * @returns A bool.
   */ isFinished() {
        return this.index >= this.length;
    }
}
