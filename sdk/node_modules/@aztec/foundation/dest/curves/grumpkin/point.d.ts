import { BufferReader, FieldReader } from '../../serialize/index.js';
import { Fr } from '../bn254/field.js';
/**
 * Represents a Point on an elliptic curve with x and y coordinates.
 * The Point class provides methods for creating instances from different input types,
 * converting instances to various output formats, and checking the equality of points.
 * TODO(#7386): Clean up this class.
 */
export declare class Point {
    /**
     * The point's x coordinate
     */
    readonly x: Fr;
    /**
     * The point's y coordinate
     */
    readonly y: Fr;
    /**
     * Whether the point is at infinity
     */
    readonly isInfinite: boolean;
    static ZERO: Point;
    static SIZE_IN_BYTES: number;
    static COMPRESSED_SIZE_IN_BYTES: number;
    /** Used to differentiate this class from AztecAddress */
    readonly kind = "point";
    constructor(
    /**
     * The point's x coordinate
     */
    x: Fr, 
    /**
     * The point's y coordinate
     */
    y: Fr, 
    /**
     * Whether the point is at infinity
     */
    isInfinite: boolean);
    toJSON(): `0x${string}`;
    static get schema(): import("zod").ZodType<Point, any, string>;
    /**
     * Creates a Point from a plain object without Zod validation.
     * This method is optimized for performance and skips validation, making it suitable
     * for deserializing trusted data (e.g., from C++ via MessagePack).
     * Handles buffers, existing instances, or objects with x, y, and isInfinite fields.
     * @param obj - Plain object, buffer, or Point instance
     * @returns A Point instance
     */
    static fromPlainObject(obj: any): Point;
    /**
     * Generate a random Point instance.
     *
     * @returns A randomly generated Point instance.
     */
    static random(): Promise<Point>;
    /**
     * Create a Point instance from a given buffer or BufferReader.
     * The input 'buffer' should have exactly 64 bytes representing the x and y coordinates.
     *
     * @param buffer - The buffer or BufferReader containing the x and y coordinates of the point.
     * @returns A Point instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): Point;
    /**
     * Create a Point instance from a compressed buffer.
     * The input 'buffer' should have exactly 33 bytes representing the x coordinate and the sign of the y coordinate.
     *
     * @param buffer - The buffer containing the x coordinate and the sign of the y coordinate.
     * @returns A Point instance.
     */
    static fromCompressedBuffer(buffer: Buffer | BufferReader): Promise<Point>;
    /**
     * Create a Point instance from a hex-encoded string.
     * The input should be prefixed with '0x' or not, and have exactly 128 hex characters representing the x and y coordinates.
     * Throws an error if the input length is invalid or coordinate values are out of range.
     *
     * @param str - The hex-encoded string representing the Point coordinates.
     * @returns A Point instance.
     */
    static fromString(str: string): Point;
    /**
     * Returns the contents of the point as an array of 2 fields.
     * @returns The point as an array of 2 fields
     */
    toFields(): Fr[];
    static fromFields(fields: Fr[] | FieldReader): Point;
    /**
     * Uses the x coordinate and isPositive flag (+/-) to reconstruct the point.
     * @dev The y coordinate can be derived from the x coordinate and the "sign" flag by solving the grumpkin curve
     * equation for y.
     * @param x - The x coordinate of the point
     * @param sign - The "sign" of the y coordinate - note that this is not a sign as is known in integer arithmetic.
     * Instead it is a boolean flag that determines whether the y coordinate is <= (Fr.MODULUS - 1) / 2
     * @returns The point as an array of 2 fields
     */
    static fromXAndSign(x: Fr, sign: boolean): Promise<Point>;
    /**
     * @returns
     */
    static YFromX(x: Fr): Promise<Fr | null>;
    /**
     * Returns the x coordinate and the sign of the y coordinate.
     * @dev The y sign can be determined by checking if the y coordinate is greater than half of the modulus.
     * @returns The x coordinate and the sign of the y coordinate.
     */
    toXAndSign(): [Fr, boolean];
    /**
     * Returns the contents of the point as BigInts.
     * @returns The point as BigInts
     */
    toBigInts(): {
        x: bigint;
        y: bigint;
        isInfinite: bigint;
    };
    /**
     * Converts the Point instance to a Buffer representation of the coordinates.
     * @returns A Buffer representation of the Point instance.
     * @dev Note that toBuffer does not include the isInfinite flag and other serialization methods do (e.g. toFields).
     * This is because currently when we work with point as bytes we don't want to populate the extra bytes for
     * isInfinite flag because:
     * 1. Our Grumpkin BB API currently does not handle point at infinity,
     * 2. we use toBuffer when serializing notes and events and there we only work with public keys and point at infinity
     *   is not considered a valid public key and the extra byte would raise DA cost.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Converts the Point instance to a compressed Buffer representation of the coordinates.
     * @returns A Buffer representation of the Point instance
     */
    toCompressedBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Convert the Point instance to a hexadecimal string representation.
     * The output string is prefixed with '0x' and consists of exactly 128 hex characters,
     * representing the concatenated x and y coordinates of the point.
     *
     * @returns A hex-encoded string representing the Point instance.
     */
    toString(): `0x${string}`;
    /**
     * Generate a short string representation of the Point instance.
     * The returned string includes the first 10 and last 4 characters of the full string representation,
     * with '...' in between to indicate truncation. This is useful for displaying or logging purposes
     * when the full string representation may be too long.
     *
     * @returns A truncated string representation of the Point instance.
     */
    toShortString(): string;
    toNoirStruct(): {
        x: Fr;
        y: Fr;
        is_infinite: boolean;
    };
    toWrappedNoirStruct(): {
        inner: {
            x: Fr;
            y: Fr;
            is_infinite: boolean;
        };
    };
    /**
     * Check if two Point instances are equal by comparing their buffer values.
     * Returns true if the buffer values are the same, and false otherwise.
     *
     * @param rhs - The Point instance to compare with the current instance.
     * @returns A boolean indicating whether the two Point instances are equal.
     */
    equals(rhs: Point): boolean;
    isZero(): boolean;
    hash(): Promise<Fr>;
    /**
     * Check if this is point at infinity.
     * Check this is consistent with how bb is encoding the point at infinity
     */
    get inf(): boolean;
    isOnGrumpkin(): boolean;
}
export declare class NotOnCurveError extends Error {
    constructor(x: Fr);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9pbnQuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jdXJ2ZXMvZ3J1bXBraW4vcG9pbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBSUEsT0FBTyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQXFCLE1BQU0sMEJBQTBCLENBQUM7QUFFeEYsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRXZDOzs7OztHQUtHO0FBQ0gscUJBQWEsS0FBSztJQVNkOztPQUVHO2FBQ2EsQ0FBQyxFQUFFLEVBQUU7SUFDckI7O09BRUc7YUFDYSxDQUFDLEVBQUUsRUFBRTtJQUNyQjs7T0FFRzthQUNhLFVBQVUsRUFBRSxPQUFPO0lBbkJyQyxNQUFNLENBQUMsSUFBSSxRQUFzQztJQUNqRCxNQUFNLENBQUMsYUFBYSxTQUF3QjtJQUM1QyxNQUFNLENBQUMsd0JBQXdCLFNBQW9CO0lBRW5ELHlEQUF5RDtJQUN6RCxTQUFnQixJQUFJLFdBQVc7SUFFL0I7SUFDRTs7T0FFRztJQUNhLENBQUMsRUFBRSxFQUFFO0lBQ3JCOztPQUVHO0lBQ2EsQ0FBQyxFQUFFLEVBQUU7SUFDckI7O09BRUc7SUFDYSxVQUFVLEVBQUUsT0FBTyxFQUdwQztJQUVELE1BQU0sa0JBRUw7SUFFRCxNQUFNLEtBQUssTUFBTSw4Q0FHaEI7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLEtBQUssQ0FRdEM7SUFFRDs7OztPQUlHO0lBQ0gsT0FBYSxNQUFNLG1CQVlsQjtJQUVEOzs7Ozs7T0FNRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxZQUFZLFNBRzlDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUcsWUFBWSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FRekU7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxTQUU1QjtJQUVEOzs7T0FHRztJQUNILFFBQVEsU0FFUDtJQUVELE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxHQUFHLFdBQVcsU0FHM0M7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILE9BQWEsWUFBWSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sa0JBYzdDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FPdkM7SUFFRDs7OztPQUlHO0lBQ0gsVUFBVSxJQUFJLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUUxQjtJQUVEOzs7T0FHRztJQUNILFNBQVM7Ozs7TUFNUjtJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILFFBQVEsNEJBU1A7SUFFRDs7O09BR0c7SUFDSCxrQkFBa0IsNEJBV2pCO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsUUFBUSxrQkFFUDtJQUVEOzs7Ozs7O09BT0c7SUFDSCxhQUFhLFdBR1o7SUFFRCxZQUFZOzs7O01BSVg7SUFHRCxtQkFBbUI7Ozs7OztNQUVsQjtJQUVEOzs7Ozs7T0FNRztJQUNILE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxXQUVoQjtJQUVELE1BQU0sWUFFTDtJQUVELElBQUksZ0JBRUg7SUFFRDs7O09BR0c7SUFDSCxJQUFXLEdBQUcsWUFFYjtJQUVELFlBQVksWUFXWDtDQUNGO0FBRUQscUJBQWEsZUFBZ0IsU0FBUSxLQUFLO0lBQ3hDLFlBQVksQ0FBQyxFQUFFLEVBQUUsRUFHaEI7Q0FDRiJ9