import { inspect } from 'util';
import { BufferReader } from '../../serialize/buffer_reader.js';
/**
 * Represents a field derived from BaseField.
 */
type DerivedField<T extends BaseField> = {
    new (value: any): T;
    /**
     * All derived fields will specify a MODULUS.
     */
    MODULUS: bigint;
};
/**
 * Base field class.
 * Uses bigint as the internal representation.
 * Buffers are generated on demand from the bigint value.
 */
declare abstract class BaseField {
    static SIZE_IN_BYTES: number;
    private readonly asBigInt;
    /**
     * Return bigint representation.
     * @deprecated Just to get things compiling. Use toBigInt().
     * */
    get value(): bigint;
    /** Returns the size in bytes. */
    get size(): number;
    protected constructor(value: number | bigint | boolean | BaseField | Buffer);
    protected abstract modulus(): bigint;
    /**
     * Converts the bigint to a Buffer.
     */
    toBuffer(): Buffer;
    toString(): `0x${string}`;
    toBigInt(): bigint;
    toBool(): boolean;
    /**
     * Converts this field to a number.
     * Throws if the underlying value is greater than MAX_SAFE_INTEGER.
     */
    toNumber(): number;
    /**
     * Converts this field to a number.
     * May cause loss of precision if the underlying value is greater than MAX_SAFE_INTEGER.
     */
    toNumberUnsafe(): number;
    toShortString(): string;
    equals(rhs: BaseField): boolean;
    lt(rhs: BaseField): boolean;
    cmp(rhs: BaseField): -1 | 0 | 1;
    static cmp(lhs: BaseField, rhs: BaseField): -1 | 0 | 1;
    isZero(): boolean;
    isEmpty(): boolean;
    toFriendlyJSON(): string;
    toField(): this;
}
/**
 * Constructs a field from a Buffer of BufferReader.
 * It maybe not read the full 32 bytes if the Buffer is shorter, but it will padded in BaseField constructor.
 */
export declare function fromBuffer<T extends BaseField>(buffer: Buffer | BufferReader, f: DerivedField<T>): T;
/** Branding to ensure fields are not interchangeable types. */
export interface Fr {
    /** Brand. */
    _branding: 'Fr';
}
/**
 * Fr field class.
 * @dev This class is used to represent elements of BN254 scalar field or elements in the base field of Grumpkin.
 * (Grumpkin's scalar field corresponds to BN254's base field and vice versa.)
 */
export declare class Fr extends BaseField {
    static ZERO: Fr;
    static ONE: Fr;
    static MODULUS: bigint;
    static MAX_FIELD_VALUE: Fr;
    constructor(value: number | bigint | boolean | Fr | Buffer);
    [inspect.custom](): string;
    protected modulus(): bigint;
    static random(): Fr;
    static zero(): Fr;
    static isZero(value: Fr): boolean;
    static fromBuffer(buffer: Buffer | BufferReader): Fr;
    static fromBufferReduce(buffer: Buffer): Fr;
    /**
     * Creates a Fr instance from a string.
     * @param buf - the string to create a Fr from.
     * @returns the Fr instance
     * @remarks if the string only consists of numbers, we assume we are parsing a bigint,
     * otherwise we require the hex string to be prepended with "0x", to ensure there is no misunderstanding
     * as to what is being parsed.
     */
    static fromString(buf: string): Fr;
    /**
     * Creates a Fr instance from a hex string.
     * @param buf - a hex encoded string.
     * @returns the Fr instance
     */
    static fromHexString(buf: string): Fr;
    /** Arithmetic */
    add(rhs: Fr): Fr;
    square(): Fr;
    negate(): Fr;
    sub(rhs: Fr): Fr;
    mul(rhs: Fr): Fr;
    div(rhs: Fr): Fr;
    ediv(rhs: Fr): Fr;
    /**
     * Computes a square root of the field element.
     * @returns A square root of the field element (null if it does not exist).
     */
    sqrt(): Promise<Fr | null>;
    toJSON(): `0x${string}`;
    /**
     * Creates an Fr instance from a plain object without Zod validation.
     * This method is optimized for performance and skips validation, making it suitable
     * for deserializing trusted data (e.g., from C++ via MessagePack).
     * Handles buffers, strings, numbers, bigints, or existing instances.
     * @param obj - Plain object, buffer, string, number, bigint, boolean, or Fr instance
     * @returns An Fr instance
     */
    static fromPlainObject(obj: any): Fr;
    static get schema(): import("zod").ZodType<Fr, any, string>;
}
/**
 * Branding to ensure fields are not interchangeable types.
 */
export interface Fq {
    /** Brand. */
    _branding: 'Fq';
}
/**
 * Fq field class.
 * @dev This class is used to represent elements of BN254 base field or elements in the scalar field of Grumpkin.
 * (Grumpkin's scalar field corresponds to BN254's base field and vice versa.)
 */
export declare class Fq extends BaseField {
    static ZERO: Fq;
    static MODULUS: bigint;
    private static HIGH_SHIFT;
    private static LOW_MASK;
    [inspect.custom](): string;
    get lo(): Fr;
    get hi(): Fr;
    constructor(value: number | bigint | boolean | Fq | Buffer);
    protected modulus(): bigint;
    static random(): Fq;
    static zero(): Fq;
    static fromBuffer(buffer: Buffer | BufferReader): Fq;
    static fromBufferReduce(buffer: Buffer): Fq;
    /**
     * Creates a Fq instance from a string.
     * @param buf - the string to create a Fq from.
     * @returns the Fq instance
     * @remarks if the string only consists of numbers, we assume we are parsing a bigint,
     * otherwise we require the hex string to be prepended with "0x", to ensure there is no misunderstanding
     * as to what is being parsed.
     */
    static fromString(buf: string): Fq;
    /**
     * Creates a Fq instance from a hex string.
     * @param buf - a hex encoded string.
     * @returns the Fq instance
     */
    static fromHexString(buf: string): Fq;
    static fromHighLow(high: Fr, low: Fr): Fq;
    add(rhs: Fq): Fq;
    /**
     * Computes a square root of the field element.
     * @returns A square root of the field element (null if it does not exist).
     */
    sqrt(): Promise<Fq | null>;
    toJSON(): `0x${string}`;
    toFields(): Fr[];
    static get schema(): import("zod").ZodType<Fq, any, string>;
}
/** Wraps a function that returns a buffer so that all results are reduced into a field of the given type. */
export declare function reduceFn<TInput, TField extends BaseField>(fn: (input: TInput) => Buffer, field: DerivedField<TField>): (input: TInput) => TField;
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmllbGQuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jdXJ2ZXMvYm4yNTQvZmllbGQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUsvQixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFLaEU7O0dBRUc7QUFDSCxLQUFLLFlBQVksQ0FBQyxDQUFDLFNBQVMsU0FBUyxJQUFJO0lBQ3ZDLEtBQUssS0FBSyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDcEI7O09BRUc7SUFDSCxPQUFPLEVBQUUsTUFBTSxDQUFDO0NBQ2pCLENBQUM7QUFFRjs7OztHQUlHO0FBQ0gsdUJBQWUsU0FBUztJQUN0QixNQUFNLENBQUMsYUFBYSxTQUFNO0lBQzFCLE9BQU8sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFTO0lBRWxDOzs7U0FHSztJQUNMLElBQUksS0FBSyxJQUFJLE1BQU0sQ0FFbEI7SUFFRCxpQ0FBaUM7SUFDakMsSUFBSSxJQUFJLElBQUksTUFBTSxDQUVqQjtJQUVELFNBQVMsYUFBYSxLQUFLLEVBQUUsTUFBTSxHQUFHLE1BQU0sR0FBRyxPQUFPLEdBQUcsU0FBUyxHQUFHLE1BQU0sRUFtQjFFO0lBRUQsU0FBUyxDQUFDLFFBQVEsQ0FBQyxPQUFPLElBQUksTUFBTSxDQUFDO0lBRXJDOztPQUVHO0lBQ0gsUUFBUSxJQUFJLE1BQU0sQ0FFakI7SUFFRCxRQUFRLElBQUksS0FBSyxNQUFNLEVBQUUsQ0FFeEI7SUFFRCxRQUFRLElBQUksTUFBTSxDQUVqQjtJQUVELE1BQU0sSUFBSSxPQUFPLENBRWhCO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUSxJQUFJLE1BQU0sQ0FLakI7SUFFRDs7O09BR0c7SUFDSCxjQUFjLElBQUksTUFBTSxDQUV2QjtJQUVELGFBQWEsSUFBSSxNQUFNLENBR3RCO0lBRUQsTUFBTSxDQUFDLEdBQUcsRUFBRSxT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