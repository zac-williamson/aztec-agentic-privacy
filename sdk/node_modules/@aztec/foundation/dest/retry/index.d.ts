import { type Logger } from '../log/index.js';
/** An error that indicates that the operation should not be retried. */
export declare class NoRetryError extends Error {
}
/**
 * Generates a backoff sequence for retrying operations with an increasing delay.
 * The backoff sequence follows this pattern: 1, 1, 1, 2, 4, 8, 16, 32, 64, ...
 * This generator can be used in combination with the `retry` function to perform
 * retries with exponential backoff and capped at 64 seconds between attempts.
 *
 * @returns A generator that yields the next backoff value in seconds as an integer.
 */
export declare function backoffGenerator(): Generator<number, void, unknown>;
/**
 * Generates a backoff sequence based on the array of retry intervals to use with the `retry` function.
 * @param retries - Intervals to retry (in seconds).
 * @returns A generator sequence.
 */
export declare function makeBackoff(retries: number[]): Generator<number, void, unknown>;
/**
 * Retry a given asynchronous function with a specific backoff strategy, until it succeeds or backoff generator ends.
 * It logs the error and retry interval in case an error is caught. The function can be named for better log output.
 *
 * @param fn - The asynchronous function to be retried.
 * @param name - The optional name of the operation, used for logging purposes.
 * @param backoff - The optional backoff generator providing the intervals in seconds between retries. Defaults to a predefined series.
 * @param log - Logger to use for logging.
 * @param failSilently - Do not log errors while retrying.
 * @returns A Promise that resolves with the successful result of the provided function, or rejects if backoff generator ends.
 * @throws If `NoRetryError` is thrown by the `fn`, it is rethrown.
 */
export declare function retry<Result>(fn: () => Promise<Result>, name?: string, backoff?: Generator<number, void, unknown>, log?: Logger, failSilently?: boolean): Promise<Result>;
/**
 * Retry an asynchronous function until it returns a truthy value or the specified timeout is exceeded.
 * The function is retried periodically with a fixed interval between attempts. The operation can be named for better error messages.
 * Will never timeout if the value is 0.
 *
 * @param fn - The asynchronous function to be retried, which should return a truthy value upon success or undefined otherwise.
 * @param name - The optional name of the operation, used for generating timeout error message.
 * @param timeout - The optional maximum time, in seconds, to keep retrying before throwing a timeout error. Defaults to 0 (never timeout).
 * @param interval - The optional interval, in seconds, between retry attempts. Defaults to 1 second.
 * @returns A Promise that resolves with the successful (truthy) result of the provided function, or rejects if timeout is exceeded.
 */
export declare function retryUntil<T>(fn: () => (T | undefined) | Promise<T | undefined>, name?: string, timeout?: number, interval?: number): Promise<NonNullable<Awaited<T>>>;
/**
 * Convenience wrapper around retryUntil with fast polling for tests.
 * Uses 10s timeout and 100ms polling interval by default.
 *
 * @param fn - The function to retry until it returns a truthy value.
 * @param name - Description of what we're waiting for (for error messages).
 * @param timeout - Optional timeout in seconds. Defaults to 10s.
 * @param interval - Optional interval in seconds. Defaults to 0.1s (100ms).
 */
export declare function retryFastUntil<T>(fn: () => (T | undefined) | Promise<T | undefined>, name?: string, timeout?: number, interval?: number): Promise<NonNullable<Awaited<T>>>;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZXRyeS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsS0FBSyxNQUFNLEVBQWdCLE1BQU0saUJBQWlCLENBQUM7QUFJNUQsd0VBQXdFO0FBQ3hFLHFCQUFhLFlBQWEsU0FBUSxLQUFLO0NBQUc7QUFFMUM7Ozs7Ozs7R0FPRztBQUNILHdCQUFpQixnQkFBZ0IscUNBTWhDO0FBRUQ7Ozs7R0FJRztBQUNILHdCQUFpQixXQUFXLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxvQ0FJN0M7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILHdCQUFzQixLQUFLLENBQUMsTUFBTSxFQUNoQyxFQUFFLEVBQUUsTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQ3pCLElBQUksU0FBYyxFQUNsQixPQUFPLG1DQUFxQixFQUM1QixHQUFHLEdBQUUsTUFBeUMsRUFDOUMsWUFBWSxVQUFRLG1CQW9CckI7QUFFRDs7Ozs7Ozs7OztHQVVHO0FBQ0gsd0JBQXNCLFVBQVUsQ0FBQyxDQUFDLEVBQ2hDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEVBQ2xELElBQUksU0FBSyxFQUNULE9BQU8sU0FBSSxFQUNYLFFBQVEsU0FBSSxvQ0FlYjtBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsd0JBQWdCLGNBQWMsQ0FBQyxDQUFDLEVBQzlCLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEVBQ2xELElBQUksU0FBSyxFQUNULE9BQU8sU0FBSyxFQUNaLFFBQVEsU0FBTSxvQ0FHZiJ9