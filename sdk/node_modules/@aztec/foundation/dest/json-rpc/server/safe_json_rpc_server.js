import cors from '@koa/cors';
import http from 'http';
import { default as Koa } from 'koa';
import bodyParser from 'koa-bodyparser';
import compress from 'koa-compress';
import Router from 'koa-router';
import { format, inspect } from 'util';
import { ZodError } from 'zod';
import { createLogger } from '../../log/index.js';
import { promiseWithResolvers } from '../../promise/utils.js';
import { parseWithOptionals, schemaHasMethod } from '../../schemas/index.js';
import { jsonStringify } from '../convert.js';
import { assert } from '../js_utils.js';
const defaultServerConfig = {
    http200OnError: false,
    maxBatchSize: 100,
    maxBodySizeBytes: '1mb'
};
export class SafeJsonRpcServer {
    proxy;
    healthCheck;
    extraMiddlewares;
    log;
    /**
   * The HTTP server accepting remote requests.
   * This member field is initialized when the server is started.
   */ httpServer;
    config;
    constructor(/** The proxy object to delegate requests to */ proxy, config = {}, /** Health check function */ healthCheck = ()=>true, /** Additional middlewares */ extraMiddlewares = [], /** Logger */ log = createLogger('json-rpc:server')){
        this.proxy = proxy;
        this.healthCheck = healthCheck;
        this.extraMiddlewares = extraMiddlewares;
        this.log = log;
        this.config = {
            ...defaultServerConfig,
            ...config
        };
        // handle empty string
        if (!this.config.maxBodySizeBytes) {
            this.config.maxBodySizeBytes = defaultServerConfig.maxBodySizeBytes;
        }
    }
    isHealthy() {
        return this.healthCheck();
    }
    /**
   * Get an express app object.
   * @param prefix - Our server prefix.
   * @returns The app object.
   */ getApp(prefix = '') {
        const router = this.getRouter(prefix);
        const exceptionHandler = async (ctx, next)=>{
            try {
                await next();
            } catch (err) {
                const method = ctx.request.body?.method ?? 'unknown';
                this.log.warn(`Uncaught error in JSON RPC server call ${method}: ${inspect(err)}`);
                if (err && 'name' in err && err.name === 'BadRequestError') {
                    ctx.status = 400;
                    ctx.body = {
                        jsonrpc: '2.0',
                        id: null,
                        error: {
                            code: -32000,
                            message: `Bad request: ${err.message}`
                        }
                    };
                } else if (err && err instanceof SyntaxError) {
                    ctx.status = 400;
                    ctx.body = {
                        jsonrpc: '2.0',
                        id: null,
                        error: {
                            code: -32700,
                            message: `Parse error: ${err.message}`
                        }
                    };
                } else {
                    ctx.status = 500;
                    ctx.body = {
                        jsonrpc: '2.0',
                        id: null,
                        error: {
                            code: -32600,
                            message: err.message ?? 'Internal error'
                        }
                    };
                }
            }
        };
        const jsonResponse = async (ctx, next)=>{
            try {
                await next();
                if (ctx.body && typeof ctx.body === 'object') {
                    ctx.body = jsonStringify(ctx.body);
                }
            } catch (err) {
                ctx.status = 500;
                ctx.body = {
                    jsonrpc: '2.0',
                    error: {
                        code: -32700,
                        message: `Unable to serialize response: ${err.message}`
                    }
                };
            }
        };
        const app = new Koa();
        app.on('error', (error)=>{
            this.log.error(`Error on API handler: ${error}`);
        });
        app.use(compress({
            br: false
        }));
        app.use(jsonResponse);
        for (const middleware of this.extraMiddlewares){
            app.use(middleware);
        }
        app.use(exceptionHandler);
        app.use(bodyParser({
            jsonLimit: this.config.maxBodySizeBytes,
            enableTypes: [
                'json'
            ]
        }));
        app.use(cors());
        app.use(router.routes());
        app.use(router.allowedMethods());
        return app;
    }
    /**
   * Get a router object wrapping our RPC class.
   * @param prefix - The server prefix.
   * @returns The router object.
   */ getRouter(prefix) {
        const router = new Router({
            prefix
        });
        // "JSON RPC mode" where a single endpoint is used and the method is given in the request body
        router.post('/', async (ctx)=>{
            if (Array.isArray(ctx.request.body)) {
                if (ctx.request.body.length > this.config.maxBatchSize) {
                    ctx.status = this.config.http200OnError ? 200 : 400;
                    ctx.body = {
                        jsonrpc: '2.0',
                        error: {
                            code: -32600,
                            message: `Batch request exceeds maximum allowed size of ${this.config.maxBatchSize}`
                        },
                        id: null
                    };
                    return;
                }
                const resp = await this.processBatch(ctx.request.body);
                if (Array.isArray(resp)) {
                    ctx.status = 200;
                    ctx.body = resp;
                } else {
                    ctx.status = this.config.http200OnError ? 200 : 400;
                    ctx.body = resp;
                }
            } else {
                const resp = await this.processRequest(ctx.request.body);
                if ('error' in resp) {
                    ctx.status = this.config.http200OnError ? 200 : 400;
                }
                ctx.body = resp;
            }
        });
        return router;
    }
    async processBatch(requests) {
        if (requests.length === 0) {
            return {
                jsonrpc: '2.0',
                error: {
                    code: -32600,
                    message: 'Invalid Request'
                },
                id: null
            };
        }
        const results = await Promise.allSettled(requests.map((req)=>this.processRequest(req)));
        return results.map((res)=>{
            if (res.status === 'fulfilled') {
                return res.value;
            }
            this.log.warn(`Uncaught error executing request in batch: ${res.reason}.`);
            return {
                jsonrpc: '2.0',
                error: {
                    code: -32600,
                    message: 'Invalid Request'
                },
                id: null
            };
        });
    }
    async processRequest(request) {
        if (!request || typeof request !== 'object') {
            return {
                jsonrpc: '2.0',
                error: {
                    code: -32600,
                    message: 'Invalid Request'
                },
                id: null
            };
        }
        const { params = [], jsonrpc = '2.0', id, method } = request;
        if (typeof method !== 'string' || !method) {
            return {
                jsonrpc: '2.0',
                id,
                error: {
                    code: -32600,
                    message: `Invalid request`
                }
            };
        }
        // Fail if not a registered function in the proxy
        if (typeof method !== 'string' || method === 'constructor' || !this.proxy.hasMethod(method)) {
            return {
                jsonrpc,
                id,
                error: {
                    code: -32601,
                    message: `Method not found: ${method}`
                }
            };
        } else {
            try {
                const result = await this.proxy.call(method, params);
                return {
                    jsonrpc,
                    id,
                    result
                };
            } catch (err) {
                if (err && err instanceof ZodError) {
                    const message = err.issues.map((e)=>`${e.message} (${e.path.join('.')})`).join('. ') || 'Validation error';
                    return {
                        jsonrpc: '2.0',
                        id,
                        error: {
                            code: -32701,
                            message
                        }
                    };
                } else if (err) {
                    return {
                        jsonrpc,
                        id,
                        error: {
                            code: -32702,
                            data: err.data,
                            message: err.message
                        }
                    };
                } else {
                    return {
                        jsonrpc,
                        id,
                        error: {
                            code: -32702,
                            message: 'Error executing request'
                        }
                    };
                }
            }
        }
    }
    /**
   * Start this server with koa.
   * @param port - Port number.
   * @param prefix - Prefix string.
   */ start(port, prefix = '') {
        if (this.httpServer) {
            throw new Error('Server is already listening');
        }
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        this.httpServer = http.createServer(this.getApp(prefix).callback());
        this.httpServer.listen(port);
    }
    /**
   * Stops the HTTP server
   */ stop() {
        if (!this.httpServer) {
            return Promise.resolve();
        }
        const { promise, resolve, reject } = promiseWithResolvers();
        this.httpServer.close((err)=>{
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
        return promise;
    }
    /**
   * Explicitly calls an RPC method.
   * @param methodName - The RPC method.
   * @param jsonParams - The RPC parameters.
   * @returns The remote result.
   */ async call(methodName, jsonParams = []) {
        return await this.proxy.call(methodName, jsonParams);
    }
}
/**
 * Forwards calls to a handler. Relies on a schema definition to validate and convert inputs
 * before forwarding calls, and then converts outputs into JSON using default conversions.
 */ export class SafeJsonProxy {
    handler;
    log;
    schema;
    constructor(handler, schema){
        this.handler = handler;
        this.log = createLogger('json-rpc:proxy');
        this.schema = schema;
    }
    /**
   * Call an RPC method.
   * @param methodName - The RPC method.
   * @param jsonParams - The RPC parameters.
   * @returns The remote result.
   */ async call(methodName, jsonParams = []) {
        this.log.debug(format(`request`, methodName, jsonParams));
        assert(Array.isArray(jsonParams), `Params to ${methodName} is not an array: ${jsonParams}`);
        assert(schemaHasMethod(this.schema, methodName), `Method ${methodName} not found in schema`);
        const method = this.handler[methodName];
        assert(typeof method === 'function', `Method ${methodName} is not a function`);
        const args = await parseWithOptionals(jsonParams, this.schema[methodName].parameters());
        const ret = await method.apply(this.handler, args);
        this.log.debug(format('response', methodName, ret));
        return ret;
    }
    hasMethod(methodName) {
        return schemaHasMethod(this.schema, methodName) && typeof this.handler[methodName] === 'function';
    }
}
class NamespacedSafeJsonProxy {
    proxies = {};
    constructor(handlers){
        for (const [namespace, [handler, schema]] of Object.entries(handlers)){
            this.proxies[namespace] = new SafeJsonProxy(handler, schema);
        }
    }
    call(namespacedMethodName, jsonParams = []) {
        const [namespace, methodName] = namespacedMethodName.split('_', 2);
        assert(namespace && methodName, `Invalid namespaced method name: ${namespacedMethodName}`);
        const handler = this.proxies[namespace];
        assert(handler, `Namespace not found: ${namespace}`);
        return handler.call(methodName, jsonParams);
    }
    hasMethod(namespacedMethodName) {
        const [namespace, methodName] = namespacedMethodName.split('_', 2);
        const handler = this.proxies[namespace];
        return handler?.hasMethod(methodName);
    }
}
export function makeHandler(handler, schema) {
    return [
        handler,
        schema
    ];
}
function makeAggregateHealthcheck(namedHandlers, log) {
    return async ()=>{
        try {
            const results = await Promise.all(Object.entries(namedHandlers).map(async ([name, [, , healthCheck]])=>[
                    name,
                    healthCheck ? await healthCheck() : true
                ]));
            const failed = results.filter(([_, result])=>!result);
            if (failed.length > 0) {
                log?.warn(`Health check failed for ${failed.map(([name])=>name).join(', ')}`);
                return false;
            }
            return true;
        } catch (err) {
            log?.error(`Error during health check`, err);
            return false;
        }
    };
}
/**
 * Creates a single SafeJsonRpcServer from multiple handlers.
 * @param servers - List of handlers to be combined.
 * @returns A single JsonRpcServer with namespaced methods.
 */ export function createNamespacedSafeJsonRpcServer(handlers, options = {}) {
    const { middlewares, log } = options;
    const proxy = new NamespacedSafeJsonProxy(handlers);
    const healthCheck = makeAggregateHealthcheck(handlers, log);
    return new SafeJsonRpcServer(proxy, options, healthCheck, middlewares, log);
}
export function createSafeJsonRpcServer(handler, schema, options = {}) {
    const { log, healthCheck, middlewares: extraMiddlewares } = options;
    const proxy = new SafeJsonProxy(handler, schema);
    return new SafeJsonRpcServer(proxy, options, healthCheck, extraMiddlewares, log);
}
/**
 * Creates a router for handling a plain status request that will return 200 status when running.
 * @param getCurrentStatus - List of health check functions to run.
 * @param apiPrefix - The prefix to use for all api requests
 * @returns - The router for handling status requests.
 */ export function createStatusRouter(getCurrentStatus, apiPrefix = '') {
    const router = new Router({
        prefix: `${apiPrefix}`
    });
    router.get('/status', async (ctx)=>{
        let ok;
        try {
            ok = await getCurrentStatus() === true;
        } catch  {
            ok = false;
        }
        ctx.status = ok ? 200 : 500;
    });
    return router;
}
/**
 * Wraps a JsonRpcServer in a nodejs http server and starts it.
 * Installs a status router that calls to the isHealthy method to the server.
 * Returns once starts listening unless noWait is set.
 * @returns A running http server.
 */ export async function startHttpRpcServer(rpcServer, options = {}) {
    const app = rpcServer.getApp(options.apiPrefix);
    const statusRouter = createStatusRouter(rpcServer.isHealthy.bind(rpcServer), options.apiPrefix);
    app.use(statusRouter.routes()).use(statusRouter.allowedMethods());
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    const httpServer = http.createServer(app.callback());
    if (options.timeoutMs) {
        httpServer.timeout = options.timeoutMs;
    }
    const { promise, resolve } = promiseWithResolvers();
    const listenPort = options.port ? typeof options.port === 'string' ? parseInt(options.port) : options.port : 0;
    httpServer.listen({
        host: options.host,
        port: listenPort,
        reuseAddress: true
    }, ()=>resolve());
    // Wait until listen callback is called
    if (!options.noWait) {
        await promise;
    }
    const port = httpServer.address().port;
    return Object.assign(httpServer, {
        port
    });
}
