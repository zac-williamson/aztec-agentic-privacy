import { format } from 'util';
import { createLogger } from '../../log/pino-logger.js';
import { promiseWithResolvers } from '../../promise/utils.js';
import { schemaHasMethod } from '../../schemas/api.js';
import { jsonStringify } from '../convert.js';
import { defaultFetch } from './fetch.js';
// batch window of 0 would capture all requests in the current sync iteration of the event loop
// and send them all at once in a single batch
// minimal latency
const DEFAULT_BATCH_WINDOW_MS = 0;
// the maximum size of a batched request
const DEFAULT_MAX_BATCH_SIZE = 100;
// 10 mb
const DEFAULT_MAX_REQUESTY_BODY_SIZE = 10 * 1024 * 1024;
// expose helpful information on the RPC clients such that we can recognize them later
const SEND_BATCH = Symbol('JsonRpcClient.sendBatch');
const CLIENT_ID = Symbol('JsonRpcClient.clientId');
let nextClientId = 1;
// keep a reference to clients so that we can force send a batch
const clients = new Map();
/**
 * Creates a Proxy object that delegates over RPC and validates outputs against a given schema.
 * The server is expected to be a JsonRpcServer.
 * @param host - The host URL.
 * @param schema - The api schema to validate returned data against.
 * @param fetch - The fetch implementation to use.
 */ export function createSafeJsonRpcClient(host, schema, config = {}) {
    const fetch = config.fetch ?? defaultFetch;
    const log = config.log ?? createLogger('json-rpc:client');
    const { namespaceMethods = false, batchWindowMS = DEFAULT_BATCH_WINDOW_MS, maxBatchSize = DEFAULT_MAX_BATCH_SIZE, maxRequestBodySize = DEFAULT_MAX_REQUESTY_BODY_SIZE } = config;
    let id = 0;
    let sendBatchTimeoutHandle;
    const queue = [];
    const sendBatch = async ()=>{
        if (sendBatchTimeoutHandle !== undefined) {
            clearTimeout(sendBatchTimeoutHandle);
            sendBatchTimeoutHandle = undefined;
        }
        const rpcCalls = [];
        let bodySize = 0;
        while(queue.length > 0 && rpcCalls.length < maxBatchSize && bodySize < maxRequestBodySize){
            const item = queue[0];
            if (!item) {
                break;
            }
            const tmpBodySize = bodySize + item.encodedLength;
            if (tmpBodySize >= maxRequestBodySize) {
                break;
            }
            bodySize = tmpBodySize;
            queue.shift();
            rpcCalls.push(item);
        }
        // no-op
        if (rpcCalls.length === 0) {
            return;
        }
        // schedule another call if there are more items to send
        if (queue.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            sendBatchTimeoutHandle = setTimeout(sendBatch, batchWindowMS);
        }
        log.debug(`Executing JSON-RPC batch of size: ${rpcCalls.length} body size: ${bodySize} bytes`, {
            methods: rpcCalls.map(({ request })=>request.method)
        });
        try {
            const { response, headers } = await fetch(host, rpcCalls.map(({ request })=>request), config.extraHeaders);
            if (config.onResponse) {
                await config.onResponse({
                    response,
                    headers
                });
            }
            if (!Array.isArray(response) || response.length !== rpcCalls.length) {
                log.warn(`Invalid response received from JSON-RPC server. Expected array of responses of length ${rpcCalls.length}`, {
                    response
                });
                for(let i = 0; i < rpcCalls.length; i++){
                    const { request, deferred } = rpcCalls[i];
                    deferred.resolve({
                        id: request.id,
                        jsonrpc: '2.0',
                        error: {
                            code: -32000,
                            data: response,
                            message: response.message ?? 'Failed request'
                        }
                    });
                }
            } else {
                for(let i = 0; i < response.length; i++){
                    const resp = response[i];
                    const { request, deferred } = rpcCalls[i];
                    if (resp.id !== request.id) {
                        log.warn(`Invalid response received at index ${i} from JSON-RPC server: id mismatch`, {
                            requestMethod: request.method,
                            requestId: request.id,
                            responseId: resp.id
                        });
                        deferred.resolve({
                            id: request.id,
                            jsonrpc: '2.0',
                            error: {
                                code: -32001,
                                data: resp,
                                message: 'RPC id mismatch'
                            }
                        });
                    } else {
                        deferred.resolve(resp);
                    }
                }
            }
        } catch (err) {
            // Re-throw ComponentsVersionsError immediately without converting to JSON-RPC error
            // This ensures version mismatch errors are surfaced to the user instead of being hidden
            if (err && typeof err === 'object' && 'name' in err && err.name === 'ComponentsVersionsError') {
                // Reject all pending requests with the version error
                for(let i = 0; i < rpcCalls.length; i++){
                    rpcCalls[i].deferred.reject(err);
                }
                return; // Return early, the promises are already rejected
            }
            log.warn(`Failed to fetch from the remote server`, err);
            for(let i = 0; i < rpcCalls.length; i++){
                const { request, deferred } = rpcCalls[i];
                deferred.resolve({
                    id: request.id,
                    jsonrpc: '2.0',
                    error: {
                        code: -32000,
                        data: err,
                        message: err.message ?? 'Failed request'
                    }
                });
            }
        }
    };
    const request = async (methodName, params)=>{
        if (!schemaHasMethod(schema, methodName)) {
            throw new Error(`Unspecified method ${methodName} in client schema`);
        }
        const method = namespaceMethods ? `${namespaceMethods}_${methodName}` : methodName;
        const body = {
            jsonrpc: '2.0',
            id: id++,
            method,
            params
        };
        const deferred = promiseWithResolvers();
        const encodedLength = jsonStringify(body).length;
        if (encodedLength >= maxRequestBodySize) {
            throw new Error(`Request body too large: ${encodedLength}`);
        }
        queue.push({
            request: body,
            deferred,
            encodedLength
        });
        if (sendBatchTimeoutHandle === undefined) {
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            sendBatchTimeoutHandle = setTimeout(sendBatch, batchWindowMS);
        }
        log.debug(format(`request`, method, params));
        const response = await deferred.promise;
        log.debug(format(`result`, method, response));
        if ('error' in response) {
            throw new Error(response.error.message, {
                cause: response.error
            });
        }
        // TODO(palla/schemas): Find a better way to handle null responses (JSON.stringify(null) is string "null").
        if ([
            null,
            undefined,
            'null',
            'undefined'
        ].includes(response.result)) {
            return;
        }
        return schema[methodName].returnType().parseAsync(response.result);
    };
    const clientId = nextClientId++;
    const proxy = {
        [CLIENT_ID]: clientId,
        [SEND_BATCH]: sendBatch
    };
    for (const method of Object.keys(schema)){
        // attach the clientId to the promise so that if we want to trigger a batch immediately, we can do that
        proxy[method] = (...params)=>Object.assign(request(method, params), {
                [CLIENT_ID]: clientId
            });
    }
    clients.set(clientId, new WeakRef(proxy));
    return proxy;
}
/**
 * Triggers a batch to be sent immediately
 */ export async function batch(values) {
    const clientIdsSeen = new Set();
    await Promise.allSettled(values.map((val)=>{
        if (typeof val === 'object' && val && Object.hasOwn(val, CLIENT_ID)) {
            const clientId = val[CLIENT_ID];
            if (typeof clientId === 'number') {
                if (clientIdsSeen.has(clientId)) {
                    return;
                }
                clientIdsSeen.add(clientId);
                const client = clients.get(clientId)?.deref();
                if (client) {
                    return client[SEND_BATCH]();
                }
            }
        }
    }));
    return Promise.all(values);
}
