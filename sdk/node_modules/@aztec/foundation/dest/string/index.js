/** Parameterized hex string type for specific byte lengths */ export function hasHexPrefix(str) {
    return str.startsWith('0x');
}
export function withoutHexPrefix(str) {
    return hasHexPrefix(str) ? str.slice(2) : str;
}
export function withHexPrefix(str) {
    return hasHexPrefix(str) ? str : `0x${str}`;
}
export function isHex(str) {
    return /^(0x)?[0-9a-fA-F]*$/.test(str);
}
export function hexToBuffer(str) {
    return Buffer.from(withoutHexPrefix(str), 'hex');
}
export function bufferToHex(buffer) {
    return `0x${buffer.toString('hex')}`;
}
export function pluralize(str, count, plural) {
    return count === 1 || count === 1n ? str : plural ?? `${str}s`;
}
export function count(count, str, plural) {
    return `${count} ${pluralize(str, count, plural)}`;
}
export function truncate(str, length = 64) {
    return str.length > length ? str.slice(0, length) + '...' : str;
}
export function isoDate(date) {
    return (date ?? new Date()).toISOString().replace(/[-:T]/g, '').replace(/\..+$/, '');
}
export function urlJoin(...args) {
    const processed = [];
    for (const arg of args){
        if (arg.length === 0) {
            continue;
        }
        let start = 0;
        let end = arg.length - 1;
        while(start <= end && arg[start] === '/'){
            start++;
        }
        while(end >= start && arg[end] === '/'){
            end--;
        }
        if (start < end) {
            processed.push(arg.slice(start, end + 1));
        }
    }
    return processed.join('/');
}
