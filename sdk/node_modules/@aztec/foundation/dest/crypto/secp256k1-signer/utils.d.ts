import { Buffer32 } from '../../buffer/buffer32.js';
import { EthAddress } from '../../eth-address/index.js';
import { Signature } from '../../eth-signature/eth_signature.js';
/** Signature recovery options */
type RecoveryOpts = {
    /**
     * Whether to allow s-values in the high half of the curve (s >= CURVE.n/2).
     * These are discouraged by EIP2 to prevent signature malleability, and outright
     * rejected in OpenZeppelin's ECDSA recover, which we use in our Rollup contract.
     */
    allowMalleable?: boolean;
    /**
     * Whether to allow an y-parity 0-1 bit instead of the standard v value 27-28.
     */
    allowYParityAsV?: boolean;
};
export declare class Secp256k1Error extends Error {
    constructor(message: string, opts?: {
        cause: unknown;
    });
}
export declare function makeEthSignDigest(message: Buffer32): Buffer32;
/**
 * Converts a private key to a public key.
 * @param privateKey - The private key to convert.
 * @returns The public key.
 */
export declare function publicKeyFromPrivateKey(privateKey: Buffer): Buffer;
/**
 * Converts a private key to an address.
 * @param privateKey - The private key to convert.
 * @returns The address.
 */
export declare function addressFromPrivateKey(privateKey: Buffer): EthAddress;
/**
 * Recovers an address from a hash and a signature.
 * @param hash - The hash to recover the address from.
 * @param signature - The signature to recover the address from.
 * @param opts - Recovery options.
 * @returns The address.
 * @throws Error if signature recovery fails or if signature is malleable and allowMalleable is false.
 */
export declare function recoverAddress(hash: Buffer32, signature: Signature, opts?: RecoveryOpts): EthAddress;
/**
 * Safely attempts to recover an address from a hash and a signature.
 * @param hash - The hash to recover the address from.
 * @param signature - The signature to recover the address from.
 * @param opts - Recovery options.
 * @returns The address if recovery succeeds, undefined otherwise.
 */
export declare function tryRecoverAddress(hash: Buffer32, signature: Signature, opts?: RecoveryOpts): EthAddress | undefined;
/**
 * @attribution - viem
 * Converts a yParityOrV value to a recovery bit.
 * @param yParityOrV - The yParityOrV value to convert.
 * @returns The recovery bit.
 */
export declare function toRecoveryBit(yParityOrV: number): 0 | 1;
/**
 * Signs a message using ecdsa over the secp256k1 curve.
 * @param message - The message to sign.
 * @param privateKey - The private key to sign the message with.
 * @returns The signature.
 */
export declare function signMessage(message: Buffer32, privateKey: Buffer): Signature;
/**
 * Flips an ECDSA signature.
 * If the signature has a low s-value (s < CURVE.n/2), it flips it to high s-value (CURVE.n - s) and vice versa.
 * Also flips the v value accordingly (27 <-> 28, or 0 <-> 1).
 * This is useful for testing signature malleability handling.
 * @param signature - The signature to flip.
 * @returns A new signature with flipped s-value and v-value.
 */
export declare function flipSignature(signature: Signature): Signature;
/**
 * Normalizes an ECDSA signature.
 * If the signature has a high s-value (s >= CURVE.n/2), it flips it to low s-value (CURVE.n - s), and flips v accordingly.
 * If the signature uses a recovery bit of 0/1, it is converted to a v-value 27/28 for ecrecover.
 * @remarks This does not handle post EIP155 tx signatures which embed the chain id in v. Use it only for feeding into ECRECOVER precompiles.
 * @param signature - The signature to normalize.
 */
export declare function normalizeSignature(signature: Signature): Signature;
/**
 * Recovers a public key from a hash and a signature.
 * @param hash - The hash to recover the public key from.
 * @param signature - The signature to recover the public key from.
 * @returns The public key.
 */
export declare function recoverPublicKey(hash: Buffer32, signature: Signature, opts?: RecoveryOpts): Buffer;
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jcnlwdG8vc2VjcDI1NmsxLXNpZ25lci91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3hELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUtqRSxpQ0FBaUM7QUFDakMsS0FBSyxZQUFZLEdBQUc7SUFDbEI7Ozs7T0FJRztJQUNILGNBQWMsQ0FBQyxFQUFFLE9BQU8sQ0FBQztJQUN6Qjs7T0FFRztJQUNILGVBQWUsQ0FBQyxFQUFFLE9BQU8sQ0FBQztDQUMzQixDQUFDO0FBRUYscUJBQWEsY0FBZSxTQUFRLEtBQUs7SUFDdkMsWUFBWSxPQUFPLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxFQUFFO1FBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQTtLQUFFLEVBR3JEO0NBQ0Y7QUFHRCx3QkFBZ0IsaUJBQWlCLENBQUMsT0FBTyxFQUFFLFFBQVEsR0FBRyxRQUFRLENBRzdEO0FBWUQ7Ozs7R0FJRztBQUNILHdCQUFnQix1QkFBdUIsQ0FBQyxVQUFVLEVBQUUsTUFBTSxHQUFHLE1BQU0sQ0FFbEU7QUFFRDs7OztHQUlHO0FBQ0gsd0JBQWdCLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxNQUFNLEdBQUcsVUFBVSxDQUdwRTtBQUVEOzs7Ozs7O0dBT0c7QUFDSCx3QkFBZ0IsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsRUFBRSxZQUFZLEdBQUcsVUFBVSxDQVVwRztBQUVEOzs7Ozs7R0FNRztBQUNILHdCQUFnQixpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLEVBQUUsWUFBWSxHQUFHLFVBQVUsR0FBRyxTQUFTLENBT25IO0FBRUQ7Ozs7O0dBS0c7QUFDSCx3QkFBZ0IsYUFBYSxDQUFDLFVBQVUsRUFBRSxNQUFNLFNBVy9DO0FBRUQ7Ozs7O0dBS0c7QUFDSCx3QkFBZ0IsV0FBVyxDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sYUFHaEU7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsd0JBQWdCLGFBQWEsQ0FBQyxTQUFTLEVBQUUsU0FBUyxHQUFHLFNBQVMsQ0FNN0Q7QUFFRDs7Ozs7O0dBTUc7QUFDSCx3QkFBZ0Isa0JBQWtCLENBQUMsU0FBUyxFQUFFLFNBQVMsR0FBRyxTQUFTLENBVWxFO0FBNkJEOzs7OztHQUtHO0FBQ0gsd0JBQWdCLGdCQUFnQixDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxJQUFJLEdBQUUsWUFBaUIsR0FBRyxNQUFNLENBWXRHIn0=