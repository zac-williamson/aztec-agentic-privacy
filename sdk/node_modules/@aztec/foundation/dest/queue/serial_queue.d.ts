/**
 * A more specialized fifo queue that enqueues functions to execute. Enqueued functions are executed in serial.
 */
export declare class SerialQueue {
    private readonly queue;
    private runningPromises;
    private started;
    /**
     * Initializes the execution of enqueued functions in the serial queue.
     * Functions are executed in the order they were added to the queue, with each function
     * waiting for the completion of the previous one before starting its execution.
     * This method should be called once to start processing the queue.
     */
    start(numWorkers?: number): void;
    /**
     * Returns the current number of enqueued functions in the serial queue.
     * This provides a way to check the size of the queue and monitor its progress.
     *
     * @returns The length of the serial queue as a number.
     */
    length(): number;
    /**
     * Cancels the processing of the remaining functions in the serial queue and resolves the running promise.
     * Any enqueued functions that have not yet been executed will be discarded. The queue can still accept new
     * functions after cancellation, but the previously enqueued functions will not be re-processed.
     *
     * @returns The running promise which resolves when the current executing function (if any) completes.
     */
    cancel(): Promise<void>;
    /**
     * Signals the SerialQueue that it should finish processing its current task and stop accepting new tasks.
     * The returned Promise resolves when all enqueued tasks have completed execution.
     *
     * @returns A Promise that resolves when the queue is completely emptied and no new tasks are allowed.
     */
    end(): Promise<void>;
    /**
     * Enqueues fn for execution on the serial queue.
     * Returns the result of the function after execution.
     * @param fn - The function to enqueue.
     * @returns A resolution promise. Rejects if the function does, or if the function could not be enqueued.
     */
    put<T>(fn: () => T | Promise<T>): Promise<Awaited<T>>;
    /**
     * Awaiting this ensures the queue is empty before resuming.
     */
    syncPoint(): Promise<void>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsX3F1ZXVlLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcXVldWUvc2VyaWFsX3F1ZXVlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBOztHQUVHO0FBQ0gscUJBQWEsV0FBVztJQUN0QixPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBOEM7SUFDcEUsT0FBTyxDQUFDLGVBQWUsQ0FBdUI7SUFDOUMsT0FBTyxDQUFDLE9BQU8sQ0FBUztJQUV4Qjs7Ozs7T0FLRztJQUNJLEtBQUssQ0FBQyxVQUFVLFNBQUksUUFNMUI7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU0sV0FFWjtJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU0sa0JBR1o7SUFFRDs7Ozs7T0FLRztJQUNJLEdBQUcsa0JBR1Q7SUFFRDs7Ozs7T0FLRztJQUNJLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBYzNEO0lBRUQ7O09BRUc7SUFDVSxTQUFTLGtCQUVyQjtDQUNGIn0=