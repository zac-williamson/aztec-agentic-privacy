/**
 * Leverages the unbounded SerialQueue and Semaphore to create a SerialQueue that will block when putting an item
 * if the queue size = maxQueueSize.
 */
export declare class BoundedSerialQueue {
    private log;
    private readonly queue;
    private semaphore;
    constructor(maxQueueSize: number, log?: import("../log/pino-logger.js").Logger);
    /**
     * Initializes the underlying SerialQueue instance, allowing items to be processed from the queue.
     * The start method should be called before using the BoundedSerialQueue to ensure proper functionality.
     */
    start(): void;
    /**
     * Returns the current number of items in the queue.
     * This is useful for monitoring the size of BoundedSerialQueue and understanding its utilization.
     *
     * @returns The length of the queue as an integer value.
     */
    length(): number;
    /**
     * Cancels the current operation in the SerialQueue, if any, and clears the queue.
     * Any pending tasks in the queue will not be executed, and the queue will be emptied.
     * This method is useful for cleaning up resources and stopping ongoing processes when they are no longer needed.
     * @returns A promise, resolved once cancelled.
     */
    cancel(): Promise<void>;
    /**
     * Ends the queue processing gracefully, preventing new items from being added.
     * The currently executing item, if any, will complete and remaining queued items
     * will be processed in order. Once all items have been processed, the queue becomes
     * permanently unusable.
     *
     * @returns A promise that resolves when all items in the queue have been processed.
     */
    end(): Promise<void>;
    /**
     * The caller will block until fn is successfully enqueued.
     * The fn itself is execute asynchronously and its result discarded.
     * TODO(AD) do we need this if we have exec()?
     * @param fn - The function to call once unblocked.
     */
    put(fn: () => Promise<void>): Promise<void>;
    /**
     * The caller will block until fn is successfully executed, and it's result returned.
     * @param fn - The function.
     * @returns A promise that resolves with the result once executed.
     */
    exec<T>(fn: () => Promise<T>): Promise<T>;
    /**
     * Awaiting this ensures the queue is empty before resuming.
     */
    syncPoint(): Promise<void>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm91bmRlZF9zZXJpYWxfcXVldWUuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9xdWV1ZS9ib3VuZGVkX3NlcmlhbF9xdWV1ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQTs7O0dBR0c7QUFDSCxxQkFBYSxrQkFBa0I7SUFNM0IsT0FBTyxDQUFDLEdBQUc7SUFMYixPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBcUI7SUFDM0MsT0FBTyxDQUFDLFNBQVMsQ0FBWTtJQUU3QixZQUNFLFlBQVksRUFBRSxNQUFNLEVBQ1osR0FBRyx5Q0FBa0QsRUFHOUQ7SUFFRDs7O09BR0c7SUFDSSxLQUFLLFNBRVg7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU0sV0FFWjtJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxrQkFFWjtJQUVEOzs7Ozs7O09BT0c7SUFDSSxHQUFHLGtCQUVUO0lBRUQ7Ozs7O09BS0c7SUFDVSxHQUFHLENBQUMsRUFBRSxFQUFFLE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FhdkQ7SUFFRDs7OztPQUlHO0lBQ1UsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQVNyRDtJQUVEOztPQUVHO0lBQ1UsU0FBUyxrQkFFckI7Q0FDRiJ9