import { type ParseInput, type ParseReturnType, type ZodObject, ZodOptional, type ZodRawShape, type ZodType, type ZodTypeAny, z } from 'zod';
import type { ZodFor } from './types.js';
export declare const hexSchema: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>;
/** Schema for a buffer represented as a base64 string or a Buffer object. */
export declare const bufferSchema: ZodFor<Buffer>;
export declare class ZodNullableOptional<T extends ZodTypeAny> extends ZodOptional<T> {
    _isNullableOptional: boolean;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create<T extends ZodTypeAny>(type: T): ZodNullableOptional<T>;
}
/**
 * Declares a parameter as optional. Use this over z.optional in order to accept nulls as undefineds.
 * This is required as JSON does not have an undefined type, and null is used to represent it, so we
 * need to convert nulls to undefineds as we parse.
 */
export declare function optional<T extends ZodTypeAny>(schema: T): ZodNullableOptional<T>;
type ToJsonIs<T, TRet> = T extends {
    toJSON(): TRet;
} ? T : never;
/**
 * Creates a schema that accepts a hex string and uses it to hydrate an instance.
 * @param klazz - Class that implements either fromString or fromBuffer.
 * @returns A schema for the class.
 */
export declare function hexSchemaFor<TClass extends {
    fromString(str: string): any;
} | {
    fromBuffer(buf: Buffer): any;
}>(klazz: TClass, refinement?: (input: string) => boolean): ZodType<TClass extends {
    fromString(str: string): infer TInstance;
} | {
    fromBuffer(buf: Buffer): infer TInstance;
} ? ToJsonIs<TInstance, string> : never, any, string>;
/**
 * Creates a schema that accepts a base64 string and uses it to hydrate an instance.
 * @param klazz - Class that implements fromBuffer.
 * @returns A schema for the class.
 */
export declare function bufferSchemaFor<TClass extends {
    fromBuffer(buf: Buffer): any;
}>(klazz: TClass, refinement?: (buf: Buffer) => boolean): ZodType<TClass extends {
    fromBuffer(buf: Buffer): infer TInstance;
} ? ToJsonIs<TInstance, Buffer> : never, any, string>;
/** Creates a schema for a js Map type that matches the serialization used in jsonStringify. */
export declare function mapSchema<TKey, TValue>(key: ZodFor<TKey>, value: ZodFor<TValue>): ZodFor<Map<TKey, TValue>>;
/** Creates a schema for a js Set type that matches the serialization used in jsonStringify. */
export declare function setSchema<T>(value: ZodFor<T>): ZodFor<Set<T>>;
/** Given an already parsed and validated object, extracts the keys defined in the given schema. Does not validate again. */
export declare function pickFromSchema<T extends object, S extends ZodObject<ZodRawShape>>(obj: T, schema: S): Partial<T>;
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWFzL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCxLQUFLLFVBQVUsRUFDZixLQUFLLGVBQWUsRUFFcEIsS0FBSyxTQUFTLEVBQ2QsV0FBVyxFQUVYLEtBQUssV0FBVyxFQUNoQixLQUFLLE9BQU8sRUFDWixLQUFLLFVBQVUsRUFDZixDQUFDLEVBQ0YsTUFBTSxLQUFLLENBQUM7QUFJYixPQUFPLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFekMsZUFBTyxNQUFNLFNBQVMseUVBQWlGLENBQUM7QUFLeEcsNkVBQTZFO0FBQzdFLGVBQU8sTUFBTSxZQUFZLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FpQnRDLENBQUM7QUFFSCxxQkFBYSxtQkFBbUIsQ0FBQyxDQUFDLFNBQVMsVUFBVSxDQUFFLFNBQVEsV0FBVyxDQUFDLENBQUMsQ0FBQztJQUMzRSxtQkFBbUIsVUFBUTtJQUVsQixNQUFNLENBQUMsS0FBSyxFQUFFLFVBQVUsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBTW5FO0lBRUQsT0FBZ0IsTUFBTSxDQUFDLENBQUMsU0FBUyxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FLNUU7Q0FDRjtBQUVEOzs7O0dBSUc7QUFDSCx3QkFBZ0IsUUFBUSxDQUFDLENBQUMsU0FBUyxVQUFVLEVBQUUsTUFBTSxFQUFFLENBQUMsMEJBRXZEO0FBRUQsS0FBSyxRQUFRLENBQUMsQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDLFNBQVM7SUFBRSxNQUFNLElBQUksSUFBSSxDQUFBO0NBQUUsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBRWxFOzs7O0dBSUc7QUFDSCx3QkFBZ0IsWUFBWSxDQUFDLE1BQU0sU0FBUztJQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxHQUFHLEdBQUcsQ0FBQTtDQUFFLEdBQUc7SUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLE1BQU0sR0FBRyxHQUFHLENBQUE7Q0FBRSxFQUM3RyxLQUFLLEVBQUUsTUFBTSxFQUNiLFVBQVUsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLE1BQU0sS0FBSyxPQUFPLEdBQ3RDLE9BQU8sQ0FDUixNQUFNLFNBQVM7SUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLE1BQU0sR0FBRyxNQUFNLFNBQVMsQ0FBQTtDQUFFLEdBQUc7SUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLE1BQU0sR0FBRyxNQUFNLFNBQVMsQ0FBQTtDQUFFLEdBQ3RHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLEdBQzNCLEtBQUssRUFDVCxHQUFHLEVBQ0gsTUFBTSxDQUNQLENBTUE7QUFFRDs7OztHQUlHO0FBQ0gsd0JBQWdCLGVBQWUsQ0FBQyxNQUFNLFNBQVM7SUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLE1BQU0sR0FBRyxHQUFHLENBQUE7Q0FBRSxFQUM3RSxLQUFLLEVBQUUsTUFBTSxFQUNiLFVBQVUsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLE1BQU0sS0FBSyxPQUFPLEdBQ3BDLE9BQU8sQ0FDUixNQUFNLFNBQVM7SUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLE1BQU0sR0FBRyxNQUFNLFNBQVMsQ0FBQTtDQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsR0FBRyxLQUFLLEVBQ2pHLEdBQUcsRUFDSCxNQUFNLENBQ1AsQ0FFQTtBQUVELCtGQUErRjtBQUMvRix3QkFBZ0IsU0FBUyxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBRTNHO0FBRUQsK0ZBQStGO0FBQy9GLHdCQUFnQixTQUFTLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUU3RDtBQUVELDRIQUE0SDtBQUM1SCx3QkFBZ0IsY0FBYyxDQUFDLENBQUMsU0FBUyxNQUFNLEVBQUUsQ0FBQyxTQUFTLFNBQVMsQ0FBQyxXQUFXLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLGNBRW5HIn0=