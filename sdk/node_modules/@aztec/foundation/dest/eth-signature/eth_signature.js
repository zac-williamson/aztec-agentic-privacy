import { Buffer32 } from '@aztec/foundation/buffer';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { z } from 'zod';
import { hasHexPrefix, hexToBuffer } from '../string/index.js';
/**
 * Contains a signature split into it's primary components (r,s,v)
 */ export class Signature {
    r;
    s;
    v;
    // Cached values
    size;
    empty;
    constructor(/** The r value of the signature */ r, /** The s value of the signature */ s, /** The v value of the signature */ v){
        this.r = r;
        this.s = s;
        this.v = v;
        this.empty = r.isZero() && s.isZero() && v === 0;
    }
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        const r = reader.readObject(Buffer32);
        const s = reader.readObject(Buffer32);
        const v = reader.readNumber();
        return new Signature(r, s, v);
    }
    static isValidString(sig) {
        return /^0x[0-9a-f]{129,}$/i.test(sig);
    }
    /**
   * A seperate method exists for this as when signing locally with viem, as when
   * parsing from viem, we can expect the v value to be a u8, rather than our
   * default serialization of u32
   */ static fromString(sig) {
        const buf = hexToBuffer(sig);
        const reader = BufferReader.asReader(buf);
        const r = reader.readObject(Buffer32);
        const s = reader.readObject(Buffer32);
        const v = parseInt(sig.slice(2 + 64 * 2), 16);
        return new Signature(r, s, v);
    }
    static fromViemSignature(sig) {
        return new Signature(Buffer32.fromBuffer(hexToBuffer(sig.r)), Buffer32.fromBuffer(hexToBuffer(sig.s)), sig.v);
    }
    static fromViemTransactionSignature(sig) {
        return new Signature(Buffer32.fromBuffer(hexToBuffer(sig.r)), Buffer32.fromBuffer(hexToBuffer(sig.s)), sig.yParity);
    }
    static random() {
        return new Signature(Buffer32.random(), Buffer32.random(), 1);
    }
    static empty() {
        return new Signature(Buffer32.ZERO, Buffer32.ZERO, 0);
    }
    isEmpty() {
        return this.empty;
    }
    equals(other) {
        return this.r.equals(other.r) && this.s.equals(other.s) && this.v === other.v && this.empty === other.empty;
    }
    toBuffer() {
        return serializeToBuffer([
            this.r,
            this.s,
            this.v
        ]);
    }
    getSize() {
        // We cache size to avoid recalculating it
        if (this.size) {
            return this.size;
        }
        this.size = this.toBuffer().length;
        return this.size;
    }
    toString() {
        return `0x${this.r.buffer.toString('hex')}${this.s.buffer.toString('hex')}${this.v.toString(16)}`;
    }
    /**
   * Return the signature with `0x${string}` encodings for r and s
   */ toViemSignature() {
        return {
            r: this.r.toString(),
            s: this.s.toString(),
            v: this.v
        };
    }
    /**
   * Return the signature with `0x${string}` encodings for r and s. Verifies v is valid
   */ toViemTransactionSignature() {
        if (this.v !== 0 && this.v !== 1) {
            throw new Error('Invalid transaction signature');
        }
        return {
            r: this.r.toString(),
            s: this.s.toString(),
            yParity: this.v
        };
    }
    toJSON() {
        return this.toString();
    }
    static get schema() {
        return z.string().refine(hasHexPrefix, 'No hex prefix').refine(Signature.isValidString, 'Not a valid Ethereum signature').transform(Signature.fromString);
    }
}
