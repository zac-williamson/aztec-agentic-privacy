import { poseidon2Hash } from '@aztec/foundation/crypto/poseidon';
import { MerkleTree } from './merkle_tree.js';
/**
 * Merkle tree calculator.
 */ export class MerkleTreeCalculator {
    height;
    zeroHashes;
    hasher;
    constructor(height, zeroHashes, hasher){
        this.height = height;
        this.zeroHashes = zeroHashes;
        this.hasher = hasher;
        this.hasher = hasher;
    }
    static async create(height, zeroLeaf = Buffer.alloc(32), hasher = async (left, right)=>(await poseidon2Hash([
            left,
            right
        ])).toBuffer()) {
        const zeroHashes = [
            zeroLeaf
        ];
        for(let i = 0; i < height; i++){
            zeroHashes.push(await hasher(zeroHashes[i], zeroHashes[i]));
        }
        return new MerkleTreeCalculator(height, zeroHashes, hasher);
    }
    async computeTree(leaves = []) {
        if (leaves.length === 0) {
            leaves = new Array(2 ** this.height).fill(this.zeroHashes[0]);
        }
        let result = leaves.slice();
        for(let i = 0; i < this.height; ++i){
            const numLeaves = 2 ** (this.height - i);
            const newLeaves = [];
            for(let j = 0; j < leaves.length / 2; ++j){
                const l = leaves[j * 2];
                const r = leaves[j * 2 + 1] || this.zeroHashes[i];
                newLeaves[j] = await this.hasher(l, r);
            }
            result = result.concat(new Array(numLeaves - leaves.length).fill(this.zeroHashes[i]), newLeaves);
            leaves = newLeaves;
        }
        return new MerkleTree(this.height, result);
    }
    async computeTreeRoot(leaves = []) {
        if (leaves.length === 0) {
            return this.zeroHashes[this.zeroHashes.length - 1];
        }
        leaves = leaves.slice();
        for(let i = 0; i < this.height; ++i){
            let j = 0;
            for(; j < leaves.length / 2; ++j){
                const l = leaves[j * 2];
                const r = leaves[j * 2 + 1] || this.zeroHashes[i];
                leaves[j] = await this.hasher(l, r);
            }
            leaves = leaves.slice(0, j);
        }
        return leaves[0];
    }
}
