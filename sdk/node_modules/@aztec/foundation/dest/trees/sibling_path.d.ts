import { Fr } from '../curves/bn254/index.js';
import { type Tuple } from '../serialize/index.js';
import type { Hasher } from './hasher.js';
/**
 * Contains functionality to compute and serialize/deserialize a sibling path.
 * E.g. Sibling path for a leaf at index 3 in a tree of depth 3 consists of:
 *      d0:                                            [ root ]
 *      d1:                      [ ]                                               [*]
 *      d2:         [*]                      [ ]                       [ ]                     [ ]
 *      d3:   [ ]         [ ]          [*]         [ ]           [ ]         [ ]          [ ]        [ ].
 *
 *      And the elements would be ordered as: [ leaf_at_index_2, node_at_level_2_index_0, node_at_level_1_index_1 ].
 */
export declare class SiblingPath<N extends number> {
    /** Size of the sibling path (number of fields it contains). */
    pathSize: N;
    private data;
    /**
     * Constructor.
     * @param pathSize - The size of the sibling path.
     * @param path - The sibling path data.
     */
    constructor(
    /** Size of the sibling path (number of fields it contains). */
    pathSize: N, 
    /** The sibling path data. */
    path: Buffer[]);
    static get schema(): import("zod").ZodEffects<import("../schemas/types.js").ZodFor<Buffer<ArrayBufferLike>>, SiblingPath<number>, any>;
    static schemaFor<N extends number>(size: N): import("zod").ZodEffects<import("zod").ZodEffects<import("../schemas/types.js").ZodFor<Buffer<ArrayBufferLike>>, SiblingPath<N>, any>, SiblingPath<N>, any>;
    toJSON(): Buffer<ArrayBufferLike>;
    /**
     * Returns sibling path hashed up from the a element.
     * @param size - The number of elements in a given path.
     * @param zeroElement - Value of the zero element.
     * @param hasher - Implementation of a hasher interface.
     * @returns A sibling path hashed up from a zero element.
     */
    static ZERO<N extends number>(size: N, zeroElement: Buffer, hasher: Hasher): SiblingPath<N>;
    static random<N extends number>(number: N): SiblingPath<N>;
    /**
     * Serializes this SiblingPath object to a buffer.
     * @returns The buffer representation of this object.
     */
    toBuffer(): Buffer;
    /**
     * Returns the path buffer underlying the sibling path.
     * @returns The Buffer array representation of this object.
     */
    toBufferArray(): Buffer[];
    /**
     * Convert the Sibling Path object into an array of field elements.
     * @returns The field array representation of this object.
     */
    toFields(): Fr[];
    /**
     * Convert Sibling Path object into a tuple of field elements.
     * @returns A tuple representation of the sibling path.
     */
    toTuple(): Tuple<Fr, N>;
    /**
     * Deserializes a SiblingPath from a buffer.
     * @param buf - A buffer containing the buffer representation of SiblingPath.
     * @param offset - An offset to start deserializing from.
     * @returns A SiblingPath object.
     */
    static fromBuffer<N extends number>(buf: Buffer, offset?: number): SiblingPath<N>;
    /**
     * Deserializes a SiblingPath object from a slice of a part of a buffer and returns the amount of bytes advanced.
     * @param buf - A buffer representation of the sibling path.
     * @param offset - An offset to start deserializing from.
     * @returns The deserialized sibling path and the number of bytes advanced.
     */
    static deserialize<N extends number>(buf: Buffer, offset?: number): {
        elem: SiblingPath<N>;
        adv: number;
    };
    /**
     * Serializes this SiblingPath object to a hex string representation.
     * @returns A hex string representation of the sibling path.
     */
    toString(): string;
    /**
     * Deserializes a SiblingPath object from a hex string representation.
     * @param repr - A hex string representation of the sibling path.
     * @returns A SiblingPath object.
     */
    static fromString<N extends number>(repr: string): SiblingPath<N>;
    /**
     * Generate a subtree path from the current sibling path.
     * @param subtreeHeight - The size of the subtree that we are getting the path for.
     * @returns A new sibling path that is the for the requested subtree.
     */
    getSubtreeSiblingPath<SubtreeHeight extends number, SubtreeSiblingPathHeight extends number>(subtreeHeight: SubtreeHeight): SiblingPath<SubtreeSiblingPathHeight>;
}
/** Computes the expected root of a merkle tree given a leaf and its sibling path. */
export declare function computeRootFromSiblingPath(leaf: Buffer, siblingPath: Buffer[], index: number, hasher?: (left: Buffer<ArrayBufferLike>, right: Buffer<ArrayBufferLike>) => Promise<Buffer<ArrayBufferLike>>): Promise<Buffer<ArrayBufferLike>>;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2libGluZ19wYXRoLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdHJlZXMvc2libGluZ19wYXRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUU5QyxPQUFPLEVBQ0wsS0FBSyxLQUFLLEVBSVgsTUFBTSx1QkFBdUIsQ0FBQztBQUUvQixPQUFPLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFMUM7Ozs7Ozs7OztHQVNHO0FBQ0gscUJBQWEsV0FBVyxDQUFDLENBQUMsU0FBUyxNQUFNO0lBU3JDLCtEQUErRDtJQUN4RCxRQUFRLEVBQUUsQ0FBQztJQVRwQixPQUFPLENBQUMsSUFBSSxDQUFtQjtJQUUvQjs7OztPQUlHO0lBQ0g7SUFDRSwrREFBK0Q7SUFDeEQsUUFBUSxFQUFFLENBQUM7SUFDbEIsNkJBQTZCO0lBQzdCLElBQUksRUFBRSxNQUFNLEVBQUUsRUFHZjtJQUVELE1BQU0sS0FBSyxNQUFNLHNIQUVoQjtJQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxTQUFTLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQywrSkFLekM7SUFFRCxNQUFNLDRCQUVMO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsT0FBYyxJQUFJLENBQUMsQ0FBQyxTQUFTLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBUWpHO0lBRUQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFNBQVMsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDLGtCQUd4QztJQUVEOzs7T0FHRztJQUNJLFFBQVEsSUFBSSxNQUFNLENBRXhCO0lBRUQ7OztPQUdHO0lBQ0ksYUFBYSxJQUFJLE1BQU0sRUFBRSxDQUUvQjtJQUVEOzs7T0FHRztJQUNJLFFBQVEsSUFBSSxFQUFFLEVBQUUsQ0FFdEI7SUFFRDs7O09BR0c7SUFDSSxPQUFPLElBQUksS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FHN0I7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxTQUFTLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLE1BQU0sU0FBSSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FHM0U7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxTQUFTLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLE1BQU0sU0FBSTs7O01BUTNEO0lBRUQ7OztPQUdHO0lBQ0ksUUFBUSxJQUFJLE1BQU0sQ0FFeEI7SUFFRDs7OztPQUlHO0lBQ0gsT0FBYyxVQUFVLENBQUMsQ0FBQyxTQUFTLE1BQU0sRUFBRSxJQUFJLEVBQUUsTUFBTSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FFdkU7SUFFRDs7OztPQUlHO0lBQ0kscUJBQXFCLENBQUMsYUFBYSxTQUFTLE1BQU0sRUFBRSx3QkFBd0IsU0FBUyxNQUFNLEVBQ2hHLGFBQWEsRUFBRSxhQUFhLEdBQzNCLFdBQVcsQ0FBQyx3QkFBd0IsQ0FBQyxDQUt2QztDQUNGO0FBRUQscUZBQXFGO0FBQ3JGLHdCQUFzQiwwQkFBMEIsQ0FDOUMsSUFBSSxFQUFFLE1BQU0sRUFDWixXQUFXLEVBQUUsTUFBTSxFQUFFLEVBQ3JCLEtBQUssRUFBRSxNQUFNLEVBQ2IsTUFBTSxzR0FBeUYsb0NBUWhHIn0=