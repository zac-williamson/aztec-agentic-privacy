import { type Hasher } from './hasher.js';
import { SiblingPath } from './sibling_path.js';
import { type TreeNodeLocation } from './unbalanced_tree_store.js';
/**
 * An ephemeral unbalanced Merkle tree implementation.
 * Follows the rollup implementation which greedily hashes pairs of nodes up the tree.
 * Remaining rightmost nodes are shifted up until they can be paired.
 * The values that match the `valueToCompress` are skipped and the sibling of the compressed leaf are shifted up until
 * they can be paired.
 * If there is only one leaf, the root is the leaf.
 */
export declare class UnbalancedMerkleTreeCalculator {
    private readonly leaves;
    private readonly valueToCompress;
    private readonly emptyRoot;
    private readonly hasher;
    private store;
    private leafLocations;
    constructor(leaves: Buffer[], valueToCompress: Buffer, emptyRoot: Buffer, hasher: Hasher['hash']);
    static create(leaves: Buffer[], valueToCompress?: Buffer<ArrayBuffer>, emptyRoot?: Buffer<ArrayBuffer>, hasher?: (lhs: Uint8Array<ArrayBufferLike>, rhs: Uint8Array<ArrayBufferLike>) => Buffer<ArrayBuffer>): UnbalancedMerkleTreeCalculator;
    /**
     * Returns the root of the tree.
     * @returns The root of the tree.
     */
    getRoot(): Buffer;
    /**
     * Returns a sibling path for the element.
     * @param value - The value of the element.
     * @returns A sibling path for the element.
     * Note: The sibling path is an array of sibling hashes, with the lowest hash (leaf hash) first, and the highest hash last.
     */
    getSiblingPath<N extends number>(value: Buffer): SiblingPath<N>;
    /**
     * Returns a sibling path for the leaf at the given index.
     * @param leafIndex - The index of the leaf.
     * @returns A sibling path for the leaf.
     */
    getSiblingPathByLeafIndex<N extends number>(leafIndex: number): SiblingPath<N>;
    getLeafLocation(leafIndex: number): TreeNodeLocation;
    /**
     * Adds leaves and nodes to the store. Updates the leafLocations.
     * @param leaves - The leaves of the tree.
     */
    private buildTree;
    private shiftNodeUp;
    private collectNodesToShift;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5iYWxhbmNlZF9tZXJrbGVfdHJlZV9jYWxjdWxhdG9yLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdHJlZXMvdW5iYWxhbmNlZF9tZXJrbGVfdHJlZV9jYWxjdWxhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxLQUFLLE1BQU0sRUFBaUIsTUFBTSxhQUFhLENBQUM7QUFDekQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxLQUFLLGdCQUFnQixFQUF1QixNQUFNLDRCQUE0QixDQUFDO0FBT3hGOzs7Ozs7O0dBT0c7QUFDSCxxQkFBYSw4QkFBOEI7SUFLdkMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNO0lBQ3ZCLE9BQU8sQ0FBQyxRQUFRLENBQUMsZUFBZTtJQUNoQyxPQUFPLENBQUMsUUFBUSxDQUFDLFNBQVM7SUFDMUIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNO0lBUHpCLE9BQU8sQ0FBQyxLQUFLLENBQWdDO0lBQzdDLE9BQU8sQ0FBQyxhQUFhLENBQTBCO0lBRS9DLFlBQ21CLE1BQU0sRUFBRSxNQUFNLEVBQUUsRUFDaEIsZUFBZSxFQUFFLE1BQU0sRUFDdkIsU0FBUyxFQUFFLE1BQU0sRUFDakIsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFJeEM7SUFFRCxNQUFNLENBQUMsTUFBTSxDQUNYLE1BQU0sRUFBRSxNQUFNLEVBQUUsRUFDaEIsZUFBZSxzQkFBa0IsRUFDakMsU0FBUyxzQkFBbUIsRUFDNUIsTUFBTSw4RkFBZ0Isa0NBR3ZCO0lBRUQ7OztPQUdHO0lBQ0ksT0FBTyxJQUFJLE1BQU0sQ0FFdkI7SUFFRDs7Ozs7T0FLRztJQUNJLGNBQWMsQ0FBQyxDQUFDLFNBQVMsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQU9yRTtJQUVEOzs7O09BSUc7SUFDSSx5QkFBeUIsQ0FBQyxDQUFDLFNBQVMsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQW1CcEY7SUFFTSxlQUFlLENBQUMsU0FBUyxFQUFFLE1BQU0sb0JBRXZDO0lBRUQ7OztPQUdHO0lBQ0gsT0FBTyxDQUFDLFNBQVM7SUErQ2pCLE9BQU8sQ0FBQyxXQUFXO0lBWW5CLE9BQU8sQ0FBQyxtQkFBbUI7Q0FtQjVCIn0=