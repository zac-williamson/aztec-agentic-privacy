/** Returns a new object with the same keys and where each value has been passed through the mapping function. */ export function mapValues(obj, fn) {
    const result = {};
    for(const key in obj){
        result[key] = fn(obj[key], key);
    }
    return result;
}
/** Returns a new object where all keys with undefined values have been removed. */ export function compact(obj) {
    const result = {};
    for(const key in obj){
        if (obj[key] !== undefined) {
            result[key] = obj[key];
        }
    }
    return result;
}
export function pick(object, ...props) {
    const obj = {};
    for (const prop of props){
        obj[prop] = object[prop];
    }
    return obj;
}
export function omit(object, ...props) {
    const obj = {
        ...object
    };
    for (const prop of props){
        delete obj[prop];
    }
    return obj;
}
/** Equivalent to Object.keys but preserves types. */ export function getKeys(obj) {
    return Object.keys(obj);
}
/** Equivalent to Object.entries but preserves types. */ export function getEntries(obj) {
    // See https://stackoverflow.com/a/76176570
    return Object.entries(obj);
}
/** Equivalent to Object.fromEntries but preserves types. */ export function fromEntries(entries) {
    // See https://stackoverflow.com/a/76176570
    return Object.fromEntries(entries);
}
/** Asserts all values in object are not undefined. */ export function assertRequired(obj) {
    for(const key in obj){
        if (obj[key] === undefined) {
            throw new Error(`Missing property ${key}`);
        }
    }
    return obj;
}
/** Returns the result of merging two objects ignoring properties with undefined values. */ export function merge(obj1, obj2) {
    return {
        ...obj1,
        ...compact(obj2 ?? {})
    };
}
