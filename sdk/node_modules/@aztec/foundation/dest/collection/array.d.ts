import type { Tuple } from '../serialize/types.js';
/**
 * Pads an array to the target length by appending an element to its end. Throws if target length exceeds the input array length. Does not modify the input array.
 * @param arr - Array with elements to pad.
 * @param elem - Element to use for padding.
 * @param length - Target length.
 * @param errorMsg - Error message to throw if target length exceeds the input array length.
 * @returns A new padded array.
 */
export declare function padArrayEnd<T, N extends number>(arr: T[], elem: T, length: N, errorMsg?: string): Tuple<T, N>;
/** Removes the right-padding for an array. Does not modify original array. */
export declare function removeArrayPaddingEnd<T>(arr: T[], isEmpty: (item: T) => boolean): T[];
/**
 * Pads an array to the target length by prepending elements at the beginning. Throws if target length exceeds the input array length. Does not modify the input array.
 * @param arr - Array with elements to pad.
 * @param elem - Element to use for padding.
 * @param length - Target length.
 * @returns A new padded array.
 */
export declare function padArrayStart<T, N extends number>(arr: T[], elem: T, length: N): Tuple<T, N>;
/**
 * Returns if an array is composed of empty items.
 * @param arr - Array to check.
 * @returns True if every item in the array isEmpty.
 */
export declare function isArrayEmpty<T>(arr: T[], isEmpty: (item: T) => boolean): boolean;
/**
 * Returns the number of non-empty items in an array.
 * @param arr - Array to check.
 * @returns Number of non-empty items in an array.
 */
export declare function arrayNonEmptyLength<T>(arr: T[], isEmpty: (item: T) => boolean): number;
/**
 * Executes the given function n times and returns the results in an array.
 * @param n - How many times to repeat.
 * @param fn - Mapper from index to value.
 * @returns The array with the result from all executions.
 */
export declare function times<T>(n: number, fn: (i: number) => T): T[];
/**
 * Executes the given async function n times and returns the results in an array. Awaits each execution before starting the next one.
 * @param n - How many times to repeat.
 * @param fn - Mapper from index to value.
 * @returns The array with the result from all executions.
 */
export declare function timesAsync<T>(n: number, fn: (i: number) => Promise<T>): Promise<T[]>;
/**
 * Filters an array with an async predicate. Fires all predicate promises in parallel.
 * @param arr - The array to filter.
 * @param fn - The async function to determine if an item should be included.
 * @returns A promise that resolves to the filtered array.
 */
export declare function filterAsync<T>(arr: T[], fn: (item: T) => Promise<boolean>): Promise<T[]>;
/**
 * Executes the given async function n times in parallel and returns the results in an array.
 * @param n - How many times to repeat.
 * @param fn - Mapper from index to value.
 * @returns The array with the result from all executions.
 */
export declare function timesParallel<T>(n: number, fn: (i: number) => Promise<T>): Promise<T[]>;
/**
 * Returns the serialized size of all non-empty items in an array.
 * @param arr - Array
 * @returns The serialized size in bytes.
 */
export declare function arraySerializedSizeOfNonEmpty(arr: (({
    isZero: () => boolean;
} | {
    isEmpty: () => boolean;
}) & {
    toBuffer: () => Buffer;
})[]): number;
/**
 * Removes duplicates from the given array.
 * @param arr - The array.
 * @returns A new array.
 */
export declare function unique<T>(arr: T[]): T[];
/**
 * Removes all undefined elements from the array.
 * @param arr - The array.
 * @returns A new array.
 */
export declare function compactArray<T>(arr: (T | undefined)[]): T[];
/**
 * Returns whether two arrays are equal. The arrays are equal if they have the same length and all elements are equal.
 */
export declare function areArraysEqual<T>(a: T[], b: T[], eq?: (a: T, b: T) => boolean): boolean;
/**
 * Returns the element of the array that has the maximum value of the given function.
 * In case of a tie, returns the first element with the maximum value.
 * @param arr - The array.
 * @param fn - The function to get the value to compare.
 */
export declare function maxBy<T>(arr: T[], fn: (x: T) => number | bigint): T | undefined;
/** Computes the sum of a numeric array. */
export declare function sum(arr: number[]): number;
/** Computes the median of a numeric array. Returns undefined if array is empty. */
export declare function median(arr: number[]): number | undefined;
/** Computes the median of a bigint array. Returns undefined if array is empty. */
export declare function median(arr: bigint[]): bigint | undefined;
/** Computes the mean of a numeric array. Returns undefined if the array is empty. */
export declare function mean(values: number[]): number | undefined;
/** Computes the variance of a numeric array. Returns undefined if there are less than 2 points. */
export declare function variance(values: number[]): number | undefined;
/** Computes the standard deviation of a numeric array. Returns undefined if there are less than 2 points. */
export declare function stdDev(values: number[]): number | undefined;
/** Counts how many items from the beginning of the array match the given predicate. */
export declare function countWhile<T>(collection: T[], predicate: (x: T) => boolean): number;
/** Splits the given iterable into chunks of the given size. Last chunk may be of smaller than the requested size. */
export declare function chunk<T>(items: T[], chunkSize: number): T[][];
/**
 * Splits the given array into chunks of the given size, wrapping around to the beginning
 * if the last chunk would be smaller than the requested size.
 * Returns empty array for empty input. Returns single chunk with all items if chunkSize <= 0.
 */
export declare function chunkWrapAround<T>(items: T[], chunkSize: number): T[][];
/**
 * Splits the given iterable into chunks based on the key returned by the given function.
 * Items must be contiguous to be included in the same chunk.
 */
export declare function chunkBy<T, U>(items: T[], fn: (item: T) => U): T[][];
/** Partitions the given iterable into two arrays based on the predicate. */
export declare function partition<T>(items: T[], predicate: (item: T) => boolean): [T[], T[]];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXkuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb2xsZWN0aW9uL2FycmF5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRW5EOzs7Ozs7O0dBT0c7QUFDSCx3QkFBZ0IsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsTUFBTSxFQUM3QyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQ1IsSUFBSSxFQUFFLENBQUMsRUFDUCxNQUFNLEVBQUUsQ0FBQyxFQUNULFFBQVEsU0FBcUMsR0FDNUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FNYjtBQUVELDhFQUE4RTtBQUM5RSx3QkFBZ0IscUJBQXFCLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLE9BQU8sR0FBRyxDQUFDLEVBQUUsQ0FHckY7QUFFRDs7Ozs7O0dBTUc7QUFDSCx3QkFBZ0IsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FNNUY7QUFFRDs7OztHQUlHO0FBQ0gsd0JBQWdCLFlBQVksQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssT0FBTyxHQUFHLE9BQU8sQ0FPaEY7QUFFRDs7OztHQUlHO0FBQ0gsd0JBQWdCLG1CQUFtQixDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxPQUFPLEdBQUcsTUFBTSxD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