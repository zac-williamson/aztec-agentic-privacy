import { Fq, Fr } from '../curves/bn254/field.js';
import { createConsoleLogger } from '../log/console.js';
import { getActiveNetworkName } from './network_name.js';
import { parseBooleanEnv } from './parse-env.js';
import { SecretValue } from './secret_value.js';
export { SecretValue, getActiveNetworkName };
export { NetworkConfigMapSchema, NetworkConfigSchema } from './network_config.js';
export function isBooleanConfigValue(obj, key) {
    return typeof obj[key] === 'boolean';
}
/**
 * Shared utility function to get a value from environment variables with fallback support.
 * This can be used by both getConfigFromMappings and CLI utilities.
 *
 * @param env - The primary environment variable name
 * @param fallback - Optional array of fallback environment variable names
 * @param parseFunc - Optional function to parse the environment variable value
 * @param defaultValue - Optional default value to use if no environment variable is set
 * @returns The parsed value from environment variables or the default value
 */ export function getValueFromEnvWithFallback(env, parseFunc, defaultValue, fallback) {
    let value;
    // Try primary env var
    if (env) {
        value = process.env[env];
    }
    // If primary not found, try fallbacks
    if (value === undefined && fallback && fallback.length > 0) {
        for (const fallbackEnv of fallback){
            const fallbackVal = process.env[fallbackEnv];
            if (fallbackVal !== undefined) {
                value = fallbackVal;
                break;
            }
        }
    }
    // Parse the value if needed
    if (value !== undefined) {
        return parseFunc ? parseFunc(value) : value;
    }
    // Return default if no env var found
    return defaultValue;
}
export function getConfigFromMappings(configMappings) {
    const config = {};
    for(const key in configMappings){
        const { env, parseEnv, defaultValue, nested, fallback, deprecatedFallback } = configMappings[key];
        if (nested) {
            config[key] = getConfigFromMappings(nested);
        } else {
            // Use the shared utility function
            config[key] = getValueFromEnvWithFallback(env, parseEnv, defaultValue, fallback);
            // Check for deprecated env vars and warn if logger is set
            if (deprecatedFallback?.length) {
                const userLog = createConsoleLogger('[DEPRECATED]');
                for (const { env: deprecatedEnv, message } of deprecatedFallback){
                    if (process.env[deprecatedEnv]) {
                        const warningMessage = message ?? `Environment variable ${deprecatedEnv} is deprecated. Please use ${env} instead.`;
                        userLog(warningMessage, {
                            deprecatedEnvVar: deprecatedEnv,
                            newEnvVar: env
                        });
                    }
                }
            }
        }
    }
    return config;
}
/**
 * Filters out a service's config mappings to exclude certain keys.
 * @param configMappings - The service's config mappings
 * @param keysToFilter - The keys to filter out
 * @returns The filtered config mappings
 */ export function omitConfigMappings(configMappings, keysToFilter) {
    return Object.fromEntries(Object.entries(configMappings).filter(([key])=>!keysToFilter.includes(key)));
}
/**
 * Generates parseEnv and default values for a numerical config value.
 * @param defaultVal - The default numerical value to use if the environment variable is not set or is invalid
 * @returns Object with parseEnv and default values for a numerical config value
 */ export function numberConfigHelper(defaultVal) {
    return {
        parseEnv: (val)=>safeParseNumber(val, defaultVal),
        defaultValue: defaultVal
    };
}
/**
 * Generates parseEnv and default values for a numerical config value.
 * @param defaultVal - The default numerical value to use if the environment variable is not set or is invalid
 * @returns Object with parseEnv and default values for a numerical config value
 */ export function floatConfigHelper(defaultVal, validationFn) {
    return {
        parseEnv: (val)=>{
            const parsed = safeParseFloat(val, defaultVal);
            validationFn?.(parsed);
            return parsed;
        },
        defaultValue: defaultVal
    };
}
/**
 * Parses an environment variable to a 0-1 percentage value
 */ export function percentageConfigHelper(defaultVal) {
    return {
        parseEnv: (val)=>{
            const parsed = safeParseFloat(val, defaultVal);
            if (parsed < 0 || parsed > 1) {
                throw new TypeError(`Invalid percentage value: ${parsed} should be between 0 and 1`);
            }
            return parsed;
        },
        defaultValue: defaultVal
    };
}
/**
 * Generates parseEnv and default values for a numerical config value.
 * @param defaultVal - The default numerical value to use if the environment variable is not set or is invalid
 * @returns Object with parseEnv and default values for a numerical config value
 */ export function bigintConfigHelper(defaultVal) {
    return {
        parseEnv: (val)=>{
            if (val === '') {
                return defaultVal;
            }
            return BigInt(val);
        },
        defaultValue: defaultVal
    };
}
/**
 * Generates parseEnv for an optional numerical config value.
 */ export function optionalNumberConfigHelper() {
    return {
        parseEnv: (val)=>{
            if (val !== undefined && val.length > 0) {
                const parsedValue = parseInt(val);
                return Number.isSafeInteger(parsedValue) ? parsedValue : undefined;
            }
            return undefined;
        }
    };
}
/** Generates parseEnv for an enum-like config value. */ export function enumConfigHelper(values, defaultValue) {
    return {
        parseEnv: (val)=>{
            const sanitizedVal = (val ?? '').trim().toLowerCase();
            if (values.includes(sanitizedVal)) {
                return sanitizedVal;
            }
            if (!val && defaultValue) {
                return defaultValue;
            }
            throw new Error(`Invalid config value '${val}' (must be one of ${values.join(', ')})`);
        },
        defaultValue
    };
}
/**
 * Generates parseEnv and default values for a boolean config value.
 * @param defaultVal - The default value to use if the environment variable is not set or is invalid
 * @returns Object with parseEnv and default values for a boolean config value
 */ export function booleanConfigHelper(defaultVal = false) {
    const parse = (val)=>typeof val === 'boolean' ? val : parseBooleanEnv(val);
    return {
        parseEnv: parse,
        parseVal: parse,
        defaultValue: defaultVal,
        isBoolean: true
    };
}
export function secretValueConfigHelper(parse) {
    const wrap = (val)=>new SecretValue(parse(val));
    return {
        parseEnv: wrap,
        parseVal: wrap,
        defaultValue: new SecretValue(parse(undefined)),
        isBoolean: true
    };
}
export { parseBooleanEnv } from './parse-env.js';
export function secretStringConfigHelper(defaultValue) {
    const parse = (val)=>new SecretValue(val);
    return {
        parseEnv: parse,
        parseVal: parse,
        defaultValue: defaultValue !== undefined ? new SecretValue(defaultValue) : undefined,
        isBoolean: true
    };
}
export function secretFrConfigHelper(defaultValue) {
    const parse = (val)=>new SecretValue(Fr.fromHexString(val));
    return {
        parseEnv: parse,
        parseVal: parse,
        defaultValue: defaultValue !== undefined ? new SecretValue(defaultValue) : undefined,
        isBoolean: true
    };
}
export function secretFqConfigHelper(defaultValue) {
    const parse = (val)=>new SecretValue(Fq.fromHexString(val));
    return {
        parseEnv: parse,
        parseVal: parse,
        defaultValue: typeof defaultValue !== 'undefined' ? new SecretValue(defaultValue) : undefined,
        isBoolean: true
    };
}
/**
 * Safely parses a number from a string.
 * If the value is not a number or is not a safe integer, the default value is returned.
 * @param value - The string value to parse
 * @param defaultValue - The default value to return
 * @returns Either parsed value or default value
 */ function safeParseNumber(value, defaultValue) {
    const parsedValue = parseInt(value, 10);
    return Number.isSafeInteger(parsedValue) ? parsedValue : defaultValue;
}
/**
 * Safely parses a floating point number from a string.
 * If the value is not a number, the default value is returned.
 * @param value - The string value to parse
 * @param defaultValue - The default value to return
 * @returns Either parsed value or default value
 */ function safeParseFloat(value, defaultValue) {
    const parsedValue = parseFloat(value);
    return Number.isNaN(parsedValue) ? defaultValue : parsedValue;
}
/**
 * Picks specific keys from the given configuration mappings.
 *
 * @template T - The type of the full configuration object.
 * @template K - The keys to pick from the configuration object.
 * @param {ConfigMappingsType<T>} configMappings - The full configuration mappings object.
 * @param {K[]} keys - The keys to pick from the configuration mappings.
 * @returns {ConfigMappingsType<Pick<T, K>>} - A new configuration mappings object containing only the specified keys.
 */ export function pickConfigMappings(configMappings, keys) {
    return Object.fromEntries(keys.map((key)=>[
            key,
            configMappings[key]
        ]));
}
/**
 * Extracts the default configuration values from the given configuration mappings.
 *
 * @template T - The type of the configuration object.
 * @param {ConfigMappingsType<T>} configMappings - The configuration mappings object.
 * @returns {T} - The configuration object with default values.
 */ export function getDefaultConfig(configMappings) {
    const defaultConfig = {};
    for(const key in configMappings){
        if (configMappings[key] && configMappings[key].defaultValue !== undefined) {
            defaultConfig[key] = configMappings[key].defaultValue;
        }
    }
    return defaultConfig;
}
