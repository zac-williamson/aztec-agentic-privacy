import { inspect } from 'util';
import { Fr } from '../curves/bn254/index.js';
import { BufferReader, FieldReader } from '../serialize/index.js';
/**
 * Represents an Ethereum address as a 20-byte buffer and provides various utility methods
 * for converting between different representations, generating random addresses, validating
 * checksums, and comparing addresses. EthAddress can be instantiated using a buffer or string,
 * and can be serialized/deserialized from a buffer or BufferReader.
 */
export declare class EthAddress {
    private buffer;
    /** The size of an Ethereum address in bytes. */
    static SIZE_IN_BYTES: number;
    /** Represents a zero Ethereum address with 20 bytes filled with zeros. */
    static ZERO: EthAddress;
    constructor(buffer: Buffer);
    /**
     * Creates an EthAddress instance from a valid Ethereum address string.
     * The input 'address' can be either in checksum format or lowercase, and it can be prefixed with '0x'.
     * Throws an error if the input is not a valid Ethereum address.
     *
     * @param address - The string representing the Ethereum address.
     * @returns An EthAddress instance.
     */
    static fromString(address: string): EthAddress;
    /**
     * Creates an EthAddress from a plain object without Zod validation.
     * This method is optimized for performance and skips validation, making it suitable
     * for deserializing trusted data (e.g., from C++ via MessagePack).
     * Handles buffers (20 or 32 bytes), strings, or existing instances.
     * @param obj - Plain object, buffer, string, or EthAddress instance
     * @returns An EthAddress instance
     */
    static fromPlainObject(obj: any): EthAddress;
    /**
     * Create a random EthAddress instance with 20 random bytes.
     * This method generates a new Ethereum address with a randomly generated set of 20 bytes.
     * It is useful for generating test addresses or unique identifiers.
     *
     * @returns A randomly generated EthAddress instance.
     */
    static random(): EthAddress;
    /**
     * Determines if the given string represents a valid Ethereum address.
     * A valid address should meet the following criteria:
     * 1. Contains exactly 40 hex characters (excluding an optional '0x' prefix).
     * 2. Is either all lowercase, all uppercase, or has a valid checksum based on EIP-55.
     *
     * @param address - The string to be checked for validity as an Ethereum address.
     * @returns True if the input string represents a valid Ethereum address, false otherwise.
     */
    static isAddress(address: string): boolean;
    /**
     * Checks if the EthAddress instance represents a zero address.
     * A zero address consists of 20 bytes filled with zeros and is considered an invalid address.
     *
     * @returns A boolean indicating whether the EthAddress instance is a zero address or not.
     */
    isZero(): boolean;
    /**
     * Checks if the given Ethereum address has a valid checksum.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 40 hex characters.
     * Returns true if the address has a valid checksum, false otherwise.
     *
     * @param address - The hex-encoded string representing the Ethereum address.
     * @returns A boolean value indicating whether the address has a valid checksum.
     */
    static checkAddressChecksum(address: string): boolean;
    /**
     * Converts an Ethereum address to its checksum format.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 40 hex characters.
     * The checksum format is created by capitalizing certain characters in the hex string
     * based on the hash of the lowercase address.
     * Throws an error if the input address is invalid.
     *
     * @param address - The Ethereum address as a hex-encoded string.
     * @returns The Ethereum address in its checksum format.
     */
    static toChecksumAddress(address: string): `0x${string}`;
    /**
     * Checks whether the given EthAddress instance is equal to the current instance.
     * Equality is determined by comparing the underlying byte buffers of both instances.
     *
     * @param rhs - The EthAddress instance to compare with the current instance.
     * @returns A boolean value indicating whether the two instances are equal (true) or not (false).
     */
    equals(rhs: EthAddress): boolean;
    /**
     * Converts the Ethereum address to a hex-encoded string.
     * The resulting string is prefixed with '0x' and has exactly 40 hex characters.
     * This method can be used to represent the EthAddress instance in the widely used hexadecimal format.
     *
     * @returns A hex-encoded string representation of the Ethereum address.
     */
    toString(): `0x${string}`;
    [inspect.custom](): string;
    /**
     * Returns the Ethereum address as a checksummed string.
     * The output string will have characters in the correct upper or lowercase form, according to EIP-55.
     * This provides a way to verify if an address is typed correctly, by checking the character casing.
     *
     * @returns A checksummed Ethereum address string.
     */
    toChecksumString(): `0x${string}`;
    /**
     * Returns a 20-byte buffer representation of the Ethereum address.
     * @returns A 20-byte Buffer containing the Ethereum address.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Returns a 32-byte buffer representation of the Ethereum address, with the original 20-byte address
     * occupying the last 20 bytes and the first 12 bytes being zero-filled.
     * This format is commonly used in smart contracts when handling addresses as 32-byte values.
     *
     * @returns A 32-byte Buffer containing the padded Ethereum address.
     */
    toBuffer32(): Buffer<ArrayBuffer>;
    /**
     * Returns a new field with the same contents as this EthAddress.
     *
     * @returns An Fr instance.
     */
    toField(): Fr;
    /**
     * Converts a field to a eth address.
     * @param fr - The field to convert.
     * @returns The eth address.
     */
    static fromField(fr: Fr): EthAddress;
    static fromFields(fields: Fr[] | FieldReader): EthAddress;
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer to read from.
     * @returns The EthAddress.
     */
    static fromBuffer(buffer: Buffer | BufferReader): EthAddress;
    /** Converts a number into an address. Useful for testing. */
    static fromNumber(num: bigint | number): EthAddress;
    toJSON(): `0x${string}`;
    static get schema(): import("zod").ZodType<EthAddress, any, string>;
    static areEqual(a: EthAddress | string, b: EthAddress | string): boolean;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ldGgtYWRkcmVzcy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBSS9CLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUU5QyxPQUFPLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBSWxFOzs7OztHQUtHO0FBQ0gscUJBQWEsVUFBVTtJQU1ULE9BQU8sQ0FBQyxNQUFNO0lBTDFCLGdEQUFnRDtJQUNoRCxPQUFjLGFBQWEsU0FBTTtJQUNqQywwRUFBMEU7SUFDMUUsT0FBYyxJQUFJLGFBQTBEO0lBRTVFLFlBQW9CLE1BQU0sRUFBRSxNQUFNLEVBSWpDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILE9BQWMsVUFBVSxDQUFDLE9BQU8sRUFBRSxNQUFNLGNBS3ZDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILE9BQWMsZUFBZSxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsVUFBVSxDQVFsRDtJQUVEOzs7Ozs7T0FNRztJQUNILE9BQWMsTUFBTSxlQUVuQjtJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsT0FBYyxTQUFTLENBQUMsT0FBTyxFQUFFLE1BQU0sV0FVdEM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU0sWUFFWjtJQUVEOzs7Ozs7O09BT0c7SUFDSCxPQUFjLG9CQUFvQixDQUFDLE9BQU8sRUFBRSxNQUFNLFdBY2pEO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsT0FBYyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsTUFBTSxHQUFHLEtBQUssTUFBTSxFQUFFLENBa0I5RDtJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxHQUFHLEVBQUUsVUFBVSxXQUU1QjtJQUVEOzs7Ozs7T0FNRztJQUNJLFFBQVEsa0JBRWQ7SUFFRCxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FFZjtJQUVEOzs7Ozs7T0FNRztJQUNJLGdCQUFnQixrQkFFdEI7SUFFRDs7O09BR0c7SUFDSSxRQUFRLDRCQUVkO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksVUFBVSx3QkFJaEI7SUFFRDs7OztPQUlHO0lBQ0ksT0FBTyxPQUViO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBRyxVQUFVLENBRW5DO0lBRUQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEdBQUcsV0FBVyxjQUczQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUcsWUFBWSxHQUFHLFVBQVUsQ0FHM0Q7SUFFRCw2REFBNkQ7SUFDN0QsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxHQUFHLE1BQU0sR0FBRyxVQUFVLENBSWxEO0lBRUQsTUFBTSxrQkFFTDtJQUVELE1BQU0sS0FBSyxNQUFNLG1EQUdoQjtJQUVELE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLFVBQVUsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLFVBQVUsR0FBRyxNQUFNLFdBSTdEO0NBQ0YifQ==