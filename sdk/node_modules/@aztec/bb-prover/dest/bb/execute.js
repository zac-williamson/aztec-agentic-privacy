import { sha256 } from '@aztec/foundation/crypto/sha256';
import { Timer } from '@aztec/foundation/timer';
import * as proc from 'child_process';
import { promises as fs } from 'fs';
import { basename, dirname, join } from 'path';
import readline from 'readline';
export const VK_FILENAME = 'vk';
export const PUBLIC_INPUTS_FILENAME = 'public_inputs';
export const PROOF_FILENAME = 'proof';
export const AVM_INPUTS_FILENAME = 'avm_inputs.bin';
export const AVM_BYTECODE_FILENAME = 'avm_bytecode.bin';
export const AVM_PUBLIC_INPUTS_FILENAME = 'avm_public_inputs.bin';
export var BB_RESULT = /*#__PURE__*/ function(BB_RESULT) {
    BB_RESULT[BB_RESULT["SUCCESS"] = 0] = "SUCCESS";
    BB_RESULT[BB_RESULT["FAILURE"] = 1] = "FAILURE";
    BB_RESULT[BB_RESULT["ALREADY_PRESENT"] = 2] = "ALREADY_PRESENT";
    return BB_RESULT;
}({});
/**
 * Invokes the Barretenberg binary with the provided command and args
 * @param pathToBB - The path to the BB binary
 * @param command - The command to execute
 * @param args - The arguments to pass
 * @param logger - A log function
 * @param timeout - An optional timeout before killing the BB process
 * @param resultParser - An optional handler for detecting success or failure
 * @returns The completed partial witness outputted from the circuit
 */ export function executeBB(pathToBB, command, args, logger, concurrency, timeout, resultParser = (code)=>code === 0) {
    return new Promise((resolve)=>{
        // spawn the bb process
        const { HARDWARE_CONCURRENCY: _, ...envWithoutConcurrency } = process.env;
        const env = envWithoutConcurrency;
        // We prioritise the concurrency argument if provided and > 0
        if (concurrency && concurrency > 0) {
            env.HARDWARE_CONCURRENCY = concurrency.toString();
        } else if (process.env.HARDWARE_CONCURRENCY) {
            env.HARDWARE_CONCURRENCY = process.env.HARDWARE_CONCURRENCY;
        }
        logger(`BB concurrency: ${env.HARDWARE_CONCURRENCY}`);
        logger(`Executing BB with: ${pathToBB} ${command} ${args.join(' ')}`);
        const bb = proc.spawn(pathToBB, [
            command,
            ...args
        ], {
            stdio: [
                'ignore',
                'pipe',
                'pipe'
            ],
            env
        });
        let timeoutId;
        if (timeout !== undefined) {
            timeoutId = setTimeout(()=>{
                logger(`BB execution timed out after ${timeout}ms, killing process`);
                if (bb.pid) {
                    bb.kill('SIGKILL');
                }
                resolve({
                    status: 1,
                    exitCode: -1,
                    signal: 'TIMEOUT'
                });
            }, timeout);
        }
        readline.createInterface({
            input: bb.stdout
        }).on('line', logger);
        readline.createInterface({
            input: bb.stderr
        }).on('line', logger);
        bb.on('close', (exitCode, signal)=>{
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
            if (resultParser(exitCode)) {
                resolve({
                    status: 0,
                    exitCode,
                    signal
                });
            } else {
                resolve({
                    status: 1,
                    exitCode,
                    signal
                });
            }
        });
    }).catch((_)=>({
            status: 1,
            exitCode: -1,
            signal: undefined
        }));
}
export async function executeBbChonkProof(pathToBB, workingDirectory, inputsPath, log, writeVk = false) {
    // Check that the working directory exists
    try {
        await fs.access(workingDirectory);
    } catch  {
        return {
            status: 1,
            reason: `Working directory ${workingDirectory} does not exist`
        };
    }
    // The proof is written to e.g. /workingDirectory/proof
    const outputPath = `${workingDirectory}`;
    const binaryPresent = await fs.access(pathToBB, fs.constants.R_OK).then((_)=>true).catch((_)=>false);
    if (!binaryPresent) {
        return {
            status: 1,
            reason: `Failed to find bb binary at ${pathToBB}`
        };
    }
    try {
        // Write the bytecode to the working directory
        log(`inputsPath ${inputsPath}`);
        const timer = new Timer();
        const logFunction = (message)=>{
            log(`bb - ${message}`);
        };
        const args = [
            '-o',
            outputPath,
            '--ivc_inputs_path',
            inputsPath,
            '-v',
            '--scheme',
            'chonk'
        ];
        if (writeVk) {
            args.push('--write_vk');
        }
        const result = await executeBB(pathToBB, 'prove', args, logFunction);
        const durationMs = timer.ms();
        if (result.status == 0) {
            return {
                status: 0,
                durationMs,
                proofPath: `${outputPath}`,
                pkPath: undefined,
                vkDirectoryPath: `${outputPath}`
            };
        }
        // Not a great error message here but it is difficult to decipher what comes from bb
        return {
            status: 1,
            reason: `Failed to generate proof. Exit code ${result.exitCode}. Signal ${result.signal}.`,
            retry: !!result.signal
        };
    } catch (error) {
        return {
            status: 1,
            reason: `${error}`
        };
    }
}
function getArgs(flavor) {
    switch(flavor){
        case 'ultra_honk':
            {
                return [
                    '--scheme',
                    'ultra_honk',
                    '--oracle_hash',
                    'poseidon2'
                ];
            }
        case 'ultra_keccak_honk':
            {
                return [
                    '--scheme',
                    'ultra_honk',
                    '--oracle_hash',
                    'keccak'
                ];
            }
        case 'ultra_starknet_honk':
            {
                return [
                    '--scheme',
                    'ultra_honk',
                    '--oracle_hash',
                    'starknet'
                ];
            }
        case 'ultra_rollup_honk':
            {
                return [
                    '--scheme',
                    'ultra_honk',
                    '--oracle_hash',
                    'poseidon2',
                    '--ipa_accumulation'
                ];
            }
    }
}
/**
 * Used for generating proofs of noir circuits.
 * It is assumed that the working directory is a temporary and/or random directory used solely for generating this proof.
 * @param pathToBB - The full path to the bb binary
 * @param workingDirectory - A working directory for use by bb
 * @param circuitName - An identifier for the circuit
 * @param bytecode - The compiled circuit bytecode
 * @param inputWitnessFile - The circuit input witness
 * @param log - A logging function
 * @returns An object containing a result indication, the location of the proof and the duration taken
 */ export async function generateProof(pathToBB, workingDirectory, circuitName, bytecode, verificationKey, inputWitnessFile, flavor, log) {
    // Check that the working directory exists
    try {
        await fs.access(workingDirectory);
    } catch  {
        return {
            status: 1,
            reason: `Working directory ${workingDirectory} does not exist`
        };
    }
    // The bytecode is written to e.g. /workingDirectory/ParityBaseArtifact-bytecode
    const bytecodePath = `${workingDirectory}/${circuitName}-bytecode`;
    const vkPath = `${workingDirectory}/${circuitName}-vk`;
    // The proof is written to e.g. /workingDirectory/ultra_honk/proof
    const outputPath = `${workingDirectory}`;
    const binaryPresent = await fs.access(pathToBB, fs.constants.R_OK).then((_)=>true).catch((_)=>false);
    if (!binaryPresent) {
        return {
            status: 1,
            reason: `Failed to find bb binary at ${pathToBB}`
        };
    }
    try {
        // Write the bytecode and vk to the working directory
        await Promise.all([
            fs.writeFile(bytecodePath, bytecode),
            fs.writeFile(vkPath, verificationKey)
        ]);
        const args = getArgs(flavor).concat([
            '--disable_zk',
            '-o',
            outputPath,
            '-b',
            bytecodePath,
            '-k',
            vkPath,
            '-w',
            inputWitnessFile,
            '-v'
        ]);
        const loggingArg = log.level === 'debug' || log.level === 'trace' ? '-d' : log.level === 'verbose' ? '-v' : '';
        if (loggingArg !== '') {
            args.push(loggingArg);
        }
        const timer = new Timer();
        const logFunction = (message)=>{
            log.info(`${circuitName} BB out - ${message}`);
        };
        const result = await executeBB(pathToBB, `prove`, args, logFunction);
        const duration = timer.ms();
        if (result.status == 0) {
            return {
                status: 0,
                durationMs: duration,
                proofPath: `${outputPath}`,
                pkPath: undefined,
                vkDirectoryPath: `${outputPath}`
            };
        }
        // Not a great error message here but it is difficult to decipher what comes from bb
        return {
            status: 1,
            reason: `Failed to generate proof. Exit code ${result.exitCode}. Signal ${result.signal}.`,
            retry: !!result.signal
        };
    } catch (error) {
        return {
            status: 1,
            reason: `${error}`
        };
    }
}
/**
 * Used for generating AVM proofs.
 * It is assumed that the working directory is a temporary and/or random directory used solely for generating this proof.
 * @param pathToBB - The full path to the bb binary
 * @param workingDirectory - A working directory for use by bb
 * @param input - The inputs for the public function to be proven
 * @param logger - A logging function
 * @param checkCircuitOnly - A boolean to toggle a "check-circuit only" operation instead of proving.
 * @returns An object containing a result indication, the location of the proof and the duration taken
 */ export async function generateAvmProof(pathToBB, workingDirectory, input, logger, checkCircuitOnly = false) {
    // Check that the working directory exists
    try {
        await fs.access(workingDirectory);
    } catch  {
        return {
            status: 1,
            reason: `Working directory ${workingDirectory} does not exist`
        };
    }
    // The proof is written to e.g. /workingDirectory/proof
    const outputPath = workingDirectory;
    const filePresent = async (file)=>await fs.access(file, fs.constants.R_OK).then((_)=>true).catch((_)=>false);
    const binaryPresent = await filePresent(pathToBB);
    if (!binaryPresent) {
        return {
            status: 1,
            reason: `Failed to find bb binary at ${pathToBB}`
        };
    }
    const inputsBuffer = input.serializeWithMessagePack();
    try {
        // Write the inputs to the working directory.
        const avmInputsPath = join(workingDirectory, AVM_INPUTS_FILENAME);
        await fs.writeFile(avmInputsPath, inputsBuffer);
        if (!await filePresent(avmInputsPath)) {
            return {
                status: 1,
                reason: `Could not write avm inputs to ${avmInputsPath}`
            };
        }
        const args = checkCircuitOnly ? [
            '--avm-inputs',
            avmInputsPath
        ] : [
            '--avm-inputs',
            avmInputsPath,
            '-o',
            outputPath
        ];
        const loggingArg = logger.level === 'debug' || logger.level === 'trace' ? '-d' : logger.level === 'verbose' ? '-v' : '';
        if (loggingArg !== '') {
            args.push(loggingArg);
        }
        const timer = new Timer();
        const cmd = checkCircuitOnly ? 'avm_check_circuit' : 'avm_prove';
        const logFunction = (message)=>{
            logger.verbose(`AvmCircuit (${cmd}) BB out - ${message}`);
        };
        const result = await executeBB(pathToBB, cmd, args, logFunction);
        const duration = timer.ms();
        if (result.status == 0) {
            return {
                status: 0,
                durationMs: duration,
                proofPath: join(outputPath, PROOF_FILENAME),
                pkPath: undefined,
                vkDirectoryPath: undefined
            };
        }
        // Not a great error message here but it is difficult to decipher what comes from bb
        return {
            status: 1,
            reason: `Failed to generate proof. AVM proof for TX hash ${input.hints.tx.hash}. Exit code ${result.exitCode}. Signal ${result.signal}.`,
            retry: result.signal === 'SIGKILL'
        };
    } catch (error) {
        return {
            status: 1,
            reason: `${error}`
        };
    }
}
/**
 * Used for verifying proofs of noir circuits
 * @param pathToBB - The full path to the bb binary
 * @param proofFullPath - The full path to the proof to be verified
 * @param verificationKeyPath - The full path to the circuit verification key
 * @param logger - A logger
 * @returns An object containing a result indication and duration taken
 */ export async function verifyProof(pathToBB, proofFullPath, verificationKeyPath, ultraHonkFlavor, logger) {
    // Specify the public inputs path in the case of UH verification.
    // Take proofFullPath and remove the suffix past the / to get the directory.
    const proofDir = proofFullPath.substring(0, proofFullPath.lastIndexOf('/'));
    const publicInputsFullPath = join(proofDir, '/public_inputs');
    logger.debug(`public inputs path: ${publicInputsFullPath}`);
    const args = [
        '-p',
        proofFullPath,
        '-k',
        verificationKeyPath,
        '-i',
        publicInputsFullPath,
        '--disable_zk',
        ...getArgs(ultraHonkFlavor)
    ];
    return await verifyProofInternal(pathToBB, `verify`, args, logger);
}
export async function verifyAvmProof(pathToBB, workingDirectory, proofFullPath, publicInputs, logger) {
    const inputsBuffer = publicInputs.serializeWithMessagePack();
    // Write the inputs to the working directory.
    const filePresent = async (file)=>await fs.access(file, fs.constants.R_OK).then((_)=>true).catch((_)=>false);
    const avmInputsPath = join(workingDirectory, 'avm_public_inputs.bin');
    await fs.writeFile(avmInputsPath, inputsBuffer);
    if (!await filePresent(avmInputsPath)) {
        return {
            status: 1,
            reason: `Could not write avm inputs to ${avmInputsPath}`
        };
    }
    const args = [
        '-p',
        proofFullPath,
        '--avm-public-inputs',
        avmInputsPath
    ];
    return await verifyProofInternal(pathToBB, 'avm_verify', args, logger);
}
/**
 * Verifies a ChonkProof
 * TODO(#7370) The verification keys should be supplied separately
 * @param pathToBB - The full path to the bb binary
 * @param targetPath - The path to the folder with the proof, accumulator, and verification keys
 * @param logger - A logger
 * @param concurrency - The number of threads to use for the verification
 * @returns An object containing a result indication and duration taken
 */ export async function verifyChonkProof(pathToBB, proofPath, keyPath, logger, concurrency = 1) {
    const binaryPresent = await fs.access(pathToBB, fs.constants.R_OK).then((_)=>true).catch((_)=>false);
    if (!binaryPresent) {
        return {
            status: 1,
            reason: `Failed to find bb binary at ${pathToBB}`
        };
    }
    const args = [
        '--scheme',
        'chonk',
        '-p',
        proofPath,
        '-k',
        keyPath,
        '-v'
    ];
    return await verifyProofInternal(pathToBB, 'verify', args, logger, concurrency);
}
/**
 * Used for verifying proofs with BB
 * @param pathToBB - The full path to the bb binary
 * @param command - The BB command to execute (verify/avm_verify)
 * @param args - The arguments to pass to the command
 * @param logger - A logger
 * @param concurrency - The number of threads to use for the verification
 * @returns An object containing a result indication and duration taken
 */ async function verifyProofInternal(pathToBB, command, args, logger, concurrency) {
    const binaryPresent = await fs.access(pathToBB, fs.constants.R_OK).then((_)=>true).catch((_)=>false);
    if (!binaryPresent) {
        return {
            status: 1,
            reason: `Failed to find bb binary at ${pathToBB}`
        };
    }
    const logFunction = (message)=>{
        logger.verbose(`bb-prover (verify) BB out - ${message}`);
    };
    try {
        const loggingArg = logger.level === 'debug' || logger.level === 'trace' ? '-d' : logger.level === 'verbose' ? '-v' : '';
        const finalArgs = loggingArg !== '' ? [
            ...args,
            loggingArg
        ] : args;
        const timer = new Timer();
        const result = await executeBB(pathToBB, command, finalArgs, logFunction, concurrency);
        const duration = timer.ms();
        if (result.status == 0) {
            return {
                status: 0,
                durationMs: duration
            };
        }
        // Not a great error message here but it is difficult to decipher what comes from bb
        return {
            status: 1,
            reason: `Failed to verify proof. Exit code ${result.exitCode}. Signal ${result.signal}.`,
            retry: !!result.signal
        };
    } catch (error) {
        return {
            status: 1,
            reason: `${error}`
        };
    }
}
export async function generateContractForVerificationKey(pathToBB, vkFilePath, contractPath, log) {
    const binaryPresent = await fs.access(pathToBB, fs.constants.R_OK).then((_)=>true).catch((_)=>false);
    if (!binaryPresent) {
        return {
            status: 1,
            reason: `Failed to find bb binary at ${pathToBB}`
        };
    }
    const outputDir = dirname(contractPath);
    const contractName = basename(contractPath);
    // cache contract generation based on vk file and contract name
    const cacheKey = sha256(Buffer.concat([
        Buffer.from(contractName),
        await fs.readFile(vkFilePath)
    ]));
    await fs.mkdir(outputDir, {
        recursive: true
    });
    const res = await fsCache(outputDir, cacheKey, log, false, async ()=>{
        try {
            const args = [
                '--scheme',
                'ultra_honk',
                '-k',
                vkFilePath,
                '-o',
                contractPath,
                '-v'
            ];
            const timer = new Timer();
            const result = await executeBB(pathToBB, 'contract', args, log);
            const duration = timer.ms();
            if (result.status == 0) {
                return {
                    status: 0,
                    durationMs: duration,
                    contractPath
                };
            }
            // Not a great error message here but it is difficult to decipher what comes from bb
            return {
                status: 1,
                reason: `Failed to write verifier contract. Exit code ${result.exitCode}. Signal ${result.signal}.`,
                retry: !!result.signal
            };
        } catch (error) {
            return {
                status: 1,
                reason: `${error}`
            };
        }
    });
    if (!res) {
        return {
            status: 2,
            durationMs: 0,
            contractPath
        };
    }
    return res;
}
/**
 * Compute bb gate count for a given circuit
 * @param pathToBB - The full path to the bb binary
 * @param workingDirectory - A temporary directory for writing the bytecode
 * @param circuitName - The name of the circuit
 * @param bytecode - The bytecode of the circuit
 * @param flavor - The flavor of the backend - mega_honk or ultra_honk variants
 * @returns An object containing the status, gate count, and time taken
 */ export async function computeGateCountForCircuit(pathToBB, workingDirectory, circuitName, bytecode, flavor, log) {
    // Check that the working directory exists
    try {
        await fs.access(workingDirectory);
    } catch  {
        return {
            status: 1,
            reason: `Working directory ${workingDirectory} does not exist`
        };
    }
    // The bytecode is written to e.g. /workingDirectory/ParityBaseArtifact-bytecode
    const bytecodePath = `${workingDirectory}/${circuitName}-bytecode`;
    const binaryPresent = await fs.access(pathToBB, fs.constants.R_OK).then((_)=>true).catch((_)=>false);
    if (!binaryPresent) {
        return {
            status: 1,
            reason: `Failed to find bb binary at ${pathToBB}`
        };
    }
    // Accumulate the stdout from bb
    let stdout = '';
    const logHandler = (message)=>{
        stdout += message;
        log(message);
    };
    try {
        // Write the bytecode to the working directory
        await fs.writeFile(bytecodePath, bytecode);
        const timer = new Timer();
        const result = await executeBB(pathToBB, 'gates', [
            '--scheme',
            flavor === 'mega_honk' ? 'chonk' : 'ultra_honk',
            '-b',
            bytecodePath,
            '-v'
        ], logHandler);
        const duration = timer.ms();
        if (result.status == 0) {
            // Look for "circuit_size" in the stdout and parse the number
            const circuitSizeMatch = stdout.match(/circuit_size": (\d+)/);
            if (!circuitSizeMatch) {
                return {
                    status: 1,
                    reason: 'Failed to parse circuit_size from bb gates stdout.'
                };
            }
            const circuitSize = parseInt(circuitSizeMatch[1]);
            return {
                status: 0,
                durationMs: duration,
                circuitSize: circuitSize
            };
        }
        return {
            status: 1,
            reason: 'Failed getting the gate count.'
        };
    } catch (error) {
        return {
            status: 1,
            reason: `${error}`
        };
    }
}
const CACHE_FILENAME = '.cache';
async function fsCache(dir, expectedCacheKey, logger, force, action) {
    const cacheFilePath = join(dir, CACHE_FILENAME);
    let run;
    if (force) {
        run = true;
    } else {
        try {
            run = !expectedCacheKey.equals(await fs.readFile(cacheFilePath));
        } catch (err) {
            if (err && 'code' in err && err.code === 'ENOENT') {
                // cache file doesn't exist, swallow error and run
                run = true;
            } else {
                throw err;
            }
        }
    }
    let res;
    if (run) {
        logger(`Cache miss or forced run. Running operation in ${dir}...`);
        res = await action();
    } else {
        logger(`Cache hit. Skipping operation in ${dir}...`);
    }
    try {
        await fs.writeFile(cacheFilePath, expectedCacheKey);
    } catch  {
        logger(`Couldn't write cache data to ${cacheFilePath}. Skipping cache...`);
    // ignore
    }
    return res;
}
