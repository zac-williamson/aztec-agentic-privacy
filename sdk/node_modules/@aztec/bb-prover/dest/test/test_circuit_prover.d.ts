import { AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED, NESTED_RECURSIVE_PROOF_LENGTH, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, RECURSIVE_PROOF_LENGTH } from '@aztec/constants';
import { type ServerProtocolArtifact } from '@aztec/noir-protocol-circuits-types/server';
import { type CircuitSimulator } from '@aztec/simulator/server';
import type { AvmCircuitInputs } from '@aztec/stdlib/avm';
import { type PublicInputsAndRecursiveProof, type ServerCircuitProver } from '@aztec/stdlib/interfaces/server';
import type { ParityBasePrivateInputs, ParityPublicInputs, ParityRootPrivateInputs } from '@aztec/stdlib/parity';
import { type Proof, RecursiveProof } from '@aztec/stdlib/proofs';
import { type BlockMergeRollupPrivateInputs, type BlockRollupPublicInputs, type BlockRootEmptyTxFirstRollupPrivateInputs, type BlockRootFirstRollupPrivateInputs, type BlockRootRollupPrivateInputs, type BlockRootSingleTxFirstRollupPrivateInputs, type BlockRootSingleTxRollupPrivateInputs, type CheckpointMergeRollupPrivateInputs, type CheckpointPaddingRollupPrivateInputs, type CheckpointRollupPublicInputs, type CheckpointRootRollupPrivateInputs, type CheckpointRootSingleBlockRollupPrivateInputs, type PrivateTxBaseRollupPrivateInputs, type PublicChonkVerifierPrivateInputs, PublicChonkVerifierPublicInputs, type PublicTxBaseRollupPrivateInputs, type RootRollupPrivateInputs, type RootRollupPublicInputs, type TxMergeRollupPrivateInputs, type TxRollupPublicInputs } from '@aztec/stdlib/rollup';
import { type TelemetryClient } from '@aztec/telemetry-client';
type TestDelay = {
    proverTestDelayType: 'fixed';
    proverTestDelayMs?: number;
} | {
    proverTestDelayType: 'realistic';
    proverTestDelayFactor?: number;
};
/**
 * A class for use in testing situations (e2e, unit test, etc) and temporarily for assembling a block in the sequencer.
 * Simulates circuits using the most efficient method and performs no proving.
 */
export declare class TestCircuitProver implements ServerCircuitProver {
    private simulator?;
    private opts;
    private wasmSimulator;
    private instrumentation;
    private logger;
    constructor(simulator?: CircuitSimulator | undefined, opts?: TestDelay, telemetry?: TelemetryClient);
    get tracer(): import("@aztec/telemetry-client").Tracer;
    /**
     * Simulates the base parity circuit from its inputs.
     * @param inputs - Inputs to the circuit.
     * @returns The public inputs of the parity circuit.
     */
    getBaseParityProof(inputs: ParityBasePrivateInputs): Promise<PublicInputsAndRecursiveProof<ParityPublicInputs, typeof RECURSIVE_PROOF_LENGTH>>;
    /**
     * Simulates the root parity circuit from its inputs.
     * @param inputs - Inputs to the circuit.
     * @returns The public inputs of the parity circuit.
     */
    getRootParityProof(inputs: ParityRootPrivateInputs): Promise<PublicInputsAndRecursiveProof<ParityPublicInputs, typeof NESTED_RECURSIVE_PROOF_LENGTH>>;
    getPublicChonkVerifierProof(inputs: PublicChonkVerifierPrivateInputs): Promise<PublicInputsAndRecursiveProof<PublicChonkVerifierPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getPrivateTxBaseRollupProof(inputs: PrivateTxBaseRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<TxRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getPublicTxBaseRollupProof(inputs: PublicTxBaseRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<TxRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    /**
     * Simulates the merge rollup circuit from its inputs.
     * @param input - Inputs to the circuit.
     * @returns The public inputs as outputs of the simulation.
     */
    getTxMergeRollupProof(input: TxMergeRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<TxRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getBlockRootFirstRollupProof(input: BlockRootFirstRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<BlockRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getBlockRootSingleTxFirstRollupProof(input: BlockRootSingleTxFirstRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<BlockRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getBlockRootEmptyTxFirstRollupProof(input: BlockRootEmptyTxFirstRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<BlockRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getBlockRootRollupProof(input: BlockRootRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<BlockRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getBlockRootSingleTxRollupProof(input: BlockRootSingleTxRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<BlockRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getBlockMergeRollupProof(input: BlockMergeRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<BlockRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getCheckpointRootRollupProof(input: CheckpointRootRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<CheckpointRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getCheckpointRootSingleBlockRollupProof(input: CheckpointRootSingleBlockRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<CheckpointRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getCheckpointPaddingRollupProof(input: CheckpointPaddingRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<CheckpointRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    getCheckpointMergeRollupProof(input: CheckpointMergeRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<CheckpointRollupPublicInputs, typeof NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH>>;
    /**
     * Simulates the root rollup circuit from its inputs.
     * @param input - Inputs to the circuit.
     * @returns The public inputs as outputs of the simulation.
     */
    getRootRollupProof(input: RootRollupPrivateInputs): Promise<PublicInputsAndRecursiveProof<RootRollupPublicInputs>>;
    getAvmProof(_inputs: AvmCircuitInputs): Promise<RecursiveProof<typeof AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED>>;
    private applyDelay;
    verifyProof(_1: ServerProtocolArtifact, _2: Proof): Promise<void>;
    private simulate;
}
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdF9jaXJjdWl0X3Byb3Zlci5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Rlc3QvdGVzdF9jaXJjdWl0X3Byb3Zlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsb0NBQW9DLEVBQ3BDLDZCQUE2QixFQUM3Qix5Q0FBeUMsRUFDekMsc0JBQXNCLEVBQ3ZCLE1BQU0sa0JBQWtCLENBQUM7QUFJMUIsT0FBTyxFQUNMLEtBQUssc0JBQXNCLEVBbUM1QixNQUFNLDRDQUE0QyxDQUFDO0FBSXBELE9BQU8sRUFBRSxLQUFLLGdCQUFnQixFQUFzRCxNQUFNLHlCQUF5QixDQUFDO0FBQ3BILE9BQU8sS0FBSyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDMUQsT0FBTyxFQUNMLEtBQUssNkJBQTZCLEVBQ2xDLEtBQUssbUJBQW1CLEVBRXpCLE1BQU0saUNBQWlDLENBQUM7QUFDekMsT0FBTyxLQUFLLEVBQUUsdUJBQXVCLEVBQUUsa0JBQWtCLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNqSCxPQUFPLEVBQ0wsS0FBSyxLQUFLLEVBRVYsY0FBYyxFQUdmLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUNMLEtBQUssNkJBQTZCLEVBQ2xDLEtBQUssdUJBQXVCLEVBQzVCLEtBQUssd0NBQXdDLEVBQzdDLEtBQUssaUNBQWlDLEVBQ3RDLEtBQUssNEJBQTRCLEVBQ2pDLEtBQUsseUNBQXlDLEVBQzlDLEtBQUssb0NBQW9DLEVBQ3pDLEtBQUssa0NBQWtDLEVBQ3ZDLEtBQUssb0NBQW9DLEVBQ3pDLEtBQUssNEJBQTRCLEVBQ2pDLEtBQUssaUNBQWlDLEVBQ3RDLEtBQUssNENBQTRDLEVBQ2pELEtBQUssZ0NBQWdDLEVBQ3JDLEtBQUssZ0NBQWdDLEVBQ3JDLCtCQUErQixFQUMvQixLQUFLLCtCQUErQixFQUNwQyxLQUFLLHVCQUF1QixFQUM1QixLQUFLLHNC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