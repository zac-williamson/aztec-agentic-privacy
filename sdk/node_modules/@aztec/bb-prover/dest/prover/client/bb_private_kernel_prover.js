import { AztecClientBackend, Barretenberg } from '@aztec/bb.js';
import { createLogger } from '@aztec/foundation/log';
import { Timer } from '@aztec/foundation/timer';
import { serializeWitness } from '@aztec/noir-noirc_abi';
import { convertHidingKernelPublicInputsToWitnessMapWithAbi, convertHidingKernelToRollupInputsToWitnessMapWithAbi, convertPrivateKernelInitInputsToWitnessMapWithAbi, convertPrivateKernelInitOutputsFromWitnessMapWithAbi, convertPrivateKernelInnerInputsToWitnessMapWithAbi, convertPrivateKernelInnerOutputsFromWitnessMapWithAbi, convertPrivateKernelResetInputsToWitnessMapWithAbi, convertPrivateKernelResetOutputsFromWitnessMapWithAbi, convertPrivateKernelTailForPublicOutputsFromWitnessMapWithAbi, convertPrivateKernelTailInputsToWitnessMapWithAbi, convertPrivateKernelTailOutputsFromWitnessMapWithAbi, convertPrivateKernelTailToPublicInputsToWitnessMapWithAbi, foreignCallHandler, getPrivateKernelResetArtifactName, updateResetCircuitSampleInputs } from '@aztec/noir-protocol-circuits-types/client';
import { mapProtocolArtifactNameToCircuitName } from '@aztec/noir-protocol-circuits-types/types';
import { ChonkProofWithPublicInputs } from '@aztec/stdlib/proofs';
import { ungzip } from 'pako';
export class BBPrivateKernelProver {
    artifactProvider;
    simulator;
    options;
    log;
    constructor(artifactProvider, simulator, options = {}){
        this.artifactProvider = artifactProvider;
        this.simulator = simulator;
        this.options = options;
        this.log = options.logger || createLogger('bb-prover:private-kernel');
    }
    async generateInitOutput(inputs) {
        return await this.generateCircuitOutput(inputs, 'PrivateKernelInitArtifact', convertPrivateKernelInitInputsToWitnessMapWithAbi, convertPrivateKernelInitOutputsFromWitnessMapWithAbi);
    }
    async simulateInit(inputs) {
        return await this.simulateCircuitOutput(inputs, 'PrivateKernelInitArtifact', convertPrivateKernelInitInputsToWitnessMapWithAbi, convertPrivateKernelInitOutputsFromWitnessMapWithAbi);
    }
    async generateInnerOutput(inputs) {
        return await this.generateCircuitOutput(inputs, 'PrivateKernelInnerArtifact', convertPrivateKernelInnerInputsToWitnessMapWithAbi, convertPrivateKernelInnerOutputsFromWitnessMapWithAbi);
    }
    async simulateInner(inputs) {
        return await this.simulateCircuitOutput(inputs, 'PrivateKernelInnerArtifact', convertPrivateKernelInnerInputsToWitnessMapWithAbi, convertPrivateKernelInnerOutputsFromWitnessMapWithAbi);
    }
    async generateResetOutput(inputs) {
        const variantInputs = inputs.trimToSizes();
        const artifactName = getPrivateKernelResetArtifactName(inputs.dimensions);
        return await this.generateCircuitOutput(variantInputs, artifactName, convertPrivateKernelResetInputsToWitnessMapWithAbi, convertPrivateKernelResetOutputsFromWitnessMapWithAbi);
    }
    async simulateReset(inputs) {
        updateResetCircuitSampleInputs(inputs);
        const variantInputs = inputs.trimToSizes();
        const artifactName = getPrivateKernelResetArtifactName(inputs.dimensions);
        return await this.simulateCircuitOutput(variantInputs, artifactName, convertPrivateKernelResetInputsToWitnessMapWithAbi, convertPrivateKernelResetOutputsFromWitnessMapWithAbi);
    }
    async generateTailOutput(inputs) {
        if (!inputs.isForPublic()) {
            return await this.generateCircuitOutput(inputs, 'PrivateKernelTailArtifact', convertPrivateKernelTailInputsToWitnessMapWithAbi, convertPrivateKernelTailOutputsFromWitnessMapWithAbi);
        }
        return await this.generateCircuitOutput(inputs, 'PrivateKernelTailToPublicArtifact', convertPrivateKernelTailToPublicInputsToWitnessMapWithAbi, convertPrivateKernelTailForPublicOutputsFromWitnessMapWithAbi);
    }
    async simulateTail(inputs) {
        if (!inputs.isForPublic()) {
            return await this.simulateCircuitOutput(inputs, 'PrivateKernelTailArtifact', convertPrivateKernelTailInputsToWitnessMapWithAbi, convertPrivateKernelTailOutputsFromWitnessMapWithAbi);
        }
        return await this.simulateCircuitOutput(inputs, 'PrivateKernelTailToPublicArtifact', convertPrivateKernelTailToPublicInputsToWitnessMapWithAbi, convertPrivateKernelTailForPublicOutputsFromWitnessMapWithAbi);
    }
    async generateHidingToRollupOutput(inputs) {
        return await this.generateCircuitOutput(inputs, 'HidingKernelToRollup', convertHidingKernelToRollupInputsToWitnessMapWithAbi, convertPrivateKernelTailOutputsFromWitnessMapWithAbi);
    }
    async generateHidingToPublicOutput(inputs) {
        return await this.generateCircuitOutput(inputs, 'HidingKernelToPublic', convertHidingKernelPublicInputsToWitnessMapWithAbi, convertPrivateKernelTailForPublicOutputsFromWitnessMapWithAbi);
    }
    async simulateCircuitOutput(inputs, circuitType, convertInputs, convertOutputs) {
        const compiledCircuit = await this.artifactProvider.getSimulatedClientCircuitArtifactByName(circuitType);
        const witnessMap = convertInputs(inputs, compiledCircuit.abi);
        const outputWitness = await this.simulator.executeProtocolCircuit(witnessMap, compiledCircuit, foreignCallHandler).catch((err)=>{
            this.log.debug(`Failed to simulate ${circuitType}`, {
                circuitName: mapProtocolArtifactNameToCircuitName(circuitType),
                error: err
            });
            throw err;
        });
        const output = convertOutputs(outputWitness.witness, compiledCircuit.abi);
        this.log.debug(`Simulated ${circuitType}`, {
            eventName: 'circuit-simulation',
            circuitName: mapProtocolArtifactNameToCircuitName(circuitType),
            duration: outputWitness.duration,
            inputSize: inputs.toBuffer().length,
            outputSize: output.toBuffer().length
        });
        return this.makeEmptyKernelSimulateOutput(output, circuitType);
    }
    async generateCircuitOutput(inputs, circuitType, convertInputs, convertOutputs) {
        this.log.debug(`Generating witness for ${circuitType}`);
        const compiledCircuit = await this.artifactProvider.getClientCircuitArtifactByName(circuitType);
        const witnessMap = convertInputs(inputs, compiledCircuit.abi);
        const outputWitness = await this.simulator.executeProtocolCircuit(witnessMap, compiledCircuit, foreignCallHandler);
        const output = convertOutputs(outputWitness.witness, compiledCircuit.abi);
        this.log.debug(`Generated witness for ${circuitType}`, {
            eventName: 'circuit-witness-generation',
            circuitName: mapProtocolArtifactNameToCircuitName(circuitType),
            duration: outputWitness.duration,
            inputSize: inputs.toBuffer().length,
            outputSize: output.toBuffer().length
        });
        const verificationKey = await this.artifactProvider.getCircuitVkByName(circuitType);
        const bytecode = Buffer.from(compiledCircuit.bytecode, 'base64');
        const kernelOutput = {
            publicInputs: output,
            verificationKey,
            outputWitness: outputWitness.witness,
            bytecode
        };
        return kernelOutput;
    }
    async makeEmptyKernelSimulateOutput(publicInputs, circuitType) {
        const kernelProofOutput = {
            publicInputs,
            verificationKey: await this.artifactProvider.getCircuitVkByName(circuitType),
            outputWitness: new Map(),
            bytecode: Buffer.from([])
        };
        return kernelProofOutput;
    }
    async createChonkProof(executionSteps) {
        const timer = new Timer();
        this.log.info(`Generating ClientIVC proof...`);
        const barretenberg = await Barretenberg.initSingleton({
            ...this.options,
            logger: this.options.logger?.[process.env.LOG_LEVEL || 'verbose']
        });
        const backend = new AztecClientBackend(executionSteps.map((step)=>ungzip(step.bytecode)), barretenberg, executionSteps.map((step)=>step.functionName));
        const [proof] = await backend.prove(executionSteps.map((step)=>ungzip(serializeWitness(step.witness))), executionSteps.map((step)=>step.vk));
        this.log.info(`Generated ClientIVC proof`, {
            eventName: 'client-ivc-proof-generation',
            duration: timer.ms(),
            proofSize: proof.length
        });
        return ChonkProofWithPublicInputs.fromBufferArray(proof);
    }
    async computeGateCountForCircuit(_bytecode, _circuitName) {
        // Note we do not pass the vk to the backend. This is unneeded for gate counts.
        const barretenberg = await Barretenberg.initSingleton({
            ...this.options,
            logger: this.options.logger?.[process.env.LOG_LEVEL || 'verbose']
        });
        const backend = new AztecClientBackend([
            ungzip(_bytecode)
        ], barretenberg, [
            _circuitName
        ]);
        const gateCount = await backend.gates();
        return gateCount[0];
    }
}
