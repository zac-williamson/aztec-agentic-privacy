function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
var _dec, _dec1, _dec2, _initProto;
import { AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED, NESTED_RECURSIVE_PROOF_LENGTH, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, PAIRING_POINTS_SIZE, RECURSIVE_PROOF_LENGTH, ULTRA_KECCAK_PROOF_LENGTH } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { runInDirectory } from '@aztec/foundation/fs';
import { createLogger } from '@aztec/foundation/log';
import { BufferReader } from '@aztec/foundation/serialize';
import { convertBlockMergeRollupOutputsFromWitnessMap, convertBlockMergeRollupPrivateInputsToWitnessMap, convertBlockRootEmptyTxFirstRollupOutputsFromWitnessMap, convertBlockRootEmptyTxFirstRollupPrivateInputsToWitnessMap, convertBlockRootFirstRollupOutputsFromWitnessMap, convertBlockRootFirstRollupPrivateInputsToWitnessMap, convertBlockRootRollupOutputsFromWitnessMap, convertBlockRootRollupPrivateInputsToWitnessMap, convertBlockRootSingleTxFirstRollupOutputsFromWitnessMap, convertBlockRootSingleTxFirstRollupPrivateInputsToWitnessMap, convertBlockRootSingleTxRollupOutputsFromWitnessMap, convertBlockRootSingleTxRollupPrivateInputsToWitnessMap, convertCheckpointMergeRollupOutputsFromWitnessMap, convertCheckpointMergeRollupPrivateInputsToWitnessMap, convertCheckpointPaddingRollupOutputsFromWitnessMap, convertCheckpointPaddingRollupPrivateInputsToWitnessMap, convertCheckpointRootRollupOutputsFromWitnessMap, convertCheckpointRootRollupPrivateInputsToWitnessMap, convertCheckpointRootSingleBlockRollupOutputsFromWitnessMap, convertCheckpointRootSingleBlockRollupPrivateInputsToWitnessMap, convertParityBaseOutputsFromWitnessMap, convertParityBasePrivateInputsToWitnessMap, convertParityRootOutputsFromWitnessMap, convertParityRootPrivateInputsToWitnessMap, convertPrivateTxBaseRollupOutputsFromWitnessMap, convertPrivateTxBaseRollupPrivateInputsToWitnessMap, convertPublicChonkVerifierOutputsFromWitnessMap, convertPublicChonkVerifierPrivateInputsToWitnessMap, convertPublicTxBaseRollupOutputsFromWitnessMap, convertPublicTxBaseRollupPrivateInputsToWitnessMap, convertRootRollupOutputsFromWitnessMap, convertRootRollupPrivateInputsToWitnessMap, convertTxMergeRollupOutputsFromWitnessMap, convertTxMergeRollupPrivateInputsToWitnessMap, getServerCircuitArtifact } from '@aztec/noir-protocol-circuits-types/server';
import { ServerCircuitVks } from '@aztec/noir-protocol-circuits-types/server/vks';
import { mapProtocolArtifactNameToCircuitName } from '@aztec/noir-protocol-circuits-types/types';
import { NativeACVMSimulator } from '@aztec/simulator/server';
import { ProvingError } from '@aztec/stdlib/errors';
import { makePublicInputsAndRecursiveProof } from '@aztec/stdlib/interfaces/server';
import { Proof, RecursiveProof, makeRecursiveProofFromBinary } from '@aztec/stdlib/proofs';
import { Attributes, getTelemetryClient, trackSpan } from '@aztec/telemetry-client';
import { promises as fs } from 'fs';
import * as path from 'path';
import { BB_RESULT, PROOF_FILENAME, PUBLIC_INPUTS_FILENAME, VK_FILENAME, generateAvmProof, generateProof, verifyAvmProof, verifyProof } from '../../bb/execute.js';
import { getUltraHonkFlavorForCircuit } from '../../honk.js';
import { ProverInstrumentation } from '../../instrumentation.js';
import { readProofsFromOutputDirectory } from '../proof_utils.js';
const logger = createLogger('bb-prover');
_dec = trackSpan('BBNativeRollupProver.getBaseParityProof', {
    [Attributes.PROTOCOL_CIRCUIT_NAME]: 'parity-base'
}), _dec1 = trackSpan('BBNativeRollupProver.getRootParityProof', {
    [Attributes.PROTOCOL_CIRCUIT_NAME]: 'parity-root'
}), _dec2 = trackSpan('BBNativeRollupProver.getAvmProof', (inputs)=>({
        [Attributes.APP_CIRCUIT_NAME]: inputs.hints.tx.hash
    }));
/**
 * Prover implementation that uses barretenberg native proving
 */ export class BBNativeRollupProver {
    config;
    static{
        ({ e: [_initProto] } = _apply_decs_2203_r(this, [
            [
                _dec,
                2,
                "getBaseParityProof"
            ],
            [
                _dec1,
                2,
                "getRootParityProof"
            ],
            [
                _dec2,
                2,
                "getAvmProof"
            ]
        ], []));
    }
    instrumentation;
    constructor(config, telemetry){
        this.config = config;
        _initProto(this);
        this.instrumentation = new ProverInstrumentation(telemetry, 'BBNativeRollupProver');
    }
    get tracer() {
        return this.instrumentation.tracer;
    }
    static async new(config, telemetry = getTelemetryClient()) {
        await fs.access(config.acvmBinaryPath, fs.constants.R_OK);
        await fs.mkdir(config.acvmWorkingDirectory, {
            recursive: true
        });
        await fs.access(config.bbBinaryPath, fs.constants.R_OK);
        await fs.mkdir(config.bbWorkingDirectory, {
            recursive: true
        });
        logger.info(`Using native BB at ${config.bbBinaryPath} and working directory ${config.bbWorkingDirectory}`);
        logger.info(`Using native ACVM at ${config.acvmBinaryPath} and working directory ${config.acvmWorkingDirectory}`);
        return new BBNativeRollupProver(config, telemetry);
    }
    /**
   * Simulates the base parity circuit from its inputs.
   * @param inputs - Inputs to the circuit.
   * @returns The public inputs of the parity circuit.
   */ getBaseParityProof(inputs) {
        return this.createRecursiveProofAndVerify(inputs, 'ParityBaseArtifact', RECURSIVE_PROOF_LENGTH, convertParityBasePrivateInputsToWitnessMap, convertParityBaseOutputsFromWitnessMap);
    }
    /**
   * Simulates the root parity circuit from its inputs.
   * @param inputs - Inputs to the circuit.
   * @returns The public inputs of the parity circuit.
   */ getRootParityProof(inputs) {
        return this.createRecursiveProofAndVerify(inputs, 'ParityRootArtifact', NESTED_RECURSIVE_PROOF_LENGTH, convertParityRootPrivateInputsToWitnessMap, convertParityRootOutputsFromWitnessMap);
    }
    /**
   * Creates an AVM proof and verifies it.
   * @param inputs - The inputs to the AVM circuit.
   * @returns The proof.
   */ async getAvmProof(inputs) {
        const proof = await this.createAvmProof(inputs);
        await this.verifyAvmProof(proof.binaryProof, inputs.publicInputs);
        return proof;
    }
    async getPublicChonkVerifierProof(inputs) {
        const artifactName = 'PublicChonkVerifier';
        const { circuitOutput, proof } = await this.createRecursiveProof(inputs, artifactName, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertPublicChonkVerifierPrivateInputsToWitnessMap, convertPublicChonkVerifierOutputsFromWitnessMap);
        const verificationKey = this.getVerificationKeyDataForCircuit(artifactName);
        await this.verifyProof(artifactName, proof.binaryProof);
        return makePublicInputsAndRecursiveProof(circuitOutput, proof, verificationKey);
    }
    /**
   * Simulates the base rollup circuit from its inputs.
   * @param inputs - Inputs to the circuit.
   * @returns The public inputs as outputs of the simulation.
   */ getPrivateTxBaseRollupProof(inputs) {
        return this.createRecursiveProofAndVerify(inputs, 'PrivateTxBaseRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertPrivateTxBaseRollupPrivateInputsToWitnessMap, convertPrivateTxBaseRollupOutputsFromWitnessMap);
    }
    /**
   * Requests that the public kernel tail circuit be executed and the proof generated
   * @param kernelRequest - The object encapsulating the request for a proof
   * @returns The requested circuit's public inputs and proof
   */ getPublicTxBaseRollupProof(inputs) {
        return this.createRecursiveProofAndVerify(inputs, 'PublicTxBaseRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertPublicTxBaseRollupPrivateInputsToWitnessMap, convertPublicTxBaseRollupOutputsFromWitnessMap);
    }
    /**
   * Simulates the merge rollup circuit from its inputs.
   * @param input - Inputs to the circuit.
   * @returns The public inputs as outputs of the simulation.
   */ getTxMergeRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'TxMergeRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertTxMergeRollupPrivateInputsToWitnessMap, convertTxMergeRollupOutputsFromWitnessMap);
    }
    getBlockRootFirstRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'BlockRootFirstRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertBlockRootFirstRollupPrivateInputsToWitnessMap, convertBlockRootFirstRollupOutputsFromWitnessMap);
    }
    getBlockRootSingleTxFirstRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'BlockRootSingleTxFirstRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertBlockRootSingleTxFirstRollupPrivateInputsToWitnessMap, convertBlockRootSingleTxFirstRollupOutputsFromWitnessMap);
    }
    getBlockRootEmptyTxFirstRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'BlockRootEmptyTxFirstRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertBlockRootEmptyTxFirstRollupPrivateInputsToWitnessMap, convertBlockRootEmptyTxFirstRollupOutputsFromWitnessMap);
    }
    getBlockRootRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'BlockRootRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertBlockRootRollupPrivateInputsToWitnessMap, convertBlockRootRollupOutputsFromWitnessMap);
    }
    getBlockRootSingleTxRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'BlockRootSingleTxRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertBlockRootSingleTxRollupPrivateInputsToWitnessMap, convertBlockRootSingleTxRollupOutputsFromWitnessMap);
    }
    getBlockMergeRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'BlockMergeRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertBlockMergeRollupPrivateInputsToWitnessMap, convertBlockMergeRollupOutputsFromWitnessMap);
    }
    getCheckpointRootRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'CheckpointRootRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertCheckpointRootRollupPrivateInputsToWitnessMap, convertCheckpointRootRollupOutputsFromWitnessMap);
    }
    getCheckpointRootSingleBlockRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'CheckpointRootSingleBlockRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertCheckpointRootSingleBlockRollupPrivateInputsToWitnessMap, convertCheckpointRootSingleBlockRollupOutputsFromWitnessMap);
    }
    getCheckpointPaddingRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'CheckpointPaddingRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertCheckpointPaddingRollupPrivateInputsToWitnessMap, convertCheckpointPaddingRollupOutputsFromWitnessMap);
    }
    getCheckpointMergeRollupProof(input) {
        return this.createRecursiveProofAndVerify(input, 'CheckpointMergeRollupArtifact', NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, convertCheckpointMergeRollupPrivateInputsToWitnessMap, convertCheckpointMergeRollupOutputsFromWitnessMap);
    }
    /**
   * Simulates the root rollup circuit from its inputs.
   * @param input - Inputs to the circuit.
   * @returns The public inputs as outputs of the simulation.
   */ async getRootRollupProof(input) {
        const { proof, ...output } = await this.createRecursiveProofAndVerify(input, 'RootRollupArtifact', ULTRA_KECCAK_PROOF_LENGTH, convertRootRollupPrivateInputsToWitnessMap, convertRootRollupOutputsFromWitnessMap);
        const recursiveProof = makeRecursiveProofFromBinary(proof.binaryProof, NESTED_RECURSIVE_PROOF_LENGTH);
        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/13188): Remove this hack.
        recursiveProof.binaryProof.numPublicInputs += PAIRING_POINTS_SIZE;
        return {
            ...output,
            proof: recursiveProof
        };
    }
    async createRecursiveProofAndVerify(input, artifactName, proofLength, convertInput, convertOutput) {
        const { circuitOutput, proof } = await this.createRecursiveProof(input, artifactName, proofLength, convertInput, convertOutput);
        await this.verifyProof(artifactName, proof.binaryProof);
        const verificationKey = this.getVerificationKeyDataForCircuit(artifactName);
        return makePublicInputsAndRecursiveProof(circuitOutput, proof, verificationKey);
    }
    async generateProofWithBB(input, circuitType, convertInput, convertOutput, workingDirectory) {
        // Have the ACVM write the partial witness here
        const outputWitnessFile = path.join(workingDirectory, 'partial-witness.gz');
        // Generate the partial witness using the ACVM
        // A further temp directory will be created beneath ours and then cleaned up after the partial witness has been copied to our specified location
        const simulator = new NativeACVMSimulator(this.config.acvmWorkingDirectory, this.config.acvmBinaryPath, outputWitnessFile, logger);
        const artifact = getServerCircuitArtifact(circuitType);
        logger.debug(`Generating witness data for ${circuitType}`);
        const inputWitness = convertInput(input);
        const foreignCallHandler = undefined; // We don't handle foreign calls in the native ACVM simulator
        const witnessResult = await simulator.executeProtocolCircuit(inputWitness, artifact, foreignCallHandler);
        const output = convertOutput(witnessResult.witness);
        const circuitName = mapProtocolArtifactNameToCircuitName(circuitType);
        this.instrumentation.recordDuration('witGenDuration', circuitName, witnessResult.duration);
        this.instrumentation.recordSize('witGenInputSize', circuitName, input.toBuffer().length);
        this.instrumentation.recordSize('witGenOutputSize', circuitName, output.toBuffer().length);
        logger.info(`Generated witness`, {
            circuitName,
            duration: witnessResult.duration,
            inputSize: input.toBuffer().length,
            outputSize: output.toBuffer().length,
            eventName: 'circuit-witness-generation'
        });
        // Now prove the circuit from the generated witness
        logger.debug(`Proving ${circuitType}...`);
        const provingResult = await generateProof(this.config.bbBinaryPath, workingDirectory, circuitType, Buffer.from(artifact.bytecode, 'base64'), this.getVerificationKeyDataForCircuit(circuitType).keyAsBytes, outputWitnessFile, getUltraHonkFlavorForCircuit(circuitType), logger);
        if (provingResult.status === BB_RESULT.FAILURE) {
            logger.error(`Failed to generate proof for ${circuitType}: ${provingResult.reason}`);
            throw new ProvingError(provingResult.reason, provingResult, provingResult.retry);
        }
        return {
            circuitOutput: output,
            provingResult
        };
    }
    async generateAvmProofWithBB(input, workingDirectory) {
        logger.info(`Proving avm-circuit for TX ${input.hints.tx.hash}...`);
        const provingResult = await generateAvmProof(this.config.bbBinaryPath, workingDirectory, input, logger);
        if (provingResult.status === BB_RESULT.FAILURE) {
            logger.error(`Failed to generate AVM proof for TX ${input.hints.tx.hash}: ${provingResult.reason}`);
            throw new ProvingError(provingResult.reason, provingResult, provingResult.retry);
        }
        return provingResult;
    }
    async createAvmProof(input) {
        const operation = async (bbWorkingDirectory)=>{
            const provingResult = await this.generateAvmProofWithBB(input, bbWorkingDirectory);
            const avmProof = await this.readAvmProofAsFields(provingResult.proofPath);
            const circuitType = 'avm-circuit';
            const appCircuitName = 'unknown';
            this.instrumentation.recordAvmDuration('provingDuration', appCircuitName, provingResult.durationMs);
            this.instrumentation.recordAvmSize('proofSize', appCircuitName, avmProof.binaryProof.buffer.length);
            logger.info(`Generated proof for ${circuitType}(${input.hints.tx.hash}) in ${Math.ceil(provingResult.durationMs)} ms`, {
                circuitName: circuitType,
                appCircuitName: input.hints.tx.hash,
                // does not include reading the proof from disk
                duration: provingResult.durationMs,
                proofSize: avmProof.binaryProof.buffer.length,
                eventName: 'circuit-proving',
                inputSize: input.serializeWithMessagePack().length,
                circuitSize: 1 << 21,
                numPublicInputs: 0
            });
            return avmProof;
        };
        return await this.runInDirectory(operation);
    }
    /**
   * Executes a circuit and returns its outputs and corresponding proof with embedded aggregation object
   * @param witnessMap - The input witness
   * @param circuitType - The type of circuit to be executed
   * @param proofLength - The length of the proof to be generated. This is a dummy parameter to aid in type checking
   * @param convertInput - Function for mapping the input object to a witness map.
   * @param convertOutput - Function for parsing the output witness to it's corresponding object
   * @returns The circuits output object and it's proof
   */ async createRecursiveProof(input, circuitType, proofLength, convertInput, convertOutput) {
        // this probably is gonna need to call chonk
        const operation = async (bbWorkingDirectory)=>{
            const { provingResult, circuitOutput: output } = await this.generateProofWithBB(input, circuitType, convertInput, convertOutput, bbWorkingDirectory);
            const vkData = this.getVerificationKeyDataForCircuit(circuitType);
            // Read the proof as fields
            const proof = await readProofsFromOutputDirectory(provingResult.proofPath, vkData, proofLength, logger);
            const circuitName = mapProtocolArtifactNameToCircuitName(circuitType);
            this.instrumentation.recordDuration('provingDuration', circuitName, provingResult.durationMs);
            this.instrumentation.recordSize('proofSize', circuitName, proof.binaryProof.buffer.length);
            this.instrumentation.recordSize('circuitPublicInputCount', circuitName, vkData.numPublicInputs);
            this.instrumentation.recordSize('circuitSize', circuitName, vkData.circuitSize);
            logger.info(`Generated proof for ${circuitType} in ${Math.ceil(provingResult.durationMs)} ms, size: ${proof.proof.length} fields`, {
                circuitName,
                circuitSize: vkData.circuitSize,
                duration: provingResult.durationMs,
                inputSize: output.toBuffer().length,
                proofSize: proof.binaryProof.buffer.length,
                eventName: 'circuit-proving',
                numPublicInputs: vkData.numPublicInputs
            });
            return {
                circuitOutput: output,
                proof
            };
        };
        return await this.runInDirectory(operation);
    }
    /**
   * Verifies a proof, will generate the verification key if one is not cached internally
   * @param circuitType - The type of circuit whose proof is to be verified
   * @param proof - The proof to be verified
   */ async verifyProof(circuitType, proof) {
        const verificationKey = this.getVerificationKeyDataForCircuit(circuitType);
        return await this.verifyInternal(proof, verificationKey, (proofPath, vkPath)=>verifyProof(this.config.bbBinaryPath, proofPath, vkPath, getUltraHonkFlavorForCircuit(circuitType), logger));
    }
    async verifyAvmProof(proof, publicInputs) {
        return await this.verifyInternal(proof, /*verificationKey=*/ undefined, (proofPath, /*unused*/ _vkPath)=>verifyAvmProof(this.config.bbBinaryPath, this.config.bbWorkingDirectory, proofPath, publicInputs, logger));
    }
    async verifyInternal(proof, verificationKey, verificationFunction) {
        const operation = async (bbWorkingDirectory)=>{
            const publicInputsFileName = path.join(bbWorkingDirectory, PUBLIC_INPUTS_FILENAME);
            const proofFileName = path.join(bbWorkingDirectory, PROOF_FILENAME);
            const verificationKeyPath = path.join(bbWorkingDirectory, VK_FILENAME);
            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/13189): Put this proof parsing logic in the proof class.
            await fs.writeFile(publicInputsFileName, proof.buffer.subarray(0, proof.numPublicInputs * 32));
            await fs.writeFile(proofFileName, proof.buffer.subarray(proof.numPublicInputs * 32));
            if (verificationKey !== undefined) {
                await fs.writeFile(verificationKeyPath, verificationKey.keyAsBytes);
            }
            const result = await verificationFunction(proofFileName, verificationKeyPath);
            if (result.status === BB_RESULT.FAILURE) {
                const errorMessage = `Failed to verify proof from key!`;
                throw new ProvingError(errorMessage, result, result.retry);
            }
            logger.info(`Successfully verified proof from key in ${result.durationMs} ms`);
        };
        await this.runInDirectory(operation);
    }
    /**
   * Returns the verification key data for a circuit.
   * @param circuitType - The type of circuit for which the verification key is required
   * @returns The verification key data
   */ getVerificationKeyDataForCircuit(circuitType) {
        const vk = ServerCircuitVks[circuitType];
        if (vk === undefined) {
            throw new Error('Could not find VK for server artifact ' + circuitType);
        }
        return vk;
    }
    async readAvmProofAsFields(proofFilename) {
        const rawProofBuffer = await fs.readFile(proofFilename);
        const reader = BufferReader.asReader(rawProofBuffer);
        const proofFields = reader.readArray(rawProofBuffer.length / Fr.SIZE_IN_BYTES, Fr);
        // We extend to a fixed-size padded proof as during development any new AVM circuit column changes the
        // proof length and we do not have a mechanism to feedback a cpp constant to noir/TS.
        // TODO(#13390): Revive a non-padded AVM proof
        if (proofFields.length > AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED) {
            throw new Error(`Proof has ${proofFields.length} fields, expected no more than ${AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED}.`);
        }
        const proofFieldsPadded = proofFields.concat(Array(AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED - proofFields.length).fill(new Fr(0)));
        const proof = new Proof(rawProofBuffer, /*numPublicInputs=*/ 0);
        return new RecursiveProof(proofFieldsPadded, proof, true, AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED);
    }
    runInDirectory(fn) {
        return runInDirectory(this.config.bbWorkingDirectory, (dir)=>fn(dir).catch((err)=>{
                logger.error(`Error running operation at ${dir}: ${err}`);
                throw err;
            }), this.config.bbSkipCleanup, logger);
    }
}
