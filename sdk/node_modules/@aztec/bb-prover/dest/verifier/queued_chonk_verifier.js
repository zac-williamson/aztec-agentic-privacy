import { createLogger } from '@aztec/foundation/log';
import { SerialQueue } from '@aztec/foundation/queue';
import { Attributes, Metrics, createUpDownCounterWithDefault, getTelemetryClient } from '@aztec/telemetry-client';
import { createHistogram } from 'node:perf_hooks';
class IVCVerifierMetrics {
    ivcVerificationHistogram;
    ivcTotalVerificationHistogram;
    ivcFailureCount;
    localHistogramOk = createHistogram({
        min: 1,
        max: 5 * 60 * 1000
    });
    localHistogramFails = createHistogram({
        min: 1,
        max: 5 * 60 * 1000
    });
    aggDurationMetrics;
    constructor(client, name = 'QueuedIVCVerifier'){
        const meter = client.getMeter(name);
        this.ivcVerificationHistogram = meter.createHistogram(Metrics.IVC_VERIFIER_TIME);
        this.ivcTotalVerificationHistogram = meter.createHistogram(Metrics.IVC_VERIFIER_TOTAL_TIME);
        this.ivcFailureCount = createUpDownCounterWithDefault(meter, Metrics.IVC_VERIFIER_FAILURE_COUNT);
        this.aggDurationMetrics = {
            avg: meter.createObservableGauge(Metrics.IVC_VERIFIER_AGG_DURATION_AVG),
            max: meter.createObservableGauge(Metrics.IVC_VERIFIER_AGG_DURATION_MAX),
            min: meter.createObservableGauge(Metrics.IVC_VERIFIER_AGG_DURATION_MIN),
            p50: meter.createObservableGauge(Metrics.IVC_VERIFIER_AGG_DURATION_P50),
            p90: meter.createObservableGauge(Metrics.IVC_VERIFIER_AGG_DURATION_P90)
        };
        meter.addBatchObservableCallback(this.aggregate, Object.values(this.aggDurationMetrics));
    }
    recordIVCVerification(result) {
        this.ivcVerificationHistogram.record(Math.ceil(result.durationMs), {
            [Attributes.OK]: result.valid
        });
        this.ivcTotalVerificationHistogram.record(Math.ceil(result.totalDurationMs), {
            [Attributes.OK]: result.valid
        });
        if (!result.valid) {
            this.ivcFailureCount.add(1);
            this.localHistogramFails.record(Math.max(Math.ceil(result.durationMs), 1));
        } else {
            this.localHistogramOk.record(Math.max(Math.ceil(result.durationMs), 1));
        }
    }
    aggregate = (res)=>{
        for (const [histogram, ok] of [
            [
                this.localHistogramOk,
                true
            ],
            [
                this.localHistogramFails,
                false
            ]
        ]){
            if (histogram.count === 0) {
                continue;
            }
            res.observe(this.aggDurationMetrics.avg, histogram.mean, {
                [Attributes.OK]: ok
            });
            res.observe(this.aggDurationMetrics.max, histogram.max, {
                [Attributes.OK]: ok
            });
            res.observe(this.aggDurationMetrics.min, histogram.min, {
                [Attributes.OK]: ok
            });
            res.observe(this.aggDurationMetrics.p50, histogram.percentile(50), {
                [Attributes.OK]: ok
            });
            res.observe(this.aggDurationMetrics.p90, histogram.percentile(90), {
                [Attributes.OK]: ok
            });
        }
    };
}
export class QueuedIVCVerifier {
    verifier;
    telemetry;
    logger;
    queue;
    metrics;
    constructor(config, verifier, telemetry = getTelemetryClient(), logger = createLogger('bb-prover:queued_chonk_verifier')){
        this.verifier = verifier;
        this.telemetry = telemetry;
        this.logger = logger;
        this.metrics = new IVCVerifierMetrics(this.telemetry, 'QueuedIVCVerifier');
        this.queue = new SerialQueue();
        this.logger.info(`Starting QueuedIVCVerifier with ${config.numConcurrentIVCVerifiers} concurrent verifiers`);
        this.queue.start(config.numConcurrentIVCVerifiers);
    }
    async verifyProof(tx) {
        const result = await this.queue.put(()=>this.verifier.verifyProof(tx));
        this.metrics.recordIVCVerification(result);
        return result;
    }
    stop() {
        return this.queue.end();
    }
}
