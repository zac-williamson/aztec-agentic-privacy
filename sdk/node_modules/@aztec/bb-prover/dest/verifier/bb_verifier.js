import { runInDirectory } from '@aztec/foundation/fs';
import { createLogger } from '@aztec/foundation/log';
import { Timer } from '@aztec/foundation/timer';
import { ProtocolCircuitVks } from '@aztec/noir-protocol-circuits-types/server/vks';
import { mapProtocolArtifactNameToCircuitName } from '@aztec/noir-protocol-circuits-types/types';
import { promises as fs } from 'fs';
import * as path from 'path';
import { BB_RESULT, PROOF_FILENAME, PUBLIC_INPUTS_FILENAME, VK_FILENAME, verifyChonkProof, verifyProof } from '../bb/execute.js';
import { getUltraHonkFlavorForCircuit } from '../honk.js';
import { writeChonkProofToPath } from '../prover/proof_utils.js';
export class BBCircuitVerifier {
    config;
    logger;
    constructor(config, logger){
        this.config = config;
        this.logger = logger;
    }
    stop() {
        return Promise.resolve();
    }
    static async new(config, logger = createLogger('bb-prover:verifier')) {
        if (!config.bbWorkingDirectory) {
            throw new Error(`Barretenberg working directory (BB_WORKING_DIRECTORY) is not set`);
        }
        await fs.mkdir(config.bbWorkingDirectory, {
            recursive: true
        });
        return new BBCircuitVerifier(config, logger);
    }
    getVerificationKeyData(circuit) {
        const vk = ProtocolCircuitVks[circuit];
        if (vk === undefined) {
            throw new Error(`Could not find VK for artifact ${circuit}`);
        }
        return vk;
    }
    async verifyProofForCircuit(circuit, proof) {
        const operation = async (bbWorkingDirectory)=>{
            const publicInputsFileName = path.join(bbWorkingDirectory, PUBLIC_INPUTS_FILENAME);
            const proofFileName = path.join(bbWorkingDirectory, PROOF_FILENAME);
            const verificationKeyPath = path.join(bbWorkingDirectory, VK_FILENAME);
            const verificationKey = this.getVerificationKeyData(circuit);
            this.logger.debug(`${circuit} Verifying with key: ${verificationKey.keyAsFields.hash.toString()}`);
            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/13189): Put this proof parsing logic in the proof class.
            await fs.writeFile(publicInputsFileName, proof.buffer.slice(0, proof.numPublicInputs * 32));
            await fs.writeFile(proofFileName, proof.buffer.slice(proof.numPublicInputs * 32));
            await fs.writeFile(verificationKeyPath, verificationKey.keyAsBytes);
            const result = await verifyProof(this.config.bbBinaryPath, proofFileName, verificationKeyPath, getUltraHonkFlavorForCircuit(circuit), this.logger);
            if (result.status === BB_RESULT.FAILURE) {
                const errorMessage = `Failed to verify ${circuit} proof!`;
                throw new Error(errorMessage);
            }
            this.logger.debug(`${circuit} verification successful`, {
                circuitName: mapProtocolArtifactNameToCircuitName(circuit),
                duration: result.durationMs,
                eventName: 'circuit-verification',
                proofType: 'ultra-honk'
            });
        };
        await runInDirectory(this.config.bbWorkingDirectory, operation, this.config.bbSkipCleanup, this.logger);
    }
    async verifyProof(tx) {
        const proofType = 'Chonk';
        try {
            const totalTimer = new Timer();
            let verificationDuration = 0;
            const circuit = tx.data.forPublic ? 'HidingKernelToPublic' : 'HidingKernelToRollup';
            // Block below is almost copy-pasted from verifyProofForCircuit
            const operation = async (bbWorkingDirectory)=>{
                const proofPath = path.join(bbWorkingDirectory, PROOF_FILENAME);
                await writeChonkProofToPath(tx.chonkProof.attachPublicInputs(tx.data.publicInputs().toFields()), proofPath);
                const verificationKeyPath = path.join(bbWorkingDirectory, VK_FILENAME);
                const verificationKey = this.getVerificationKeyData(circuit);
                await fs.writeFile(verificationKeyPath, verificationKey.keyAsBytes);
                const timer = new Timer();
                const result = await verifyChonkProof(this.config.bbBinaryPath, proofPath, verificationKeyPath, this.logger, this.config.bbIVCConcurrency);
                verificationDuration = timer.ms();
                if (result.status === BB_RESULT.FAILURE) {
                    const errorMessage = `Failed to verify ${proofType} proof for ${circuit}!`;
                    throw new Error(errorMessage);
                }
                this.logger.debug(`${proofType} verification successful`, {
                    circuitName: mapProtocolArtifactNameToCircuitName(circuit),
                    duration: result.durationMs,
                    eventName: 'circuit-verification',
                    proofType: 'chonk'
                });
            };
            await runInDirectory(this.config.bbWorkingDirectory, operation, this.config.bbSkipCleanup, this.logger);
            return {
                valid: true,
                durationMs: verificationDuration,
                totalDurationMs: totalTimer.ms()
            };
        } catch (err) {
            this.logger.warn(`Failed to verify ${proofType} proof for tx ${tx.getTxHash().toString()}: ${String(err)}`);
            return {
                valid: false,
                durationMs: 0,
                totalDurationMs: 0
            };
        }
    }
}
