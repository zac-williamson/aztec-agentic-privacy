import { Ecdsa } from '@aztec/foundation/crypto/ecdsa';
import { AuthWitness } from '@aztec/stdlib/auth-witness';
import { DefaultAccountContract } from '../../defaults/account_contract.js';
/**
 * Account contract that authenticates transactions using ECDSA signatures
 * verified against a secp256r1 public key stored in an immutable encrypted note.
 * This abstract version does not provide a way to retrieve the artifact, as it
 * can be implemented with or without lazy loading.
 */ export class EcdsaRBaseAccountContract extends DefaultAccountContract {
    signingPrivateKey;
    constructor(signingPrivateKey){
        super(), this.signingPrivateKey = signingPrivateKey;
    }
    async getInitializationFunctionAndArgs() {
        const signingPublicKey = await new Ecdsa('secp256r1').computePublicKey(this.signingPrivateKey);
        return {
            constructorName: 'constructor',
            constructorArgs: [
                signingPublicKey.subarray(0, 32),
                signingPublicKey.subarray(32, 64)
            ]
        };
    }
    getAuthWitnessProvider(_address) {
        return new EcdsaRAuthWitnessProvider(this.signingPrivateKey);
    }
}
/** Creates auth witnesses using ECDSA signatures. */ class EcdsaRAuthWitnessProvider {
    signingPrivateKey;
    constructor(signingPrivateKey){
        this.signingPrivateKey = signingPrivateKey;
    }
    async createAuthWit(messageHash) {
        const ecdsa = new Ecdsa('secp256r1');
        const signature = await ecdsa.constructSignature(messageHash.toBuffer(), this.signingPrivateKey);
        return Promise.resolve(new AuthWitness(messageHash, [
            ...signature.r,
            ...signature.s
        ]));
    }
}
