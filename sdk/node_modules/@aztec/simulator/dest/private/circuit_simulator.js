import { abiDecodeError } from '@aztec/noir-noirc_abi';
import { parseDebugSymbols } from '@aztec/stdlib/abi';
import { extractCallStack } from './acvm/acvm.js';
// Payload parsing taken from noir/noir-repo/tooling/noir_js/src/witness_generation.ts.
// TODO: import this in isolation without having to import noir_js in its entirety.
export function enrichNoirError(artifact, originalError) {
    const enrichedError = originalError;
    if (originalError.rawAssertionPayload) {
        try {
            // Decode the payload
            const decodedPayload = abiDecodeError(artifact.abi, originalError.rawAssertionPayload);
            if (typeof decodedPayload === 'string') {
                // If it's a string, just add it to the error message
                enrichedError.message = `Circuit execution failed: ${decodedPayload}`;
            } else {
                // If not, attach the payload to the original error
                enrichedError.decodedAssertionPayload = decodedPayload;
            }
        } catch  {
        // Ignore errors decoding the payload
        }
    }
    try {
        // Decode the callstack
        const callStack = extractCallStack(originalError, {
            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/5813)
            // We only support handling debug info for the circuit entry point.
            // So for now we simply index into the first debug info.
            debugSymbols: parseDebugSymbols(artifact.debug_symbols)[0],
            files: artifact.file_map
        });
        enrichedError.noirCallStack = callStack?.map((errorLocation)=>{
            if (typeof errorLocation === 'string') {
                return `at opcode ${errorLocation}`;
            } else {
                return `at ${errorLocation.locationText} (${errorLocation.filePath}:${errorLocation.line}:${errorLocation.column})`;
            }
        });
    } catch  {
    // Ignore errors resolving the callstack
    }
    return enrichedError;
}
