/**
 * Takes a circuit simulator and wraps it in a circuit recorder. See CircuitRecorder for more details on how circuit
 * recording works.
 */ export class SimulatorRecorderWrapper {
    simulator;
    recorder;
    constructor(simulator, recorder){
        this.simulator = simulator;
        this.recorder = recorder;
    }
    executeProtocolCircuit(input, artifact, callback) {
        const bytecode = Buffer.from(artifact.bytecode, 'base64');
        return this.#simulate((wrappedCallback)=>this.simulator.executeProtocolCircuit(input, artifact, wrappedCallback), input, bytecode, artifact.name, 'main', callback);
    }
    executeUserCircuit(input, artifact, callback) {
        return this.#simulate((wrappedCallback)=>this.simulator.executeUserCircuit(input, artifact, wrappedCallback), input, artifact.bytecode, artifact.contractName, artifact.name, callback);
    }
    async #simulate(simulateFn, input, bytecode, contractName, functionName, callback) {
        // Start recording circuit execution
        await this.recorder.start(input, bytecode, contractName, functionName);
        // If callback was provided, we wrap it in a circuit recorder callback wrapper
        const wrappedCallback = this.recorder.wrapCallback(callback);
        let result;
        try {
            result = await simulateFn(wrappedCallback);
        } catch (error) {
            // If an error occurs, we finalize the recording file with the error
            await this.recorder.finishWithError(error);
            throw error;
        }
        // Witness generation is complete so we finish the circuit recorder
        const recording = await this.recorder.finish();
        result.oracles = recording.oracleCalls?.reduce((acc, { time, name })=>{
            if (!acc[name]) {
                acc[name] = {
                    times: []
                };
            }
            acc[name].times.push(time);
            return acc;
        }, {});
        return result;
    }
}
