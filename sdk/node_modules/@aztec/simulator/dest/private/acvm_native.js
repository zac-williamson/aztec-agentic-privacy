import { runInDirectory } from '@aztec/foundation/fs';
import { resolveLogger } from '@aztec/foundation/log';
import { Timer } from '@aztec/foundation/timer';
import * as proc from 'child_process';
import { promises as fs } from 'fs';
export var ACVM_RESULT = /*#__PURE__*/ function(ACVM_RESULT) {
    ACVM_RESULT[ACVM_RESULT["SUCCESS"] = 0] = "SUCCESS";
    ACVM_RESULT[ACVM_RESULT["FAILURE"] = 1] = "FAILURE";
    return ACVM_RESULT;
}({});
/**
 * Parses a TOML format witness map string into a Map structure
 * @param outputString - The witness map in TOML format
 * @returns The parsed witness map
 */ function parseIntoWitnessMap(outputString) {
    const lines = outputString.split('\n');
    return new Map(lines.filter((line)=>line.length).map((line)=>{
        const pair = line.replaceAll(' ', '').split('=');
        return [
            Number(pair[0]),
            pair[1].replaceAll('"', '')
        ];
    }));
}
/**
 *
 * @param inputWitness - The circuit's input witness
 * @param bytecode - The circuit bytecode
 * @param workingDirectory - A directory to use for temporary files by the ACVM
 * @param pathToAcvm - The path to the ACVM binary
 * @param outputFilename - If specified, the output will be stored as a file, encoded using Bincode
 * @returns The completed partial witness outputted from the circuit
 */ export async function executeNativeCircuit(inputWitness, bytecode, workingDirectory, pathToAcvm, outputFilename, loggerOrBindings) {
    const logger = resolveLogger('simulator:acvm-native', loggerOrBindings);
    const bytecodeFilename = 'bytecode';
    const witnessFilename = 'input_witness.toml';
    // convert the witness map to TOML format
    let witnessMap = '';
    inputWitness.forEach((value, key)=>{
        witnessMap = witnessMap.concat(`${key} = '${value}'\n`);
    });
    try {
        // Check that the directory exists
        await fs.access(workingDirectory);
    } catch  {
        return {
            status: 1,
            reason: `Working directory ${workingDirectory} does not exist`
        };
    }
    try {
        // Write the bytecode and input witness to the working directory
        await fs.writeFile(`${workingDirectory}/${bytecodeFilename}`, bytecode);
        await fs.writeFile(`${workingDirectory}/${witnessFilename}`, witnessMap);
        // Execute the ACVM using the given args
        const args = [
            `execute`,
            `--working-directory`,
            `${workingDirectory}`,
            `--bytecode`,
            `${bytecodeFilename}`,
            `--input-witness`,
            `${witnessFilename}`,
            '--print',
            '--output-witness',
            'output-witness'
        ];
        logger.debug(`Calling ACVM with ${args.join(' ')}`);
        const processPromise = new Promise((resolve, reject)=>{
            const outChunks = [];
            const errChunks = [];
            let outLen = 0;
            let errLen = 0;
            const acvm = proc.spawn(pathToAcvm, args);
            acvm.stdout.on('data', (data)=>{
                outChunks.push(data);
                outLen += data.length;
            });
            acvm.stderr.on('data', (data)=>{
                errChunks.push(data);
                errLen += data.length;
            });
            acvm.on('close', (code)=>{
                if (code === 0) {
                    resolve(Buffer.concat(outChunks, outLen).toString('utf-8'));
                } else {
                    const stderr = Buffer.concat(errChunks, errLen);
                    logger.error(`From ACVM: ${stderr.toString('utf-8')}`);
                    reject(stderr.toString('utf-8'));
                }
            });
        });
        const timer = new Timer();
        const output = await processPromise;
        const duration = timer.ms();
        if (outputFilename) {
            const outputWitnessFileName = `${workingDirectory}/output-witness.gz`;
            await fs.copyFile(outputWitnessFileName, outputFilename);
        }
        // TODO: We shouldn't be parsing the witness from stdout, it's not very performant, and we end up with two ways of fetching the witness.
        // We probably should implement the WitnessStack type, run the ACVM with msgpack serialization mode (env variable), and ungzip and parse the witness from
        // the outputted gz witness file.
        const witness = parseIntoWitnessMap(output);
        return {
            status: 0,
            witness,
            duration
        };
    } catch (error) {
        return {
            status: 1,
            reason: `${error}`
        };
    }
}
export class NativeACVMSimulator {
    workingDirectory;
    pathToAcvm;
    witnessFilename;
    logger;
    constructor(workingDirectory, pathToAcvm, witnessFilename, loggerOrBindings){
        this.workingDirectory = workingDirectory;
        this.pathToAcvm = pathToAcvm;
        this.witnessFilename = witnessFilename;
        this.logger = resolveLogger('simulator:acvm-native', loggerOrBindings);
    }
    async executeProtocolCircuit(input, artifact, callback) {
        // Execute the circuit on those initial witness values
        if (callback) {
            throw new Error('Native ACVM simulator does not support foreign calls. Ignoring callback.');
        }
        const operation = async (directory)=>{
            // Decode the bytecode from base64 since the acvm does not know about base64 encoding
            const decodedBytecode = Buffer.from(artifact.bytecode, 'base64');
            // Execute the circuit
            const result = await executeNativeCircuit(input, decodedBytecode, directory, this.pathToAcvm, this.witnessFilename, this.logger);
            if (result.status == 1) {
                throw new Error(`Failed to generate witness: ${result.reason}`);
            }
            return result;
        };
        return await runInDirectory(this.workingDirectory, operation, false, this.logger);
    }
    executeUserCircuit(_input, _artifact, _callback) {
        throw new Error('Not implemented');
    }
}
