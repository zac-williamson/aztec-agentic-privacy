import { Fr } from '@aztec/foundation/curves/bn254';
import { createLogger } from '@aztec/foundation/log';
import { FunctionSelector } from '@aztec/stdlib/abi';
import { deserializeFromMessagePack, serializeWithMessagePack } from '@aztec/stdlib/avm';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { ContractDeploymentData } from '@aztec/stdlib/contract';
export class ContractProviderForCpp {
    contractsDB;
    globalVariables;
    log;
    constructor(contractsDB, globalVariables, bindings){
        this.contractsDB = contractsDB;
        this.globalVariables = globalVariables;
        this.getContractInstance = async (address)=>{
            this.log.trace(`Contract provider callback: getContractInstance(${address})`);
            const aztecAddr = AztecAddress.fromString(address);
            const instance = await this.contractsDB.getContractInstance(aztecAddr, this.globalVariables.timestamp);
            if (!instance) {
                this.log.debug(`Contract instance not found: ${address}`);
                return undefined;
            }
            return serializeWithMessagePack(instance);
        };
        this.getContractClass = async (classId)=>{
            this.log.trace(`Contract provider callback: getContractClass(${classId})`);
            // Parse classId string to Fr
            const classIdFr = Fr.fromString(classId);
            // Fetch contract class from the contracts DB
            const contractClass = await this.contractsDB.getContractClass(classIdFr);
            if (!contractClass) {
                this.log.debug(`Contract class not found: ${classId}`);
                return undefined;
            }
            return serializeWithMessagePack(contractClass);
        };
        this.addContracts = async (contractDeploymentDataBuffer)=>{
            this.log.trace(`Contract provider callback: addContracts`);
            const rawData = deserializeFromMessagePack(contractDeploymentDataBuffer);
            // Construct ContractDeploymentData from plain object.
            const contractDeploymentData = ContractDeploymentData.fromPlainObject(rawData);
            // Add contracts to the contracts DB
            this.log.trace(`Calling contractsDB.addContracts`);
            await this.contractsDB.addContracts(contractDeploymentData);
        };
        this.getBytecodeCommitment = async (classId)=>{
            this.log.trace(`Contract provider callback: getBytecodeCommitment(${classId})`);
            // Parse classId string to Fr
            const classIdFr = Fr.fromString(classId);
            // Fetch bytecode commitment from the contracts DB
            const commitment = await this.contractsDB.getBytecodeCommitment(classIdFr);
            if (!commitment) {
                this.log.debug(`Bytecode commitment not found: ${classId}`);
                return undefined;
            }
            // Serialize the Fr to buffer
            return serializeWithMessagePack(commitment);
        };
        this.getDebugFunctionName = async (address, selector)=>{
            this.log.trace(`Contract provider callback: getDebugFunctionName(${address}, ${selector})`);
            // Parse address and selector strings
            const aztecAddr = AztecAddress.fromString(address);
            const selectorFr = Fr.fromString(selector);
            const functionSelector = FunctionSelector.fromFieldOrUndefined(selectorFr);
            if (!functionSelector) {
                this.log.trace(`calldata[0] is not a function selector: ${selector}`);
                return undefined;
            }
            // Fetch debug function name from the contracts DB
            const name = await this.contractsDB.getDebugFunctionName(aztecAddr, functionSelector);
            if (!name) {
                this.log.trace(`Debug function name not found for ${address}:${selector}`);
                return undefined;
            }
            return name;
        };
        this.createCheckpoint = ()=>{
            this.log.trace(`Contract provider callback: createCheckpoint`);
            return Promise.resolve(this.contractsDB.createCheckpoint());
        };
        this.commitCheckpoint = ()=>{
            this.log.trace(`Contract provider callback: commitCheckpoint`);
            return Promise.resolve(this.contractsDB.commitCheckpoint());
        };
        this.revertCheckpoint = ()=>{
            this.log.trace(`Contract provider callback: revertCheckpoint`);
            return Promise.resolve(this.contractsDB.revertCheckpoint());
        };
        this.log = createLogger('simulator:contract_provider_for_cpp', bindings);
    }
    getContractInstance;
    getContractClass;
    addContracts;
    getBytecodeCommitment;
    getDebugFunctionName;
    createCheckpoint;
    commitCheckpoint;
    revertCheckpoint;
}
