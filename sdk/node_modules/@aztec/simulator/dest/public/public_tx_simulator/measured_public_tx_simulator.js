import { Timer } from '@aztec/foundation/timer';
import { PublicTxSimulator } from './public_tx_simulator.js';
/**
 * A public tx simulator that tracks miscellaneous simulation metrics without telemetry.
 */ export class MeasuredPublicTxSimulator extends PublicTxSimulator {
    metrics;
    constructor(merkleTree, contractsDB, globalVariables, metrics, config){
        super(merkleTree, contractsDB, globalVariables, config), this.metrics = metrics;
    }
    async simulate(tx, txLabel = 'unlabeledTx') {
        this.metrics.startRecordingTxSimulation(txLabel);
        let avmResult;
        try {
            avmResult = await super.simulate(tx);
        } finally{
            this.metrics.stopRecordingTxSimulation(txLabel, avmResult?.gasUsed, avmResult?.revertCode);
        }
        return avmResult;
    }
    async insertNonRevertiblesFromPrivate(context) {
        const timer = new Timer();
        await super.insertNonRevertiblesFromPrivate(context);
        this.metrics.recordPrivateEffectsInsertion(timer.us(), 'non-revertible');
    }
    async insertRevertiblesFromPrivate(context) {
        const timer = new Timer();
        await super.insertRevertiblesFromPrivate(context);
        this.metrics.recordPrivateEffectsInsertion(timer.us(), 'revertible');
    }
    async simulatePhase(phase, context) {
        const timer = new Timer();
        const result = await super.simulatePhase(phase, context);
        result.durationMs = timer.ms();
        return result;
    }
    async simulateEnqueuedCallInternal(stateManager, callRequest, allocatedGas, transactionFee, fnName) {
        const timer = new Timer();
        const result = await super.simulateEnqueuedCallInternal(stateManager, callRequest, allocatedGas, transactionFee, fnName);
        this.log.verbose(result.reverted ? `Simulation of enqueued public call ${fnName} reverted with reason ${result.revertReason?.message}.` : `Simulation of enqueued public call ${fnName} completed successfully.`, {
            eventName: 'avm-simulation',
            appCircuitName: fnName,
            duration: timer.ms()
        });
        if (result.reverted) {
            this.metrics.recordEnqueuedCallSimulationFailure(fnName, timer.ms(), allocatedGas.sub(result.gasLeft).l2Gas, result.totalInstructions);
        } else {
            this.metrics.recordEnqueuedCallSimulation(fnName, timer.ms(), allocatedGas.sub(result.gasLeft).l2Gas, result.totalInstructions);
        }
        return result;
    }
}
