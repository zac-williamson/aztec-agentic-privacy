import { type Logger, type LoggerBindings } from '@aztec/foundation/log';
import { type PublicSimulatorConfig, PublicTxResult } from '@aztec/stdlib/avm';
import type { MerkleTreeWriteOperations } from '@aztec/stdlib/trees';
import type { GlobalVariables, Tx } from '@aztec/stdlib/tx';
import type { ExecutorMetricsInterface } from '../executor_metrics_interface.js';
import type { PublicContractsDB } from '../public_db_sources.js';
import { PublicTxSimulator } from './public_tx_simulator.js';
import type { MeasuredPublicTxSimulatorInterface, PublicTxSimulatorInterface } from './public_tx_simulator_interface.js';
/**
 * An implementation of PublicTxSimulator that first simulates in C++, then TS, an compares the results.
 * The C++ simulator accesses the world state directly/natively within C++.
 * For contract DB accesses, it makes callbacks through NAPI back to the TS PublicContractsDB cache.
 */
export declare class CppVsTsPublicTxSimulator extends PublicTxSimulator implements PublicTxSimulatorInterface {
    protected log: Logger;
    constructor(merkleTree: MerkleTreeWriteOperations, contractsDB: PublicContractsDB, globalVariables: GlobalVariables, config?: Partial<PublicSimulatorConfig>, bindings?: LoggerBindings);
    /**
     * Simulate a transaction's public portion using the C++ avvm simulator.
     *
     * @param tx - The transaction to simulate.
     * @returns The result of the transaction's public execution.
     */
    simulate(tx: Tx): Promise<PublicTxResult>;
}
export declare class MeasuredCppVsTsPublicTxSimulator extends CppVsTsPublicTxSimulator implements MeasuredPublicTxSimulatorInterface {
    protected readonly metrics: ExecutorMetricsInterface;
    constructor(merkleTree: MerkleTreeWriteOperations, contractsDB: PublicContractsDB, globalVariables: GlobalVariables, metrics: ExecutorMetricsInterface, config?: Partial<PublicSimulatorConfig>, bindings?: LoggerBindings);
    simulate(tx: Tx, txLabel?: string): Promise<PublicTxResult>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3BwX3ZzX3RzX3B1YmxpY190eF9zaW11bGF0b3IuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wdWJsaWMvcHVibGljX3R4X3NpbXVsYXRvci9jcHBfdnNfdHNfcHVibGljX3R4X3NpbXVsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsS0FBSyxNQUFNLEVBQUUsS0FBSyxjQUFjLEVBQTBCLE1BQU0sdUJBQXVCLENBQUM7QUFHakcsT0FBTyxFQUdMLEtBQUsscUJBQXFCLEVBQzFCLGNBQWMsRUFFZixNQUFNLG1CQUFtQixDQUFDO0FBRTNCLE9BQU8sS0FBSyxFQUFFLHlCQUF5QixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDckUsT0FBTyxLQUFLLEVBQUUsZUFBZSxFQUFrQixFQUFFLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUs1RSxPQUFPLEtBQUssRUFBRSx3QkFBd0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ2pGLE9BQU8sS0FBSyxFQUFFLGlCQUFpQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFakUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDN0QsT0FBTyxLQUFLLEVBQ1Ysa0NBQWtDLEVBQ2xDLDBCQUEwQixFQUMzQixNQUFNLG9DQUFvQyxDQUFDO0FBRTVDOzs7O0dBSUc7QUFDSCxxQkFBYSx3QkFBeUIsU0FBUSxpQkFBa0IsWUFBVywwQkFBMEI7SUFDbkcsVUFBbUIsR0FBRyxFQUFFLE1BQU0sQ0FBQztJQUUvQixZQUNFLFVBQVUsRUFBRSx5QkFBeUIsRUFDckMsV0FBVyxFQUFFLGlCQUFpQixFQUM5QixlQUFlLEVBQUUsZUFBZSxFQUNoQyxNQUFNLENBQUMsRUFBRSxPQUFPLENBQUMscUJBQXFCLENBQUMsRUFDdkMsUUFBUSxDQUFDLEVBQUUsY0FBYyxFQUkxQjtJQUVEOzs7OztPQUtHO0lBQ21CLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0ErSjlEO0NBQ0Y7QUFFRCxxQkFBYSxnQ0FDWCxTQUFRLHdCQUNSLFlBQVcsa0NBQWtDO0lBTTNDLFNBQVMsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLHdCQUF3QjtJQUp0RCxZQUNFLFVBQVUsRUFBRSx5QkFBeUIsRUFDckMsV0FBVyxFQUFFLGlCQUFpQixFQUM5QixlQUFlLEVBQUUsZUFBZSxFQUNiLE9BQU8sRUFBRSx3QkFBd0IsRUFDcEQsTUFBTSxDQUFDLEVBQUUsT0FBTyxDQUFDLHFCQUFxQixDQUFDLEVBQ3ZDLFFBQVEsQ0FBQyxFQUFFLGNBQWMsRUFHMUI7SUFFcUIsUUFBUSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxHQUFFLE1BQXNCLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQVMvRjtDQUNGIn0=