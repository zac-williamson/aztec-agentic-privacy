import { Attributes, Metrics, createUpDownCounterWithDefault } from '@aztec/telemetry-client';
export class ExecutorMetrics {
    tracer;
    fnCount;
    fnDuration;
    manaPerSecond;
    manaUsed;
    totalInstructionsExecuted;
    txHashing;
    privateEffectsInsertions;
    constructor(client, name = 'PublicExecutor'){
        this.tracer = client.getTracer(name);
        const meter = client.getMeter(name);
        this.fnCount = createUpDownCounterWithDefault(meter, Metrics.PUBLIC_EXECUTOR_SIMULATION_COUNT, {
            [Attributes.OK]: [
                true,
                false
            ]
        });
        this.fnDuration = meter.createHistogram(Metrics.PUBLIC_EXECUTOR_SIMULATION_DURATION);
        this.manaPerSecond = meter.createHistogram(Metrics.PUBLIC_EXECUTOR_SIMULATION_MANA_PER_SECOND);
        this.manaUsed = meter.createHistogram(Metrics.PUBLIC_EXECUTOR_SIMULATION_MANA_USED);
        this.totalInstructionsExecuted = meter.createHistogram(Metrics.PUBLIC_EXECUTOR_SIMULATION_TOTAL_INSTRUCTIONS);
        this.txHashing = meter.createHistogram(Metrics.PUBLIC_EXECUTOR_TX_HASHING);
        this.privateEffectsInsertions = meter.createHistogram(Metrics.PUBLIC_EXECUTOR_PRIVATE_EFFECTS_INSERTION);
    }
    startRecordingTxSimulation(_txLabel) {
    // do nothing (unimplemented)
    }
    stopRecordingTxSimulation(_txLabel, _gasUsed, _revertedCode) {
    // do nothing (unimplemented)
    }
    recordEnqueuedCallSimulation(fnName, durationMs, manaUsed, totalInstructionsExecuted) {
        this.fnCount.add(1, {
            [Attributes.OK]: true,
            [Attributes.APP_CIRCUIT_NAME]: fnName
        });
        this.manaUsed.record(Math.ceil(manaUsed), {
            [Attributes.APP_CIRCUIT_NAME]: fnName
        });
        this.totalInstructionsExecuted.record(Math.ceil(totalInstructionsExecuted), {
            [Attributes.APP_CIRCUIT_NAME]: fnName
        });
        this.fnDuration.record(Math.ceil(durationMs), {
            [Attributes.APP_CIRCUIT_NAME]: fnName
        });
        if (durationMs > 0 && manaUsed > 0) {
            const manaPerSecond = Math.round(manaUsed * 1000 / durationMs);
            this.manaPerSecond.record(manaPerSecond, {
                [Attributes.APP_CIRCUIT_NAME]: fnName
            });
        }
    }
    recordEnqueuedCallSimulationFailure(_fnName, _durationMs, _manaUsed, _totalInstructionsExecuted) {
        this.fnCount.add(1, {
            [Attributes.OK]: false
        });
    }
    recordPrivateEffectsInsertion(durationUs, type) {
        this.privateEffectsInsertions.record(Math.ceil(durationUs), {
            [Attributes.REVERTIBILITY]: type
        });
    }
}
