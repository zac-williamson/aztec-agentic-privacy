import { FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH, MAX_L2_TO_L1_MSGS_PER_TX, MAX_NOTE_HASHES_PER_TX, MAX_NULLIFIERS_PER_TX, MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX, PROTOCOL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { EthAddress } from '@aztec/foundation/eth-address';
import { createLogger } from '@aztec/foundation/log';
import { PublicDataUpdateRequest } from '@aztec/stdlib/avm';
import { computePublicDataTreeLeafSlot } from '@aztec/stdlib/hash';
import { NoteHash, Nullifier } from '@aztec/stdlib/kernel';
import { DebugLog, PublicLog } from '@aztec/stdlib/logs';
import { L2ToL1Message } from '@aztec/stdlib/messaging';
import { strict as assert } from 'assert';
import { L2ToL1MessageLimitReachedError, MaxCallsToUniqueContractClassIdsError, NoteHashLimitReachedError, NullifierLimitReachedError, SideEffectLimitReachedError } from './side_effect_errors.js';
import { UniqueClassIds } from './unique_class_ids.js';
export class SideEffectArrayLengths {
    publicDataWrites;
    protocolPublicDataWrites;
    noteHashes;
    nullifiers;
    l2ToL1Msgs;
    publicLogFields;
    constructor(publicDataWrites, protocolPublicDataWrites, noteHashes, nullifiers, l2ToL1Msgs, publicLogFields){
        this.publicDataWrites = publicDataWrites;
        this.protocolPublicDataWrites = protocolPublicDataWrites;
        this.noteHashes = noteHashes;
        this.nullifiers = nullifiers;
        this.l2ToL1Msgs = l2ToL1Msgs;
        this.publicLogFields = publicLogFields;
    }
    static empty() {
        return new this(0, 0, 0, 0, 0, 0);
    }
}
/**
 * Trace side effects for an enqueued public call's execution.
 */ export class SideEffectTrace {
    startSideEffectCounter;
    previousSideEffectArrayLengths;
    uniqueClassIds;
    writtenPublicDataSlots;
    debugLogs;
    debugLogMemoryReads;
    log;
    /** The side effect counter increments with every call to the trace. */ sideEffectCounter;
    publicDataWrites;
    protocolPublicDataWritesLength;
    userPublicDataWritesLength;
    noteHashes;
    nullifiers;
    l2ToL1Messages;
    publicLogs;
    /** Make sure a forked trace is never merged twice. */ alreadyMergedIntoParent;
    constructor(/** The counter of this trace's first side effect. */ startSideEffectCounter = 0, bindings, /** Track parent's (or previous kernel's) lengths so the AVM can properly enforce TX-wide limits,
     *  otherwise the public kernel can fail to prove because TX limits are breached.
     */ previousSideEffectArrayLengths = SideEffectArrayLengths.empty(), /** We need to track the set of class IDs used, to enforce limits. */ uniqueClassIds = new UniqueClassIds(), writtenPublicDataSlots = new Set(), debugLogs = [], debugLogMemoryReads = 0){
        this.startSideEffectCounter = startSideEffectCounter;
        this.previousSideEffectArrayLengths = previousSideEffectArrayLengths;
        this.uniqueClassIds = uniqueClassIds;
        this.writtenPublicDataSlots = writtenPublicDataSlots;
        this.debugLogs = debugLogs;
        this.debugLogMemoryReads = debugLogMemoryReads;
        this.publicDataWrites = [];
        this.protocolPublicDataWritesLength = 0;
        this.userPublicDataWritesLength = 0;
        this.noteHashes = [];
        this.nullifiers = [];
        this.l2ToL1Messages = [];
        this.publicLogs = [];
        this.alreadyMergedIntoParent = false;
        this.sideEffectCounter = startSideEffectCounter;
        this.log = createLogger('simulator:side_effect_trace', bindings);
    }
    fork() {
        return new SideEffectTrace(this.sideEffectCounter, this.log.getBindings(), new SideEffectArrayLengths(this.previousSideEffectArrayLengths.publicDataWrites + this.userPublicDataWritesLength, this.previousSideEffectArrayLengths.protocolPublicDataWrites + this.protocolPublicDataWritesLength, this.previousSideEffectArrayLengths.noteHashes + this.noteHashes.length, this.previousSideEffectArrayLengths.nullifiers + this.nullifiers.length, this.previousSideEffectArrayLengths.l2ToL1Msgs + this.l2ToL1Messages.length, this.previousSideEffectArrayLengths.publicLogFields + this.publicLogs.reduce((acc, log)=>acc + log.sizeInFields(), 0)), this.uniqueClassIds.fork(), new Set(this.writtenPublicDataSlots), this.debugLogs.slice(), this.debugLogMemoryReads);
    }
    merge(forkedTrace, reverted = false) {
        // sanity check to avoid merging the same forked trace twice
        assert(!forkedTrace.alreadyMergedIntoParent, 'Bug! Cannot merge a forked trace that has already been merged into its parent!');
        forkedTrace.alreadyMergedIntoParent = true;
        this.sideEffectCounter = forkedTrace.sideEffectCounter;
        this.uniqueClassIds.acceptAndMerge(forkedTrace.uniqueClassIds);
        this.debugLogs = forkedTrace.debugLogs;
        this.debugLogMemoryReads = forkedTrace.debugLogMemoryReads;
        if (!reverted) {
            this.publicDataWrites.push(...forkedTrace.publicDataWrites);
            this.noteHashes.push(...forkedTrace.noteHashes);
            this.nullifiers.push(...forkedTrace.nullifiers);
            this.l2ToL1Messages.push(...forkedTrace.l2ToL1Messages);
            this.publicLogs.push(...forkedTrace.publicLogs);
            this.userPublicDataWritesLength += forkedTrace.userPublicDataWritesLength;
            this.protocolPublicDataWritesLength += forkedTrace.protocolPublicDataWritesLength;
            for (const slot of forkedTrace.writtenPublicDataSlots){
                this.writtenPublicDataSlots.add(slot);
            }
        }
    }
    getCounter() {
        return this.sideEffectCounter;
    }
    incrementSideEffectCounter() {
        this.sideEffectCounter++;
    }
    getNoteHashCount() {
        return this.previousSideEffectArrayLengths.noteHashes + this.noteHashes.length;
    }
    async tracePublicStorageWrite(contractAddress, slot, value, protocolWrite) {
        // Only increment counts if the storage slot has not been written to before.
        if (this.isStorageCold(contractAddress, slot)) {
            if (protocolWrite) {
                if (this.protocolPublicDataWritesLength + this.previousSideEffectArrayLengths.protocolPublicDataWrites >= PROTOCOL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX) {
                    throw new SideEffectLimitReachedError('protocol public data (contract storage) write', PROTOCOL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX);
                }
                this.protocolPublicDataWritesLength++;
            } else {
                if (this.userPublicDataWritesLength + this.previousSideEffectArrayLengths.publicDataWrites >= MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX) {
                    throw new SideEffectLimitReachedError('public data (contract storage) write', MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX);
                }
                this.userPublicDataWritesLength++;
            }
        }
        const leafSlot = await computePublicDataTreeLeafSlot(contractAddress, slot);
        this.publicDataWrites.push(new PublicDataUpdateRequest(leafSlot, value, this.sideEffectCounter));
        this.log.trace(`Traced public data write (address=${contractAddress}, slot=${slot}): value=${value} (counter=${this.sideEffectCounter}, isProtocol:${protocolWrite})`);
        this.incrementSideEffectCounter();
        this.writtenPublicDataSlots.add(this.computePublicDataSlotKey(contractAddress, slot));
    }
    computePublicDataSlotKey(contractAddress, slot) {
        return `${contractAddress.toString()}:${slot.toString()}`;
    }
    isStorageCold(contractAddress, slot) {
        return !this.writtenPublicDataSlots.has(this.computePublicDataSlotKey(contractAddress, slot));
    }
    traceNewNoteHash(noteHash) {
        if (this.noteHashes.length + this.previousSideEffectArrayLengths.noteHashes >= MAX_NOTE_HASHES_PER_TX) {
            throw new NoteHashLimitReachedError();
        }
        this.noteHashes.push(new NoteHash(noteHash, this.sideEffectCounter));
        this.log.trace(`Tracing new note hash (counter=${this.sideEffectCounter})`);
        this.incrementSideEffectCounter();
    }
    traceNewNullifier(siloedNullifier) {
        if (this.nullifiers.length + this.previousSideEffectArrayLengths.nullifiers >= MAX_NULLIFIERS_PER_TX) {
            throw new NullifierLimitReachedError();
        }
        this.nullifiers.push(new Nullifier(siloedNullifier, /*noteHash=*/ Fr.ZERO, this.sideEffectCounter));
        this.log.trace(`Tracing new nullifier (counter=${this.sideEffectCounter})`);
        this.incrementSideEffectCounter();
    }
    traceNewL2ToL1Message(contractAddress, recipient, content) {
        if (this.l2ToL1Messages.length + this.previousSideEffectArrayLengths.l2ToL1Msgs >= MAX_L2_TO_L1_MSGS_PER_TX) {
            throw new L2ToL1MessageLimitReachedError();
        }
        const recipientAddress = EthAddress.fromField(recipient);
        this.l2ToL1Messages.push(new L2ToL1Message(recipientAddress, content).scope(contractAddress));
        this.log.trace(`Tracing new l2 to l1 message (counter=${this.sideEffectCounter})`);
        this.incrementSideEffectCounter();
    }
    tracePublicLog(contractAddress, log) {
        const previouslyEmittedPublicLogFieldsCount = this.previousSideEffectArrayLengths.publicLogFields + this.publicLogs.reduce((acc, log)=>acc + log.sizeInFields(), 0);
        const publicLog = new PublicLog(contractAddress, log);
        if (previouslyEmittedPublicLogFieldsCount + publicLog.sizeInFields() > FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH) {
            throw new SideEffectLimitReachedError('public log fields', FLAT_PUBLIC_LOGS_PAYLOAD_LENGTH);
        }
        this.publicLogs.push(publicLog);
        this.log.trace(`Tracing new public log (counter=${this.sideEffectCounter})`);
        this.incrementSideEffectCounter();
    }
    traceDebugLog(contractAddress, level, message, fields) {
        this.debugLogs.push(new DebugLog(contractAddress, level, message, fields));
    }
    getDebugLogs() {
        return this.debugLogs;
    }
    getDebugLogMemoryReads() {
        return this.debugLogMemoryReads;
    }
    traceDebugLogMemoryReads(memoryReads) {
        this.debugLogMemoryReads += memoryReads;
    }
    traceGetContractClass(contractClassId, exists) {
        // We limit the number of unique contract class IDs due to hashing and the trace length limit.
        if (exists && !this.uniqueClassIds.has(contractClassId.toString())) {
            if (this.uniqueClassIds.size() >= MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS) {
                this.log.debug(`Bytecode retrieval failure for contract class ID ${contractClassId} (limit reached)`);
                throw new MaxCallsToUniqueContractClassIdsError();
            }
            this.log.trace(`Adding contract class ID ${contractClassId} (counter=${this.sideEffectCounter})`);
            this.uniqueClassIds.add(contractClassId.toString());
            this.incrementSideEffectCounter();
        }
    }
    getSideEffects() {
        return {
            publicDataWrites: this.publicDataWrites,
            noteHashes: this.noteHashes,
            nullifiers: this.nullifiers,
            l2ToL1Msgs: this.l2ToL1Messages,
            publicLogs: this.publicLogs
        };
    }
}
