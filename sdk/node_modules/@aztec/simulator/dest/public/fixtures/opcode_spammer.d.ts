import { Fr } from '@aztec/foundation/curves/bn254';
import type { Bufferable } from '@aztec/foundation/serialize';
import { type PublicTxResult } from '@aztec/stdlib/avm';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import type { MerkleTreeWriteOperations } from '@aztec/stdlib/interfaces/server';
import { type MemoryValue } from '../avm/avm_memory_types.js';
import { Opcode } from '../avm/serialization/instruction_serialization.js';
import type { PublicTxSimulationTester } from './public_tx_simulation_tester.js';
/**
 * Memory cell to initialize before spamming.
 */
interface MemSetup {
    offset: number;
    value: MemoryValue;
}
/**
 * Some setup action to take before spamming.
 * Either a memory cell to initialize, or some instruction generator.
 */
type SetupItem = MemSetup | (() => Bufferable[]);
/**
 * Everything needed to spam an opcode.
 */
export interface SpamConfig {
    /** Memory cells to initialize */
    setup: SetupItem[];
    /** Factory to create target instruction(s) to spam */
    targetInstructions: () => Bufferable[];
    /** Instructions to run after target spam (e.g., REVERT) */
    cleanupInstructions?: () => Bufferable[];
    /**
     * Per-TX limit for the target opcode (for side-effect-limited opcodes)
     * If set:
     *   1. makes nested CALL
     *   2. executes target opcode #limit times in a nested call
     *   3. REVERT
     *   4. CALL again to repeat
     */
    limit?: number;
    /** Optional label for this config variant (e.g., UINT8 or MAXSIZE) */
    label?: string;
    /** Whether to pass the contract address as calldata[0] */
    addressAsCalldata?: boolean;
}
/**
 * An object containing opcode name and its SpamConfigs
 * Useful when ready to iterate over all opcodes and test them.
 */
export interface SpamConfigsForOpcode {
    /** Opcode name (e.g., "ADD_8") */
    opcode: string;
    /** All spam configs for this opcode (one or more) */
    configs: SpamConfig[];
}
/**
 * Constants for "warm" tree reads - these values are inserted into the trees
 * before running the spammer so that existence checks can find them.
 */
export declare const WARM_NOTE_HASH: Fr;
export declare const WARM_L1_TO_L2_MSG: Fr;
/** Warm nullifier constant - a pre-siloed nullifier value inserted directly into the tree */
export declare const WARM_SILOED_NULLIFIER: Fr;
/** Warm storage constants - storage is inserted for the deployed contract's address */
export declare const WARM_STORAGE_SLOT: Fr;
export declare const WARM_STORAGE_VALUE: Fr;
/**
 * Leaf indices inserted to by insertWarmTreeEntries().
 * Ideally we'd getTreeInfo and set dynamically, but that doesn't
 * work easily with static spam configs, so we assume intial index 0.
 */
export declare const WARM_NOTE_HASH_LEAF_INDEX = 0n;
export declare const WARM_L1_TO_L2_MSG_LEAF_INDEX = 0n;
/**
 * Insert entries into the trees so that "warm" configs can find them with existence checks.
 * Call this before running the opcode spammer to enable warm tree reads.
 *
 * Inserts:
 * - Note hash into NOTE_HASH_TREE
 * - L1 to L2 message into L1_TO_L2_MESSAGE_TREE
 * - Siloed nullifier into NULLIFIER_TREE (for NULLIFIEREXISTS warm check)
 * - Storage value into PUBLIC_DATA_TREE (for SLOAD warm check)
 */
export declare function insertWarmTreeEntries(merkleTrees: MerkleTreeWriteOperations, contractAddress: AztecAddress): Promise<void>;
/**
 * A SpamConfig for to make external CALLs to an address specified in calldata[0].
 */
export declare const EXTERNAL_CALL_CONFIG: SpamConfig;
/**
 * Opcode spammer configs for ~all opcodes.
 * Each opcode maps to an array of configs (usually one, but can be multiple for type variants, etc.)
 * Uses smallest wire format (_8) for maximum instruction density.
 */
export declare const SPAM_CONFIGS: Partial<Record<Opcode, SpamConfig[]>>;
/**
 * Get all spam test cases grouped by opcode.
 * This is the main entry point for tests - it handles all the complexity of
 * type variants, multiple configs, etc.
 *
 * Returns hierarchical structure for nested describe blocks in tests.
 *
 * @param maxConfigsPerOpcode - Maximum number of configs to include per opcode.
 *                              Defaults to Infinity (no limit). Useful for quick
 *                              smoke tests where testing all type variants is too slow,
 *                              or for proving tests that are inherently slower.
 */
export declare function getSpamConfigsPerOpcode(maxConfigsPerOpcode?: number): SpamConfigsForOpcode[];
/**
 * Generate basic opcode spam bytecode from a SpamConfig.
 * Spams the target instruction(s) in an infinite loop until out-of-gas.
 */
export declare function createOpcodeSpamBytecode(config: SpamConfig): Buffer;
/**
 * Generate a bytecode that spams a side-effect limited opcode #limit times
 * NOT in a loop, but inline/unrolled. Then revert.
 *
 * @param config - the side-effect limited spam config to use
 * @returns the bytecode for the side-effect limited spam
 */
export declare function createSideEffectSpamBytecode(config: SpamConfig): Buffer;
export declare function testOpcodeSpamCase(tester: PublicTxSimulationTester, config: SpamConfig, expectToBeTrue?: (x: boolean) => void): Promise<PublicTxResult>;
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3Bjb2RlX3NwYW1tZXIuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wdWJsaWMvZml4dHVyZXMvb3Bjb2RlX3NwYW1tZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0tBLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNwRCxPQUFPLEtBQUssRUFBRSxVQUFVLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUM5RCxPQUFPLEVBQTJDLEtBQUssY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDakcsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRTNELE9BQU8sS0FBSyxFQUFFLHlCQUF5QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFLakYsT0FBTyxFQUFTLEtBQUssV0FBVyxFQUFnRCxNQUFNLDRCQUE0QixDQUFDO0FBa0RuSCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sbURBQW1ELENBQUM7QUFFM0UsT0FBTyxLQUFLLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQU1qRjs7R0FFRztBQUNILFVBQVUsUUFBUTtJQUNoQixNQUFNLEVBQUUsTUFBTSxDQUFDO0lBQ2YsS0FBSyxFQUFFLFdBQVcsQ0FBQztDQUNwQjtBQUVEOzs7R0FHRztBQUNILEtBQUssU0FBUyxHQUFHLFFBQVEsR0FBRyxDQUFDLE1BQU0sVUFBVSxFQUFFLENBQUMsQ0FBQztBQUVqRDs7R0FFRztBQUNILE1BQU0sV0FBVyxVQUFVO0lBQ3pCLGlDQUFpQztJQUNqQyxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUM7SUFFbkIsc0RBQXNEO0lBQ3RELGtCQUFrQixFQUFFLE1BQU0sVUFBVSxFQUFFLENBQUM7SUFFdkMsMkRBQTJEO0lBQzNELG1CQUFtQixDQUFDLEVBQUUsTUFBTSxVQUFVLEVBQUUsQ0FBQztJQUV6Qzs7Ozs7OztPQU9HO0lBQ0gsS0FBSyxDQUFDLEVBQUUsTUFBTSxDQUFDO0lBRWYsc0VBQXNFO0lBQ3RFLEtBQUssQ0FBQyxFQUFFLE1BQU0sQ0FBQztJQUVmLDBEQUEwRDtJQUMxRCxpQkFBaUIsQ0FBQyxFQUFFLE9BQU8sQ0FBQztDQUM3QjtBQUVEOzs7R0FHRztBQUNILE1BQU0sV0FBVyxvQkFBb0I7SUFDbkMsa0NBQWtDO0lBQ2xDLE1BQU0sRUFBRSxNQUFNLENBQUM7SUFFZixxREFBcUQ7SUFDckQsT0FBTyxFQUFFLFVBQVUsRUFBRSxDQUFDO0NBQ3ZCO0FBTUQ7OztHQUdHO0FBQ0gsZUFBTyxNQUFNLGNBQWMsSUFBc0IsQ0FBQztBQUNsRCxlQUFPLE1BQU0saUJBQWlCLElBQThCLENBQUM7QUFFN0QsNkZBQTZGO0FBQzdGLGVBQU8sTUFBTSxxQkFBcUIsSUFBMEIsQ0FBQztBQUU3RCx1RkFBdUY7QUFDdkYsZUFBTyxNQUFNLGlCQUFpQixJQUEwQixDQUFDO0FBQ3pELGVBQU8sTUFBTSxrQkFBa0IsSUFBMEIsQ0FBQztBQUUxRDs7OztHQUlHO0FBQ0gsZUFBTyxNQUFNLHlCQUF5QixLQUFLLENBQUM7QUFDNUMsZUFBTyxNQUFNLDRCQUE0QixLQUFLLENBQUM7QUFFL0M7Ozs7Ozs7OztHQVNHO0FBQ0gsd0JBQXNCLHFCQUFxQixDQUN6QyxXQUFXLEVBQUUseUJBQXlCLEVBQ3RDLGVBQWUsRUFBRSxZQUFZLEdBQzVCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FjZjtBQW1HRDs7R0FFRztBQUNILGVBQU8sTUFBTSxvQkFBb0IsRUFBRSxVQTBCbEMsQ0FBQztBQWtDRjs7OztHQUlHO0FBQ0gsZUFBTyxNQUFNLFlBQVksRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQXM4QjlELENBQUM7QUFFRjs7Ozs7Ozs7Ozs7R0FXRztBQUNILHdCQUFnQix1QkFBdUIsQ0FBQyxtQkFBbUIsR0FBRSxNQUFpQixHQUFHLG9CQUFvQixFQUFFLENBc0J0RztBQTRGRDs7O0dBR0c7QUFDSCx3QkFBZ0Isd0JBQXdCLENBQUMsTUFBTSxFQUFFLFVBQVUsR0FBRyxNQUFNLENBZW5FO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsd0JBQWdCLDRCQUE0QixDQUFDLE1BQU0sRUFBRSxVQUFVLEdBQUcsTUFBTSxDQW1CdkU7QUE0REQsd0JBQXNCLGtCQUFrQixDQUN0QyxNQUFNLEVBQUUsd0JBQXdCLEVBQ2hDLE1BQU0sRUFBRSxVQUFVLEVBQ2xCLGNBQWMsR0FBRSxDQUFDLENBQUMsRUFBRSxPQUFPLEtBQUssSUFBZSxHQUM5QyxPQUFPLENBQUMsY0FBYyxDQUFDLENBS3pCIn0=