import { createLogger } from '@aztec/foundation/log';
import { getFunctionSelector } from '../avm/fixtures/utils.js';
/**
 * This class is used during public/avm testing to function as a database of
 * contract contract classes and instances. Tests can populate it with classes
 * and instances and then probe it via the ContractDataSource interface.
 *
 * This class does not include any real merkle trees & merkle operations.
 */ export class SimpleContractDataSource {
    logger = createLogger('simple-contract-data-source');
    // maps contract class ID to class
    contractClasses = new Map();
    // maps contract instance address to instance
    contractInstances = new Map();
    // maps contract instance address to address
    contractArtifacts = new Map();
    // maps `${classID}:${fnSelector}` to name
    debugFunctionName = new Map();
    /////////////////////////////////////////////////////////////
    // Helper functions not in the contract data source interface
    /**
   * Derive the contract class and instance with some seed.
   * Add both to the contract data source along with the contract artifact.
   */ async addNewContract(contractArtifact, contractClass, contractInstance) {
        await this.addContractArtifact(contractClass.id, contractArtifact);
        await this.addContractClass(contractClass);
        await this.addContractInstance(contractInstance);
    }
    async addContractArtifact(classId, artifact) {
        this.contractArtifacts.set(classId.toString(), artifact);
        const classIdStr = classId.toString();
        const publicFns = artifact.nonDispatchPublicFunctions;
        if (publicFns.length !== 0) {
            for (const fn of publicFns){
                const actualFnName = `${fn.name}`;
                const fnSelector = await getFunctionSelector(actualFnName, artifact);
                const key = `${classIdStr}:${fnSelector.toString()}`;
                const longFnName = `${artifact.name}.${actualFnName}`;
                this.debugFunctionName.set(key, longFnName);
            }
        }
    }
    /////////////////////////////////////////////////////////////
    // ContractDataSource function implementations
    getBlockNumber() {
        throw new Error('Method not implemented.');
    }
    getContractClass(id) {
        return Promise.resolve(this.contractClasses.get(id.toString()));
    }
    getBytecodeCommitment(_id) {
        return Promise.resolve(undefined);
    }
    getContract(address) {
        return Promise.resolve(this.contractInstances.get(address.toString()));
    }
    getContractClassIds() {
        throw new Error('Method not implemented.');
    }
    async getContractArtifact(address) {
        const contractInstance = await this.getContract(address);
        if (!contractInstance) {
            this.logger.warn(`Contract not found at address: ${address}`);
            return undefined;
        }
        this.logger.debug(`Retrieved contract artifact for address: ${address}`);
        this.logger.debug(`Contract class ID: ${contractInstance.currentContractClassId}`);
        return this.contractArtifacts.get(contractInstance.currentContractClassId.toString());
    }
    async getDebugFunctionName(address, selector) {
        const contractInstance = await this.getContract(address);
        if (!contractInstance) {
            this.logger.warn(`Couldn't get fn name for debugging. Contract not in tester's ContractDataSource.`);
            return undefined;
        }
        const key = `${contractInstance.currentContractClassId.toString()}:${selector.toString()}`;
        const fnName = this.debugFunctionName.get(key);
        if (!fnName) {
            this.logger.warn(`Couldn't get fn name for debugging...`);
            return undefined;
        }
        return fnName;
    }
    registerContractFunctionSignatures(_signatures) {
        return Promise.resolve();
    }
    addContractClass(contractClass) {
        this.contractClasses.set(contractClass.id.toString(), contractClass);
        return Promise.resolve();
    }
    addContractInstance(contractInstance) {
        this.contractInstances.set(contractInstance.address.toString(), contractInstance);
        return Promise.resolve();
    }
}
