function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
var _dec, _dec1, _dec2, _initProto;
import { MAX_NOTE_HASHES_PER_TX, MAX_NULLIFIERS_PER_TX, NULLIFIER_SUBTREE_HEIGHT } from '@aztec/constants';
import { padArrayEnd } from '@aztec/foundation/collection';
import { Fr } from '@aztec/foundation/curves/bn254';
import { createLogger } from '@aztec/foundation/log';
import { sleep } from '@aztec/foundation/sleep';
import { DateProvider, Timer, elapsed, executeTimeout } from '@aztec/foundation/timer';
import { ProtocolContractAddress } from '@aztec/protocol-contracts';
import { ContractClassPublishedEvent } from '@aztec/protocol-contracts/class-registry';
import { computeFeePayerBalanceLeafSlot, computeFeePayerBalanceStorageSlot } from '@aztec/protocol-contracts/fee-juice';
import { AvmCircuitInputs, AvmExecutionHints, PublicDataWrite } from '@aztec/stdlib/avm';
import { computeTransactionFee } from '@aztec/stdlib/fees';
import { Gas } from '@aztec/stdlib/gas';
import { ProvingRequestType } from '@aztec/stdlib/proofs';
import { MerkleTreeId } from '@aztec/stdlib/trees';
import { NestedProcessReturnValues, makeProcessedTxFromPrivateOnlyTx, makeProcessedTxFromTxWithPublicCalls } from '@aztec/stdlib/tx';
import { Attributes, getTelemetryClient, trackSpan } from '@aztec/telemetry-client';
import { ForkCheckpoint } from '@aztec/world-state/native';
import { AssertionError } from 'assert';
import { PublicContractsDB, PublicTreesDB } from '../public_db_sources.js';
import { TelemetryCppPublicTxSimulator } from '../public_tx_simulator/index.js';
import { GuardedMerkleTreeOperations } from './guarded_merkle_tree.js';
import { PublicProcessorMetrics } from './public_processor_metrics.js';
/**
 * Creates new instances of PublicProcessor given the provided merkle tree db and contract data source.
 */ export class PublicProcessorFactory {
    contractDataSource;
    dateProvider;
    telemetryClient;
    log;
    constructor(contractDataSource, dateProvider = new DateProvider(), telemetryClient = getTelemetryClient(), bindings){
        this.contractDataSource = contractDataSource;
        this.dateProvider = dateProvider;
        this.telemetryClient = telemetryClient;
        this.log = createLogger('simulator:public-processor-factory', bindings);
    }
    /**
   * Creates a new instance of a PublicProcessor.
   * @param globalVariables - The global variables for the block being processed.
   * @param skipFeeEnforcement - Allows disabling balance checks for fee estimations.
   * @returns A new instance of a PublicProcessor.
   */ create(merkleTree, globalVariables, config) {
        const bindings = this.log.getBindings();
        const contractsDB = new PublicContractsDB(this.contractDataSource, bindings);
        const guardedFork = new GuardedMerkleTreeOperations(merkleTree);
        const publicTxSimulator = this.createPublicTxSimulator(guardedFork, contractsDB, globalVariables, config);
        return new PublicProcessor(globalVariables, guardedFork, contractsDB, publicTxSimulator, this.dateProvider, this.telemetryClient, createLogger('simulator:public-processor', bindings));
    }
    createPublicTxSimulator(merkleTree, contractsDB, globalVariables, config) {
        return new TelemetryCppPublicTxSimulator(merkleTree, contractsDB, globalVariables, this.telemetryClient, config, this.log.getBindings());
    }
}
class PublicProcessorTimeoutError extends Error {
    constructor(message = 'Timed out while processing tx'){
        super(message);
        this.name = 'PublicProcessorTimeoutError';
    }
}
_dec = trackSpan('PublicProcessor.processTx', (tx)=>({
        [Attributes.TX_HASH]: tx.getTxHash().toString()
    })), _dec1 = trackSpan('PublicProcessor.processPrivateOnlyTx', (tx)=>({
        [Attributes.TX_HASH]: tx.getTxHash().toString()
    })), _dec2 = trackSpan('PublicProcessor.processTxWithPublicCalls', (tx)=>({
        [Attributes.TX_HASH]: tx.getTxHash().toString()
    }));
/**
 * Converts Txs lifted from the P2P module into ProcessedTx objects by executing
 * any public function calls in them. Txs with private calls only are unaffected.
 */ export class PublicProcessor {
    globalVariables;
    guardedMerkleTree;
    contractsDB;
    publicTxSimulator;
    dateProvider;
    log;
    opts;
    static{
        ({ e: [_initProto] } = _apply_decs_2203_r(this, [
            [
                _dec,
                2,
                "processTx"
            ],
            [
                _dec1,
                2,
                "processPrivateOnlyTx"
            ],
            [
                _dec2,
                2,
                "processTxWithPublicCalls"
            ]
        ], []));
    }
    metrics;
    constructor(globalVariables, guardedMerkleTree, contractsDB, publicTxSimulator, dateProvider, telemetryClient = getTelemetryClient(), log, opts = {}){
        this.globalVariables = globalVariables;
        this.guardedMerkleTree = guardedMerkleTree;
        this.contractsDB = contractsDB;
        this.publicTxSimulator = publicTxSimulator;
        this.dateProvider = dateProvider;
        this.log = log;
        this.opts = opts;
        _initProto(this);
        this.metrics = new PublicProcessorMetrics(telemetryClient, 'PublicProcessor');
    }
    get tracer() {
        return this.metrics.tracer;
    }
    /**
   * Run each tx through the public circuit and the public kernel circuit if needed.
   * @param txs - Txs to process.
   * @param limits - Limits for processing the txs.
   * @param validator - Pre-process validator and nullifier cache to use for processing the txs.
   * @returns The list of processed txs with their circuit simulation outputs.
   */ async process(txs, limits = {}, validator = {}) {
        const { maxTransactions, maxBlockSize, deadline, maxBlockGas, maxBlobFields } = limits;
        const { preprocessValidator, nullifierCache } = validator;
        const result = [];
        const usedTxs = [];
        const failed = [];
        const timer = new Timer();
        let totalSizeInBytes = 0;
        let returns = [];
        let totalPublicGas = new Gas(0, 0);
        let totalBlockGas = new Gas(0, 0);
        let totalBlobFields = 0;
        for await (const tx of txs){
            // Only process up to the max tx limit
            if (maxTransactions !== undefined && result.length >= maxTransactions) {
                this.log.debug(`Stopping tx processing due to reaching the max tx limit.`);
                break;
            }
            // Bail if we've hit the deadline
            if (deadline && this.dateProvider.now() > +deadline) {
                this.log.warn(`Stopping tx processing due to timeout.`);
                break;
            }
            // Skip this tx if it'd exceed max block size
            const txHash = tx.getTxHash().toString();
            const preTxSizeInBytes = tx.getEstimatedPrivateTxEffectsSize();
            if (maxBlockSize !== undefined && totalSizeInBytes + preTxSizeInBytes > maxBlockSize) {
                this.log.warn(`Skipping processing of tx ${txHash} sized ${preTxSizeInBytes} bytes due to block size limit`, {
                    txHash,
                    sizeInBytes: preTxSizeInBytes,
                    totalSizeInBytes,
                    maxBlockSize
                });
                continue;
            }
            // Skip this tx if its gas limit would exceed the block gas limit
            const txGasLimit = tx.data.constants.txContext.gasSettings.gasLimits;
            if (maxBlockGas !== undefined && totalBlockGas.add(txGasLimit).gtAny(maxBlockGas)) {
                this.log.warn(`Skipping processing of tx ${txHash} due to block gas limit`, {
                    txHash,
                    txGasLimit,
                    totalBlockGas,
                    maxBlockGas
                });
                continue;
            }
            // We validate the tx before processing it, to avoid unnecessary work.
            if (preprocessValidator) {
                const result = await preprocessValidator.validateTx(tx);
                const txHash = tx.getTxHash();
                if (result.result === 'invalid') {
                    const reason = result.reason.join(', ');
                    this.log.debug(`Rejecting tx ${txHash.toString()} due to pre-process validation fail: ${reason}`);
                    failed.push({
                        tx,
                        error: new Error(`Tx failed preprocess validation: ${reason}`)
                    });
                    returns.push(new NestedProcessReturnValues([]));
                    continue;
                } else if (result.result === 'skipped') {
                    const reason = result.reason.join(', ');
                    this.log.debug(`Skipping tx ${txHash.toString()} due to pre-process validation: ${reason}`);
                    returns.push(new NestedProcessReturnValues([]));
                    continue;
                } else {
                    this.log.trace(`Tx ${txHash.toString()} is valid before processing.`);
                }
            }
            // We checkpoint the transaction here, then within the try/catch we
            // 1. Revert the checkpoint if the tx fails or needs to be discarded for any reason
            // 2. Commit the transaction in the finally block. Note that by using the ForkCheckpoint lifecycle only the first commit/revert takes effect
            // By doing this, every transaction starts on a fresh checkpoint and it's state updates only make it to the fork if this checkpoint is committed.
            // Note: We use the underlying fork here not the guarded one, this ensures that it's not impacted by stopping the guarded version
            const checkpoint = await ForkCheckpoint.new(this.guardedMerkleTree.getUnderlyingFork());
            const startStateReference = await this.guardedMerkleTree.getUnderlyingFork().getStateReference();
            this.contractsDB.createCheckpoint();
            try {
                const [processedTx, returnValues] = await this.processTx(tx, deadline);
                // Inject a fake processing failure after N txs if requested
                const fakeThrowAfter = this.opts.fakeThrowAfterProcessingTxCount;
                if (fakeThrowAfter !== undefined && result.length + failed.length + 1 >= fakeThrowAfter) {
                    throw new Error(`Fake error after processing ${fakeThrowAfter} txs`);
                }
                const txBlobFields = processedTx.txEffect.getNumBlobFields();
                // If the actual size of this tx would exceed block size, skip it
                const txSize = txBlobFields * Fr.SIZE_IN_BYTES;
                if (maxBlockSize !== undefined && totalSizeInBytes + txSize > maxBlockSize) {
                    this.log.debug(`Skipping processed tx ${txHash} sized ${txSize} due to max block size.`, {
                        txHash,
                        sizeInBytes: txSize,
                        totalSizeInBytes,
                        maxBlockSize
                    });
                    // Need to revert the checkpoint here and don't go any further
                    await checkpoint.revert();
                    this.contractsDB.revertCheckpoint();
                    continue;
                }
                // If the actual blob fields of this tx would exceed the limit, skip it
                // Note: maxBlobFields already accounts for block end blob fields and previous blocks in checkpoint.
                if (maxBlobFields !== undefined && totalBlobFields + txBlobFields > maxBlobFields) {
                    this.log.debug(`Skipping processed tx ${txHash} with ${txBlobFields} blob fields due to max blob fields limit.`, {
                        txHash,
                        txBlobFields,
                        totalBlobFields,
                        maxBlobFields
                    });
                    // Need to revert the checkpoint here and don't go any further
                    await checkpoint.revert();
                    this.contractsDB.revertCheckpoint();
                    continue;
                }
                // FIXME(fcarreiro): it's ugly to have to notify the validator of nullifiers.
                // I'd rather pass the validators the processedTx as well and let them deal with it.
                nullifierCache?.addNullifiers(processedTx.txEffect.nullifiers.map((n)=>n.toBuffer()));
                result.push(processedTx);
                usedTxs.push(tx);
                returns = returns.concat(returnValues);
                totalPublicGas = totalPublicGas.add(processedTx.gasUsed.publicGas);
                totalBlockGas = totalBlockGas.add(processedTx.gasUsed.totalGas);
                totalSizeInBytes += txSize;
                totalBlobFields += txBlobFields;
            } catch (err) {
                if (err?.name === 'PublicProcessorTimeoutError') {
                    this.log.warn(`Stopping tx processing due to timeout.`);
                    // We hit the transaction execution deadline.
                    // There may still be a transaction executing on a worker thread (C++ via NAPI).
                    // Signal cancellation AND WAIT for the simulation to actually stop.
                    // This is critical because C++ might be in the middle of a slow operation (e.g., pad_trees)
                    // and won't check the cancellation flag until that operation completes.
                    // Without waiting, we'd proceed to revert checkpoints while C++ is still writing to state.
                    // Wait for C++ to stop gracefully.
                    await this.publicTxSimulator.cancel?.();
                    // Now stop the guarded fork to prevent any further TS-side access to the world state.
                    await this.guardedMerkleTree.stop();
                    // We now know there can't be any further access to world state. The fork is in a state where there is:
                    // 1. At least one outstanding checkpoint that has not been committed (the one created before we processed the tx).
                    // 2. Possible state updates on that checkpoint or any others created during execution.
                    // First we revert a checkpoint as managed by the ForkCheckpoint. This will revert whatever is the current checkpoint
                    // which may not be the one originally created by this object. But that is ok, we do this to fulfil the ForkCheckpoint
                    // lifecycle expectations and ensure it doesn't attempt to commit later on.
                    await checkpoint.revert();
                    // Now we want to revert any/all remaining checkpoints, destroying any outstanding state updates.
                    // This needs to be done directly on the underlying fork as the guarded fork has been stopped.
                    await this.guardedMerkleTree.getUnderlyingFork().revertAllCheckpoints();
                    // Revert any contracts added to the DB for the tx.
                    this.contractsDB.revertCheckpoint();
                    // Ensure we're at the same state as when we started processing this tx.
                    await this.checkWorldStateUnchanged(startStateReference, txHash, err);
                    break;
                }
                // Roll back state to start of TX before proceeding to next TX
                await checkpoint.revert();
                await this.guardedMerkleTree.getUnderlyingFork().revertAllCheckpoints();
                this.contractsDB.revertCheckpoint();
                const errorMessage = err instanceof Error || err instanceof AssertionError ? err.message : 'Unknown error';
                this.log.warn(`Failed to process tx ${txHash.toString()}: ${errorMessage} ${err?.stack}`);
                failed.push({
                    tx,
                    error: err instanceof Error ? err : new Error(errorMessage)
                });
                returns.push(new NestedProcessReturnValues([]));
                // Ensure we're at the same state as when we started processing this tx.
                await this.checkWorldStateUnchanged(startStateReference, txHash, err);
            } finally{
                // Base case is we always commit the checkpoint. Using the ForkCheckpoint means this has no effect if the tx was previously reverted
                await checkpoint.commit();
                this.contractsDB.commitCheckpointOkIfNone();
            }
        }
        const duration = timer.s();
        const rate = duration > 0 ? totalPublicGas.l2Gas / duration : 0;
        this.metrics.recordAllTxs(totalPublicGas, rate);
        this.log.info(`Processed ${result.length} successful txs and ${failed.length} failed txs in ${duration}s`, {
            duration,
            rate,
            totalPublicGas,
            totalBlockGas,
            totalSizeInBytes
        });
        return [
            result,
            failed,
            usedTxs,
            returns,
            totalBlobFields
        ];
    }
    async checkWorldStateUnchanged(startStateReference, txHash, cause) {
        const endStateReference = await this.guardedMerkleTree.getUnderlyingFork().getStateReference();
        if (!startStateReference.equals(endStateReference)) {
            this.log.warn(`Fork state reference changed by tx ${txHash} after error in public processor`, {
                expected: startStateReference.toInspect(),
                actual: endStateReference.toInspect(),
                cause
            });
            throw new Error(`Fork state reference changed by tx ${txHash} after error in public processor`, {
                cause
            });
        }
    }
    async processTx(tx, deadline) {
        const [time, [processedTx, returnValues]] = await elapsed(()=>this.processTxWithinDeadline(tx, deadline));
        this.log.verbose(!tx.hasPublicCalls() ? `Processed tx ${processedTx.hash} with no public calls in ${time}ms` : `Processed tx ${processedTx.hash} with ${tx.numberOfPublicCalls()} public calls in ${time}ms`, {
            txHash: processedTx.hash,
            txFee: processedTx.txEffect.transactionFee.toBigInt(),
            revertCode: processedTx.txEffect.revertCode.getCode(),
            revertReason: processedTx.revertReason,
            gasUsed: processedTx.gasUsed,
            publicDataWriteCount: processedTx.txEffect.publicDataWrites.length,
            nullifierCount: processedTx.txEffect.nullifiers.length,
            noteHashCount: processedTx.txEffect.noteHashes.length,
            contractClassLogCount: processedTx.txEffect.contractClassLogs.length,
            publicLogCount: processedTx.txEffect.publicLogs.length,
            privateLogCount: processedTx.txEffect.privateLogs.length,
            l2ToL1MessageCount: processedTx.txEffect.l2ToL1Msgs.length,
            durationMs: time
        });
        return [
            processedTx,
            returnValues ?? []
        ];
    }
    async doTreeInsertionsForPrivateOnlyTx(processedTx) {
        const treeInsertionStart = process.hrtime.bigint();
        // Update the state so that the next tx in the loop has the correct .startState
        // NB: before this change, all .startStates were actually incorrect, but the issue was never caught because we either:
        // a) had only 1 tx with public calls per block, so this loop had len 1
        // b) always had a txHandler with the same db passed to it as this.db, which updated the db in buildBaseRollupHints in this loop
        // To see how this ^ happens, move back to one shared db in test_context and run orchestrator_multi_public_functions.test.ts
        // The below is taken from buildBaseRollupHints:
        await this.guardedMerkleTree.appendLeaves(MerkleTreeId.NOTE_HASH_TREE, padArrayEnd(processedTx.txEffect.noteHashes, Fr.ZERO, MAX_NOTE_HASHES_PER_TX));
        try {
            await this.guardedMerkleTree.batchInsert(MerkleTreeId.NULLIFIER_TREE, padArrayEnd(processedTx.txEffect.nullifiers, Fr.ZERO, MAX_NULLIFIERS_PER_TX).map((n)=>n.toBuffer()), NULLIFIER_SUBTREE_HEIGHT);
        } catch (cause) {
            throw new Error(`Transaction ${processedTx.hash} failed with duplicate nullifiers`, {
                cause
            });
        }
        const treeInsertionEnd = process.hrtime.bigint();
        this.metrics.recordTreeInsertions(Number(treeInsertionEnd - treeInsertionStart) / 1_000);
    }
    /** Processes the given tx within deadline. Returns timeout if deadline is hit. */ async processTxWithinDeadline(tx, deadline) {
        const innerProcessFn = tx.hasPublicCalls() ? ()=>this.processTxWithPublicCalls(tx) : ()=>this.processPrivateOnlyTx(tx);
        // Fake a delay per tx if instructed (used for tests)
        const fakeDelayPerTxMs = this.opts.fakeProcessingDelayPerTxMs;
        const processFn = fakeDelayPerTxMs && fakeDelayPerTxMs > 0 ? async ()=>{
            const result = await innerProcessFn();
            this.log.warn(`Sleeping ${fakeDelayPerTxMs}ms after processing tx ${tx.getTxHash().toString()}`);
            await sleep(fakeDelayPerTxMs);
            return result;
        } : innerProcessFn;
        if (!deadline) {
            return await processFn();
        }
        const txHash = tx.getTxHash();
        const timeout = +deadline - this.dateProvider.now();
        if (timeout <= 0) {
            throw new PublicProcessorTimeoutError();
        }
        this.log.debug(`Processing tx ${txHash.toString()} within ${timeout}ms`, {
            deadline: deadline.toISOString(),
            now: new Date(this.dateProvider.now()).toISOString(),
            txHash
        });
        return await executeTimeout(()=>processFn(), timeout, ()=>new PublicProcessorTimeoutError());
    }
    /**
   * Creates the public data write for paying the tx fee.
   * This is used in private only txs, since for txs with public calls
   * the avm handles the fee payment itself.
   */ async performFeePaymentPublicDataWrite(txFee, feePayer) {
        const feeJuiceAddress = ProtocolContractAddress.FeeJuice;
        const balanceSlot = await computeFeePayerBalanceStorageSlot(feePayer);
        const leafSlot = await computeFeePayerBalanceLeafSlot(feePayer);
        // This high-level db is used as a convenient helper. It could be done with the merkleTree directly.
        const treesDB = new PublicTreesDB(this.guardedMerkleTree);
        this.log.debug(`Deducting ${txFee.toBigInt()} balance in Fee Juice for ${feePayer}`);
        const balance = await treesDB.storageRead(feeJuiceAddress, balanceSlot);
        if (balance.lt(txFee)) {
            throw new Error(`Not enough balance for fee payer to pay for transaction (got ${balance.toBigInt()} needs ${txFee.toBigInt()})`);
        }
        const updatedBalance = balance.sub(txFee);
        await treesDB.storageWrite(feeJuiceAddress, balanceSlot, updatedBalance);
        return new PublicDataWrite(leafSlot, updatedBalance);
    }
    async processPrivateOnlyTx(tx) {
        const gasFees = this.globalVariables.gasFees;
        const transactionFee = computeTransactionFee(gasFees, tx.data.constants.txContext.gasSettings, tx.data.gasUsed);
        const feePaymentPublicDataWrite = await this.performFeePaymentPublicDataWrite(transactionFee, tx.data.feePayer);
        const processedTx = makeProcessedTxFromPrivateOnlyTx(tx, transactionFee, feePaymentPublicDataWrite, this.globalVariables);
        this.metrics.recordClassPublication(...tx.getContractClassLogs().filter((log)=>ContractClassPublishedEvent.isContractClassPublishedEvent(log)).map((log)=>ContractClassPublishedEvent.fromLog(log)));
        // Fee payment insertion has already been done. Do the rest.
        await this.doTreeInsertionsForPrivateOnlyTx(processedTx);
        await this.contractsDB.addNewContracts(tx);
        return [
            processedTx,
            undefined
        ];
    }
    async processTxWithPublicCalls(tx) {
        const timer = new Timer();
        const result = await this.publicTxSimulator.simulate(tx);
        // TODO: use the callStackMetadata here to extract more data about public execution
        const { hints, publicInputs, publicTxEffect, gasUsed, revertCode/*callStackMetadata*/  } = result;
        const contractClassLogs = revertCode.isOK() ? tx.getContractClassLogs() : tx.getSplitContractClassLogs(false);
        this.metrics.recordClassPublication(...contractClassLogs.filter((log)=>ContractClassPublishedEvent.isContractClassPublishedEvent(log)).map((log)=>ContractClassPublishedEvent.fromLog(log)));
        // TODO(fcarreiro): remove phase count metric.
        const durationMs = timer.ms();
        this.metrics.recordTx(/*phaseCount=*/ 1, durationMs, gasUsed.publicGas);
        // Extract the return values from the call stack metadata.
        const appLogicReturnValues = result.getAppLogicReturnValues();
        // Extract the revert reason from the call stack metadata.
        const revertReason = result.findRevertReason();
        // Create proving request if we have hints and public inputs.
        const avmProvingRequest = hints && publicInputs ? PublicProcessor.generateProvingRequest(publicInputs, hints) : undefined;
        const processedTx = makeProcessedTxFromTxWithPublicCalls(tx, this.globalVariables, avmProvingRequest, publicTxEffect, gasUsed, revertCode, revertReason);
        return [
            processedTx,
            appLogicReturnValues
        ];
    }
    /**
   * Generate the proving request for the AVM circuit.
   */ static generateProvingRequest(publicInputs, hints = AvmExecutionHints.empty()) {
        return {
            type: ProvingRequestType.PUBLIC_VM,
            inputs: new AvmCircuitInputs(hints, publicInputs)
        };
    }
}
