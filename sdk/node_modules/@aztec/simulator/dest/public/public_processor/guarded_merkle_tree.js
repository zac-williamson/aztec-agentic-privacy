var _computedKey;
import { SerialQueue } from '@aztec/foundation/queue';
_computedKey = Symbol.asyncDispose;
/**
 * Wraps an instance of `MerkleTreeWriteOperations` to allow the sequencer to gate access.
 * If transactions execution goes past the deadline, the simulator will continue to execute and update the world state
 * The public processor however requires that the world state remain constant after the deadline in order to finalize the block
 * The public processor provides this implementation of MerkleTreeWriteOperations to the simulator
 */ export class GuardedMerkleTreeOperations {
    target;
    isStopped;
    serialQueue;
    constructor(target){
        this.target = target;
        this.isStopped = false;
        this.serialQueue = new SerialQueue();
        this.serialQueue.start();
    }
    guard() {
        if (this.isStopped) {
            throw new Error('Merkle tree access has been stopped');
        }
    }
    // Executes the provided function only if the guard is not stopped.
    guardAndPush(fn) {
        this.guard();
        return this.serialQueue.put(()=>{
            this.guard();
            return fn();
        });
    }
    getUnderlyingFork() {
        return this.target;
    }
    // Stops all further access to the merkle trees via this object
    async stop() {
        await this.serialQueue.put(()=>{
            this.isStopped = true;
            return Promise.resolve();
        });
        return this.serialQueue.end();
    }
    // Proxy all methods to the target
    appendLeaves(treeId, leaves) {
        return this.guardAndPush(()=>this.target.appendLeaves(treeId, leaves));
    }
    updateArchive(header) {
        return this.guardAndPush(()=>this.target.updateArchive(header));
    }
    batchInsert(treeId, leaves, subtreeHeight) {
        return this.guardAndPush(()=>this.target.batchInsert(treeId, leaves, subtreeHeight));
    }
    sequentialInsert(treeId, leaves) {
        return this.guardAndPush(()=>this.target.sequentialInsert(treeId, leaves));
    }
    close() {
        return this.guardAndPush(()=>this.target.close());
    }
    async [_computedKey]() {
        await this.close();
    }
    getTreeInfo(treeId) {
        return this.guardAndPush(()=>this.target.getTreeInfo(treeId));
    }
    getStateReference() {
        return this.guardAndPush(()=>this.target.getStateReference());
    }
    getInitialHeader() {
        return this.target.getInitialHeader();
    }
    getRevision() {
        return this.target.getRevision();
    }
    getSiblingPath(treeId, index) {
        return this.guardAndPush(()=>this.target.getSiblingPath(treeId, index));
    }
    getPreviousValueIndex(treeId, value) {
        return this.guardAndPush(()=>this.target.getPreviousValueIndex(treeId, value));
    }
    getLeafPreimage(treeId, index) {
        return this.guardAndPush(()=>this.target.getLeafPreimage(treeId, index));
    }
    findLeafIndices(treeId, values) {
        return this.guardAndPush(()=>this.target.findLeafIndices(treeId, values));
    }
    findLeafIndicesAfter(treeId, values, startIndex) {
        return this.guardAndPush(()=>this.target.findLeafIndicesAfter(treeId, values, startIndex));
    }
    getLeafValue(treeId, index) {
        return this.guardAndPush(()=>this.target.getLeafValue(treeId, index));
    }
    getBlockNumbersForLeafIndices(treeId, leafIndices) {
        return this.guardAndPush(()=>this.target.getBlockNumbersForLeafIndices(treeId, leafIndices));
    }
    createCheckpoint() {
        return this.guardAndPush(()=>this.target.createCheckpoint());
    }
    commitCheckpoint() {
        return this.guardAndPush(()=>this.target.commitCheckpoint());
    }
    revertCheckpoint() {
        return this.guardAndPush(()=>this.target.revertCheckpoint());
    }
    commitAllCheckpoints() {
        return this.guardAndPush(()=>this.target.commitAllCheckpoints());
    }
    revertAllCheckpoints() {
        return this.guardAndPush(()=>this.target.revertAllCheckpoints());
    }
    findSiblingPaths(treeId, values) {
        return this.guardAndPush(()=>this.target.findSiblingPaths(treeId, values));
    }
}
