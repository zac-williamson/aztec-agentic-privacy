import { L1_TO_L2_MSG_TREE_LEAF_COUNT, MAX_L2_TO_L1_MSGS_PER_TX, MAX_NOTE_HASHES_PER_TX, MAX_NULLIFIERS_PER_TX, MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS, NOTE_HASH_TREE_LEAF_COUNT } from '@aztec/constants';
import { CheckedPublicExecutionError } from './public_errors.js';
/**
 * Any error that can be thrown during side effect insertion in public.
 * Includes SideEffectLimitReachedError and NullifierCollisionError.
 */ export class SideEffectError extends CheckedPublicExecutionError {
    constructor(message){
        super(message);
        this.name = 'SideEffectInsertionError';
    }
}
export class SideEffectLimitReachedError extends SideEffectError {
    constructor(sideEffectType, limit){
        super(`Reached the limit (${limit}) on number of '${sideEffectType}' per tx`);
        this.name = 'SideEffectLimitReachedError';
    }
}
export class MaxCallsToUniqueContractClassIdsError extends SideEffectLimitReachedError {
    constructor(){
        super('contract calls to unique class IDs', MAX_PUBLIC_CALLS_TO_UNIQUE_CONTRACT_CLASS_IDS);
        this.name = 'MaxCallsToUniqueContractClassIdsError';
    }
}
export class NullifierLimitReachedError extends SideEffectLimitReachedError {
    constructor(){
        super('nullifier', MAX_NULLIFIERS_PER_TX);
        this.name = 'NullifierLimitReachedError';
    }
}
export class NoteHashLimitReachedError extends SideEffectLimitReachedError {
    constructor(){
        super('note hash', MAX_NOTE_HASHES_PER_TX);
        this.name = 'NoteHashLimitReachedError';
    }
}
export class L2ToL1MessageLimitReachedError extends SideEffectLimitReachedError {
    constructor(){
        super('l2 to l1 message', MAX_L2_TO_L1_MSGS_PER_TX);
        this.name = 'L2ToL1MessageLimitReachedError';
    }
}
export class NullifierCollisionError extends SideEffectError {
    constructor(message){
        super(`Nullifier collision: ${message}`);
        this.name = 'NullifierCollisionError';
    }
}
/**
 * Any error that can be thrown during side effect reads in public.
 * Note: Thrown at state manager level and unknown by simulation, hence NOT considered
 * CheckedPublicExecutionErrors. Currently only includes append-only tree reads.
 */ export class SideEffectReadError extends Error {
    constructor(message){
        super(message);
        this.name = 'SideEffectReadError';
    }
}
export class IndexOutOfRangeError extends SideEffectReadError {
    constructor(tree, index, limit){
        super(`Attempting to read index ${index} of ${tree} tree with maximum ${limit} leaves`);
        this.name = 'IndexOutOfRangeError';
    }
}
export class NoteHashIndexOutOfRangeError extends IndexOutOfRangeError {
    constructor(index){
        super('note hash', index, NOTE_HASH_TREE_LEAF_COUNT);
        this.name = 'NoteHashIndexOutOfRangeError';
    }
}
export class L1ToL2MessageIndexOutOfRangeError extends IndexOutOfRangeError {
    constructor(index){
        super('l1 to l2 message', index, L1_TO_L2_MSG_TREE_LEAF_COUNT);
        this.name = 'L1ToL2MessageIndexOutOfRangeError';
    }
}
