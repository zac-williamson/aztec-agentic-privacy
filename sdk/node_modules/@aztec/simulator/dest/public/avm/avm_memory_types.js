import { MEM_TAG_FF, MEM_TAG_U1, MEM_TAG_U8, MEM_TAG_U16, MEM_TAG_U32, MEM_TAG_U64, MEM_TAG_U128 } from '@aztec/constants';
import { toBufferBE } from '@aztec/foundation/bigint-buffer';
import { Fr } from '@aztec/foundation/curves/bn254';
import { createLogger } from '@aztec/foundation/log';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { strict as assert } from 'assert';
import { InvalidTagValueError, MemorySliceOutOfRangeError, TagCheckError } from './errors.js';
/** MemoryValue gathers the common operations for all memory types. */ export class MemoryValue {
    getTag() {
        return TaggedMemory.getTag(this);
    }
    // To field
    toFr() {
        return new Fr(this.toBigInt());
    }
    toAztecAddress() {
        return new AztecAddress(this.toFr());
    }
    // To number. Throws if exceeds max safe int.
    toNumber() {
        return this.toFr().toNumber();
    }
    toString() {
        return `${this.constructor.name}(0x${this.toBigInt().toString(16)})`;
    }
}
/** IntegralValue gathers the common operations for all integral memory types. */ export class IntegralValue extends MemoryValue {
}
/**
 * This function creates a class for unsigned integers of a given number of bits.
 * In TypeScript terms, it's a class mixin.
 **/ function UnsignedIntegerClassFactory(bits) {
    return class NewUintClass extends IntegralValue {
        static bits = bits;
        static mod = 1n << BigInt(bits);
        static bitmask = this.mod - 1n;
        n;
        constructor(n){
            super();
            this.n = BigInt(n);
            assert(n >= 0n, `${this.constructor.name} cannot handle negative values: ${n}.`);
            assert(n < NewUintClass.mod, `Value ${n} is too large for ${this.constructor.name}.`);
        }
        build(n) {
            return new this.constructor.prototype.constructor(n);
        }
        add(rhs) {
            return this.build(this.n + rhs.n & NewUintClass.bitmask);
        }
        sub(rhs) {
            const res = this.n - rhs.n;
            return this.build(res >= 0 ? res : res + NewUintClass.mod);
        }
        mul(rhs) {
            return this.build(this.n * rhs.n & NewUintClass.bitmask);
        }
        div(rhs) {
            return this.build(this.n / rhs.n);
        }
        // No sign extension.
        shr(rhs) {
            // Note that this.n is >= 0 by class invariant.
            return this.build(this.n >> rhs.n);
        }
        shl(rhs) {
            const shiftAmount = rhs.n;
            const bitSize = BigInt(NewUintClass.bits);
            // Shifting by more than the bit size always results in 0
            if (shiftAmount >= bitSize) {
                return this.build(0n);
            }
            return this.build(this.n << shiftAmount & NewUintClass.bitmask);
        }
        and(rhs) {
            return this.build(this.n & rhs.n);
        }
        or(rhs) {
            return this.build(this.n | rhs.n);
        }
        xor(rhs) {
            return this.build(this.n ^ rhs.n);
        }
        not() {
            return this.build(~this.n & NewUintClass.bitmask);
        }
        equals(rhs) {
            return this.n === rhs.n;
        }
        lt(rhs) {
            return this.n < rhs.n;
        }
        toBigInt() {
            return this.n;
        }
        toBuffer() {
            if (bits < 8) {
                return toBufferBE(this.n, 1);
            }
            return toBufferBE(this.n, bits / 8);
        }
    };
}
// Now we can create the classes for each unsigned integer type.
// We extend instead of just assigning so that the class has the right name.
// Otherwise they are all called "NewUintClass".
export class Uint1 extends UnsignedIntegerClassFactory(1) {
}
export class Uint8 extends UnsignedIntegerClassFactory(8) {
}
export class Uint16 extends UnsignedIntegerClassFactory(16) {
}
export class Uint32 extends UnsignedIntegerClassFactory(32) {
}
export class Uint64 extends UnsignedIntegerClassFactory(64) {
}
export class Uint128 extends UnsignedIntegerClassFactory(128) {
}
export class Field extends MemoryValue {
    static MODULUS = Fr.MODULUS;
    rep;
    constructor(v){
        super();
        this.rep = new Fr(v);
    }
    build(n) {
        return new Field(n);
    }
    add(rhs) {
        return new Field(this.rep.add(rhs.rep));
    }
    sub(rhs) {
        return new Field(this.rep.sub(rhs.rep));
    }
    mul(rhs) {
        return new Field(this.rep.mul(rhs.rep));
    }
    // Euclidean division.
    div(rhs) {
        return new Field(this.rep.ediv(rhs.rep));
    }
    // Field division.
    fdiv(rhs) {
        return new Field(this.rep.div(rhs.rep));
    }
    equals(rhs) {
        return this.rep.equals(rhs.rep);
    }
    lt(rhs) {
        return this.rep.lt(rhs.rep);
    }
    toBigInt() {
        return this.rep.toBigInt();
    }
    toBuffer() {
        return this.rep.toBuffer();
    }
}
export var TypeTag = /*#__PURE__*/ function(TypeTag) {
    TypeTag[TypeTag["FIELD"] = MEM_TAG_FF] = "FIELD";
    TypeTag[TypeTag["UINT1"] = MEM_TAG_U1] = "UINT1";
    TypeTag[TypeTag["UINT8"] = MEM_TAG_U8] = "UINT8";
    TypeTag[TypeTag["UINT16"] = MEM_TAG_U16] = "UINT16";
    TypeTag[TypeTag["UINT32"] = MEM_TAG_U32] = "UINT32";
    TypeTag[TypeTag["UINT64"] = MEM_TAG_U64] = "UINT64";
    TypeTag[TypeTag["UINT128"] = MEM_TAG_U128] = "UINT128";
    TypeTag[TypeTag["INVALID"] = MEM_TAG_U128 + 1] = "INVALID";
    return TypeTag;
}({});
export class TaggedMemory {
    static log = createLogger('simulator:avm:memory');
    // Whether to track and validate memory accesses for each instruction.
    static TRACK_MEMORY_ACCESSES = process.env.NODE_ENV === 'test';
    // Memory is modelled by a map with key type being number.
    // We however restrict the keys to be non-negative integers smaller than
    // MAX_MEMORY_SIZE.
    static MAX_MEMORY_SIZE = Number(1n << 32n);
    _mem;
    constructor(){
        this._mem = new Map();
    }
    getMaxMemorySize() {
        return TaggedMemory.MAX_MEMORY_SIZE;
    }
    get(offset) {
        return this.getAs(offset);
    }
    getAs(offset) {
        assert(Number.isInteger(offset) && offset < TaggedMemory.MAX_MEMORY_SIZE);
        const word = this._mem.get(offset);
        //TaggedMemory.log.trace(`Memory read: ${offset} -> ${word}`);
        if (word === undefined) {
            TaggedMemory.log.debug(`WARNING: Memory at offset ${offset} is undefined!`);
            return new Field(0);
        }
        return word;
    }
    getSlice(offset, size) {
        assert(Number.isInteger(offset) && Number.isInteger(size));
        if (offset + size > TaggedMemory.MAX_MEMORY_SIZE) {
            throw new MemorySliceOutOfRangeError(offset, size);
        }
        const slice = new Array(size);
        for(let i = 0; i < size; i++){
            slice[i] = this._mem.get(offset + i) ?? new Field(0);
        }
        TaggedMemory.log.trace(`getSlice(${offset}, ${size}) = ${slice}`);
        return slice;
    }
    getSliceAs(offset, size) {
        return this.getSlice(offset, size);
    }
    getSliceTags(offset, size) {
        return this.getSlice(offset, size).map(TaggedMemory.getTag);
    }
    set(offset, v) {
        assert(Number.isInteger(offset) && offset < TaggedMemory.MAX_MEMORY_SIZE);
        this._mem.set(offset, v);
    //TaggedMemory.log.trace(`Memory write: ${offset} <- ${v}`);
    }
    setSlice(offset, slice) {
        assert(Number.isInteger(offset));
        if (offset + slice.length > TaggedMemory.MAX_MEMORY_SIZE) {
            throw new MemorySliceOutOfRangeError(offset, slice.length);
        }
        slice.forEach((element, idx)=>{
            this._mem.set(offset + idx, element);
        });
        TaggedMemory.log.trace(`setSlice(${offset}, ${slice})`);
    }
    getTag(offset) {
        assert(Number.isInteger(offset) && offset < TaggedMemory.MAX_MEMORY_SIZE);
        return TaggedMemory.getTag(this._mem.get(offset));
    }
    /**
   * Check that the memory at the given offset matches the specified tag.
   */ checkTag(tag, offset) {
        const gotTag = this.getTag(offset);
        if (gotTag !== tag) {
            throw TagCheckError.forOffset(offset, TypeTag[gotTag], TypeTag[tag]);
        }
    }
    static isValidMemoryAddressTag(tag) {
        return tag === TypeTag.UINT32;
    }
    static checkIsIntegralTag(tag) {
        if (!INTEGRAL_TAGS.has(tag)) {
            throw TagCheckError.forTag(TypeTag[tag], 'integral');
        }
    }
    static checkIsValidTag(tagNumber) {
        if (!VALID_TAGS.has(tagNumber)) {
            throw new InvalidTagValueError(tagNumber);
        }
    }
    /**
   * Check tags for memory at all of the specified offsets.
   */ checkTags(tag, ...offsets) {
        for (const offset of offsets){
            this.checkTag(tag, offset);
        }
    }
    /**
   * Check that all tags at the given offsets are the same.
   */ checkTagsAreSame(offset0, offset1) {
        const tag0 = this.getTag(offset0);
        this.checkTag(tag0, offset1);
    }
    /**
   * Check tags for all memory in the specified range.
   */ checkTagsRange(tag, startOffset, size) {
        if (startOffset + size > TaggedMemory.MAX_MEMORY_SIZE) {
            throw new MemorySliceOutOfRangeError(startOffset, size);
        }
        for(let offset = startOffset; offset < startOffset + size; offset++){
            this.checkTag(tag, offset);
        }
    }
    static getTag(v) {
        if (v === undefined) {
            return TypeTag.FIELD; // uninitialized memory is Field(0)
        } else {
            return TAG_FOR_MEM_VAL.get(v.constructor.name) ?? TypeTag.INVALID;
        }
    }
    // Truncates the value to fit the type.
    static buildFromTagTruncating(v, tag) {
        v = BigInt(v);
        switch(tag){
            case TypeTag.FIELD:
                return new Field(v);
            case TypeTag.UINT1:
                return new Uint1(v & 1n);
            case TypeTag.UINT8:
                return new Uint8(v & (1n << 8n) - 1n);
            case TypeTag.UINT16:
                return new Uint16(v & (1n << 16n) - 1n);
            case TypeTag.UINT32:
                return new Uint32(v & (1n << 32n) - 1n);
            case TypeTag.UINT64:
                return new Uint64(v & (1n << 64n) - 1n);
            case TypeTag.UINT128:
                return new Uint128(v & (1n << 128n) - 1n);
            default:
                throw new InvalidTagValueError(tag);
        }
    }
}
const TAG_FOR_MEM_VAL = new Map([
    [
        'Field',
        TypeTag.FIELD
    ],
    [
        'Uint1',
        TypeTag.UINT1
    ],
    [
        'Uint8',
        TypeTag.UINT8
    ],
    [
        'Uint16',
        TypeTag.UINT16
    ],
    [
        'Uint32',
        TypeTag.UINT32
    ],
    [
        'Uint64',
        TypeTag.UINT64
    ],
    [
        'Uint128',
        TypeTag.UINT128
    ]
]);
const VALID_TAGS = new Set([
    TypeTag.FIELD,
    TypeTag.UINT1,
    TypeTag.UINT8,
    TypeTag.UINT16,
    TypeTag.UINT32,
    TypeTag.UINT64,
    TypeTag.UINT128
]);
const INTEGRAL_TAGS = new Set([
    TypeTag.UINT1,
    TypeTag.UINT8,
    TypeTag.UINT16,
    TypeTag.UINT32,
    TypeTag.UINT64,
    TypeTag.UINT128
]);
