import type { Fr } from '@aztec/foundation/curves/bn254';
import type { Gas } from './avm_gas.js';
import { TaggedMemory } from './avm_memory_types.js';
import { type ReturnData } from './calldata.js';
import { type AvmRevertReason } from './errors.js';
/**
 * A few fields of machine state are initialized from AVM session inputs or call instruction arguments
 */
export type InitialAvmMachineState = {
    l2GasLeft: number;
    daGasLeft: number;
};
/**
 * Used to track the call stack and revert data of nested calls.
 * This is used to provide a more detailed revert reason when a contract call reverts.
 * It is only a heuristic and may not always provide the correct revert reason.
 */
type TrackedRevertInfo = {
    revertDataRepresentative: Fr[];
    recursiveRevertReason: AvmRevertReason;
};
type CallStackEntry = {
    callPc: number;
    returnPc: number;
};
/**
 * Avm state modified on an instruction-per-instruction basis.
 */
export declare class AvmMachineState {
    /** gas remaining of the gas allocated for a contract call */
    l2GasLeft: number;
    daGasLeft: number;
    /** program counter, byte based */
    pc: number;
    /** program counter of the next instruction, byte based */
    nextPc: number;
    /** return/revertdata of the last nested call. */
    nestedReturndata: ReturnData;
    /** Tracks whether the last external call was successful */
    nestedCallSuccess: boolean;
    /**
     * Used to track the call stack and revert data of nested calls.
     * This is used to provide a more detailed revert reason when a contract call reverts.
     * It is only a heuristic and may not always provide the correct revert reason.
     */
    collectedRevertInfo: TrackedRevertInfo | undefined;
    /**
     * On INTERNALCALL, internal call stack is pushed to with the current pc and the return pc.
     * On INTERNALRETURN, value is popped from the internal call stack and assigned to the return pc.
     */
    internalCallStack: CallStackEntry[];
    /** Memory accessible to user code */
    readonly memory: TaggedMemory;
    /**
     * Signals that execution should end.
     * AvmContext execution continues executing instructions until the machine state signals "halted"
     */
    private halted;
    /** Signals that execution has reverted normally (this does not cover exceptional halts) */
    private reverted;
    /** Output data must NOT be modified once it is set */
    private output;
    /** instruction counter, including nested calls */
    instrCounter: number;
    constructor(gasLeft: Gas);
    constructor(l2GasLeft: number, daGasLeft: number);
    get gasLeft(): Gas;
    static fromState(state: InitialAvmMachineState): AvmMachineState;
    /**
     * Consumes the given gas.
     * Should any of the gas dimensions get depleted, it sets all gas left to zero and triggers
     * an exceptional halt by throwing an OutOfGasError.
     */
    consumeGas(gasCost: Partial<Gas>): void;
    /** Increases the gas left by the amounts specified. */
    refundGas(gasRefund: Partial<Gas>): void;
    /**
     * Halt as successful
     * Output data must NOT be modified once it is set
     * @param output
     */
    return(output: ReturnData): void;
    /**
     * Halt as reverted
     * Output data must NOT be modified once it is set
     * @param output
     */
    revert(output: ReturnData): void;
    getHalted(): boolean;
    getReverted(): boolean;
    getOutput(): ReturnData;
    /**
     * Flag an exceptional halt. Clears gas left and sets the reverted flag. No output data.
     */
    private exceptionalHalt;
}
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZtX21hY2hpbmVfc3RhdGUuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wdWJsaWMvYXZtL2F2bV9tYWNoaW5lX3N0YXRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxFQUFFLEVBQUUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRXpELE9BQU8sS0FBSyxFQUFFLEdBQUcsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN4QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDckQsT0FBTyxFQUFFLEtBQUssVUFBVSxFQUFtQixNQUFNLGVBQWUsQ0FBQztBQUNqRSxPQUFPLEVBQUUsS0FBSyxlQUFlLEVBQWlCLE1BQU0sYUFBYSxDQUFDO0FBRWxFOztHQUVHO0FBQ0gsTUFBTSxNQUFNLHNCQUFzQixHQUFHO0lBQ25DLFNBQVMsRUFBRSxNQUFNLENBQUM7SUFDbEIsU0FBUyxFQUFFLE1BQU0sQ0FBQztDQUNuQixDQUFDO0FBRUY7Ozs7R0FJRztBQUNILEtBQUssaUJBQWlCLEdBQUc7SUFDdkIsd0JBQXdCLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFDL0IscUJBQXFCLEVBQUUsZUFBZSxDQUFDO0NBQ3hDLENBQUM7QUFFRixLQUFLLGNBQWMsR0FBRztJQUNwQixNQUFNLEVBQUUsTUFBTSxDQUFDO0lBQ2YsUUFBUSxFQUFFLE1BQU0sQ0FBQztDQUNsQixDQUFDO0FBRUY7O0dBRUc7QUFDSCxxQkFBYSxlQUFlO0lBQzFCLDZEQUE2RDtJQUN0RCxTQUFTLEVBQUUsTUFBTSxDQUFDO0lBQ2xCLFNBQVMsRUFBRSxNQUFNLENBQUM7SUFDekIsa0NBQWtDO0lBQzNCLEVBQUUsRUFBRSxNQUFNLENBQUs7SUFDdEIsMERBQTBEO0lBQ25ELE1BQU0sRUFBRSxNQUFNLENBQUs7SUFDMUIsaURBQWlEO0lBQzFDLGdCQUFnQixFQUFFLFVBQVUsQ0FBMkI7SUFDOUQsMkRBQTJEO0lBQ3BELGlCQUFpQixFQUFFLE9BQU8sQ0FBUztJQUMxQzs7OztPQUlHO0lBQ0ksbUJBQW1CLEVBQUUsaUJBQWlCLEdBQUcsU0FBUyxDQUFDO0lBRTFEOzs7T0FHRztJQUNJLGlCQUFpQixFQUFFLGNBQWMsRUFBRSxDQUFNO0lBRWhELHFDQUFxQztJQUNyQyxTQUFnQixNQUFNLEVBQUUsWUFBWSxDQUFzQjtJQUUxRDs7O09BR0c7SUFDSCxPQUFPLENBQUMsTUFBTSxDQUFrQjtJQUNoQywyRkFBMkY7SUFDM0YsT0FBTyxDQUFDLFFBQVEsQ0FBa0I7SUFDbEMsc0RBQXNEO0lBQ3RELE9BQU8sQ0FBQyxNQUFNLENBQXVDO0lBR3JELGtEQUFrRDtJQUMzQyxZQUFZLEVBQUUsTUFBTSxDQUFLO0lBR2hDLFlBQVksT0FBTyxFQUFFLEdBQUcsRUFBRTtJQUMxQixZQUFZLFNBQVMsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRTtJQVVsRCxJQUFXLE9BQU8sSUFBSSxHQUFHLENBRXhCO0lBRUQsT0FBYyxTQUFTLENBQUMsS0FBSyxFQUFFLHNCQUFzQixHQUFHLGVBQWUsQ0FFdEU7SUFFRDs7OztPQUlHO0lBQ0ksVUFBVSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBbUJ0QztJQUVELHVEQUF1RDtJQUNoRCxTQUFTLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFHdkM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLFFBRy9CO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxNQUFNLEVBQUUsVUFBVSxRQUkvQjtJQUVNLFNBQVMsSUFBSSxPQUFPLENBRTFCO0lBRU0sV0FBVyxJQUFJLE9BQU8sQ0FFNUI7SUFFTSxTQUFTLElBQUksVUFBVSxDQUU3QjtJQUVEOztPQUVHO0lBQ0gsT0FBTyxDQUFDLGVBQWU7Q0FNeEIifQ==