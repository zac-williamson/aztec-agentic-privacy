import { CONTRACT_INSTANCE_REGISTRY_CONTRACT_ADDRESS } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { createLogger } from '@aztec/foundation/log';
import { ProtocolContractAddress } from '@aztec/protocol-contracts';
import { getCanonicalAuthRegistry } from '@aztec/protocol-contracts/auth-registry';
import { computeFeePayerBalanceStorageSlot, getCanonicalFeeJuice } from '@aztec/protocol-contracts/fee-juice';
import { getCanonicalInstanceRegistry } from '@aztec/protocol-contracts/instance-registry';
import { PublicDataWrite } from '@aztec/stdlib/avm';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { computePublicDataTreeLeafSlot, siloNullifier } from '@aztec/stdlib/hash';
import { MerkleTreeId } from '@aztec/stdlib/trees';
import { createContractClassAndInstance } from './utils.js';
/**
 * An abstract test class that enables tests of real apps in the AVM without requiring e2e tests.
 * It enables this by letting us (1) perform pseudo-contract-deployments (and registrations)
 * that trigger merkle tree operations and (2) maintain a contract data source to store
 * and retrieve contract classes and instances.
 *
 * This class is meant to be extended when writing tests for a specific simulation interface.
 * For example, has been extended for testing of the core AvmSimulator, and again for the PublicTxSimulator,
 * both of which benefit from such pseudo-deployments by populating merkle trees and a contract data source
 * with contract information.
 */ export class BaseAvmSimulationTester {
    contractDataSource;
    merkleTrees;
    initialFeePayerBalance;
    logger;
    constructor(contractDataSource, merkleTrees, initialFeePayerBalance = new Fr(10 ** 10)){
        this.contractDataSource = contractDataSource;
        this.merkleTrees = merkleTrees;
        this.initialFeePayerBalance = initialFeePayerBalance;
        this.logger = createLogger('avm-simulation-tester');
    }
    async setFeePayerBalance(feePayer, balance = this.initialFeePayerBalance) {
        const feeJuiceAddress = ProtocolContractAddress.FeeJuice;
        const balanceSlot = await computeFeePayerBalanceStorageSlot(feePayer);
        await this.setPublicStorage(feeJuiceAddress, balanceSlot, balance);
    }
    async setPublicStorage(address, slot, value) {
        const leafSlot = await computePublicDataTreeLeafSlot(address, slot);
        // get existing preimage
        const publicDataWrite = new PublicDataWrite(leafSlot, value);
        await this.merkleTrees.sequentialInsert(MerkleTreeId.PUBLIC_DATA_TREE, [
            publicDataWrite.toBuffer()
        ]);
    }
    /**
   * Derive the contract class and instance with some seed.
   * Add both to the contract data source along with the contract artifact.
   */ async registerAndDeployContract(constructorArgs, deployer, contractArtifact, skipNullifierInsertion = false, seed = 0, contractClassSeed = seed, originalContractClassId) {
        const { contractClass, contractInstance } = await createContractClassAndInstance(constructorArgs, deployer, contractArtifact, seed, contractClassSeed, originalContractClassId);
        await this.contractDataSource.addNewContract(contractArtifact, contractClass, contractInstance);
        if (!skipNullifierInsertion) {
            await this.insertContractAddressNullifier(contractInstance.address);
        }
        return contractInstance;
    }
    async registerFeeJuiceContract() {
        const feeJuice = await getCanonicalFeeJuice();
        const feeJuiceContractClassPublic = {
            ...feeJuice.contractClass,
            privateFunctions: [],
            utilityFunctions: []
        };
        await this.contractDataSource.addNewContract(feeJuice.artifact, feeJuiceContractClassPublic, feeJuice.instance);
        return feeJuice.instance;
    }
    async registerAuthContract() {
        const authRegistry = await getCanonicalAuthRegistry();
        const authRegistryContractClassPublic = {
            ...authRegistry.contractClass,
            privateFunctions: [],
            utilityFunctions: []
        };
        await this.contractDataSource.addNewContract(authRegistry.artifact, authRegistryContractClassPublic, authRegistry.instance);
        return authRegistry.instance;
    }
    async registerInstanceRegistryContract() {
        const instanceRegistry = await getCanonicalInstanceRegistry();
        const instanceRegistryContractClassPublic = {
            ...instanceRegistry.contractClass,
            privateFunctions: [],
            utilityFunctions: []
        };
        await this.contractDataSource.addNewContract(instanceRegistry.artifact, instanceRegistryContractClassPublic, instanceRegistry.instance);
        return instanceRegistry.instance;
    }
    async addContractInstance(contractInstance, skipNullifierInsertion = false) {
        if (!skipNullifierInsertion) {
            await this.insertContractAddressNullifier(contractInstance.address);
        }
        await this.contractDataSource.addContractInstance(contractInstance);
    }
    async insertContractAddressNullifier(contractAddress) {
        const contractAddressNullifier = await siloNullifier(AztecAddress.fromNumber(CONTRACT_INSTANCE_REGISTRY_CONTRACT_ADDRESS), contractAddress.toField());
        await this.merkleTrees.sequentialInsert(MerkleTreeId.NULLIFIER_TREE, [
            contractAddressNullifier.toBuffer()
        ]);
    }
    async insertNullifier(contractThatEmitted, nullifier) {
        const siloedNullifier = await siloNullifier(contractThatEmitted, nullifier);
        await this.merkleTrees.sequentialInsert(MerkleTreeId.NULLIFIER_TREE, [
            siloedNullifier.toBuffer()
        ]);
    }
}
