import { TaggedMemory } from './avm_memory_types.js';
// Allow reading up to 300 kB of return data when unspecified.
const DEFAULT_BEST_EFFORT_READ_CAP = 10000;
export class LazyReaderMemory {
    memory;
    offset;
    size;
    constructor(memory, offset, size){
        this.memory = memory;
        this.offset = offset;
        this.size = size;
    }
    bestEffortReadAll(readCap = DEFAULT_BEST_EFFORT_READ_CAP) {
        const size = Math.min(this.size, readCap, TaggedMemory.MAX_MEMORY_SIZE - this.offset);
        return this.memory.getSlice(this.offset, size).map((word)=>word.toFr());
    }
    read(idx) {
        if (idx >= this.size) {
            return undefined;
        }
        return this.memory.get(this.offset + idx).toFr();
    }
    slice(start, end) {
        const clampedEnd = Math.min(end, this.size);
        const length = Math.max(0, clampedEnd - start);
        return this.memory.getSlice(this.offset + start, length).map((word)=>word.toFr());
    }
    readAll() {
        return this.memory.getSlice(this.offset, this.size).map((word)=>word.toFr());
    }
    length() {
        return this.size;
    }
}
export class LazyReaderArray {
    array;
    constructor(array){
        this.array = array;
    }
    bestEffortReadAll(readCap = DEFAULT_BEST_EFFORT_READ_CAP) {
        return this.array.slice(0, readCap);
    }
    read(idx) {
        return this.array[idx];
    }
    slice(start, end) {
        return this.array.slice(start, end);
    }
    readAll() {
        return this.array;
    }
    length() {
        return this.array.length;
    }
}
export class CallDataArray extends LazyReaderArray {
}
export class CallDataMemory extends LazyReaderMemory {
}
export class ReturnDataArray extends LazyReaderArray {
}
export class ReturnDataMemory extends LazyReaderMemory {
}
