import type { Point } from '@aztec/foundation/curves/grumpkin';
import type { FailingFunction, NoirCallStack } from '@aztec/stdlib/errors';
import { ExecutionError } from '../../common/errors.js';
import { CheckedPublicExecutionError } from '../public_errors.js';
/**
 * Avm-specific errors should derive from this
 */
export declare abstract class AvmExecutionError extends CheckedPublicExecutionError {
    constructor(message: string);
}
export declare class ArithmeticError extends AvmExecutionError {
    constructor(message: string);
}
/**
 * Error is thrown when the program counter goes to an invalid location.
 * There is no instruction at the provided pc
 */
export declare class InvalidProgramCounterError extends AvmExecutionError {
    constructor(pc: number, max: number);
}
/**
 * Error is thrown when the program counter points to a byte
 * of an invalid opcode.
 */
export declare class InvalidOpcodeError extends AvmExecutionError {
    constructor(str: string);
}
/**
 * Error is thrown during parsing.
 */
export declare class AvmParsingError extends AvmExecutionError {
    constructor(str: string);
}
/**
 * Error is thrown when the tag has an invalid value.
 */
export declare class InvalidTagValueError extends AvmExecutionError {
    constructor(tagValue: number);
}
/**
 * Error thrown during an instruction's execution (during its execute()).
 */
export declare class InstructionExecutionError extends AvmExecutionError {
    constructor(message: string);
}
/**
 * Error thrown on failed AVM memory tag check.
 */
export declare class TagCheckError extends AvmExecutionError {
    static forBaseAddress(gotTag: string): TagCheckError;
    static forIndirectAddress(address: number, gotTag: string): TagCheckError;
    static forOffset(offset: number, gotTag: string, expectedTag: string): TagCheckError;
    static forTag(gotTag: string, expectedTag: string): TagCheckError;
    constructor(message: string);
}
/**
 * Error is thrown when a relative memory address resolved to an offset which
 * is out of range, i.e, greater than maxUint32.
 */
export declare class RelativeAddressOutOfRangeError extends AvmExecutionError {
    constructor(baseAddr: number, relOffset: number);
}
/**
 * Error is thrown when a memory slice contains addresses which are
 * out of range, i.e, greater than maxUint32.
 */
export declare class MemorySliceOutOfRangeError extends AvmExecutionError {
    constructor(baseAddr: number, size: number);
}
/** Error thrown when out of gas. */
export declare class OutOfGasError extends AvmExecutionError {
    constructor(dimensions: string[]);
}
/**
 * Error is thrown when one of the supplied points does not lie on the Grumpkin curve. Specific for ECADD opcode.
 */
export declare class EcAddPointNotOnCurveError extends AvmExecutionError {
    constructor(pointIndex: number, point: Point);
}
/**
 * Error is thrown when some inputs of ToRadixBE are not valid.
 */
export declare class InvalidToRadixInputsError extends AvmExecutionError {
    constructor(errorString: string);
}
/**
 * Error is thrown when a static call attempts to alter some state
 */
export declare class StaticCallAlterationError extends InstructionExecutionError {
    constructor();
}
/**
 * Meaningfully named alias for ExecutionError when used in the context of the AVM.
 * Maintains a recursive structure reflecting the AVM's external callstack/errorstack, where
 * options.cause is the error that caused this error (if this is not the root-cause itself).
 */
export declare class AvmRevertReason extends ExecutionError {
    constructor(message: string, failingFunction: FailingFunction, noirCallStack: NoirCallStack, options?: ErrorOptions);
}
/**
 * Helper to annotate errors occurring during instruction fetching.
 */
export declare function duringInstrFetch(error: Error, pc: number): Error;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3JzLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcHVibGljL2F2bS9lcnJvcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDL0QsT0FBTyxLQUFLLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRTNFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUVsRTs7R0FFRztBQUNILDhCQUFzQixpQkFBa0IsU0FBUSwyQkFBMkI7SUFDekUsWUFBWSxPQUFPLEVBQUUsTUFBTSxFQUcxQjtDQUNGO0FBRUQscUJBQWEsZUFBZ0IsU0FBUSxpQkFBaUI7SUFDcEQsWUFBWSxPQUFPLEVBQUUsTUFBTSxFQUcxQjtDQUNGO0FBRUQ7OztHQUdHO0FBQ0gscUJBQWEsMEJBQTJCLFNBQVEsaUJBQWlCO0lBQy9ELFlBQVksRUFBRSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUdsQztDQUNGO0FBRUQ7OztHQUdHO0FBQ0gscUJBQWEsa0JBQW1CLFNBQVEsaUJBQWlCO0lBQ3ZELFlBQVksR0FBRyxFQUFFLE1BQU0sRUFHdEI7Q0FDRjtBQUVEOztHQUVHO0FBQ0gscUJBQWEsZUFBZ0IsU0FBUSxpQkFBaUI7SUFDcEQsWUFBWSxHQUFHLEVBQUUsTUFBTSxFQUd0QjtDQUNGO0FBRUQ7O0dBRUc7QUFDSCxxQkFBYSxvQkFBcUIsU0FBUSxpQkFBaUI7SUFDekQsWUFBWSxRQUFRLEVBQUUsTUFBTSxFQUczQjtDQUNGO0FBRUQ7O0dBRUc7QUFDSCxxQkFBYSx5QkFBMEIsU0FBUSxpQkFBaUI7SUFDOUQsWUFBWSxPQUFPLEVBQUUsTUFBTSxFQUcxQjtDQUNGO0FBRUQ7O0dBRUc7QUFDSCxxQkFBYSxhQUFjLFNBQVEsaUJBQWlCO0lBQ2xELE9BQWMsY0FBYyxDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUcsYUFBYSxDQUUxRDtJQUNELE9BQWMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxHQUFHLGFBQWEsQ0FFL0U7SUFDRCxPQUFjLFNBQVMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLE1BQU0sR0FBRyxhQUFhLENBRTFGO0lBRUQsT0FBYyxNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsTUFBTSxHQUFHLGFBQWEsQ0FFdkU7SUFFRCxZQUFZLE9BQU8sRUFBRSxNQUFNLEVBRzFCO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxxQkFBYSw4QkFBK0IsU0FBUSxpQkFBaUI7SUFDbkUsWUFBWSxRQUFRLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBRzlDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxxQkFBYSwwQkFBMkIsU0FBUSxpQkFBaUI7SUFDL0QsWUFBWSxRQUFRLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLEVBR3pDO0NBQ0Y7QUFFRCxvQ0FBb0M7QUFDcEMscUJBQWEsYUFBYyxTQUFRLGlCQUFpQjtJQUNsRCxZQUFZLFVBQVUsRUFBRSxNQUFNLEVBQUUsRUFHL0I7Q0FDRjtBQUVEOztHQUVHO0FBQ0gscUJBQWEseUJBQTBCLFNBQVEsaUJBQWlCO0lBQzlELFlBQVksVUFBVSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUczQztDQUNGO0FBRUQ7O0dBRUc7QUFDSCxxQkFBYSx5QkFBMEIsU0FBUSxpQkFBaUI7SUFDOUQsWUFBWSxXQUFXLEVBQUUsTUFBTSxFQUc5QjtDQUNGO0FBRUQ7O0dBRUc7QUFDSCxxQkFBYSx5QkFBMEIsU0FBUSx5QkFBeUI7SUFDdEUsY0FHQztDQUNGO0FBRUQ7Ozs7R0FJRztBQUNILHFCQUFhLGVBQWdCLFNBQVEsY0FBYztJQUNqRCxZQUFZLE9BQU8sRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLE9BQU8sQ0FBQyxFQUFFLFlBQVksRUFFbEg7Q0FDRjtBQUVEOztHQUVHO0FBQ0gsd0JBQWdCLGdCQUFnQixDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFLE1BQU0sU0FHeEQifQ==