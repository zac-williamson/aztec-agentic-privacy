import { Fr } from '@aztec/foundation/curves/bn254';
import { type Logger } from '@aztec/foundation/log';
import type { FunctionsOf } from '@aztec/foundation/types';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
/** MemoryValue gathers the common operations for all memory types. */
export declare abstract class MemoryValue {
    abstract add(rhs: MemoryValue): MemoryValue;
    abstract sub(rhs: MemoryValue): MemoryValue;
    abstract mul(rhs: MemoryValue): MemoryValue;
    abstract div(rhs: MemoryValue): MemoryValue;
    abstract equals(rhs: MemoryValue): boolean;
    abstract lt(rhs: MemoryValue): boolean;
    abstract build(n: bigint): MemoryValue;
    abstract toBigInt(): bigint;
    getTag(): TypeTag;
    abstract toBuffer(): Buffer;
    toFr(): Fr;
    toAztecAddress(): AztecAddress;
    toNumber(): number;
    toString(): string;
}
/** IntegralValue gathers the common operations for all integral memory types. */
export declare abstract class IntegralValue extends MemoryValue {
    abstract shl(rhs: IntegralValue): IntegralValue;
    abstract shr(rhs: IntegralValue): IntegralValue;
    abstract and(rhs: IntegralValue): IntegralValue;
    abstract or(rhs: IntegralValue): IntegralValue;
    abstract xor(rhs: IntegralValue): IntegralValue;
    abstract not(): IntegralValue;
}
declare const Uint1_base: {
    new (n: number | bigint): {
        readonly n: bigint;
        build(n: bigint): /*elided*/ any;
        add(rhs: /*elided*/ any): /*elided*/ any;
        sub(rhs: /*elided*/ any): /*elided*/ any;
        mul(rhs: /*elided*/ any): /*elided*/ any;
        div(rhs: /*elided*/ any): /*elided*/ any;
        shr(rhs: /*elided*/ any): /*elided*/ any;
        shl(rhs: /*elided*/ any): /*elided*/ any;
        and(rhs: /*elided*/ any): /*elided*/ any;
        or(rhs: /*elided*/ any): /*elided*/ any;
        xor(rhs: /*elided*/ any): /*elided*/ any;
        not(): /*elided*/ any;
        equals(rhs: /*elided*/ any): boolean;
        lt(rhs: /*elided*/ any): boolean;
        toBigInt(): bigint;
        toBuffer(): Buffer<ArrayBufferLike>;
        getTag(): TypeTag;
        toFr(): Fr;
        toAztecAddress(): AztecAddress;
        toNumber(): number;
        toString(): string;
    };
    readonly bits: number;
    readonly mod: bigint;
    readonly bitmask: bigint;
};
export declare class Uint1 extends Uint1_base {
}
declare const Uint8_base: {
    new (n: number | bigint): {
        readonly n: bigint;
        build(n: bigint): /*elided*/ any;
        add(rhs: /*elided*/ any): /*elided*/ any;
        sub(rhs: /*elided*/ any): /*elided*/ any;
        mul(rhs: /*elided*/ any): /*elided*/ any;
        div(rhs: /*elided*/ any): /*elided*/ any;
        shr(rhs: /*elided*/ any): /*elided*/ any;
        shl(rhs: /*elided*/ any): /*elided*/ any;
        and(rhs: /*elided*/ any): /*elided*/ any;
        or(rhs: /*elided*/ any): /*elided*/ any;
        xor(rhs: /*elided*/ any): /*elided*/ any;
        not(): /*elided*/ any;
        equals(rhs: /*elided*/ any): boolean;
        lt(rhs: /*elided*/ any): boolean;
        toBigInt(): bigint;
        toBuffer(): Buffer<ArrayBufferLike>;
        getTag(): TypeTag;
        toFr(): Fr;
        toAztecAddress(): AztecAddress;
        toNumber(): number;
        toString(): string;
    };
    readonly bits: number;
    readonly mod: bigint;
    readonly bitmask: bigint;
};
export declare class Uint8 extends Uint8_base {
}
declare const Uint16_base: {
    new (n: number | bigint): {
        readonly n: bigint;
        build(n: bigint): /*elided*/ any;
        add(rhs: /*elided*/ any): /*elided*/ any;
        sub(rhs: /*elided*/ any): /*elided*/ any;
        mul(rhs: /*elided*/ any): /*elided*/ any;
        div(rhs: /*elided*/ any): /*elided*/ any;
        shr(rhs: /*elided*/ any): /*elided*/ any;
        shl(rhs: /*elided*/ any): /*elided*/ any;
        and(rhs: /*elided*/ any): /*elided*/ any;
        or(rhs: /*elided*/ any): /*elided*/ any;
        xor(rhs: /*elided*/ any): /*elided*/ any;
        not(): /*elided*/ any;
        equals(rhs: /*elided*/ any): boolean;
        lt(rhs: /*elided*/ any): boolean;
        toBigInt(): bigint;
        toBuffer(): Buffer<ArrayBufferLike>;
        getTag(): TypeTag;
        toFr(): Fr;
        toAztecAddress(): AztecAddress;
        toNumber(): number;
        toString(): string;
    };
    readonly bits: number;
    readonly mod: bigint;
    readonly bitmask: bigint;
};
export declare class Uint16 extends Uint16_base {
}
declare const Uint32_base: {
    new (n: number | bigint): {
        readonly n: bigint;
        build(n: bigint): /*elided*/ any;
        add(rhs: /*elided*/ any): /*elided*/ any;
        sub(rhs: /*elided*/ any): /*elided*/ any;
        mul(rhs: /*elided*/ any): /*elided*/ any;
        div(rhs: /*elided*/ any): /*elided*/ any;
        shr(rhs: /*elided*/ any): /*elided*/ any;
        shl(rhs: /*elided*/ any): /*elided*/ any;
        and(rhs: /*elided*/ any): /*elided*/ any;
        or(rhs: /*elided*/ any): /*elided*/ any;
        xor(rhs: /*elided*/ any): /*elided*/ any;
        not(): /*elided*/ any;
        equals(rhs: /*elided*/ any): boolean;
        lt(rhs: /*elided*/ any): boolean;
        toBigInt(): bigint;
        toBuffer(): Buffer<ArrayBufferLike>;
        getTag(): TypeTag;
        toFr(): Fr;
        toAztecAddress(): AztecAddress;
        toNumber(): number;
        toString(): string;
    };
    readonly bits: number;
    readonly mod: bigint;
    readonly bitmask: bigint;
};
export declare class Uint32 extends Uint32_base {
}
declare const Uint64_base: {
    new (n: number | bigint): {
        readonly n: bigint;
        build(n: bigint): /*elided*/ any;
        add(rhs: /*elided*/ any): /*elided*/ any;
        sub(rhs: /*elided*/ any): /*elided*/ any;
        mul(rhs: /*elided*/ any): /*elided*/ any;
        div(rhs: /*elided*/ any): /*elided*/ any;
        shr(rhs: /*elided*/ any): /*elided*/ any;
        shl(rhs: /*elided*/ any): /*elided*/ any;
        and(rhs: /*elided*/ any): /*elided*/ any;
        or(rhs: /*elided*/ any): /*elided*/ any;
        xor(rhs: /*elided*/ any): /*elided*/ any;
        not(): /*elided*/ any;
        equals(rhs: /*elided*/ any): boolean;
        lt(rhs: /*elided*/ any): boolean;
        toBigInt(): bigint;
        toBuffer(): Buffer<ArrayBufferLike>;
        getTag(): TypeTag;
        toFr(): Fr;
        toAztecAddress(): AztecAddress;
        toNumber(): number;
        toString(): string;
    };
    readonly bits: number;
    readonly mod: bigint;
    readonly bitmask: bigint;
};
export declare class Uint64 extends Uint64_base {
}
declare const Uint128_base: {
    new (n: number | bigint): {
        readonly n: bigint;
        build(n: bigint): /*elided*/ any;
        add(rhs: /*elided*/ any): /*elided*/ any;
        sub(rhs: /*elided*/ any): /*elided*/ any;
        mul(rhs: /*elided*/ any): /*elided*/ any;
        div(rhs: /*elided*/ any): /*elided*/ any;
        shr(rhs: /*elided*/ any): /*elided*/ any;
        shl(rhs: /*elided*/ any): /*elided*/ any;
        and(rhs: /*elided*/ any): /*elided*/ any;
        or(rhs: /*elided*/ any): /*elided*/ any;
        xor(rhs: /*elided*/ any): /*elided*/ any;
        not(): /*elided*/ any;
        equals(rhs: /*elided*/ any): boolean;
        lt(rhs: /*elided*/ any): boolean;
        toBigInt(): bigint;
        toBuffer(): Buffer<ArrayBufferLike>;
        getTag(): TypeTag;
        toFr(): Fr;
        toAztecAddress(): AztecAddress;
        toNumber(): number;
        toString(): string;
    };
    readonly bits: number;
    readonly mod: bigint;
    readonly bitmask: bigint;
};
export declare class Uint128 extends Uint128_base {
}
export declare class Field extends MemoryValue {
    static readonly MODULUS: bigint;
    private readonly rep;
    constructor(v: number | bigint | Fr | Buffer);
    build(n: bigint): Field;
    add(rhs: Field): Field;
    sub(rhs: Field): Field;
    mul(rhs: Field): Field;
    div(rhs: Field): Field;
    fdiv(rhs: Field): Field;
    equals(rhs: Field): boolean;
    lt(rhs: Field): boolean;
    toBigInt(): bigint;
    toBuffer(): Buffer;
}
export declare enum TypeTag {
    FIELD = 0,
    UINT1 = 1,
    UINT8 = 2,
    UINT16 = 3,
    UINT32 = 4,
    UINT64 = 5,
    UINT128 = 6,
    INVALID = 7
}
export type TaggedMemoryInterface = FunctionsOf<TaggedMemory>;
export declare class TaggedMemory implements TaggedMemoryInterface {
    static readonly log: Logger;
    static readonly TRACK_MEMORY_ACCESSES: boolean;
    static readonly MAX_MEMORY_SIZE: number;
    private _mem;
    constructor();
    getMaxMemorySize(): number;
    get(offset: number): MemoryValue;
    getAs<T>(offset: number): T;
    getSlice(offset: number, size: number): MemoryValue[];
    getSliceAs<T>(offset: number, size: number): T[];
    getSliceTags(offset: number, size: number): TypeTag[];
    set(offset: number, v: MemoryValue): void;
    setSlice(offset: number, slice: MemoryValue[]): void;
    getTag(offset: number): TypeTag;
    /**
     * Check that the memory at the given offset matches the specified tag.
     */
    checkTag(tag: TypeTag, offset: number): void;
    static isValidMemoryAddressTag(tag: TypeTag): tag is TypeTag.UINT32;
    static checkIsIntegralTag(tag: TypeTag): void;
    static checkIsValidTag(tagNumber: number): void;
    /**
     * Check tags for memory at all of the specified offsets.
     */
    checkTags(tag: TypeTag, ...offsets: number[]): void;
    /**
     * Check that all tags at the given offsets are the same.
     */
    checkTagsAreSame(offset0: number, offset1: number): void;
    /**
     * Check tags for all memory in the specified range.
     */
    checkTagsRange(tag: TypeTag, startOffset: number, size: number): void;
    static getTag(v: MemoryValue | undefined): TypeTag;
    static buildFromTagTruncating(v: bigint | number, tag: TypeTag): MemoryValue;
}
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZtX21lbW9yeV90eXBlcy5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3B1YmxpYy9hdm0vYXZtX21lbW9yeV90eXBlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFVQSxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDcEQsT0FBTyxFQUFFLEtBQUssTUFBTSxFQUFnQixNQUFNLHVCQUF1QixDQUFDO0FBQ2xFLE9BQU8sS0FBSyxFQUFFLFdBQVcsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzNELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQU0zRCxzRUFBc0U7QUFDdEUsOEJBQXNCLFdBQVc7SUFDL0IsU0FBZ0IsR0FBRyxDQUFDLEdBQUcsRUFBRSxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ25ELFNBQWdCLEdBQUcsQ0FBQyxHQUFHLEVBQUUsV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNuRCxTQUFnQixHQUFHLENBQUMsR0FBRyxFQUFFLFdBQVcsR0FBRyxXQUFXLENBQUM7SUFDbkQsU0FBZ0IsR0FBRyxDQUFDLEdBQUcsRUFBRSxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBRW5ELFNBQWdCLE1BQU0sQ0FBQyxHQUFHLEVBQUUsV0FBVyxHQUFHLE9BQU8sQ0FBQztJQUNsRCxTQUFnQixFQUFFLENBQUMsR0FBRyxFQUFFLFdBQVcsR0FBRyxPQUFPLENBQUM7SUFHOUMsU0FBZ0IsS0FBSyxDQUFDLENBQUMsRUFBRSxNQUFNLEdBQUcsV0FBVyxDQUFDO0lBRzlDLFNBQWdCLFFBQVEsSUFBSSxNQUFNLENBQUM7SUFDNUIsTUFBTSxJQUFJLE9BQU8sQ0FFdkI7SUFHRCxTQUFnQixRQUFRLElBQUksTUFBTSxDQUFDO0lBRzVCLElBQUksSUFBSSxFQUFFLENBRWhCO0lBRU0sY0FBYyxJQUFJLFlBQVksQ0FFcEM7SUFHTSxRQUFRLElBQUksTUFBTSxDQUV4QjtJQUVNLFFBQVEsSUFB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