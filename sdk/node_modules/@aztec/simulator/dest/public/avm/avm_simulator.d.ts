import { Fr } from '@aztec/foundation/curves/bn254';
import type { PublicSimulatorConfig } from '@aztec/stdlib/avm';
import type { AztecAddress } from '@aztec/stdlib/aztec-address';
import type { GlobalVariables } from '@aztec/stdlib/tx';
import type { PublicPersistableStateManager } from '../state_manager/state_manager.js';
import { AvmContext } from './avm_context.js';
import { AvmContractCallResult } from './avm_contract_call_result.js';
import type { Gas } from './avm_gas.js';
import type { AvmSimulatorInterface } from './avm_simulator_interface.js';
import { type CallData } from './calldata.js';
import { type InstructionSet } from './serialization/bytecode_serialization.js';
export declare class AvmSimulator implements AvmSimulatorInterface {
    private context;
    private instructionSet;
    private log;
    private bytecode;
    private opcodeTallies;
    private deserializedInstructionsCache;
    private tallyPrintFunction;
    private tallyInstructionFunction;
    constructor(context: AvmContext, instructionSet?: InstructionSet, enableTallying?: boolean);
    static build(context: AvmContext): Promise<AvmSimulator>;
    static create(stateManager: PublicPersistableStateManager, address: AztecAddress, sender: AztecAddress, transactionFee: Fr, globals: GlobalVariables, isStaticCall: boolean, calldata: CallData, allocatedGas: Gas, config: PublicSimulatorConfig): Promise<AvmSimulator>;
    /**
     * Fetch the bytecode and execute it in the current context.
     */
    execute(): Promise<AvmContractCallResult>;
    /**
     * Return the bytecode used for execution, if any.
     */
    getBytecode(): Buffer | undefined;
    /**
     * Executes the provided bytecode in the current context.
     * This method is useful for testing and debugging.
     */
    executeBytecode(bytecode: Buffer): Promise<AvmContractCallResult>;
    private handleFailureToRetrieveBytecode;
    private tallyInstruction;
    private printOpcodeTallies;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZtX3NpbXVsYXRvci5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3B1YmxpYy9hdm0vYXZtX3NpbXVsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFHcEQsT0FBTyxLQUFLLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUMvRCxPQUFPLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUNoRSxPQUFPLEtBQUssRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUt4RCxPQUFPLEtBQUssRUFBRSw2QkFBNkIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3ZGLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUV0RSxPQUFPLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFFeEMsT0FBTyxLQUFLLEVBQUUscUJBQXFCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUMxRSxPQUFPLEVBQUUsS0FBSyxRQUFRLEVBQW1CLE1BQU0sZUFBZSxDQUFDO0FBSS9ELE9BQU8sRUFFTCxLQUFLLGNBQWMsRUFFcEIsTUFBTSwyQ0FBMkMsQ0FBQztBQU9uRCxxQkFBYSxZQUFhLFlBQVcscUJBQXFCO0lBYXRELE9BQU8sQ0FBQyxPQUFPO0lBQ2YsT0FBTyxDQUFDLGNBQWM7SUFieEIsT0FBTyxDQUFDLEdBQUcsQ0FBUztJQUNwQixPQUFPLENBQUMsUUFBUSxDQUFxQjtJQUNyQyxPQUFPLENBQUMsYUFBYSxDQUF1QztJQUU1RCxPQUFPLENBQUMsNkJBQTZCLENBQWlEO0lBRXRGLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBWTtJQUN0QyxPQUFPLENBQUMsd0JBQXdCLENBQStCO0lBSS9ELFlBQ1UsT0FBTyxFQUFFLFVBQVUsRUFDbkIsY0FBYyxHQUFFLGNBQWdDLEVBQ3hELGNBQWMsVUFBUSxFQVd2QjtJQUlELE9BQW9CLEtBQUssQ0FBQyxPQUFPLEVBQUUsVUFBVSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FNcEU7SUFFRCxPQUFvQixNQUFNLENBQ3hCLFlBQVksRUFBRSw2QkFBNkIsRUFDM0MsT0FBTyxFQUFFLFlBQVksRUFDckIsTUFBTSxFQUFFLFlBQVksRUFDcEIsY0FBYyxFQUFFLEVBQUUsRUFDbEIsT0FBTyxFQUFFLGVBQWUsRUFDeEIsWUFBWSxFQUFFLE9BQU8sRUFDckIsUUFBUSxFQUFFLFFBQVEsRUFDbEIsWUFBWSxFQUFFLEdBQUcsRUFDakIsTUFBTSxFQUFFLHFCQUFxQix5QkFnQjlCO0lBRUQ7O09BRUc7SUFDVSxPQUFPLElBQUksT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBWXJEO0lBRUQ7O09BRUc7SUFDSSxXQUFXLElBQUksTUFBTSxHQUFHLFNBQVMsQ0FFdkM7SUFFRDs7O09BR0c7SUFDVSxlQUFlLENBQUMsUUFBUSxFQUFFLE1BQU0sR0FBRyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0ErRzdFO1lBRWEsK0JBQStCO0lBdUI3QyxPQUFPLENBQUMsZ0JBQWdCO0lBUXhCLE9BQU8sQ0FBQyxrQkFBa0I7Q0FTM0IifQ==