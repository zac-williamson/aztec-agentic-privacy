import { Grumpkin } from '@aztec/foundation/crypto/grumpkin';
import { Point } from '@aztec/foundation/curves/grumpkin';
import { Field, TypeTag, Uint1 } from '../avm_memory_types.js';
import { EcAddPointNotOnCurveError } from '../errors.js';
import { Opcode, OperandType } from '../serialization/instruction_serialization.js';
import { Addressing } from './addressing_mode.js';
import { Instruction } from './instruction.js';
export class EcAdd extends Instruction {
    addressingMode;
    p1XOffset;
    p1YOffset;
    p1IsInfiniteOffset;
    p2XOffset;
    p2YOffset;
    p2IsInfiniteOffset;
    dstOffset;
    static type = 'ECADD';
    static opcode = Opcode.ECADD;
    // Informs (de)serialization. See Instruction.deserialize.
    static wireFormat = [
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.UINT16,
        OperandType.UINT16,
        OperandType.UINT16,
        OperandType.UINT16,
        OperandType.UINT16,
        OperandType.UINT16,
        OperandType.UINT16
    ];
    constructor(addressingMode, p1XOffset, p1YOffset, p1IsInfiniteOffset, p2XOffset, p2YOffset, p2IsInfiniteOffset, dstOffset){
        super(), this.addressingMode = addressingMode, this.p1XOffset = p1XOffset, this.p1YOffset = p1YOffset, this.p1IsInfiniteOffset = p1IsInfiniteOffset, this.p2XOffset = p2XOffset, this.p2YOffset = p2YOffset, this.p2IsInfiniteOffset = p2IsInfiniteOffset, this.dstOffset = dstOffset;
    }
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.p1XOffset,
            this.p1YOffset,
            this.p1IsInfiniteOffset,
            this.p2XOffset,
            this.p2YOffset,
            this.p2IsInfiniteOffset,
            this.dstOffset
        ];
        const [p1XOffset, p1YOffset, p1IsInfiniteOffset, p2XOffset, p2YOffset, p2IsInfiniteOffset, dstOffset] = addressing.resolve(operands, memory);
        memory.checkTags(TypeTag.FIELD, p1XOffset, p1YOffset, p2XOffset, p2YOffset);
        memory.checkTags(TypeTag.UINT1, p1IsInfiniteOffset, p2IsInfiniteOffset);
        const p1X = memory.get(p1XOffset);
        const p1Y = memory.get(p1YOffset);
        const p1IsInfinite = memory.get(p1IsInfiniteOffset).toNumber() === 1;
        const p1 = new Point(p1X.toFr(), p1Y.toFr(), p1IsInfinite);
        if (!p1.isOnGrumpkin()) {
            throw new EcAddPointNotOnCurveError(/*pointIndex=*/ 1, p1);
        }
        const p2X = memory.get(p2XOffset);
        const p2Y = memory.get(p2YOffset);
        // unused. Point doesn't store this information
        const p2IsInfinite = memory.get(p2IsInfiniteOffset).toNumber() === 1;
        const p2 = new Point(p2X.toFr(), p2Y.toFr(), p2IsInfinite);
        if (!p2.isOnGrumpkin()) {
            throw new EcAddPointNotOnCurveError(/*pointIndex=*/ 2, p2);
        }
        let dest;
        if (p1IsInfinite && p2IsInfinite) {
            dest = Point.ZERO;
        } else if (p1IsInfinite) {
            dest = p2;
        } else if (p2IsInfinite) {
            dest = p1;
        } else {
            // TS<>BB ecc add communication is broken for points that add up to infinity.
            // However, here we know that both points are on the curve, and that none is infinity
            // so we can check for the case where you add p + (-p) = infinity.
            if (p1.x.equals(p2.x) && !p1.y.equals(p2.y)) {
                dest = Point.ZERO;
            } else {
                dest = await Grumpkin.add(p1, p2);
            }
        }
        // Important to use setSlice() and not set() in the two following statements as
        // this checks that the offsets lie within memory range.
        memory.setSlice(dstOffset, [
            new Field(dest.x),
            new Field(dest.y)
        ]);
        // Check representation of infinity for grumpkin
        memory.setSlice(dstOffset + 2, [
            new Uint1(dest.equals(Point.ZERO) ? 1 : 0)
        ]);
    }
}
