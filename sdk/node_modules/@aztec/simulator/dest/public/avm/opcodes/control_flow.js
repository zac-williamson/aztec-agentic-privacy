import { TypeTag } from '../avm_memory_types.js';
import { InstructionExecutionError } from '../errors.js';
import { Opcode, OperandType } from '../serialization/instruction_serialization.js';
import { Addressing } from './addressing_mode.js';
import { Instruction } from './instruction.js';
export class Jump extends Instruction {
    jumpOffset;
    static type = 'JUMP';
    static opcode = Opcode.JUMP_32;
    // Informs (de)serialization. See Instruction.deserialize.
    static wireFormat = [
        OperandType.UINT8,
        OperandType.UINT32
    ];
    constructor(jumpOffset){
        super(), this.jumpOffset = jumpOffset;
    }
    async execute(context) {
        context.machineState.consumeGas(this.baseGasCost(0, 0));
        context.machineState.pc = this.jumpOffset;
    }
    handlesPC() {
        return true;
    }
}
export class JumpI extends Instruction {
    addressingMode;
    condOffset;
    loc;
    static type = 'JUMPI';
    static opcode = Opcode.JUMPI_32;
    // Instruction wire format with opcode.
    static wireFormat = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.UINT32
    ];
    constructor(addressingMode, condOffset, loc){
        super(), this.addressingMode = addressingMode, this.condOffset = condOffset, this.loc = loc;
    }
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.condOffset
        ];
        const [resolvedCondOffset] = addressing.resolve(operands, memory);
        memory.checkTag(TypeTag.UINT1, resolvedCondOffset);
        const condition = memory.getAs(resolvedCondOffset);
        if (condition.toNumber() == 0) {
            context.machineState.pc = context.machineState.nextPc;
        } else {
            context.machineState.pc = this.loc;
        }
    }
    handlesPC() {
        return true;
    }
}
export class InternalCall extends Instruction {
    loc;
    static type = 'INTERNALCALL';
    static opcode = Opcode.INTERNALCALL;
    // Informs (de)serialization. See Instruction.deserialize.
    static wireFormat = [
        OperandType.UINT8,
        OperandType.UINT32
    ];
    constructor(loc){
        super(), this.loc = loc;
    }
    async execute(context) {
        context.machineState.consumeGas(this.baseGasCost(0, 0));
        context.machineState.internalCallStack.push({
            callPc: context.machineState.pc,
            returnPc: context.machineState.nextPc
        });
        context.machineState.pc = this.loc;
    }
    handlesPC() {
        return true;
    }
}
export class InternalReturn extends Instruction {
    static type = 'INTERNALRETURN';
    static opcode = Opcode.INTERNALRETURN;
    // Informs (de)serialization. See Instruction.deserialize.
    static wireFormat = [
        OperandType.UINT8
    ];
    constructor(){
        super();
    }
    async execute(context) {
        context.machineState.consumeGas(this.baseGasCost(0, 0));
        const stackEntry = context.machineState.internalCallStack.pop();
        if (stackEntry === undefined) {
            throw new InstructionExecutionError('Internal call stack empty!');
        }
        context.machineState.pc = stackEntry.returnPc;
    }
    handlesPC() {
        return true;
    }
}
