import { strict as assert } from 'assert';
import { computeAddressingCost, getBaseGasCost, getDynamicGasCost, mulGas, sumGas } from '../avm_gas.js';
import { Opcode, deserialize, serializeAs } from '../serialization/instruction_serialization.js';
/**
 * Parent class for all AVM instructions.
 * It's most important aspects are execute and (de)serialize.
 */ export class Instruction {
    /**
   * Whether the instruction will modify the PC itself.
   */ handlesPC() {
        return false;
    }
    /**
   * Generate a string representation of the instruction including
   * the instruction sub-class name all of its flags and operands.
   * @returns Thee string representation.
   */ toString() {
        // Note: we could have this be the actual wire opcode if `bytecode_serialization.ts` were to
        // pass it into the class' static `Instruction.as(this, wireFormat)` method.
        let instructionStr = this.constructor.name + ': ';
        // assumes that all properties are flags or operands
        for (const prop of Object.getOwnPropertyNames(this)){
            instructionStr += `${prop}:${this[prop].toString()}, `;
        }
        return instructionStr;
    }
    // Default deserialization which uses Class.opcode and Class.wireFormat.
    static fromBuffer(buf) {
        return this.as(this.wireFormat).fromBuffer(buf);
    }
    // Default serialization which uses Class.opcode and Class.wireFormat.
    toBuffer() {
        const klass = this.constructor;
        assert(klass.opcode !== undefined && klass.opcode !== null);
        assert(klass.wireFormat !== undefined && klass.wireFormat !== null);
        return this.as(klass.opcode, klass.wireFormat).toBuffer();
    }
    /**
   * Returns a new instruction instance that can be serialized with the given opcode and wire format.
   * @param opcode The opcode of the instruction.
   * @param wireFormat The wire format of the instruction.
   * @returns The new instruction instance.
   */ as(opcode, wireFormat) {
        return Object.defineProperty(this, 'toBuffer', {
            value: ()=>{
                return serializeAs(wireFormat, opcode, this);
            },
            enumerable: false
        });
    }
    /**
   * Returns a new instruction class that can be deserialized with the given opcode and wire format.
   * @param opcode The opcode of the instruction.
   * @param wireFormat The wire format of the instruction.
   * @returns The new instruction class.
   */ static as(wireFormat) {
        return Object.assign(this, {
            fromBuffer: (buf)=>{
                const res = deserialize(buf, wireFormat);
                const args = res.slice(1); // Remove opcode.
                return new this(...args);
            }
        });
    }
    /**
   * Returns the base gas cost for the instruction.
   * @returns The base gas cost.
   */ baseGasCost(indirectOperandsCount, relativeOperandsCount) {
        return sumGas(getBaseGasCost(this.opcode), computeAddressingCost(indirectOperandsCount, relativeOperandsCount));
    }
    /**
   * Computes the dynamic gas cost for the instruction
   * @param dynMultiplier - The multiplier for the dynamic gas cost.
   * @returns The dynamic gas cost.
   */ dynamicGasCost(dynMultiplier = 0) {
        return mulGas(getDynamicGasCost(this.opcode), dynMultiplier);
    }
    /**
   * Returns the stringified type of the instruction.
   * Instruction sub-classes should have a static `type` property.
   */ get type() {
        const type = 'type' in this.constructor && this.constructor.type;
        assert(!!type, `Instruction class ${this.constructor.name} does not have a static 'type' property defined.`);
        return type;
    }
    /**
   * Returns the opcode of the instruction.
   * Instruction sub-classes should have a static `opcode` property.
   */ get opcode() {
        const opcode = 'opcode' in this.constructor ? this.constructor.opcode : undefined;
        assert(opcode !== undefined, `Instruction class ${this.constructor.name} does not have a static 'opcode' property defined.`);
        assert(Opcode[opcode] !== undefined, `Invalid opcode ${opcode} for instruction class ${this.constructor.name}.`);
        return opcode;
    }
}
