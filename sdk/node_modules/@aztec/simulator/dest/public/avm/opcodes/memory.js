import { Fr } from '@aztec/foundation/curves/bn254';
import { strict as assert } from 'assert';
import { Field, TaggedMemory, TypeTag, Uint32 } from '../avm_memory_types.js';
import { Opcode, OperandType } from '../serialization/instruction_serialization.js';
import { Addressing } from './addressing_mode.js';
import { Instruction } from './instruction.js';
export class Set extends Instruction {
    addressingMode;
    dstOffset;
    inTag;
    value;
    static type = 'SET';
    // Required for gas.
    static opcode = Opcode.SET_8;
    static wireFormat8 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.TAG,
        OperandType.UINT8
    ];
    static wireFormat16 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.TAG,
        OperandType.UINT16
    ];
    static wireFormat32 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.TAG,
        OperandType.UINT32
    ];
    static wireFormat64 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.TAG,
        OperandType.UINT64
    ];
    static wireFormat128 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.TAG,
        OperandType.UINT128
    ];
    static wireFormatFF = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.TAG,
        OperandType.FF
    ];
    constructor(addressingMode, dstOffset, inTag, value){
        super(), this.addressingMode = addressingMode, this.dstOffset = dstOffset, this.inTag = inTag, this.value = value;
        assert(this.value >= 0, `Value ${this.value} is negative`);
        assert(this.value < Fr.MODULUS, `Value ${this.value} is larger than Fr.MODULUS`);
    }
    async execute(context) {
        // Constructor ensured that this.inTag is a valid tag
        const res = TaggedMemory.buildFromTagTruncating(this.value, this.inTag);
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.dstOffset
        ];
        const [dstOffset] = addressing.resolve(operands, memory);
        memory.set(dstOffset, res);
    }
}
export class Cast extends Instruction {
    addressingMode;
    srcOffset;
    dstOffset;
    dstTag;
    static type = 'CAST';
    static opcode = Opcode.CAST_8;
    static wireFormat8 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.TAG
    ];
    static wireFormat16 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.UINT16,
        OperandType.TAG
    ];
    constructor(addressingMode, srcOffset, dstOffset, dstTag){
        super(), this.addressingMode = addressingMode, this.srcOffset = srcOffset, this.dstOffset = dstOffset, this.dstTag = dstTag;
    }
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.srcOffset,
            this.dstOffset
        ];
        const [srcOffset, dstOffset] = addressing.resolve(operands, memory);
        const a = memory.get(srcOffset);
        // Constructor ensured that this.dstTag is a valid tag
        const casted = TaggedMemory.buildFromTagTruncating(a.toBigInt(), this.dstTag);
        memory.set(dstOffset, casted);
    }
}
export class Mov extends Instruction {
    addressingMode;
    srcOffset;
    dstOffset;
    static type = 'MOV';
    // FIXME: This is needed for gas.
    static opcode = Opcode.MOV_8;
    static wireFormat8 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT8
    ];
    static wireFormat16 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.UINT16
    ];
    constructor(addressingMode, srcOffset, dstOffset){
        super(), this.addressingMode = addressingMode, this.srcOffset = srcOffset, this.dstOffset = dstOffset;
    }
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.srcOffset,
            this.dstOffset
        ];
        const [srcOffset, dstOffset] = addressing.resolve(operands, memory);
        const a = memory.get(srcOffset);
        memory.set(dstOffset, a);
    }
}
export class CalldataCopy extends Instruction {
    addressingMode;
    copySizeOffset;
    cdStartOffset;
    dstOffset;
    static type = 'CALLDATACOPY';
    static opcode = Opcode.CALLDATACOPY;
    // Informs (de)serialization. See Instruction.deserialize.
    static wireFormat = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.UINT16,
        OperandType.UINT16
    ];
    constructor(addressingMode, copySizeOffset, cdStartOffset, dstOffset){
        super(), this.addressingMode = addressingMode, this.copySizeOffset = copySizeOffset, this.cdStartOffset = cdStartOffset, this.dstOffset = dstOffset;
    }
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.copySizeOffset,
            this.cdStartOffset,
            this.dstOffset
        ];
        const [copySizeOffset, cdStartOffset, dstOffset] = addressing.resolve(operands, memory);
        memory.checkTags(TypeTag.UINT32, cdStartOffset, copySizeOffset);
        const cdStart = memory.get(cdStartOffset).toNumber();
        const copySize = memory.get(copySizeOffset).toNumber();
        context.machineState.consumeGas(this.dynamicGasCost(copySize));
        // Values which are out-of-range of the calldata array will be set with Field(0);
        const slice = context.environment.calldata.slice(cdStart, cdStart + copySize).map((f)=>new Field(f));
        // slice has size = MIN(copySize, calldata.length - cdStart) as TS truncates out-of-range portion
        const transformedData = [
            ...slice,
            ...Array(copySize - slice.length).fill(new Field(0))
        ];
        memory.setSlice(dstOffset, transformedData);
    }
}
export class ReturndataSize extends Instruction {
    addressingMode;
    dstOffset;
    static type = 'RETURNDATASIZE';
    static opcode = Opcode.RETURNDATASIZE;
    // Informs (de)serialization. See Instruction.deserialize.
    static wireFormat = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16
    ];
    constructor(addressingMode, dstOffset){
        super(), this.addressingMode = addressingMode, this.dstOffset = dstOffset;
    }
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.dstOffset
        ];
        const [dstOffset] = addressing.resolve(operands, memory);
        memory.set(dstOffset, new Uint32(context.machineState.nestedReturndata.length()));
    }
}
export class ReturndataCopy extends Instruction {
    addressingMode;
    copySizeOffset;
    rdStartOffset;
    dstOffset;
    static type = 'RETURNDATACOPY';
    static opcode = Opcode.RETURNDATACOPY;
    // Informs (de)serialization. See Instruction.deserialize.
    static wireFormat = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.UINT16,
        OperandType.UINT16
    ];
    constructor(addressingMode, copySizeOffset, rdStartOffset, dstOffset){
        super(), this.addressingMode = addressingMode, this.copySizeOffset = copySizeOffset, this.rdStartOffset = rdStartOffset, this.dstOffset = dstOffset;
    }
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.copySizeOffset,
            this.rdStartOffset,
            this.dstOffset
        ];
        const [copySizeOffset, rdStartOffset, dstOffset] = addressing.resolve(operands, memory);
        memory.checkTags(TypeTag.UINT32, rdStartOffset, copySizeOffset);
        const copySize = memory.get(copySizeOffset).toNumber();
        const rdStart = memory.get(rdStartOffset).toNumber();
        context.machineState.consumeGas(this.dynamicGasCost(copySize));
        // Values which are out-of-range of the returndata array will be set with Field(0);
        const slice = context.machineState.nestedReturndata.slice(rdStart, rdStart + copySize).map((f)=>new Field(f));
        // slice has size = MIN(copySize, returndata.length - rdStart) as TS truncates out-of-range portion
        const transformedData = [
            ...slice,
            ...Array(copySize - slice.length).fill(new Field(0))
        ];
        memory.setSlice(dstOffset, transformedData);
    }
}
