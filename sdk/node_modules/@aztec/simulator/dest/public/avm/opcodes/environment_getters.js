import { Field, Uint1, Uint32, Uint64, Uint128 } from '../avm_memory_types.js';
import { InstructionExecutionError } from '../errors.js';
import { Opcode, OperandType } from '../serialization/instruction_serialization.js';
import { Addressing } from './addressing_mode.js';
import { Instruction } from './instruction.js';
export var EnvironmentVariable = /*#__PURE__*/ function(EnvironmentVariable) {
    EnvironmentVariable[EnvironmentVariable["ADDRESS"] = 0] = "ADDRESS";
    EnvironmentVariable[EnvironmentVariable["SENDER"] = 1] = "SENDER";
    EnvironmentVariable[EnvironmentVariable["TRANSACTIONFEE"] = 2] = "TRANSACTIONFEE";
    EnvironmentVariable[EnvironmentVariable["CHAINID"] = 3] = "CHAINID";
    EnvironmentVariable[EnvironmentVariable["VERSION"] = 4] = "VERSION";
    EnvironmentVariable[EnvironmentVariable["BLOCKNUMBER"] = 5] = "BLOCKNUMBER";
    EnvironmentVariable[EnvironmentVariable["TIMESTAMP"] = 6] = "TIMESTAMP";
    EnvironmentVariable[EnvironmentVariable["MINFEEPERL2GAS"] = 7] = "MINFEEPERL2GAS";
    EnvironmentVariable[EnvironmentVariable["MINFEEPERDAGAS"] = 8] = "MINFEEPERDAGAS";
    EnvironmentVariable[EnvironmentVariable["ISSTATICCALL"] = 9] = "ISSTATICCALL";
    EnvironmentVariable[EnvironmentVariable["L2GASLEFT"] = 10] = "L2GASLEFT";
    EnvironmentVariable[EnvironmentVariable["DAGASLEFT"] = 11] = "DAGASLEFT";
    return EnvironmentVariable;
}({});
function getValue(varEnum, ctx) {
    switch(varEnum){
        case 0:
            return new Field(ctx.environment.address.toField());
        case 1:
            return new Field(ctx.environment.sender.toField());
        case 2:
            return new Field(ctx.environment.transactionFee);
        case 3:
            return new Field(ctx.environment.globals.chainId);
        case 4:
            return new Field(ctx.environment.globals.version);
        case 5:
            return new Uint32(ctx.environment.globals.blockNumber);
        case 6:
            return new Uint64(ctx.environment.globals.timestamp);
        case 7:
            return new Uint128(ctx.environment.globals.gasFees.feePerL2Gas);
        case 8:
            return new Uint128(ctx.environment.globals.gasFees.feePerDaGas);
        case 9:
            return new Uint1(ctx.environment.isStaticCall ? 1 : 0);
        case 10:
            return new Uint32(ctx.machineState.l2GasLeft);
        case 11:
            return new Uint32(ctx.machineState.daGasLeft);
        default:
            throw new InstructionExecutionError(`Invalid GETENVVAR var enum ${varEnum}`);
    }
}
export class GetEnvVar extends Instruction {
    addressingMode;
    dstOffset;
    varEnum;
    static type = 'GETENVVAR';
    static opcode = Opcode.GETENVVAR_16;
    static wireFormat16 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.UINT8
    ];
    constructor(addressingMode, dstOffset, varEnum){
        super(), this.addressingMode = addressingMode, this.dstOffset = dstOffset, this.varEnum = varEnum;
    }
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.dstOffset
        ];
        const [dstOffset] = addressing.resolve(operands, memory);
        const value = getValue(this.varEnum, context);
        memory.set(dstOffset, value);
    }
}
