import { TaggedMemory, TypeTag } from '../avm_memory_types.js';
import { ArithmeticError } from '../errors.js';
import { Opcode } from '../serialization/instruction_serialization.js';
import { Addressing } from './addressing_mode.js';
import { ThreeOperandInstruction } from './instruction_impl.js';
export class ThreeOperandArithmeticInstruction extends ThreeOperandInstruction {
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.aOffset,
            this.bOffset,
            this.dstOffset
        ];
        const [aOffset, bOffset, dstOffset] = addressing.resolve(operands, memory);
        this.checkTags(memory, aOffset, bOffset);
        const a = memory.get(aOffset);
        const b = memory.get(bOffset);
        const dest = this.compute(a, b);
        memory.set(dstOffset, dest);
    }
    checkTags(memory, aOffset, bOffset) {
        memory.checkTagsAreSame(aOffset, bOffset);
    }
}
export class Add extends ThreeOperandArithmeticInstruction {
    static type = 'ADD';
    static opcode = Opcode.ADD_8;
    compute(a, b) {
        return a.add(b);
    }
}
export class Sub extends ThreeOperandArithmeticInstruction {
    static type = 'SUB';
    static opcode = Opcode.SUB_8;
    compute(a, b) {
        return a.sub(b);
    }
}
export class Mul extends ThreeOperandArithmeticInstruction {
    static type = 'MUL';
    static opcode = Opcode.MUL_8;
    compute(a, b) {
        return a.mul(b);
    }
}
export class Div extends ThreeOperandArithmeticInstruction {
    static type = 'DIV';
    static opcode = Opcode.DIV_8;
    compute(a, b) {
        if (b.toBigInt() === 0n) {
            throw new ArithmeticError('Division by zero');
        }
        return a.div(b);
    }
    checkTags(memory, aOffset, bOffset) {
        memory.checkTagsAreSame(aOffset, bOffset);
        TaggedMemory.checkIsIntegralTag(memory.getTag(aOffset)); // Follows that bOffset tag is also of integral type
    }
}
export class FieldDiv extends ThreeOperandArithmeticInstruction {
    static type = 'FDIV';
    static opcode = Opcode.FDIV_8;
    compute(a, b) {
        if (b.toBigInt() === 0n) {
            throw new ArithmeticError('Division by zero');
        }
        return a.fdiv(b);
    }
    checkTags(memory, aOffset, bOffset) {
        memory.checkTagsAreSame(aOffset, bOffset);
        memory.checkTag(TypeTag.FIELD, aOffset); // Follows that bOffset has also tag of type Field
    }
}
export class Shl extends ThreeOperandArithmeticInstruction {
    static type = 'SHL';
    static opcode = Opcode.SHL_8;
    compute(a, b) {
        return a.shl(b);
    }
    checkTags(memory, aOffset, bOffset) {
        memory.checkTagsAreSame(aOffset, bOffset);
        TaggedMemory.checkIsIntegralTag(memory.getTag(aOffset)); // Follows that bOffset tag is also of integral type
    }
}
export class Shr extends ThreeOperandArithmeticInstruction {
    static type = 'SHR';
    static opcode = Opcode.SHR_8;
    compute(a, b) {
        return a.shr(b);
    }
    checkTags(memory, aOffset, bOffset) {
        memory.checkTagsAreSame(aOffset, bOffset);
        TaggedMemory.checkIsIntegralTag(memory.getTag(aOffset)); // Follows that bOffset tag is also of integral type
    }
}
