import { getBitwiseDynamicGasMultiplier } from '../avm_gas.js';
import { TaggedMemory } from '../avm_memory_types.js';
import { Opcode, OperandType } from '../serialization/instruction_serialization.js';
import { Addressing } from './addressing_mode.js';
import { Instruction } from './instruction.js';
import { ThreeOperandInstruction } from './instruction_impl.js';
class ThreeOperandBitwiseInstruction extends ThreeOperandInstruction {
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.aOffset,
            this.bOffset,
            this.dstOffset
        ];
        const [aOffset, bOffset, dstOffset] = addressing.resolve(operands, memory);
        this.checkTags(memory, aOffset, bOffset);
        const multiplier = this.getDynamicMultiplier(memory.getTag(aOffset));
        context.machineState.consumeGas(this.dynamicGasCost(multiplier));
        const a = memory.getAs(aOffset);
        const b = memory.getAs(bOffset);
        const res = this.compute(a, b);
        memory.set(dstOffset, res);
    }
    checkTags(memory, aOffset, bOffset) {
        TaggedMemory.checkIsIntegralTag(memory.getTag(aOffset));
        memory.checkTagsAreSame(aOffset, bOffset);
    }
    getDynamicMultiplier(_lhsTag) {
        return 0;
    }
}
export class And extends ThreeOperandBitwiseInstruction {
    static type = 'AND';
    static opcode = Opcode.AND_8;
    compute(a, b) {
        return a.and(b);
    }
    getDynamicMultiplier(lhsTag) {
        return getBitwiseDynamicGasMultiplier(lhsTag);
    }
}
export class Or extends ThreeOperandBitwiseInstruction {
    static type = 'OR';
    static opcode = Opcode.OR_8;
    compute(a, b) {
        return a.or(b);
    }
    getDynamicMultiplier(lhsTag) {
        return getBitwiseDynamicGasMultiplier(lhsTag);
    }
}
export class Xor extends ThreeOperandBitwiseInstruction {
    static type = 'XOR';
    static opcode = Opcode.XOR_8;
    compute(a, b) {
        return a.xor(b);
    }
    getDynamicMultiplier(lhsTag) {
        return getBitwiseDynamicGasMultiplier(lhsTag);
    }
}
export class Not extends Instruction {
    addressingMode;
    srcOffset;
    dstOffset;
    static type = 'NOT';
    static opcode = Opcode.NOT_8;
    static wireFormat8 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT8
    ];
    static wireFormat16 = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.UINT16
    ];
    constructor(addressingMode, srcOffset, dstOffset){
        super(), this.addressingMode = addressingMode, this.srcOffset = srcOffset, this.dstOffset = dstOffset;
    }
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.srcOffset,
            this.dstOffset
        ];
        const [srcOffset, dstOffset] = addressing.resolve(operands, memory);
        TaggedMemory.checkIsIntegralTag(memory.getTag(srcOffset));
        const value = memory.getAs(srcOffset);
        const res = value.not();
        memory.set(dstOffset, res);
    }
}
