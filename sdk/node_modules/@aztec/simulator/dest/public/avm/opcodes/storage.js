import { Field, TypeTag } from '../avm_memory_types.js';
import { StaticCallAlterationError } from '../errors.js';
import { Opcode, OperandType } from '../serialization/instruction_serialization.js';
import { Addressing } from './addressing_mode.js';
import { Instruction } from './instruction.js';
export class SStore extends Instruction {
    addressingMode;
    srcOffset;
    slotOffset;
    static type = 'SSTORE';
    static opcode = Opcode.SSTORE;
    // Informs (de)serialization. See Instruction.deserialize.
    static wireFormat = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.UINT16
    ];
    constructor(addressingMode, srcOffset, slotOffset){
        super(), this.addressingMode = addressingMode, this.srcOffset = srcOffset, this.slotOffset = slotOffset;
    }
    async execute(context) {
        if (context.environment.isStaticCall) {
            throw new StaticCallAlterationError();
        }
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.srcOffset,
            this.slotOffset
        ];
        const [srcOffset, slotOffset] = addressing.resolve(operands, memory);
        // We read before tag checking since it's needed for gas cost calculation
        const slot = memory.get(slotOffset).toFr();
        context.machineState.consumeGas(this.dynamicGasCost(Number(context.persistableState.isStorageCold(context.environment.address, slot))));
        memory.checkTag(TypeTag.FIELD, slotOffset);
        memory.checkTag(TypeTag.FIELD, srcOffset);
        const value = memory.get(srcOffset).toFr();
        await context.persistableState.writeStorage(context.environment.address, slot, value);
    }
}
export class SLoad extends Instruction {
    addressingMode;
    slotOffset;
    contractAddressOffset;
    dstOffset;
    static type = 'SLOAD';
    static opcode = Opcode.SLOAD;
    // Informs (de)serialization. See Instruction.deserialize.
    static wireFormat = [
        OperandType.UINT8,
        OperandType.UINT8,
        OperandType.UINT16,
        OperandType.UINT16,
        OperandType.UINT16
    ];
    constructor(addressingMode, slotOffset, contractAddressOffset, dstOffset){
        super(), this.addressingMode = addressingMode, this.slotOffset = slotOffset, this.contractAddressOffset = contractAddressOffset, this.dstOffset = dstOffset;
    }
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.slotOffset,
            this.contractAddressOffset,
            this.dstOffset
        ];
        const [slotOffset, contractAddressOffset, dstOffset] = addressing.resolve(operands, memory);
        memory.checkTag(TypeTag.FIELD, slotOffset);
        memory.checkTag(TypeTag.FIELD, contractAddressOffset);
        const slot = memory.get(slotOffset).toFr();
        const contractAddress = memory.get(contractAddressOffset).toAztecAddress();
        const value = await context.persistableState.readStorage(contractAddress, slot);
        memory.set(dstOffset, new Field(value));
    }
}
