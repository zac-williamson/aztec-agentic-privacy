import { Uint1 } from '../avm_memory_types.js';
import { Opcode } from '../serialization/instruction_serialization.js';
import { Addressing } from './addressing_mode.js';
import { ThreeOperandInstruction } from './instruction_impl.js';
class ComparatorInstruction extends ThreeOperandInstruction {
    async execute(context) {
        const memory = context.machineState.memory;
        const addressing = Addressing.fromWire(this.addressingMode);
        context.machineState.consumeGas(this.baseGasCost(addressing.indirectOperandsCount(), addressing.relativeOperandsCount()));
        const operands = [
            this.aOffset,
            this.bOffset,
            this.dstOffset
        ];
        const [aOffset, bOffset, dstOffset] = addressing.resolve(operands, memory);
        memory.checkTagsAreSame(aOffset, bOffset); // Brillig semantic enforces that tags match.
        const a = memory.get(aOffset);
        const b = memory.get(bOffset);
        const dest = new Uint1(this.compare(a, b) ? 1 : 0);
        memory.set(dstOffset, dest);
    }
}
export class Eq extends ComparatorInstruction {
    static type = 'EQ';
    static opcode = Opcode.EQ_8;
    compare(a, b) {
        return a.equals(b);
    }
}
export class Lt extends ComparatorInstruction {
    static type = 'LT';
    static opcode = Opcode.LT_8;
    compare(a, b) {
        return a.lt(b);
    }
}
export class Lte extends ComparatorInstruction {
    static type = 'LTE';
    static opcode = Opcode.LTE_8;
    compare(a, b) {
        return a.lt(b) || a.equals(b);
    }
}
