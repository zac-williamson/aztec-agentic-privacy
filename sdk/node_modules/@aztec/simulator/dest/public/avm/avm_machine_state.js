import { TaggedMemory } from './avm_memory_types.js';
import { ReturnDataArray } from './calldata.js';
import { OutOfGasError } from './errors.js';
/**
 * Avm state modified on an instruction-per-instruction basis.
 */ export class AvmMachineState {
    /** gas remaining of the gas allocated for a contract call */ l2GasLeft;
    daGasLeft;
    /** program counter, byte based */ pc = 0;
    /** program counter of the next instruction, byte based */ nextPc = 0;
    /** return/revertdata of the last nested call. */ nestedReturndata = new ReturnDataArray([]);
    /** Tracks whether the last external call was successful */ nestedCallSuccess = false;
    /**
   * Used to track the call stack and revert data of nested calls.
   * This is used to provide a more detailed revert reason when a contract call reverts.
   * It is only a heuristic and may not always provide the correct revert reason.
   */ collectedRevertInfo;
    /**
   * On INTERNALCALL, internal call stack is pushed to with the current pc and the return pc.
   * On INTERNALRETURN, value is popped from the internal call stack and assigned to the return pc.
   */ internalCallStack = [];
    /** Memory accessible to user code */ memory = new TaggedMemory();
    /**
   * Signals that execution should end.
   * AvmContext execution continues executing instructions until the machine state signals "halted"
   */ halted = false;
    /** Signals that execution has reverted normally (this does not cover exceptional halts) */ reverted = false;
    /** Output data must NOT be modified once it is set */ output = new ReturnDataArray([]);
    // Metrics only - not needed for execution
    /** instruction counter, including nested calls */ instrCounter = 0;
    constructor(gasLeftOrL2GasLeft, daGasLeft){
        if (typeof gasLeftOrL2GasLeft === 'object') {
            ({ l2Gas: this.l2GasLeft, daGas: this.daGasLeft } = gasLeftOrL2GasLeft);
        } else {
            this.l2GasLeft = gasLeftOrL2GasLeft;
            this.daGasLeft = daGasLeft;
        }
    }
    get gasLeft() {
        return {
            l2Gas: this.l2GasLeft,
            daGas: this.daGasLeft
        };
    }
    static fromState(state) {
        return new AvmMachineState(state.l2GasLeft, state.daGasLeft);
    }
    /**
   * Consumes the given gas.
   * Should any of the gas dimensions get depleted, it sets all gas left to zero and triggers
   * an exceptional halt by throwing an OutOfGasError.
   */ consumeGas(gasCost) {
        // Assert there is enough gas on every dimension.
        const outOfL2Gas = this.l2GasLeft - (gasCost.l2Gas ?? 0) < 0;
        const outOfDaGas = this.daGasLeft - (gasCost.daGas ?? 0) < 0;
        // If not, trigger an exceptional halt.
        if (outOfL2Gas || outOfDaGas) {
            this.exceptionalHalt();
            const dimensions = [];
            if (outOfL2Gas) {
                dimensions.push('l2Gas');
            }
            if (outOfDaGas) {
                dimensions.push('daGas');
            }
            throw new OutOfGasError(dimensions);
        }
        // Otherwise, charge the corresponding gas
        this.l2GasLeft -= gasCost.l2Gas ?? 0;
        this.daGasLeft -= gasCost.daGas ?? 0;
    }
    /** Increases the gas left by the amounts specified. */ refundGas(gasRefund) {
        this.l2GasLeft += gasRefund.l2Gas ?? 0;
        this.daGasLeft += gasRefund.daGas ?? 0;
    }
    /**
   * Halt as successful
   * Output data must NOT be modified once it is set
   * @param output
   */ return(output) {
        this.halted = true;
        this.output = output;
    }
    /**
   * Halt as reverted
   * Output data must NOT be modified once it is set
   * @param output
   */ revert(output) {
        this.halted = true;
        this.reverted = true;
        this.output = output;
    }
    getHalted() {
        return this.halted;
    }
    getReverted() {
        return this.reverted;
    }
    getOutput() {
        return this.output;
    }
    /**
   * Flag an exceptional halt. Clears gas left and sets the reverted flag. No output data.
   */ exceptionalHalt() {
        this.l2GasLeft = 0;
        this.daGasLeft = 0;
        this.reverted = true;
        this.halted = true;
    }
}
