import { Fr } from '@aztec/foundation/curves/bn254';
import { mock } from 'jest-mock-extended';
export function mockTraceFork(trace, nestedTrace) {
    trace.fork.mockReturnValue(nestedTrace ?? mock());
}
export function mockStorageRead(worldStateDB, value) {
    worldStateDB.storageRead.mockResolvedValue(value);
}
export function mockNoteHashCount(mockedTrace, count) {
    mockedTrace.getNoteHashCount.mockReturnValue(count);
}
export function mockStorageReadWithMap(worldStateDB, mockedStorage) {
    worldStateDB.storageRead.mockImplementation((_address, slot)=>Promise.resolve(mockedStorage.get(slot.toBigInt()) ?? Fr.ZERO));
}
export function mockGetNoteHash(worldStateDB, _leafIndex, value) {
    worldStateDB.getNoteHash.mockImplementation((index)=>{
        if (index == _leafIndex && value) {
            return Promise.resolve(value);
        } else {
            return Promise.resolve(Fr.ZERO);
        }
    });
}
export function mockCheckNullifierExists(worldStateDB, exists, _ignoredValue) {
    worldStateDB.checkNullifierExists.mockResolvedValue(exists);
}
export function mockGetL1ToL2LeafValue(worldStateDB, leafIndex, value) {
    worldStateDB.getL1ToL2LeafValue.mockImplementation((index)=>{
        if (index == leafIndex && value) {
            return Promise.resolve(value);
        } else {
            return Promise.resolve(Fr.ZERO);
        }
    });
}
export function mockGetContractInstance(contractsDB, contractInstance) {
    contractsDB.getContractInstance.mockResolvedValue(contractInstance);
}
export function mockGetContractClass(contractsDB, contractClass) {
    contractsDB.getContractClass.mockResolvedValue(contractClass);
}
export function mockGetBytecodeCommitment(contractsDB, commitment) {
    contractsDB.getBytecodeCommitment.mockResolvedValue(commitment);
}
