import { Fr } from '@aztec/foundation/curves/bn254';
import { strict as assert } from 'assert';
import { TaggedMemory } from '../avm_memory_types.js';
import { BufferCursor } from './buffer_cursor.js';
/**
 * All AVM opcodes. (Keep in sync with cpp counterpart code avm_opcode.hpp and rs in opcodes.rs).
 * Source: https://yp-aztec.netlify.app/docs/public-vm/instruction-set
 */ export var Opcode = /*#__PURE__*/ function(Opcode) {
    // Compute
    Opcode[Opcode["ADD_8"] = 0] = "ADD_8";
    Opcode[Opcode["ADD_16"] = 1] = "ADD_16";
    Opcode[Opcode["SUB_8"] = 2] = "SUB_8";
    Opcode[Opcode["SUB_16"] = 3] = "SUB_16";
    Opcode[Opcode["MUL_8"] = 4] = "MUL_8";
    Opcode[Opcode["MUL_16"] = 5] = "MUL_16";
    Opcode[Opcode["DIV_8"] = 6] = "DIV_8";
    Opcode[Opcode["DIV_16"] = 7] = "DIV_16";
    Opcode[Opcode["FDIV_8"] = 8] = "FDIV_8";
    Opcode[Opcode["FDIV_16"] = 9] = "FDIV_16";
    Opcode[Opcode["EQ_8"] = 10] = "EQ_8";
    Opcode[Opcode["EQ_16"] = 11] = "EQ_16";
    Opcode[Opcode["LT_8"] = 12] = "LT_8";
    Opcode[Opcode["LT_16"] = 13] = "LT_16";
    Opcode[Opcode["LTE_8"] = 14] = "LTE_8";
    Opcode[Opcode["LTE_16"] = 15] = "LTE_16";
    Opcode[Opcode["AND_8"] = 16] = "AND_8";
    Opcode[Opcode["AND_16"] = 17] = "AND_16";
    Opcode[Opcode["OR_8"] = 18] = "OR_8";
    Opcode[Opcode["OR_16"] = 19] = "OR_16";
    Opcode[Opcode["XOR_8"] = 20] = "XOR_8";
    Opcode[Opcode["XOR_16"] = 21] = "XOR_16";
    Opcode[Opcode["NOT_8"] = 22] = "NOT_8";
    Opcode[Opcode["NOT_16"] = 23] = "NOT_16";
    Opcode[Opcode["SHL_8"] = 24] = "SHL_8";
    Opcode[Opcode["SHL_16"] = 25] = "SHL_16";
    Opcode[Opcode["SHR_8"] = 26] = "SHR_8";
    Opcode[Opcode["SHR_16"] = 27] = "SHR_16";
    Opcode[Opcode["CAST_8"] = 28] = "CAST_8";
    Opcode[Opcode["CAST_16"] = 29] = "CAST_16";
    // Execution environment
    Opcode[Opcode["GETENVVAR_16"] = 30] = "GETENVVAR_16";
    Opcode[Opcode["CALLDATACOPY"] = 31] = "CALLDATACOPY";
    Opcode[Opcode["SUCCESSCOPY"] = 32] = "SUCCESSCOPY";
    Opcode[Opcode["RETURNDATASIZE"] = 33] = "RETURNDATASIZE";
    Opcode[Opcode["RETURNDATACOPY"] = 34] = "RETURNDATACOPY";
    // Control flow
    Opcode[Opcode["JUMP_32"] = 35] = "JUMP_32";
    Opcode[Opcode["JUMPI_32"] = 36] = "JUMPI_32";
    Opcode[Opcode["INTERNALCALL"] = 37] = "INTERNALCALL";
    Opcode[Opcode["INTERNALRETURN"] = 38] = "INTERNALRETURN";
    // Memory
    Opcode[Opcode["SET_8"] = 39] = "SET_8";
    Opcode[Opcode["SET_16"] = 40] = "SET_16";
    Opcode[Opcode["SET_32"] = 41] = "SET_32";
    Opcode[Opcode["SET_64"] = 42] = "SET_64";
    Opcode[Opcode["SET_128"] = 43] = "SET_128";
    Opcode[Opcode["SET_FF"] = 44] = "SET_FF";
    Opcode[Opcode["MOV_8"] = 45] = "MOV_8";
    Opcode[Opcode["MOV_16"] = 46] = "MOV_16";
    // World state
    Opcode[Opcode["SLOAD"] = 47] = "SLOAD";
    Opcode[Opcode["SSTORE"] = 48] = "SSTORE";
    Opcode[Opcode["NOTEHASHEXISTS"] = 49] = "NOTEHASHEXISTS";
    Opcode[Opcode["EMITNOTEHASH"] = 50] = "EMITNOTEHASH";
    Opcode[Opcode["NULLIFIEREXISTS"] = 51] = "NULLIFIEREXISTS";
    Opcode[Opcode["EMITNULLIFIER"] = 52] = "EMITNULLIFIER";
    Opcode[Opcode["L1TOL2MSGEXISTS"] = 53] = "L1TOL2MSGEXISTS";
    Opcode[Opcode["GETCONTRACTINSTANCE"] = 54] = "GETCONTRACTINSTANCE";
    Opcode[Opcode["EMITPUBLICLOG"] = 55] = "EMITPUBLICLOG";
    Opcode[Opcode["SENDL2TOL1MSG"] = 56] = "SENDL2TOL1MSG";
    // External calls
    Opcode[Opcode["CALL"] = 57] = "CALL";
    Opcode[Opcode["STATICCALL"] = 58] = "STATICCALL";
    Opcode[Opcode["RETURN"] = 59] = "RETURN";
    Opcode[Opcode["REVERT_8"] = 60] = "REVERT_8";
    Opcode[Opcode["REVERT_16"] = 61] = "REVERT_16";
    // Misc
    Opcode[Opcode["DEBUGLOG"] = 62] = "DEBUGLOG";
    // Gadgets
    Opcode[Opcode["POSEIDON2"] = 63] = "POSEIDON2";
    Opcode[Opcode["SHA256COMPRESSION"] = 64] = "SHA256COMPRESSION";
    Opcode[Opcode["KECCAKF1600"] = 65] = "KECCAKF1600";
    Opcode[Opcode["ECADD"] = 66] = "ECADD";
    // Conversion
    Opcode[Opcode["TORADIXBE"] = 67] = "TORADIXBE";
    return Opcode;
}({});
export const MAX_OPCODE_VALUE = Math.max(...Object.values(Opcode).map((k)=>+k).filter((k)=>!isNaN(k)));
// Possible types for an instruction's operand in its wire format.
// The counterpart cpp file is: vm2/simulation/lib/serialization.hpp.
export var OperandType = /*#__PURE__*/ function(OperandType) {
    OperandType[OperandType["UINT8"] = 0] = "UINT8";
    OperandType[OperandType["UINT16"] = 1] = "UINT16";
    OperandType[OperandType["UINT32"] = 2] = "UINT32";
    OperandType[OperandType["UINT64"] = 3] = "UINT64";
    OperandType[OperandType["UINT128"] = 4] = "UINT128";
    OperandType[OperandType["FF"] = 5] = "FF";
    OperandType[OperandType["TAG"] = 6] = "TAG";
    return OperandType;
}({});
// Specifies how to read and write each operand type.
const OPERAND_SPEC = new Map([
    [
        0,
        [
            1,
            Buffer.prototype.readUint8,
            Buffer.prototype.writeUint8
        ]
    ],
    [
        1,
        [
            2,
            Buffer.prototype.readUint16BE,
            Buffer.prototype.writeUint16BE
        ]
    ],
    [
        2,
        [
            4,
            Buffer.prototype.readUint32BE,
            Buffer.prototype.writeUint32BE
        ]
    ],
    [
        3,
        [
            8,
            readUint64BE,
            writeUint64BE
        ]
    ],
    [
        4,
        [
            16,
            readUint128BE,
            writeUint128BE
        ]
    ],
    [
        5,
        [
            32,
            readUint254BE,
            writeUint254BE
        ]
    ],
    [
        6,
        [
            1,
            Buffer.prototype.readUint8,
            Buffer.prototype.writeUint8
        ]
    ]
]);
/**
 * Returns the size of an operand in bytes.
 * Should not be called with unknown operand types.
 * @param operandType
 * @returns number size in bytes
 * @throws AssertionError if the operand type is unknown
 */ export function getOperandSize(operandType) {
    assert(OPERAND_SPEC.has(operandType), `Unknown operand type: ${operandType}`);
    return OPERAND_SPEC.get(operandType)[0];
}
function readUintBE(buf, offset, totalBytes) {
    let value = 0n;
    for(let i = 0; i < totalBytes; ++i){
        value <<= 8n;
        value |= BigInt(buf.readUint8(i + offset));
    }
    return value;
}
function writeUintBE(buf, value, totalBytes) {
    for(let offset = totalBytes - 1; offset >= 0; --offset){
        buf.writeUint8(Number(value & 0xffn), offset);
        value >>= 8n;
    }
}
function readUint64BE(offset) {
    return readUintBE(this, offset, 8);
}
function writeUint64BE(value) {
    writeUintBE(this, value, 8);
}
function readUint254BE(offset) {
    let value = readUintBE(this, offset, 32);
    // In circuit, we only support values up to Fr.MODULUS and any deserialized value
    // would naturally undergo a modulus reduction.
    if (value >= Fr.MODULUS) {
        value = value % Fr.MODULUS;
    }
    return value;
}
function writeUint254BE(value) {
    writeUintBE(this, value, 32);
}
function readUint128BE(offset) {
    return readUintBE(this, offset, 16);
}
function writeUint128BE(value) {
    writeUintBE(this, value, 16);
}
/**
 * Reads an array of operands from a buffer.
 * @param cursor Buffer to read from. Might be longer than needed.
 * @param operands Specification of the operand types.
 * @returns An array as big as {@code operands}, with the converted TS values.
 */ export function deserialize(cursor, operands) {
    const argValues = [];
    if (Buffer.isBuffer(cursor)) {
        cursor = new BufferCursor(cursor);
    }
    for (const opType of operands){
        const [sizeBytes, reader, _writer] = OPERAND_SPEC.get(opType);
        const value = reader.call(cursor.buffer(), cursor.position());
        argValues.push(value);
        cursor.advance(sizeBytes);
    }
    // We first want to detect other parsing errors (e.g., instruction size
    // is longer than remaining bytes) first and therefore tag validation is done after completion
    // of parsing above. Order of errors need to match with circuit.
    for(let i = 0; i < operands.length; i++){
        if (operands[i] === 6) {
            // We parsed a single byte (readUInt8()) and therefore value is of number type (not bigint)
            // We need to cast to number because checkIsValidTag expects a number.
            TaggedMemory.checkIsValidTag(Number(argValues[i] ?? 0));
        }
    }
    return argValues;
}
/**
 * Serializes a class using the specified operand types.
 * More specifically, this serializes {@code [cls.constructor.opcode, ...Object.values(cls)]}.
 * Observe in particular that:
 *   (1) the first operand type specified must correspond to the opcode;
 *   (2) the rest of the operand types must be specified in the order returned by {@code Object.values()}.
 * @param operands Type specification for the values to be serialized.
 * @param cls The class to be serialized.
 * @returns
 */ export function serializeAs(operands, opcode, cls) {
    const chunks = [];
    const rawClassValues = [
        opcode,
        ...Object.values(cls)
    ];
    assert(rawClassValues.length === operands.length, `Got ${rawClassValues.length} values but only ${operands.length} serialization operands are specified!`);
    const classValues = rawClassValues;
    for(let i = 0; i < operands.length; i++){
        const opType = operands[i];
        const [sizeBytes, _reader, writer] = OPERAND_SPEC.get(opType);
        const buf = Buffer.alloc(sizeBytes);
        writer.call(buf, classValues[i]);
        chunks.push(buf);
    }
    return Buffer.concat(chunks);
}
