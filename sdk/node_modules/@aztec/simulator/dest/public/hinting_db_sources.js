var _computedKey;
import { sha256Trunc } from '@aztec/foundation/crypto/sha256';
import { Fr } from '@aztec/foundation/curves/bn254';
import { createLogger } from '@aztec/foundation/log';
import { AvmAppendLeavesHint, AvmBytecodeCommitmentHint, AvmCommitCheckpointHint, AvmContractClassHint, AvmContractDbCommitCheckpointHint, AvmContractDbCreateCheckpointHint, AvmContractDbRevertCheckpointHint, AvmContractInstanceHint, AvmCreateCheckpointHint, AvmDebugFunctionNameHint, AvmGetLeafPreimageHintNullifierTree, AvmGetLeafPreimageHintPublicDataTree, AvmGetLeafValueHint, AvmGetPreviousValueIndexHint, AvmGetSiblingPathHint, AvmRevertCheckpointHint, AvmSequentialInsertHintNullifierTree, AvmSequentialInsertHintPublicDataTree } from '@aztec/stdlib/avm';
import { AppendOnlyTreeSnapshot, MerkleTreeId, NullifierLeaf, PublicDataTreeLeaf, getTreeName, merkleTreeIds } from '@aztec/stdlib/trees';
import { TreeSnapshots } from '@aztec/stdlib/tx';
import { strict as assert } from 'assert';
/**
 * A public contracts database that forwards requests and collects AVM hints.
 */ export class HintingPublicContractsDB {
    db;
    hints;
    static log = createLogger('simulator:hinting-public-contracts-db');
    checkpointActionCounter;
    nextCheckpointId;
    checkpointStack;
    constructor(db, hints){
        this.db = db;
        this.hints = hints;
        this.checkpointActionCounter = 0;
        this.nextCheckpointId = 1;
        this.checkpointStack = [
            0
        ];
    }
    async getContractInstance(address, timestamp) {
        const instance = await this.db.getContractInstance(address, timestamp);
        if (instance) {
            const hintKey = this.getHintKey();
            this.hints.contractInstances.push(new AvmContractInstanceHint(hintKey, instance.address, instance.salt, instance.deployer, instance.currentContractClassId, instance.originalContractClassId, instance.initializationHash, instance.publicKeys));
            HintingPublicContractsDB.log.trace(`[getContractInstance:${hintKey}] Added contract instance ${instance.address.toString()} to hints.`);
        }
        return instance;
    }
    async getContractClass(contractClassId) {
        const contractClass = await this.db.getContractClass(contractClassId);
        if (contractClass) {
            const hintKey = this.getHintKey();
            this.hints.contractClasses.push(new AvmContractClassHint(hintKey, contractClass.id, contractClass.artifactHash, contractClass.privateFunctionsRoot, contractClass.packedBytecode));
            HintingPublicContractsDB.log.trace(`[getContractClass:${hintKey}] Added contract class ${contractClassId.toString()} to hints.`);
        }
        return contractClass;
    }
    async getBytecodeCommitment(contractClassId) {
        const commitment = await this.db.getBytecodeCommitment(contractClassId);
        if (commitment) {
            const hintKey = this.getHintKey();
            this.hints.bytecodeCommitments.push(new AvmBytecodeCommitmentHint(hintKey, contractClassId, commitment));
            HintingPublicContractsDB.log.trace(`[getBytecodeCommitment:${hintKey}] Added bytecode commitment ${commitment.toString()} to hints for contract class ${contractClassId.toString()}.`);
        }
        return commitment;
    }
    async getDebugFunctionName(contractAddress, selector) {
        const name = await this.db.getDebugFunctionName(contractAddress, selector);
        if (name) {
            HintingPublicContractsDB.log.debug(`[getDebugFunctionName] Adding debug function name ${name} to hints for contract ${contractAddress.toString()} and selector ${selector.toString()}.`);
            // We hint selector as a field to make things way simpler in C++.
            this.hints.debugFunctionNames.push(new AvmDebugFunctionNameHint(contractAddress, selector.toField(), name));
        }
        return name;
    }
    createCheckpoint() {
        const hintKey = this.getHintKey();
        this.checkpointActionCounter++;
        const oldCheckpointId = this.getCurrentCheckpointId();
        this.db.createCheckpoint();
        const newCheckpointId = this.nextCheckpointId++;
        this.checkpointStack.push(newCheckpointId);
        this.hints.contractDbCreateCheckpointHints.push(new AvmContractDbCreateCheckpointHint(hintKey, oldCheckpointId, newCheckpointId));
        HintingPublicContractsDB.log.trace(`[createCheckpoint:${hintKey}] Checkpoint evolved ${oldCheckpointId} -> ${newCheckpointId}.`);
    }
    commitCheckpoint() {
        const hintKey = this.getHintKey();
        this.checkpointActionCounter++;
        const oldCheckpointId = this.getCurrentCheckpointId();
        this.db.commitCheckpoint();
        this.checkpointStack.pop();
        const newCheckpointId = this.getCurrentCheckpointId();
        this.hints.contractDbCommitCheckpointHints.push(new AvmContractDbCommitCheckpointHint(hintKey, oldCheckpointId, newCheckpointId));
        HintingPublicContractsDB.log.trace(`[commitCheckpoint:${hintKey}] Checkpoint evolved ${oldCheckpointId} -> ${newCheckpointId}.`);
    }
    revertCheckpoint() {
        const hintKey = this.getHintKey();
        this.checkpointActionCounter++;
        const oldCheckpointId = this.getCurrentCheckpointId();
        this.db.revertCheckpoint();
        this.checkpointStack.pop();
        const newCheckpointId = this.getCurrentCheckpointId();
        this.hints.contractDbRevertCheckpointHints.push(new AvmContractDbRevertCheckpointHint(hintKey, oldCheckpointId, newCheckpointId));
        HintingPublicContractsDB.log.trace(`[revertCheckpoint:${hintKey}] Checkpoint evolved ${oldCheckpointId} -> ${newCheckpointId}.`);
    }
    // Private methods.
    getHintKey() {
        return this.checkpointActionCounter;
    }
    getCurrentCheckpointId() {
        return this.checkpointStack[this.checkpointStack.length - 1];
    }
}
_computedKey = Symbol.asyncDispose;
/**
 * A low-level merkle DB that collects hints.
 */ export class HintingMerkleWriteOperations {
    db;
    hints;
    static log = createLogger('simulator:hinting-merkle-db');
    // This stack is only for debugging purposes.
    // The top of the stack is the current checkpoint id.
    // We need the stack to be non-empty and use 0 as an arbitrary initial checkpoint id.
    // This is not necessarily a checkpoint that happened, but whatever tree state we start with.
    checkpointStack;
    nextCheckpointId;
    checkpointActionCounter;
    static async create(db, hints) {
        const hintingTreesDB = new HintingMerkleWriteOperations(db, hints);
        const startStateReference = await db.getStateReference();
        hints.startingTreeRoots = new TreeSnapshots(startStateReference.l1ToL2MessageTree, startStateReference.partial.noteHashTree, startStateReference.partial.nullifierTree, startStateReference.partial.publicDataTree);
        return hintingTreesDB;
    }
    // Use create() to instantiate.
    constructor(db, hints){
        this.db = db;
        this.hints = hints;
        this.checkpointStack = [
            0
        ];
        this.nextCheckpointId = 1;
        this.checkpointActionCounter = 0;
    }
    // Getters.
    async getSiblingPath(treeId, index) {
        const path = await this.db.getSiblingPath(treeId, index);
        const key = await this.getHintKey(treeId);
        this.hints.getSiblingPathHints.push(new AvmGetSiblingPathHint(key, treeId, index, path.toFields()));
        return Promise.resolve(path);
    }
    async getPreviousValueIndex(treeId, value) {
        const result = await this.db.getPreviousValueIndex(treeId, value);
        if (result === undefined) {
            throw new Error(`getPreviousValueIndex(${getTreeName(treeId)}, ${value}}) returned undefined. Possible wrong tree setup or corrupted state.`);
        }
        const key = await this.getHintKey(treeId);
        this.hints.getPreviousValueIndexHints.push(new AvmGetPreviousValueIndexHint(key, treeId, new Fr(value), result.index, result.alreadyPresent));
        return result;
    }
    async getLeafPreimage(treeId, index) {
        const preimage = await this.db.getLeafPreimage(treeId, index);
        if (preimage) {
            const key = await this.getHintKey(treeId);
            switch(treeId){
                case MerkleTreeId.PUBLIC_DATA_TREE:
                    this.hints.getLeafPreimageHintsPublicDataTree.push(new AvmGetLeafPreimageHintPublicDataTree(key, index, preimage));
                    break;
                case MerkleTreeId.NULLIFIER_TREE:
                    this.hints.getLeafPreimageHintsNullifierTree.push(new AvmGetLeafPreimageHintNullifierTree(key, index, preimage));
                    break;
                default:
                    // Use getLeafValue for the other trees.
                    throw new Error('getLeafPreimage only supported for PublicDataTree and NullifierTree!');
                    break;
            }
        }
        return preimage;
    }
    async getLeafValue(treeId, index) {
        // Use getLeafPreimage for PublicDataTree and NullifierTree.
        assert(treeId == MerkleTreeId.NOTE_HASH_TREE || treeId == MerkleTreeId.L1_TO_L2_MESSAGE_TREE);
        const value = await this.db.getLeafValue(treeId, index);
        if (value) {
            const key = await this.getHintKey(treeId);
            // We can cast to Fr because we know the type of the tree.
            this.hints.getLeafValueHints.push(new AvmGetLeafValueHint(key, treeId, index, value));
        }
        return value;
    }
    // State modification.
    // FIXME(fcarreiro): This is a horrible interface (in the merkle ops). It's receiving the leaves as buffers,
    // from a leaf class that is NOT the one that will be used to write. Make this type safe.
    async sequentialInsert(treeId, leaves) {
        // Use appendLeaf for NoteHashTree and L1ToL2MessageTree.
        assert(treeId == MerkleTreeId.PUBLIC_DATA_TREE || treeId == MerkleTreeId.NULLIFIER_TREE);
        // We only support 1 leaf at a time for now. Can easily be extended.
        assert(leaves.length === 1, 'sequentialInsert supports only one leaf at a time!');
        const beforeState = await this.getHintKey(treeId);
        const result = await this.db.sequentialInsert(treeId, leaves);
        const afterState = await this.getHintKey(treeId);
        HintingMerkleWriteOperations.logTreeChange('sequentialInsert', beforeState, afterState, treeId);
        switch(treeId){
            case MerkleTreeId.PUBLIC_DATA_TREE:
                this.hints.sequentialInsertHintsPublicDataTree.push(new AvmSequentialInsertHintPublicDataTree(beforeState, afterState, treeId, PublicDataTreeLeaf.fromBuffer(leaves[0]), {
                    leaf: result.lowLeavesWitnessData[0].leafPreimage,
                    index: result.lowLeavesWitnessData[0].index,
                    path: result.lowLeavesWitnessData[0].siblingPath.toFields()
                }, {
                    leaf: result.insertionWitnessData[0].leafPreimage,
                    index: result.insertionWitnessData[0].index,
                    path: result.insertionWitnessData[0].siblingPath.toFields()
                }));
                break;
            case MerkleTreeId.NULLIFIER_TREE:
                this.hints.sequentialInsertHintsNullifierTree.push(new AvmSequentialInsertHintNullifierTree(beforeState, afterState, treeId, NullifierLeaf.fromBuffer(leaves[0]), {
                    leaf: result.lowLeavesWitnessData[0].leafPreimage,
                    index: result.lowLeavesWitnessData[0].index,
                    path: result.lowLeavesWitnessData[0].siblingPath.toFields()
                }, {
                    leaf: result.insertionWitnessData[0].leafPreimage,
                    index: result.insertionWitnessData[0].index,
                    path: result.insertionWitnessData[0].siblingPath.toFields()
                }));
                break;
            default:
                throw new Error('sequentialInsert only supported for PublicDataTree and NullifierTree!');
                break;
        }
        return result;
    }
    async appendLeaves(treeId, leaves) {
        // Use sequentialInsert for PublicDataTree and NullifierTree.
        assert(treeId == MerkleTreeId.NOTE_HASH_TREE || treeId == MerkleTreeId.L1_TO_L2_MESSAGE_TREE);
        // We need to process each leaf individually because we need the sibling path after insertion, to be able to constraint the insertion.
        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/13380): This can be changed if the world state appendLeaves returns the sibling paths.
        if (leaves.length === 1) {
            await this.appendLeafInternal(treeId, leaves[0]);
            return;
        } else {
            // TODO(dbanks12): NON-HINTING! We skip hinting here for now because:
            // 1. We only ever append multiple leaves (for now) when padding (all empty leaves).
            // 2. We don't need hints per-item when padding.
            // 3. In order to get per-item hints today, you need to append one-at-a-time (mentioned above), which is VERY slow.
            await this.db.appendLeaves(treeId, leaves);
        }
    }
    async createCheckpoint() {
        const actionCounter = this.checkpointActionCounter++;
        const oldCheckpointId = this.getCurrentCheckpointId();
        const treesStateHash = await this.getTreesStateHash();
        await this.db.createCheckpoint();
        this.checkpointStack.push(this.nextCheckpointId++);
        const newCheckpointId = this.getCurrentCheckpointId();
        this.hints.createCheckpointHints.push(new AvmCreateCheckpointHint(actionCounter, oldCheckpointId, newCheckpointId));
        HintingMerkleWriteOperations.log.trace(`[createCheckpoint:${actionCounter}] Checkpoint evolved ${oldCheckpointId} -> ${newCheckpointId} at trees state ${treesStateHash}.`);
    }
    commitAllCheckpoints() {
        throw new Error('commitAllCheckpoints is not supported in HintingMerkleWriteOperations.');
    }
    revertAllCheckpoints() {
        throw new Error('revertAllCheckpoints is not supported in HintingMerkleWriteOperations.');
    }
    async commitCheckpoint() {
        const actionCounter = this.checkpointActionCounter++;
        const oldCheckpointId = this.getCurrentCheckpointId();
        const treesStateHash = await this.getTreesStateHash();
        await this.db.commitCheckpoint();
        this.checkpointStack.pop();
        const newCheckpointId = this.getCurrentCheckpointId();
        this.hints.commitCheckpointHints.push(new AvmCommitCheckpointHint(actionCounter, oldCheckpointId, newCheckpointId));
        HintingMerkleWriteOperations.log.trace(`[commitCheckpoint:${actionCounter}] Checkpoint evolved ${oldCheckpointId} -> ${newCheckpointId} at trees state ${treesStateHash}.`);
    }
    async revertCheckpoint() {
        const actionCounter = this.checkpointActionCounter++;
        const oldCheckpointId = this.getCurrentCheckpointId();
        const treesStateHash = await this.getTreesStateHash();
        const beforeState = {
            [MerkleTreeId.PUBLIC_DATA_TREE]: await this.getHintKey(MerkleTreeId.PUBLIC_DATA_TREE),
            [MerkleTreeId.NULLIFIER_TREE]: await this.getHintKey(MerkleTreeId.NULLIFIER_TREE),
            [MerkleTreeId.NOTE_HASH_TREE]: await this.getHintKey(MerkleTreeId.NOTE_HASH_TREE),
            [MerkleTreeId.L1_TO_L2_MESSAGE_TREE]: await this.getHintKey(MerkleTreeId.L1_TO_L2_MESSAGE_TREE),
            [MerkleTreeId.ARCHIVE]: await this.getHintKey(MerkleTreeId.ARCHIVE)
        };
        await this.db.revertCheckpoint();
        this.checkpointStack.pop();
        const newCheckpointId = this.getCurrentCheckpointId();
        const afterState = {
            [MerkleTreeId.PUBLIC_DATA_TREE]: await this.getHintKey(MerkleTreeId.PUBLIC_DATA_TREE),
            [MerkleTreeId.NULLIFIER_TREE]: await this.getHintKey(MerkleTreeId.NULLIFIER_TREE),
            [MerkleTreeId.NOTE_HASH_TREE]: await this.getHintKey(MerkleTreeId.NOTE_HASH_TREE),
            [MerkleTreeId.L1_TO_L2_MESSAGE_TREE]: await this.getHintKey(MerkleTreeId.L1_TO_L2_MESSAGE_TREE),
            [MerkleTreeId.ARCHIVE]: await this.getHintKey(MerkleTreeId.ARCHIVE)
        };
        this.hints.revertCheckpointHints.push(AvmRevertCheckpointHint.create(actionCounter, oldCheckpointId, newCheckpointId, beforeState, afterState));
        HintingMerkleWriteOperations.log.trace(`[revertCheckpoint:${actionCounter}] Checkpoint evolved ${oldCheckpointId} -> ${newCheckpointId} at trees state ${treesStateHash}.`);
        for (const treeId of merkleTreeIds()){
            HintingMerkleWriteOperations.logTreeChange('revertCheckpoint', beforeState[treeId], afterState[treeId], treeId);
        }
    }
    // Private methods.
    async getHintKey(treeId) {
        const treeInfo = await this.db.getTreeInfo(treeId);
        return new AppendOnlyTreeSnapshot(Fr.fromBuffer(treeInfo.root), Number(treeInfo.size));
    }
    getCurrentCheckpointId() {
        return this.checkpointStack[this.checkpointStack.length - 1];
    }
    // For logging/debugging purposes.
    async getTreesStateHash() {
        const stateReferenceFields = (await this.db.getStateReference()).toFields();
        return Fr.fromBuffer(sha256Trunc(Buffer.concat(stateReferenceFields.map((field)=>field.toBuffer()))));
    }
    static logTreeChange(action, beforeState, afterState, treeId) {
        const treeName = getTreeName(treeId);
        HintingMerkleWriteOperations.log.trace(`[${action}] ${treeName} tree state: ${beforeState.root}, ${beforeState.nextAvailableLeafIndex} -> ${afterState.root}, ${afterState.nextAvailableLeafIndex}.`);
    }
    async appendLeafInternal(treeId, leaf) {
        // Use sequentialInsert for PublicDataTree and NullifierTree.
        assert(treeId == MerkleTreeId.NOTE_HASH_TREE || treeId == MerkleTreeId.L1_TO_L2_MESSAGE_TREE);
        const beforeState = await this.getHintKey(treeId);
        await this.db.appendLeaves(treeId, [
            leaf
        ]);
        const afterState = await this.getHintKey(treeId);
        HintingMerkleWriteOperations.logTreeChange('appendLeaves', beforeState, afterState, treeId);
        this.hints.appendLeavesHints.push(new AvmAppendLeavesHint(beforeState, afterState, treeId, [
            leaf
        ]));
        return await this.getSiblingPath(treeId, BigInt(beforeState.nextAvailableLeafIndex));
    }
    // Non-hinted required methods from MerkleTreeWriteOperations interface
    async getTreeInfo(treeId) {
        return await this.db.getTreeInfo(treeId);
    }
    async getStateReference() {
        return await this.db.getStateReference();
    }
    getInitialHeader() {
        return this.db.getInitialHeader();
    }
    getRevision() {
        return this.db.getRevision();
    }
    async updateArchive(header) {
        return await this.db.updateArchive(header);
    }
    async batchInsert(treeId, leaves, subtreeHeight) {
        return await this.db.batchInsert(treeId, leaves, subtreeHeight);
    }
    async close() {
        return await this.db.close();
    }
    async [_computedKey]() {
        await this.close();
    }
    async findLeafIndices(treeId, values) {
        return await this.db.findLeafIndices(treeId, values);
    }
    findSiblingPaths(treeId, values) {
        return this.db.findSiblingPaths(treeId, values);
    }
    async findLeafIndicesAfter(treeId, values, startIndex) {
        return await this.db.findLeafIndicesAfter(treeId, values, startIndex);
    }
    async getBlockNumbersForLeafIndices(treeId, leafIndices) {
        return await this.db.getBlockNumbersForLeafIndices(treeId, leafIndices);
    }
}
