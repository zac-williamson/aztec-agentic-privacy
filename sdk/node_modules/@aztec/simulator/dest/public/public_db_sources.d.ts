import { Fr } from '@aztec/foundation/curves/bn254';
import { type LoggerBindings } from '@aztec/foundation/log';
import type { FunctionSelector } from '@aztec/stdlib/abi';
import type { AztecAddress } from '@aztec/stdlib/aztec-address';
import { type ContractClassPublic, type ContractDataSource, type ContractDeploymentData, type ContractInstanceWithAddress } from '@aztec/stdlib/contract';
import type { MerkleTreeWriteOperations } from '@aztec/stdlib/interfaces/server';
import { MerkleTreeId } from '@aztec/stdlib/trees';
import { TreeSnapshots, type Tx } from '@aztec/stdlib/tx';
import type { UInt64 } from '@aztec/stdlib/types';
import type { PublicContractsDBInterface, PublicStateDBInterface } from './db_interfaces.js';
/**
 * Implements the PublicContractsDBInterface using a ContractDataSource.
 * Uses a stack-based checkpoint model for managing contract state.
 */
export declare class PublicContractsDB implements PublicContractsDBInterface {
    private dataSource;
    private contractStateStack;
    private log;
    constructor(dataSource: ContractDataSource, bindings?: LoggerBindings);
    addContracts(contractDeploymentData: ContractDeploymentData): Promise<void>;
    addNewContracts(tx: Tx): Promise<void>;
    /**
     * Creates a new checkpoint, copying the current state for upcoming modifications,
     * and enabling rollbacks to current state in case of a revert.
     */
    createCheckpoint(): void;
    /**
     * Commits the current checkpoint, accepting its state latest.
     */
    commitCheckpoint(): void;
    /**
     * Commits the current checkpoint, not erroring if there is no checkpoint
     * to commit. This is useful to do a sanity commit at the end of tx execution,
     * doing nothing if the checkpoint was already reverted, but truly committing
     * otherwise.
     */
    commitCheckpointOkIfNone(): void;
    /**
     * Reverts the current checkpoint, discarding its state and rolling back
     * to the state as of the latest checkpoint.
     */
    revertCheckpoint(): void;
    private getCurrentState;
    getContractInstance(address: AztecAddress, timestamp: UInt64): Promise<ContractInstanceWithAddress | undefined>;
    getContractClass(contractClassId: Fr): Promise<ContractClassPublic | undefined>;
    getBytecodeCommitment(contractClassId: Fr): Promise<Fr | undefined>;
    getDebugFunctionName(address: AztecAddress, selector: FunctionSelector): Promise<string | undefined>;
    private addContractClassesFromEvents;
    private addContractInstancesFromEvents;
}
/**
 * A high-level class that provides access to the merkle trees.
 *
 * This class is just a helper wrapper around a merkle db. Anything that you can do with it
 * can also be done directly with the merkle db. This class should NOT be exposed or used
 * outside of `simulator/src/public`.
 *
 * NOTE: This class is currently written in such a way that it would generate the
 * necessary hints if used with a hinting merkle db. This is a bit of a leak of concepts.
 * Eventually we can have everything depend on a config/factory at the TxSimulator level
 * to decide whether to use hints or not (same with tracing, etc).
 */
export declare class PublicTreesDB implements PublicStateDBInterface {
    private readonly db;
    private logger;
    constructor(db: MerkleTreeWriteOperations, bindings?: LoggerBindings);
    storageRead(contract: AztecAddress, slot: Fr): Promise<Fr>;
    storageWrite(contract: AztecAddress, slot: Fr, newValue: Fr): Promise<void>;
    getL1ToL2LeafValue(leafIndex: bigint): Promise<Fr>;
    getNoteHash(leafIndex: bigint): Promise<Fr>;
    writeNoteHash(noteHash: Fr): Promise<void>;
    checkNullifierExists(nullifier: Fr): Promise<boolean>;
    writeNullifier(siloedNullifier: Fr): Promise<void>;
    padTree(treeId: MerkleTreeId, leavesToInsert: number): Promise<void>;
    createCheckpoint(): Promise<void>;
    commitCheckpoint(): Promise<void>;
    revertCheckpoint(): Promise<void>;
    getTreeSnapshots(): Promise<TreeSnapshots>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVibGljX2RiX3NvdXJjZXMuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wdWJsaWMvcHVibGljX2RiX3NvdXJjZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBTUEsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3BELE9BQU8sRUFBZSxLQUFLLGNBQWMsRUFBZ0IsTUFBTSx1QkFBdUIsQ0FBQztBQUl2RixPQUFPLEtBQUssRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBRTFELE9BQU8sS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ2hFLE9BQU8sRUFFTCxLQUFLLG1CQUFtQixFQUN4QixLQUFLLGtCQUFrQixFQUN2QixLQUFLLHNCQUFzQixFQUMzQixLQUFLLDJCQUEyQixFQUVqQyxNQUFNLHdCQUF3QixDQUFDO0FBRWhDLE9BQU8sS0FBSyxFQUFFLHlCQUF5QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFakYsT0FBTyxFQUNMLFlBQVksRUFLYixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUMxRCxPQUFPLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUtsRCxPQUFPLEtBQUssRUFBRSwwQkFBMEIsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRzdGOzs7R0FHRztBQUNILHFCQUFhLGlCQUFrQixZQUFXLDBCQUEwQjtJQU1oRSxPQUFPLENBQUMsVUFBVTtJQUxwQixPQUFPLENBQUMsa0JBQWtCLENBQTBEO0lBRXBGLE9BQU8sQ0FBQyxHQUFHLENBQVM7SUFFcEIsWUFDVSxVQUFVLEVBQUUsa0JBQWtCLEVBQ3RDLFFBQVEsQ0FBQyxFQUFFLGNBQWMsRUFHMUI7SUFFWSxZQUFZLENBQUMsc0JBQXNCLEVBQUUsc0JB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