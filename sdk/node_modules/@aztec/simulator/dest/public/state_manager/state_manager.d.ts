import { Fr } from '@aztec/foundation/curves/bn254';
import { type LogLevel, type LoggerBindings } from '@aztec/foundation/log';
import { FunctionSelector } from '@aztec/stdlib/abi';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { SerializableContractInstance } from '@aztec/stdlib/contract';
import type { DebugLog } from '@aztec/stdlib/logs';
import { ScopedL2ToL1Message } from '@aztec/stdlib/messaging';
import { MerkleTreeId } from '@aztec/stdlib/trees';
import type { TreeSnapshots } from '@aztec/stdlib/tx';
import type { UInt64 } from '@aztec/stdlib/types';
import type { AvmExecutionEnvironment } from '../avm/avm_execution_environment.js';
import type { PublicContractsDBInterface } from '../db_interfaces.js';
import type { PublicTreesDB } from '../public_db_sources.js';
import type { PublicSideEffectTraceInterface } from '../side_effect_trace_interface.js';
import { NullifierManager } from './nullifiers.js';
import { PublicStorage } from './public_storage.js';
/**
 * A class to manage persistable AVM state for contract calls.
 * Maintains a cache of the current world state,
 * a trace of all side effects.
 *
 * The simulator should make any world state / tree queries through this object.
 *
 * Manages merging of successful/reverted child state into current state.
 */
export declare class PublicPersistableStateManager {
    private readonly treesDB;
    private readonly contractsDB;
    private readonly trace;
    private readonly firstNullifier;
    private readonly timestamp;
    private readonly doMerkleOperations;
    private readonly publicStorage;
    private readonly nullifiers;
    private readonly log;
    /** Make sure a forked state is never merged twice. */
    private alreadyMergedIntoParent;
    constructor(treesDB: PublicTreesDB, contractsDB: PublicContractsDBInterface, trace: PublicSideEffectTraceInterface, firstNullifier: Fr, timestamp: UInt64, doMerkleOperations?: boolean, publicStorage?: PublicStorage, nullifiers?: NullifierManager, bindings?: LoggerBindings);
    /**
     * Create a new state manager
     */
    static create(treesDB: PublicTreesDB, contractsDB: PublicContractsDBInterface, trace: PublicSideEffectTraceInterface, firstNullifier: Fr, timestamp: UInt64, bindings?: LoggerBindings): PublicPersistableStateManager;
    /**
     * Create a new state manager forked from this one
     */
    fork(): Promise<PublicPersistableStateManager>;
    /**
     * Accept forked world state modifications & traced side effects / hints
     */
    merge(forkedState: PublicPersistableStateManager): Promise<void>;
    /**
     * Reject forked world state modifications & traced side effects, keep traced hints
     */
    reject(forkedState: PublicPersistableStateManager): Promise<void>;
    private _merge;
    /**
     * Write to public storage, journal/trace the write.
     *
     * @param contractAddress - the address of the contract whose storage is being written to
     * @param slot - the slot in the contract's storage being written to
     * @param value - the value being written to the slot
     */
    writeStorage(contractAddress: AztecAddress, slot: Fr, value: Fr, protocolWrite?: boolean): Promise<void>;
    isStorageCold(contractAddress: AztecAddress, slot: Fr): boolean;
    /**
     * Read from public storage.
     *
     * @param contractAddress - the address of the contract whose storage is being read from
     * @param slot - the slot in the contract's storage being read from
     * @returns the latest value written to slot, or 0 if never written to before
     */
    readStorage(contractAddress: AztecAddress, slot: Fr): Promise<Fr>;
    /**
     * Check if a note hash exists at the given leaf index, trace the check.
     *
     * @param contractAddress - the address of the contract whose storage is being read from
     * @param noteHash - the unsiloed note hash being checked
     * @param leafIndex - the leaf index being checked
     * @returns true if the note hash exists at the given leaf index, false otherwise
     */
    checkNoteHashExists(contractAddress: AztecAddress, noteHash: Fr, leafIndex: bigint): Promise<boolean>;
    /**
     * Write a raw note hash, silo it and make it unique, then trace the write.
     * @param noteHash - the unsiloed note hash to write
     */
    writeNoteHash(contractAddress: AztecAddress, noteHash: Fr): Promise<void>;
    /**
     * Write a note hash, make it unique, trace the write.
     * @param siloedNoteHash - the non unique note hash to write
     */
    writeSiloedNoteHash(siloedNoteHash: Fr): Promise<void>;
    /**
     * Write a note hash, trace the write.
     * @param uniqueNoteHash - the siloed unique hash to write
     */
    writeUniqueNoteHash(uniqueNoteHash: Fr): Promise<void>;
    /**
     * Check if a nullifier exists, trace the check.
     * @param contractAddress - address of the contract that the nullifier is associated with
     * @param nullifier - the unsiloed nullifier to check
     * @returns exists - whether the nullifier exists in the nullifier set
     */
    checkNullifierExists(contractAddress: AztecAddress, nullifier: Fr): Promise<boolean>;
    /**
     * Check if a siloed nullifier exists.
     * @param siloedNullifier - the siloed nullifier to check
     * @returns exists - whether the nullifier exists in the nullifier set
     */
    checkSiloedNullifierExists(siloedNullifier: Fr): Promise<boolean>;
    /**
     * Write a nullifier to the nullifier set, trace the write.
     * @param contractAddress - address of the contract that the nullifier is associated with
     * @param nullifier - the unsiloed nullifier to write
     */
    writeNullifier(contractAddress: AztecAddress, nullifier: Fr): Promise<void>;
    /**
     * Write a nullifier to the nullifier set, trace the write.
     * @param siloedNullifier - the siloed nullifier to write
     */
    writeSiloedNullifier(siloedNullifier: Fr): Promise<void>;
    /**
     * Check if an L1 to L2 message exists, trace the check.
     * @param msgHash - the message hash to check existence of
     * @param msgLeafIndex - the message leaf index to use in the check
     * @returns exists - whether the message exists in the L1 to L2 Messages tree
     */
    checkL1ToL2MessageExists(msgHash: Fr, msgLeafIndex: Fr): Promise<boolean>;
    /**
     * Write an L2 to L1 message.
     * @param contractAddress - L2 contract address that created this message
     * @param recipient - L1 contract address to send the message to.
     * @param content - Message content.
     */
    writeL2ToL1Message(contractAddress: AztecAddress, recipient: Fr, content: Fr): void;
    /**
     * Write a scoped L2 to L1 message.
     * @param l2ToL1Message - The L2 to L1 message to write.
     */
    writeScopedL2ToL1Message(l2ToL1Message: ScopedL2ToL1Message): void;
    writeDebugLog(contractAddress: AztecAddress, level: LogLevel, message: string, fields: Fr[]): void;
    writeDebugLogMemoryReads(memoryReads: number): void;
    getDebugLogMemoryReads(): number;
    getLogs(): DebugLog[];
    /**
     * Write a public log
     * @param contractAddress - address of the contract that emitted the log
     * @param log - log contents
     */
    writePublicLog(contractAddress: AztecAddress, log: Fr[]): void;
    /**
     * Get a contract instance.
     * @param contractAddress - address of the contract instance to retrieve.
     * @returns the contract instance or undefined if it does not exist.
     */
    getContractInstance(contractAddress: AztecAddress): Promise<SerializableContractInstance | undefined>;
    private checkContractUpdateInformation;
    private getContractClass;
    /**
     * Get a contract's bytecode from the contracts DB, also trace the contract class and instance indirectly.
     */
    getBytecode(contractAddress: AztecAddress): Promise<Buffer | undefined>;
    getPublicFunctionDebugName(avmEnvironment: AvmExecutionEnvironment): Promise<string>;
    getPublicFunctionSelectorAndName(avmEnvironment: AvmExecutionEnvironment): Promise<{
        functionSelector?: FunctionSelector;
        functionName?: string;
    }>;
    padTree(treeId: MerkleTreeId, leavesToInsert: number): Promise<void>;
    getTreeSnapshots(): Promise<TreeSnapshots>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGVfbWFuYWdlci5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3B1YmxpYy9zdGF0ZV9tYW5hZ2VyL3N0YXRlX21hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRXBELE9BQU8sRUFBRSxLQUFLLFFBQVEsRUFBZSxLQUFLLGNBQWMsRUFBZ0IsTUFBTSx1QkFBdUIsQ0FBQztBQUV0RyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFM0QsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFHdEUsT0FBTyxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDbkQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ25ELE9BQU8sS0FBSyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3RELE9BQU8sS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBSWxELE9BQU8sS0FBSyxFQUFFLHVCQUF1QixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDbkYsT0FBTyxLQUFLLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUV0RSxPQUFPLEtBQUssRUFBRSxhQUFhLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQU83RCxPQUFPLEtBQUssRUFBRSw4QkFBOEIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3hGLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxxQkFBcUIsQ0FB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