var _computedKey, _computedKey1;
import { LmdbAztecSingleton } from './singleton.js';
_computedKey = Symbol.iterator, _computedKey1 = Symbol.asyncIterator;
/**
 * An persistent array backed by LMDB.
 */ export class LmdbAztecArray {
    #db;
    #name;
    #length;
    constructor(db, arrName){
        this.#name = arrName;
        this.#length = new LmdbAztecSingleton(db, `${arrName}:meta:length`);
        this.#db = db;
    }
    get length() {
        return this.#length.get() ?? 0;
    }
    lengthAsync() {
        return Promise.resolve(this.length);
    }
    push(...vals) {
        return this.#db.childTransaction(()=>{
            let length = this.length;
            for (const val of vals){
                void this.#db.put(this.#slot(length), val);
                length += 1;
            }
            void this.#length.set(length);
            return length;
        });
    }
    pop() {
        return this.#db.childTransaction(()=>{
            const length = this.length;
            if (length === 0) {
                return undefined;
            }
            const slot = this.#slot(length - 1);
            const val = this.#db.get(slot);
            void this.#db.remove(slot);
            void this.#length.set(length - 1);
            return val;
        });
    }
    at(index) {
        if (index < 0) {
            index = this.length + index;
        }
        // the Array API only accepts indexes in the range [-this.length, this.length)
        // so if after normalizing the index is still out of range, return undefined
        if (index < 0 || index >= this.length) {
            return undefined;
        }
        return this.#db.get(this.#slot(index));
    }
    atAsync(index) {
        return Promise.resolve(this.at(index));
    }
    setAt(index, val) {
        if (index < 0) {
            index = this.length + index;
        }
        if (index < 0 || index >= this.length) {
            return Promise.resolve(false);
        }
        return this.#db.put(this.#slot(index), val);
    }
    *entries() {
        const transaction = this.#db.useReadTransaction();
        try {
            const values = this.#db.getRange({
                start: this.#slot(0),
                limit: this.length,
                transaction
            });
            for (const { key, value } of values){
                const index = key[3];
                yield [
                    index,
                    value
                ];
            }
        } finally{
            transaction.done();
        }
    }
    async *entriesAsync() {
        for (const [key, value] of this.entries()){
            yield [
                key,
                value
            ];
        }
    }
    *values() {
        for (const [_, value] of this.entries()){
            yield value;
        }
    }
    async *valuesAsync() {
        for (const [_, value] of this.entries()){
            yield value;
        }
    }
    [_computedKey]() {
        return this.values();
    }
    [_computedKey1]() {
        return this.valuesAsync();
    }
    #slot(index) {
        return [
            'array',
            this.#name,
            'slot',
            index
        ];
    }
}
