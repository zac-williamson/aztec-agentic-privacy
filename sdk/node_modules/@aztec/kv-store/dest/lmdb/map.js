/**
 * A map backed by LMDB.
 */ export class LmdbAztecMap {
    db;
    name;
    startSentinel;
    endSentinel;
    constructor(rootDb, mapName){
        this.name = mapName;
        this.db = rootDb;
        // sentinels are used to define the start and end of the map
        // with LMDB's key encoding, no _primitive value_ can be "less than" an empty buffer or greater than Byte 255
        // these will be used later to answer range queries
        this.startSentinel = [
            'map',
            this.name,
            'slot',
            Buffer.from([])
        ];
        this.endSentinel = [
            'map',
            this.name,
            'slot',
            Buffer.from([
                255
            ])
        ];
    }
    close() {
        return this.db.close();
    }
    get(key) {
        return this.db.get(this.slot(key))?.[1];
    }
    getAsync(key) {
        return Promise.resolve(this.get(key));
    }
    has(key) {
        return this.db.doesExist(this.slot(key));
    }
    hasAsync(key) {
        return Promise.resolve(this.has(key));
    }
    async set(key, val) {
        await this.db.put(this.slot(key), [
            key,
            val
        ]);
    }
    async setMany(entries) {
        for (const { key, value } of entries){
            await this.set(key, value);
        }
    }
    swap(key, fn) {
        return this.db.childTransaction(()=>{
            const slot = this.slot(key);
            const entry = this.db.get(slot);
            void this.db.put(slot, [
                key,
                fn(entry?.[1])
            ]);
        });
    }
    setIfNotExists(key, val) {
        const slot = this.slot(key);
        return this.db.ifNoExists(slot, ()=>{
            void this.db.put(slot, [
                key,
                val
            ]);
        });
    }
    async delete(key) {
        await this.db.remove(this.slot(key));
    }
    *entries(range = {}) {
        const transaction = this.db.useReadTransaction();
        try {
            const { reverse = false, limit } = range;
            // LMDB has a quirk where it expects start > end when reverse=true
            // in that case, we need to swap the start and end sentinels
            const start = reverse ? range.end ? this.slot(range.end) : this.endSentinel : range.start ? this.slot(range.start) : this.startSentinel;
            const end = reverse ? range.start ? this.slot(range.start) : this.startSentinel : range.end ? this.slot(range.end) : this.endSentinel;
            const lmdbRange = {
                start,
                end,
                reverse,
                limit,
                transaction
            };
            const iterator = this.db.getRange(lmdbRange);
            for (const { value: [key, value] } of iterator){
                yield [
                    key,
                    value
                ];
            }
        } finally{
            transaction.done();
        }
    }
    async *entriesAsync(range) {
        for (const entry of this.entries(range)){
            yield entry;
        }
    }
    *values(range = {}) {
        for (const [_, value] of this.entries(range)){
            yield value;
        }
    }
    async *valuesAsync(range = {}) {
        for await (const [_, value] of this.entriesAsync(range)){
            yield value;
        }
    }
    size() {
        const iterator = this.db.getRange({
            start: this.startSentinel,
            end: this.endSentinel
        });
        return iterator.asArray.length;
    }
    sizeAsync() {
        return Promise.resolve(this.size());
    }
    *keys(range = {}) {
        for (const [key, _] of this.entries(range)){
            yield key;
        }
    }
    async *keysAsync(range = {}) {
        for await (const [key, _] of this.entriesAsync(range)){
            yield key;
        }
    }
    slot(key) {
        return [
            'map',
            this.name,
            'slot',
            key
        ];
    }
    async clear() {
        const lmdbRange = {
            start: this.startSentinel,
            end: this.endSentinel
        };
        const iterator = this.db.getRange(lmdbRange);
        for (const { key } of iterator){
            await this.db.remove(key);
        }
    }
}
