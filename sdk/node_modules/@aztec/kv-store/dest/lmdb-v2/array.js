var _computedKey;
import { Encoder } from 'msgpackr/pack';
import { execInReadTx, execInWriteTx } from './tx-helpers.js';
import { deserializeKey, serializeKey } from './utils.js';
_computedKey = Symbol.asyncIterator;
export class LMDBArray {
    store;
    length;
    encoder;
    prefix;
    constructor(store, name){
        this.store = store;
        this.encoder = new Encoder();
        this.length = store.openSingleton(name + ':length');
        this.prefix = `array:${name}`;
    }
    pop() {
        return execInWriteTx(this.store, async (tx)=>{
            const length = await this.lengthAsync();
            if (length === 0) {
                return;
            }
            const val = await tx.get(serializeKey(this.prefix, length - 1));
            await tx.remove(serializeKey(this.prefix, length - 1));
            await this.length.set(length - 1);
            return val ? this.encoder.unpack(val) : undefined;
        });
    }
    push(...vals) {
        return execInWriteTx(this.store, async (tx)=>{
            let length = await this.lengthAsync();
            for (const val of vals){
                await tx.set(serializeKey(this.prefix, length++), this.encoder.pack(val));
            }
            await this.length.set(length);
            return length;
        });
    }
    setAt(index, val) {
        return execInWriteTx(this.store, async (tx)=>{
            const length = await this.lengthAsync();
            if (index < 0) {
                index += length;
            }
            if (index < 0 || index >= length) {
                return false;
            }
            await tx.set(serializeKey(this.prefix, index), this.encoder.pack(val));
            return true;
        });
    }
    atAsync(index) {
        return execInReadTx(this.store, async (tx)=>{
            const length = await this.lengthAsync();
            if (index < 0) {
                index += length;
            }
            if (index < 0 || index >= length) {
                return undefined;
            }
            const val = await tx.get(serializeKey(this.prefix, index));
            return val ? this.encoder.unpack(val) : undefined;
        });
    }
    async lengthAsync() {
        return await this.length.getAsync() ?? 0;
    }
    async *entriesAsync() {
        // pin array length so that pushes don't affect iteration
        const length = await this.lengthAsync();
        if (length === 0) {
            return;
        }
        let tx = this.store.getCurrentWriteTx();
        const shouldClose = !tx;
        tx ??= this.store.getReadTx();
        try {
            for await (const [key, val] of tx.iterate(serializeKey(this.prefix, 0), undefined, false, length)){
                const deserializedKey = deserializeKey(this.prefix, key);
                // if pops happened while iterating we may have read too much. Terminate early
                if (deserializedKey === false) {
                    break;
                }
                yield [
                    deserializedKey,
                    this.encoder.unpack(val)
                ];
            }
        } finally{
            if (shouldClose) {
                tx.close();
            }
        }
    }
    async *valuesAsync() {
        for await (const [_, value] of this.entriesAsync()){
            yield value;
        }
    }
    [_computedKey]() {
        return this.valuesAsync();
    }
}
