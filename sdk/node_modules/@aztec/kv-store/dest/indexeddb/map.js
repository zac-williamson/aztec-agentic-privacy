import { hash } from 'ohash';
/**
 * A map backed by IndexedDB.
 */ export class IndexedDBAztecMap {
    name;
    container;
    #_db;
    #rootDB;
    constructor(rootDB, mapName){
        this.name = mapName;
        this.container = `map:${mapName}`;
        this.#rootDB = rootDB;
    }
    set db(db) {
        this.#_db = db;
    }
    get db() {
        return this.#_db ? this.#_db : this.#rootDB.transaction('data', 'readwrite').store;
    }
    async getAsync(key) {
        const data = await this.db.get(this.slot(key));
        return data ? this.restoreBuffers(data.value) : undefined;
    }
    async hasAsync(key) {
        const result = await this.getAsync(key) !== undefined;
        return result;
    }
    async sizeAsync() {
        const index = this.db.index('key');
        const rangeQuery = IDBKeyRange.bound([
            this.container
        ], [
            this.container + '\uffff'
        ], true, true);
        return await index.count(rangeQuery);
    }
    async set(key, val) {
        await this.db.put({
            value: val,
            hash: hash(val),
            container: this.container,
            key: this.normalizeKey(key),
            keyCount: 1,
            slot: this.slot(key)
        });
    }
    async setMany(entries) {
        for (const { key, value } of entries){
            await this.set(key, value);
        }
    }
    swap(_key, _fn) {
        throw new Error('Not implemented');
    }
    async setIfNotExists(key, val) {
        if (!await this.hasAsync(key)) {
            await this.set(key, val);
            return true;
        }
        return false;
    }
    async delete(key) {
        await this.db.delete(this.slot(key));
    }
    async *entriesAsync(range = {}) {
        const index = this.db.index('key');
        const startKey = range.start ? this.normalizeKey(range.start) : [];
        const endKey = range.end ? this.normalizeKey(range.end) : [
            '\uffff'
        ];
        const rangeQuery = IDBKeyRange.bound([
            this.container,
            startKey
        ], [
            this.container,
            endKey
        ], !!range.reverse, !range.reverse);
        let count = 0;
        for await (const cursor of index.iterate(rangeQuery, range.reverse ? 'prev' : 'next')){
            if (range.limit && count >= range.limit) {
                return;
            }
            yield [
                this.#denormalizeKey(cursor.value.key),
                this.restoreBuffers(cursor.value.value)
            ];
            count++;
        }
    }
    async *valuesAsync(range = {}) {
        for await (const [_, value] of this.entriesAsync(range)){
            yield value;
        }
    }
    async *keysAsync(range = {}) {
        for await (const [key, _] of this.entriesAsync(range)){
            yield key;
        }
    }
    /**
   * IndexedDB's structured clone downcasts Buffer (a Node.js subclass of Uint8Array) to plain Uint8Array.
   * This breaks .toString() behavior: Buffer.toString() returns UTF-8, Uint8Array.toString() returns
   * comma-separated decimal bytes. We restore Buffer identity on read so callers get consistent behavior.
   */ restoreBuffers(val) {
        if (val instanceof Uint8Array && !Buffer.isBuffer(val)) {
            return Buffer.from(val);
        }
        return val;
    }
    #denormalizeKey(key) {
        return key.length > 1 ? key : key[0];
    }
    normalizeKey(key) {
        return Array.isArray(key) ? key : [
            key
        ];
    }
    slot(key, index = 0) {
        return `map:${this.name}:slot:${this.normalizeKey(key)}:${index}`;
    }
}
