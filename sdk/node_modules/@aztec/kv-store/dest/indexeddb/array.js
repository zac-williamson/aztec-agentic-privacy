var _computedKey;
import { hash } from 'ohash';
_computedKey = Symbol.asyncIterator;
/**
 * A persistent array backed by IndexedDB.
 */ export class IndexedDBAztecArray {
    #_db;
    #rootDB;
    #container;
    #name;
    constructor(rootDB, name){
        this.#rootDB = rootDB;
        this.#name = name;
        this.#container = `array:${this.#name}`;
    }
    set db(db) {
        this.#_db = db;
    }
    get db() {
        return this.#_db ? this.#_db : this.#rootDB.transaction('data', 'readwrite').store;
    }
    async lengthAsync() {
        return await this.db.index('key').count(IDBKeyRange.bound([
            this.#container,
            [
                this.#name
            ]
        ], [
            this.#container,
            [
                this.#name
            ]
        ])) ?? 0;
    }
    async push(...vals) {
        let length = await this.lengthAsync();
        for (const val of vals){
            await this.db.put({
                value: val,
                hash: hash(val),
                container: this.#container,
                key: [
                    this.#name
                ],
                keyCount: length + 1,
                slot: this.#slot(length)
            });
            length += 1;
        }
        return length;
    }
    async pop() {
        const length = await this.lengthAsync();
        if (length === 0) {
            return undefined;
        }
        const slot = this.#slot(length - 1);
        const data = await this.db.get(slot);
        await this.db.delete(slot);
        return data?.value;
    }
    async atAsync(index) {
        const length = await this.lengthAsync();
        if (index < 0) {
            index = length + index;
        }
        const data = await this.db.get(this.#slot(index));
        return data?.value;
    }
    async setAt(index, val) {
        const length = await this.lengthAsync();
        if (index < 0) {
            index = length + index;
        }
        if (index < 0 || index >= length) {
            return Promise.resolve(false);
        }
        await this.db.put({
            value: val,
            hash: hash(val),
            container: this.#container,
            key: [
                this.#name
            ],
            keyCount: index + 1,
            slot: this.#slot(index)
        });
        return true;
    }
    async *entriesAsync() {
        const index = this.db.index('key');
        const rangeQuery = IDBKeyRange.bound([
            this.#container,
            [
                this.#name
            ]
        ], [
            this.#container,
            [
                this.#name
            ]
        ]);
        for await (const cursor of index.iterate(rangeQuery)){
            yield [
                cursor.value.keyCount - 1,
                cursor.value.value
            ];
        }
    }
    async *valuesAsync() {
        for await (const [_, value] of this.entriesAsync()){
            yield value;
        }
    }
    [_computedKey]() {
        return this.valuesAsync();
    }
    #slot(index) {
        return `array:${this.#name}:slot:${index}`;
    }
}
