import { toArray } from '@aztec/foundation/iterable';
import { expect } from 'chai';
import { isSyncStore } from './utils.js';
export function describeAztecSet(testName, getStore, forceAsync = false) {
    describe(testName, ()=>{
        let store;
        let set;
        beforeEach(async ()=>{
            store = await getStore();
            set = store.openSet('test');
        });
        afterEach(async ()=>{
            await store.delete();
        });
        async function has(key) {
            return isSyncStore(store) && !forceAsync ? set.has(key) : await set.hasAsync(key);
        }
        async function entries(range) {
            return isSyncStore(store) && !forceAsync ? await toArray(set.entries(range)) : await toArray(set.entriesAsync(range));
        }
        it('should be able to set and get values', async ()=>{
            await set.add('foo');
            await set.add('baz');
            expect(await has('foo')).to.equal(true);
            expect(await has('baz')).to.equal(true);
            expect(await has('bar')).to.equal(false);
        });
        it('should be able to delete values', async ()=>{
            await set.add('foo');
            await set.add('baz');
            await set.delete('foo');
            expect(await has('foo')).to.equal(false);
            expect(await has('baz')).to.equal(true);
        });
        it('should be able to iterate over entries', async ()=>{
            await set.add('baz');
            await set.add('foo');
            expect(await entries()).to.deep.equal([
                'baz',
                'foo'
            ]);
        });
        it('supports range queries', async ()=>{
            await set.add('a');
            await set.add('b');
            await set.add('c');
            await set.add('d');
            expect(await entries({
                start: 'b',
                end: 'c'
            })).to.deep.equal([
                'b'
            ]);
            expect(await entries({
                start: 'b'
            })).to.deep.equal([
                'b',
                'c',
                'd'
            ]);
            expect(await entries({
                end: 'c'
            })).to.deep.equal([
                'a',
                'b'
            ]);
            expect(await entries({
                start: 'b',
                end: 'c',
                reverse: true
            })).to.deep.equal([
                'c'
            ]);
            expect(await entries({
                start: 'b',
                limit: 1
            })).to.deep.equal([
                'b'
            ]);
            expect(await entries({
                start: 'b',
                reverse: true
            })).to.deep.equal([
                'd',
                'c'
            ]);
            expect(await entries({
                end: 'b',
                reverse: true
            })).to.deep.equal([
                'b',
                'a'
            ]);
        });
    });
}
