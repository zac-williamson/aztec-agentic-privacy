import { L2TipsStoreBase } from '@aztec/stdlib/block';
import { PublishedCheckpoint } from '@aztec/stdlib/checkpoint';
/**
 * Persistent implementation of L2 tips store backed by a KV store.
 * Used by nodes that need to persist chain state across restarts.
 */ export class L2TipsKVStore extends L2TipsStoreBase {
    store;
    l2TipsStore;
    l2BlockHashesStore;
    l2BlockNumberToCheckpointNumberStore;
    l2CheckpointStore;
    constructor(store, namespace){
        super(), this.store = store;
        this.l2TipsStore = store.openMap([
            namespace,
            'l2_tips'
        ].join('_'));
        this.l2BlockHashesStore = store.openMap([
            namespace,
            'l2_block_hashes'
        ].join('_'));
        this.l2BlockNumberToCheckpointNumberStore = store.openMap([
            namespace,
            'l2_block_number_to_checkpoint_number'
        ].join('_'));
        this.l2CheckpointStore = store.openMap([
            namespace,
            'l2_checkpoint_store'
        ].join('_'));
    }
    getTip(tag) {
        return this.l2TipsStore.getAsync(tag);
    }
    setTip(tag, blockNumber) {
        return this.l2TipsStore.set(tag, blockNumber);
    }
    getStoredBlockHash(blockNumber) {
        return this.l2BlockHashesStore.getAsync(blockNumber);
    }
    setBlockHash(blockNumber, hash) {
        return this.l2BlockHashesStore.set(blockNumber, hash);
    }
    async deleteBlockHashesBefore(blockNumber) {
        for await (const key of this.l2BlockHashesStore.keysAsync({
            end: blockNumber
        })){
            await this.l2BlockHashesStore.delete(key);
        }
    }
    getCheckpointNumberForBlock(blockNumber) {
        return this.l2BlockNumberToCheckpointNumberStore.getAsync(blockNumber);
    }
    setCheckpointNumberForBlock(blockNumber, checkpointNumber) {
        return this.l2BlockNumberToCheckpointNumberStore.set(blockNumber, checkpointNumber);
    }
    async deleteBlockToCheckpointBefore(blockNumber) {
        for await (const key of this.l2BlockNumberToCheckpointNumberStore.keysAsync({
            end: blockNumber
        })){
            await this.l2BlockNumberToCheckpointNumberStore.delete(key);
        }
    }
    async getCheckpoint(checkpointNumber) {
        const buffer = await this.l2CheckpointStore.getAsync(checkpointNumber);
        if (!buffer) {
            return undefined;
        }
        return PublishedCheckpoint.fromBuffer(buffer);
    }
    saveCheckpointData(checkpoint) {
        return this.l2CheckpointStore.set(checkpoint.checkpoint.number, checkpoint.toBuffer());
    }
    async deleteCheckpointsBefore(checkpointNumber) {
        for await (const key of this.l2CheckpointStore.keysAsync({
            end: checkpointNumber
        })){
            await this.l2CheckpointStore.delete(key);
        }
    }
    runInTransaction(fn) {
        return this.store.transactionAsync(fn);
    }
}
