import type { PrivateEventFilter } from '@aztec/aztec.js/wallet';
import { Fr } from '@aztec/foundation/curves/bn254';
import { type Logger } from '@aztec/foundation/log';
import type { AztecAsyncKVStore } from '@aztec/kv-store';
import { type ProtocolContractsProvider } from '@aztec/protocol-contracts';
import type { CircuitSimulator } from '@aztec/simulator/client';
import { type ContractArtifact, EventSelector, FunctionCall } from '@aztec/stdlib/abi';
import type { AuthWitness } from '@aztec/stdlib/auth-witness';
import type { AztecAddress } from '@aztec/stdlib/aztec-address';
import { CompleteAddress, type ContractInstanceWithAddress, type PartialAddress } from '@aztec/stdlib/contract';
import type { AztecNode, PrivateKernelProver } from '@aztec/stdlib/interfaces/client';
import { BlockHeader, type InTx, SimulationOverrides, TxExecutionRequest, TxProfileResult, TxProvingResult, TxSimulationResult, UtilitySimulationResult } from '@aztec/stdlib/tx';
import type { AccessScopes } from './access_scopes.js';
import type { PXEConfig } from './config/index.js';
import { PXEDebugUtils } from './debug/pxe_debug_utils.js';
export type PackedPrivateEvent = InTx & {
    packedEvent: Fr[];
    eventSelector: EventSelector;
};
/** Options for PXE.profileTx. */
export type ProfileTxOpts = {
    /** The profiling mode to use. */
    profileMode: 'full' | 'execution-steps' | 'gates';
    /** If true, proof generation is skipped during profiling. Defaults to true. */
    skipProofGeneration?: boolean;
    /** Addresses whose private state and keys are accessible during private execution. */
    scopes: AccessScopes;
};
/** Options for PXE.simulateTx. */
export type SimulateTxOpts = {
    /** Whether to simulate the public part of the transaction. */
    simulatePublic: boolean;
    /** If false, this function throws if the transaction is unable to be included in a block at the current state. */
    skipTxValidation?: boolean;
    /** If false, fees are enforced. */
    skipFeeEnforcement?: boolean;
    /** State overrides for the simulation, such as contract instances and artifacts. */
    overrides?: SimulationOverrides;
    /** Addresses whose private state and keys are accessible during private execution */
    scopes: AccessScopes;
};
/** Options for PXE.simulateUtility. */
export type SimulateUtilityOpts = {
    /** The authentication witnesses required for the function call. */
    authwits?: AuthWitness[];
    /** The accounts whose notes we can access in this call */
    scopes: AccessScopes;
};
/** Args for PXE.create. */
export type PXECreateArgs = {
    /** The Aztec node to connect to. */
    node: AztecNode;
    /** The key-value store for persisting PXE state. */
    store: AztecAsyncKVStore;
    /** The prover for generating private kernel proofs. */
    proofCreator: PrivateKernelProver;
    /** The circuit simulator for executing ACIR circuits. */
    simulator: CircuitSimulator;
    /** Provider for protocol contract artifacts and instances. */
    protocolContractsProvider: ProtocolContractsProvider;
    /** PXE configuration options. */
    config: PXEConfig;
    /** Optional logger instance or string suffix for the logger name. */
    loggerOrSuffix?: string | Logger;
};
/**
 * Private eXecution Environment (PXE) is a library used by wallets to simulate private phase of transactions and to
 * manage private state of users.
 */
export declare class PXE {
    #private;
    private node;
    private blockStateSynchronizer;
    private keyStore;
    private contractStore;
    private noteStore;
    private capsuleStore;
    private anchorBlockStore;
    private senderTaggingStore;
    private senderAddressBookStore;
    private recipientTaggingStore;
    private addressStore;
    private privateEventStore;
    private contractSyncService;
    private simulator;
    private proverEnabled;
    private proofCreator;
    private protocolContractsProvider;
    private log;
    private jobQueue;
    private jobCoordinator;
    debug: PXEDebugUtils;
    private constructor();
    /**
     * Creates an instance of a PXE by instantiating all the necessary data providers and services.
     * Also triggers the registration of the protocol contracts and makes sure the provided node
     * can be contacted.
     *
     * @returns A promise that resolves PXE is ready to be used.
     */
    static create({ node, store, proofCreator, simulator, protocolContractsProvider, config, loggerOrSuffix }: PXECreateArgs): Promise<PXE>;
    /**
     * Returns the block header up to which the PXE has synced.
     * @returns The synced block header
     */
    getSyncedBlockHeader(): Promise<BlockHeader>;
    /**
     * Returns the contract instance for a given address, if it's registered in the PXE.
     * @param address - The contract address.
     * @returns The contract instance if found, undefined otherwise.
     */
    getContractInstance(address: AztecAddress): Promise<ContractInstanceWithAddress | undefined>;
    /**
     * Returns the contract artifact for a given contract class id, if it's registered in the PXE.
     * @param id - Identifier of the contract class.
     * @returns The contract artifact if found, undefined otherwise.
     */
    getContractArtifact(id: Fr): Promise<ContractArtifact | undefined>;
    /**
     * Registers a user account in PXE given its master encryption private key.
     * Once a new account is registered, the PXE will trial-decrypt all published notes on
     * the chain and store those that correspond to the registered account. Will do nothing if the
     * account is already registered.
     *
     * @param secretKey - Secret key of the corresponding user master public key.
     * @param partialAddress - The partial address of the account contract corresponding to the account being registered.
     * @returns The complete address of the account.
     */
    registerAccount(secretKey: Fr, partialAddress: PartialAddress): Promise<CompleteAddress>;
    /**
     * Registers a sender in this PXE.
     *
     * After registering a new sender, the PXE will sync private logs that are tagged with this sender's address.
     * Will do nothing if the address is already registered.
     *
     * @param sender - Address of the sender to register.
     * @returns The address of the sender.
     * TODO: It's strange that we return the address here and I (benesjan) think we should drop the return value.
     */
    registerSender(sender: AztecAddress): Promise<AztecAddress>;
    /**
     * Retrieves senders registered in this PXE.
     * @returns Senders registered in this PXE.
     */
    getSenders(): Promise<AztecAddress[]>;
    /**
     * Removes a sender registered in this PXE.
     * @param sender - The address of the sender to remove.
     */
    removeSender(sender: AztecAddress): Promise<void>;
    /**
     * Retrieves the user accounts registered on this PXE.
     * @returns An array of the accounts registered on this PXE.
     */
    getRegisteredAccounts(): Promise<CompleteAddress[]>;
    /**
     * Registers a contract class in the PXE without registering any associated contract instance with it.
     *
     * @param artifact - The build artifact for the contract class.
     */
    registerContractClass(artifact: ContractArtifact): Promise<void>;
    /**
     * Adds deployed contracts to the PXE. Deployed contract information is used to access the
     * contract code when simulating local transactions. This is automatically called by aztec.js when
     * deploying a contract. Dapps that wish to interact with contracts already deployed should register
     * these contracts in their users' PXE through this method.
     *
     * @param contract - A contract instance to register, with an optional artifact which can be omitted if the contract class has already been registered.
     */
    registerContract(contract: {
        instance: ContractInstanceWithAddress;
        artifact?: ContractArtifact;
    }): Promise<void>;
    /**
     * Updates a deployed contract in the PXE. This is used to update the contract artifact when
     * an update has happened, so the new code can be used in the simulation of local transactions.
     * This is called by aztec.js when instantiating a contract in a given address with a mismatching artifact.
     * @param contractAddress - The address of the contract to update.
     * @param artifact - The updated artifact for the contract.
     * @throws If the artifact's contract class is not found in the PXE or if the contract class is different from
     * the current one (current one from the point of view of the node to which the PXE is connected).
     */
    updateContract(contractAddress: AztecAddress, artifact: ContractArtifact): Promise<void>;
    /**
     * Retrieves the addresses of contracts added to this PXE.
     * @returns An array of contracts addresses registered on this PXE.
     */
    getContracts(): Promise<AztecAddress[]>;
    /**
     * Proves the private portion of a simulated transaction, ready to send to the network
     * (where validators prove the public portion).
     *
     * @param txRequest - An authenticated tx request ready for proving
     * @param scopes - Addresses whose private state and keys are accessible during private execution.
     * @returns A result containing the proof and public inputs of the tail circuit.
     * @throws If contract code not found, or public simulation reverts.
     * Also throws if simulatePublic is true and public simulation reverts.
     */
    proveTx(txRequest: TxExecutionRequest, scopes: AztecAddress[]): Promise<TxProvingResult>;
    /**
     * Profiles a transaction, reporting gate counts (unless disabled) and returns an execution trace.
     * @param txRequest - An authenticated tx request ready for simulation.
     * @returns A trace of the program execution with gate counts.
     * @throws If the code for the functions executed in this transaction have not been made available via `addContracts`.
     */
    profileTx(txRequest: TxExecutionRequest, { profileMode, skipProofGeneration, scopes }: ProfileTxOpts): Promise<TxProfileResult>;
    /**
     * Simulates a transaction based on the provided preauthenticated execution request.
     * This will run a local simulation of private execution (and optionally of public as well), run the
     * kernel circuits to ensure adherence to protocol rules (without generating a proof), and return the
     * simulation results .
     *
     *
     * Note that this is used with `ContractFunctionInteraction::simulateTx` to bypass certain checks.
     * In that case, the transaction returned is only potentially ready to be sent to the network for execution.
     *
     *
     * @param txRequest - An authenticated tx request ready for simulation.
     * @returns A simulated transaction result object that includes public and private return values.
     * @throws If the code for the functions executed in this transaction have not been made available via `addContracts`.
     * Also throws if simulatePublic is true and public simulation reverts.
     *
     * TODO(#7456) Prevent msgSender being defined here for the first call
     */
    simulateTx(txRequest: TxExecutionRequest, { simulatePublic, skipTxValidation, skipFeeEnforcement, overrides, scopes }: SimulateTxOpts): Promise<TxSimulationResult>;
    /**
     * Simulates the execution of a contract utility function.
     * @param call - The function call containing the function details, arguments, and target contract address.
     */
    simulateUtility(call: FunctionCall, { authwits, scopes }?: SimulateUtilityOpts): Promise<UtilitySimulationResult>;
    /**
     * Returns the private events given search parameters.
     * @param eventSelector - Event selector to search for.
     * @param filter
     *  contractAddress - The address of the contract to get events from. Required.
     *  scopes - One or more event scope addresses to filter by. Required.
     *  fromBlock - The block number to search from (inclusive). Optional. If provided, it must be >= 0.
     *    Defaults to 0.
     *    If toBlock is defined but fromBlock is not, fromBlock defaults to toBlock - 1.
     *  toBlock - The block number to search up to (exclusive). Optional. If provided, it must be > 0.
     *    Defaults to the latest known block to PXE + 1.
     * @returns - The packed events with block and tx metadata.
     */
    getPrivateEvents(eventSelector: EventSelector, filter: PrivateEventFilter): Promise<PackedPrivateEvent[]>;
    /**
     * Stops the PXE's job queue.
     */
    stop(): Promise<void>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHhlLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvcHhlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFakUsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3BELE9BQU8sRUFBRSxLQUFLLE1BQU0sRUFBcUMsTUFBTSx1QkFBdUIsQ0FBQztBQUl2RixPQUFPLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXpELE9BQU8sRUFBRSxLQUFLLHlCQUF5QixFQUF5QixNQUFNLDJCQUEyQixDQUFDO0FBQ2xHLE9BQU8sS0FBSyxFQUFFLGdCQUFnQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDaEUsT0FBTyxFQUNMLEtBQUssZ0JBQWdCLEVBQ3JCLGFBQWEsRUFDYixZQUFZLEVBR2IsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUM5RCxPQUFPLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUNoRSxPQUFPLEVBQ0wsZUFBZSxFQUNmLEtBQUssMkJBQTJCLEVBQ2hDLEtBQUssY0FBYyxFQUdwQixNQUFNLHdCQUF3QixDQUFDO0FBRWhDLE9BQU8sS0FBSyxFQUFFLFNBQVMsRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBTXRGLE9BQU8sRUFDTCxXQUFXLEVBRVgsS0FBSyxJQUFJLEVBS1QsbUJBQW1CLEVBR25CLGtCQUFrQixFQUNsQixlQUFlLEVBQ2YsZUFBZSxFQUNmLGtCQUFrQixFQUNsQix1QkFBdUIsRUFDeEIsTUFBTSxrQkFBa0IsQ0FBQztBQUkxQixPQUFPLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUV2RCxPQUFPLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQVNuRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFtQjNELE1BQU0sTUFBTSxrQkFBa0IsR0FBRyxJQUFJLEdBQUc7SUFDdEMsV0FBVyxFQUFFLEVBQUUsRUFBRSxDQUFDO0lBQ2xCLGFBQWEsRUFBRSxhQUFhLENBQUM7Q0FDOUIsQ0FBQztBQUVGLGlDQUFpQztBQUNqQyxNQUFNLE1BQU0sYUFBYSxHQUFHO0lBQzFCLGlDQUFpQztJQUNqQyxXQUFXLEVBQUUsTUFBTSxHQUFHLGlCQUFpQixHQUFHLE9BQU8sQ0FBQztJQUNsRCwrRUFBK0U7SUFDL0UsbUJBQW1CLENBQUMsRUFBRSxPQUFPLENBQUM7SUFDOUIsc0ZBQXNGO0lBQ3RGLE1BQU0sRUFBRSxZQUFZLENBQUM7Q0FDdEIsQ0FBQztBQUVGLGtDQUFrQztBQUNsQyxNQUFNLE1BQU0sY0FBYyxHQUFHO0lBQzNCLDhEQUE4RDtJQUM5RCxjQUFjLEVBQUUsT0FBTyxDQUFDO0lBQ3hCLGtIQUFrSDtJQUNsSCxnQkFBZ0IsQ0FBQyxFQUFFLE9BQU8sQ0FBQztJQUMzQixtQ0FBbUM7SUFDbkMsa0JBQWtCLENBQUMsRUFBRSxPQUFPLENBQUM7SUFDN0Isb0ZBQW9GO0lBQ3BGLFNBQVMsQ0FBQyxFQUFFLG1CQUFtQixDQUFDO0lBQ2hDLHFGQUFxRjtJQUNyRixNQUFNLEVBQUUsWUFBWSxDQUFDO0NBQ3RCLENBQUM7QUFFRix1Q0FBdUM7QUFDdkMsTUFBTSxNQUFNLG1CQUFtQixHQUFHO0lBQ2hDLG1FQUFtRTtJQUNuRSxRQUFRLENBQUMsRUFBRSxXQUFXLEVBQUUsQ0FBQztJQUN6QiwwREFBMEQ7SUFDMUQsTUFBTSxFQUFFLFlBQVksQ0FBQztDQUN0QixDQUFDO0FBRUYsMkJBQTJCO0FBQzNCLE1BQU0sTUFBTSxhQUFhLEdBQUc7SUFDMUIsb0NBQW9DO0lBQ3BDLElBQUksRUFBRSxTQUFTLENBQUM7SUFDaEIsb0RBQW9EO0lBQ3BELEtBQUssRUFBRSxpQkFBaUIsQ0FBQztJQUN6Qix1REFBdUQ7SUFDdkQsWUFBWSxFQUFFLG1CQUFtQixDQUFDO0lBQ2xDLHlEQUF5RDtJQUN6RCxTQUFTLEVBQUUsZ0JBQWdCLENBQUM7SUFDNUIsOERBQThEO0lBQzlELHlCQUF5QixFQUFFLHlCQUF5QixDQUFDO0lBQ3JELGlDQUFpQztJQUNqQyxNQUFNLEVBQUUsU0FBUyxDQUFDO0lBQ2xCLHFFQUFxRTtJQUNyRSxjQUFjLENBQUMsRUFBRSxNQUFNLEdBQUcsTUFBTSxDQUFDO0NBQ2xDLENBQUM7QUFFRjs7O0dBR0c7QUFDSCxxQkFBYSxHQUFHOztJQUVaLE9BQU8sQ0FBQyxJQUFJO0lBQ1osT0FBTyxDQUFDLHNCQUFzQjtJQUM5QixPQUFPLENBQUMsUUFBUTtJQUNoQixPQUFPLENBQUMsYUFBYTtJQUNyQixPQUFPLENBQUMsU0FBUztJQUNqQixPQUFPLENBQUMsWUFBWTtJQUNwQixPQUFPLENBQUMsZ0JBQWdCO0lBQ3hCLE9BQU8sQ0FBQyxrQkFBa0I7SUFDMUIsT0FBTyxDQUFDLHNCQUFzQjtJQUM5QixPQUFPLENBQUMscUJBQXFCO0lBQzdCLE9BQU8sQ0FBQyxZQUFZO0lBQ3BCLE9BQU8sQ0FBQyxpQkFBaUI7SUFDekIsT0FBTyxDQUFDLG1CQUFtQjtJQUMzQixPQUFPLENBQUMsU0FBUztJQUNqQixPQUFPLENBQUMsYUFBYTtJQUNyQixPQUFPLENBQUMsWUFBWTtJQUNwQixPQUFPLENBQUMseUJBQXlCO0lBQ2pDLE9BQU8sQ0FBQyxHQUFHO0lBQ1gsT0FBTyxDQUFDLFFBQVE7SUFDaEIsT0FBTyxDQUFDLGNBQWM7SUFDZixLQUFLLEVBQUUsYUFBYTtJQXJCN0IsT0FBTyxlQXNCSDtJQUVKOzs7Ozs7T0FNRztJQUNILE9BQW9CLE1BQU0sQ0FBQyxFQUN6QixJQUFJLEVBQ0osS0FBSyxFQUNMLFlBQVksRUFDWixTQUFTLEVBQ1QseUJBQXlCLEVBQ3pCLE1BQU0sRUFDTixjQUFjLEVBQ2YsRUFBRSxhQUFhLGdCQTJGZjtJQWdORDs7O09BR0c7SUFDSSxvQkFBb0IsSUFBSSxPQUFPLENBQUMsV0FBVyxDQUFDLENBRWxEO0lBRUQ7Ozs7T0FJRztJQUNJLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxZQUFZLEdBQUcsT0FBTyxDQUFDLDJCQUEyQixHQUFHLFNBQVMsQ0FBQyxDQUVsRztJQUVEOzs7O09BSUc7SUFDVSxtQkFBbUIsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxTQUFTLENBQUMsQ0FFOUU7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDVSxlQUFlLENBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRSxjQUFjLEVBQUUsY0FBYyxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FhcEc7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDVSxjQUFjLENBQUMsTUFBTSxFQUFFLFlBQVksR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBZ0J2RTtJQUVEOzs7T0FHRztJQUNJLFVBQVUsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FFM0M7SUFFRDs7O09BR0c7SUFDVSxZQUFZLENBQUMsTUFBTSxFQUFFLFlBQVksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBUTdEO0lBRUQ7OztPQUdHO0lBQ1UscUJBQXFCLElBQUksT0FBTyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBUS9EO0lBRUQ7Ozs7T0FJRztJQUNVLHFCQUFxQixDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBSTVFO0lBRUQ7Ozs7Ozs7T0FPRztJQUNVLGdCQUFnQixDQUFDLFFBQVEsRUFBRTtRQUFFLFFBQVEsRUFBRSwyQkFBMkIsQ0FBQztRQUFDLFFBQVEsQ0FBQyxFQUFFLGdCQUFnQixDQUFBO0tBQUUsaUJBcUM3RztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksY0FBYyxDQUFDLGVBQWUsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0E2QjlGO0lBRUQ7OztPQUdHO0lBQ0ksWUFBWSxJQUFJLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUU3QztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLE9BQU8sQ0FBQyxTQUFTLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0F1RTlGO0lBRUQ7Ozs7O09BS0c7SUFDSSxTQUFTLENBQ2QsU0FBUyxFQUFFLGtCQUFrQixFQUM3QixFQUFFLFdBQVcsRUFBRSxtQkFBMEIsRUFBRSxNQUFNLEVBQUUsRUFBRSxhQUFhLEdBQ2pFLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FrRTFCO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaUJHO0lBQ0ksVUFBVSxDQUNmLFNBQVMsRUFBRSxrQkFBa0IsRUFDN0IsRUFBRSxjQUFjLEVBQUUsZ0JBQXdCLEVBQUUsa0JBQTBCLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxFQUFFLGNBQWMsR0FDMUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBZ0k3QjtJQUVEOzs7T0FHRztJQUNJLGVBQWUsQ0FDcEIsSUFBSSxFQUFFLFlBQVksRUFDbEIsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLEdBQUUsbUJBQThDLEdBQ25FLE9BQU8sQ0FBQyx1QkFBdUIsQ0FBQyxDQXdEbEM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDVSxnQkFBZ0IsQ0FDM0IsYUFBYSxFQUFFLGFBQWEsRUFDNUIsTUFBTSxFQUFFLGtCQUFrQixHQUN6QixPQUFPLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxDQThCL0I7SUFFRDs7T0FFRztJQUNJLElBQUksSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLENBRTNCO0NBQ0YifQ==