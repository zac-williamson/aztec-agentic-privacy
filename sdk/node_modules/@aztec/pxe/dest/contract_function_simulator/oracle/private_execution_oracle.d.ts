import { Fr } from '@aztec/foundation/curves/bn254';
import { type CircuitSimulator } from '@aztec/simulator/client';
import { type FunctionAbi, type FunctionCall, FunctionSelector, type NoteSelector } from '@aztec/stdlib/abi';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { PrivateContextInputs } from '@aztec/stdlib/kernel';
import { type ContractClassLog, type PreTag } from '@aztec/stdlib/logs';
import { Tag } from '@aztec/stdlib/logs';
import { type NoteStatus } from '@aztec/stdlib/note';
import { CallContext, CountedContractClassLog, NoteAndSlot, PrivateCallExecutionResult, type TxContext } from '@aztec/stdlib/tx';
import type { AccessScopes } from '../../access_scopes.js';
import type { ContractSyncService } from '../../contract_sync/contract_sync_service.js';
import type { SenderTaggingStore } from '../../storage/tagging_store/sender_tagging_store.js';
import type { ExecutionNoteCache } from '../execution_note_cache.js';
import { ExecutionTaggingIndexCache } from '../execution_tagging_index_cache.js';
import type { HashedValuesCache } from '../hashed_values_cache.js';
import type { IPrivateExecutionOracle, NoteData } from './interfaces.js';
import { UtilityExecutionOracle, type UtilityExecutionOracleArgs } from './utility_execution_oracle.js';
/** Args for PrivateExecutionOracle constructor. */
export type PrivateExecutionOracleArgs = Omit<UtilityExecutionOracleArgs, 'contractAddress'> & {
    argsHash: Fr;
    txContext: TxContext;
    callContext: CallContext;
    /** Needed to trigger contract synchronization before nested calls */
    utilityExecutor: (call: FunctionCall, scopes: AccessScopes) => Promise<void>;
    executionCache: HashedValuesCache;
    noteCache: ExecutionNoteCache;
    taggingIndexCache: ExecutionTaggingIndexCache;
    senderTaggingStore: SenderTaggingStore;
    contractSyncService: ContractSyncService;
    totalPublicCalldataCount?: number;
    sideEffectCounter?: number;
    senderForTags?: AztecAddress;
    simulator?: CircuitSimulator;
};
/**
 * The execution oracle for the private part of a transaction.
 */
export declare class PrivateExecutionOracle extends UtilityExecutionOracle implements IPrivateExecutionOracle {
    #private;
    isPrivate: true;
    /**
     * New notes created during this execution.
     * It's possible that a note in this list has been nullified (in the same or other executions) and doesn't exist in
     * the ExecutionNoteCache and the final proof data. But we still include those notes in the execution result because
     * their commitments are still in the public inputs of this execution.
     * This information is only for references (currently used for tests), and is not used for any sort of constrains.
     * Users can also use this to get a clearer idea of what's happened during a simulation.
     */
    private newNotes;
    private noteHashNullifierCounterMap;
    private contractClassLogs;
    private offchainEffects;
    private nestedExecutionResults;
    private readonly argsHash;
    private readonly txContext;
    private readonly callContext;
    private readonly utilityExecutor;
    private readonly executionCache;
    private readonly noteCache;
    private readonly taggingIndexCache;
    private readonly senderTaggingStore;
    private readonly contractSyncService;
    private totalPublicCalldataCount;
    protected sideEffectCounter: number;
    private senderForTags?;
    private readonly simulator?;
    constructor(args: PrivateExecutionOracleArgs);
    getPrivateContextInputs(): PrivateContextInputs;
    /**
     * Writes the function inputs to the initial witness.
     * @param abi - The function ABI.
     * @returns The initial witness.
     */
    getInitialWitness(abi: FunctionAbi): Map<number, string>;
    /**
     * Get the data for the newly created notes.
     */
    getNewNotes(): NoteAndSlot[];
    getNoteHashNullifierCounterMap(): Map<number, number>;
    /**
     * Return the contract class logs emitted during this execution.
     */
    getContractClassLogs(): CountedContractClassLog[];
    /**
     * Return the offchain effects emitted during this execution.
     */
    getOffchainEffects(): {
        data: Fr[];
    }[];
    /**
     * Returns the pre-tags that were used in this execution (and that need to be stored in the db).
     */
    getUsedPreTags(): PreTag[];
    /**
     * Return the nested execution results during this execution.
     */
    getNestedExecutionResults(): PrivateCallExecutionResult[];
    /**
     * Get the sender for tags.
     *
     * This unconstrained value is used as the sender when computing an unconstrained shared secret
     * for a tag in order to emit a log. Constrained tagging should not use this as there is no
     * guarantee that the recipient knows about the sender, and hence about the shared secret.
     *
     * The value persists through nested calls, meaning all calls down the stack will use the same
     * 'senderForTags' value (unless it is replaced).
     */
    privateGetSenderForTags(): Promise<AztecAddress | undefined>;
    /**
     * Set the sender for tags.
     *
     * This unconstrained value is used as the sender when computing an unconstrained shared secret
     * for a tag in order to emit a log. Constrained tagging should not use this as there is no
     * guarantee that the recipient knows about the sender, and hence about the shared secret.
     *
     * Account contracts typically set this value before calling other contracts. The value persists
     * through nested calls, meaning all calls down the stack will use the same 'senderForTags'
     * value (unless it is replaced by another call to this setter).
     */
    privateSetSenderForTags(senderForTags: AztecAddress): Promise<void>;
    /**
     * Returns the next app tag for a given sender and recipient pair.
     * @param sender - The address sending the log
     * @param recipient - The address receiving the log
     * @returns An app tag to be used in a log.
     */
    privateGetNextAppTagAsSender(sender: AztecAddress, recipient: AztecAddress): Promise<Tag>;
    /**
     * Store values in the execution cache.
     * @param values - Values to store.
     * @returns The hash of the values.
     */
    privateStoreInExecutionCache(values: Fr[], hash: Fr): void;
    /**
     * Gets values from the execution cache.
     * @param hash - Hash of the values.
     * @returns The values.
     */
    privateLoadFromExecutionCache(hash: Fr): Promise<Fr[]>;
    utilityCheckNullifierExists(innerNullifier: Fr): Promise<boolean>;
    /**
     * Gets some notes for a storage slot.
     *
     * @remarks
     * Check for pending notes with matching slot.
     * Real notes coming from DB will have a leafIndex which
     * represents their index in the note hash tree.
     *
     * @param owner - The owner of the notes. If undefined, returns notes for all owners.
     * @param storageSlot - The storage slot.
     * @param numSelects - The number of valid selects in selectBy and selectValues.
     * @param selectBy - An array of indices of the fields to selects.
     * @param selectValues - The values to match.
     * @param selectComparators - The comparators to match by.
     * @param sortBy - An array of indices of the fields to sort.
     * @param sortOrder - The order of the corresponding index in sortBy. (1: DESC, 2: ASC, 0: Do nothing)
     * @param limit - The number of notes to retrieve per query.
     * @param offset - The starting index for pagination.
     * @param status - The status of notes to fetch.
     * @returns Array of note data.
     */
    utilityGetNotes(owner: AztecAddress | undefined, storageSlot: Fr, numSelects: number, selectByIndexes: number[], selectByOffsets: number[], selectByLengths: number[], selectValues: Fr[], selectComparators: number[], sortByIndexes: number[], sortByOffsets: number[], sortByLengths: number[], sortOrder: number[], limit: number, offset: number, status: NoteStatus): Promise<NoteData[]>;
    /**
     * Keep track of the new note created during execution.
     * It can be used in subsequent calls (or transactions when chaining txs is possible).
     * @param owner - The owner of the note.
     * @param storageSlot - The storage slot.
     * @param randomness - The randomness injected into the note.
     * @param noteTypeId - The type ID of the note.
     * @param noteItems - The items to be included in a Note.
     * @param noteHash - A hash of the new note.
     * @returns
     */
    privateNotifyCreatedNote(owner: AztecAddress, storageSlot: Fr, randomness: Fr, noteTypeId: NoteSelector, noteItems: Fr[], noteHash: Fr, counter: number): void;
    /**
     * Adding a siloed nullifier into the current set of all pending nullifiers created
     * within the current transaction/execution.
     * @param innerNullifier - The pending nullifier to add in the list (not yet siloed by contract address).
     * @param noteHash - A hash of the new note.
     */
    privateNotifyNullifiedNote(innerNullifier: Fr, noteHash: Fr, counter: number): Promise<void>;
    /**
     * Adding a siloed nullifier into the current set of all pending nullifiers created
     * within the current transaction/execution.
     * @param innerNullifier - The pending nullifier to add in the list (not yet siloed by contract address).
     * @param noteHash - A hash of the new note.
     */
    privateNotifyCreatedNullifier(innerNullifier: Fr): Promise<void>;
    /**
     * Check if a nullifier has been emitted in the same transaction, i.e. if privateNotifyCreatedNullifier has been
     * called for this inner nullifier from the contract with the specified address.
     * @param innerNullifier - The inner nullifier to check.
     * @param contractAddress - Address of the contract that emitted the nullifier.
     * @returns A boolean indicating whether the nullifier is pending or not.
     */
    privateIsNullifierPending(innerNullifier: Fr, contractAddress: AztecAddress): Promise<boolean>;
    /**
     * Emit a contract class log.
     * This fn exists because we only carry a poseidon hash through the kernels, and need to
     * keep the preimage in ts for later.
     * @param log - The contract class log to be emitted.
     * @param counter - The contract class log's counter.
     */
    privateNotifyCreatedContractClassLog(log: ContractClassLog, counter: number): void;
    /**
     * Calls a private function as a nested execution.
     * @param targetContractAddress - The address of the contract to call.
     * @param functionSelector - The function selector of the function to call.
     * @param argsHash - The arguments hash to pass to the function.
     * @param sideEffectCounter - The side effect counter at the start of the call.
     * @param isStaticCall - Whether the call is a static call.
     * @returns The execution result.
     */
    privateCallPrivateFunction(targetContractAddress: AztecAddress, functionSelector: FunctionSelector, argsHash: Fr, sideEffectCounter: number, isStaticCall: boolean): Promise<{
        endSideEffectCounter: Fr;
        returnsHash: Fr;
    }>;
    /**
     * Verify relevant information when a public function is enqueued.
     * @param targetContractAddress - The address of the contract to call.
     * @param calldataHash - The hash of the function selector and arguments.
     * @param sideEffectCounter - The side effect counter at the start of the call.
     * @param isStaticCall - Whether the call is a static call.
     */
    privateNotifyEnqueuedPublicFunctionCall(_targetContractAddress: AztecAddress, calldataHash: Fr, _sideEffectCounter: number, _isStaticCall: boolean): Promise<void>;
    /**
     * Verify relevant information when a public teardown function is set.
     * @param targetContractAddress - The address of the contract to call.
     * @param argsHash - The arguments hash to pass to the function.
     * @param sideEffectCounter - The side effect counter at the start of the call.
     * @param isStaticCall - Whether the call is a static call.
     */
    privateNotifySetPublicTeardownFunctionCall(_targetContractAddress: AztecAddress, calldataHash: Fr, _sideEffectCounter: number, _isStaticCall: boolean): Promise<void>;
    privateNotifySetMinRevertibleSideEffectCounter(minRevertibleSideEffectCounter: number): Promise<void>;
    privateIsSideEffectCounterRevertible(sideEffectCounter: number): Promise<boolean>;
    private deriveCallContext;
    getDebugFunctionName(): Promise<string>;
    utilityEmitOffchainEffect(data: Fr[]): Promise<void>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJpdmF0ZV9leGVjdXRpb25fb3JhY2xlLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udHJhY3RfZnVuY3Rpb25fc2ltdWxhdG9yL29yYWNsZS9wcml2YXRlX2V4ZWN1dGlvbl9vcmFjbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBR3BELE9BQU8sRUFBRSxLQUFLLGdCQUFnQixFQUFpQixNQUFNLHlCQUF5QixDQUFDO0FBQy9FLE9BQU8sRUFDTCxLQUFLLFdBQVcsRUFFaEIsS0FBSyxZQUFZLEVBQ2pCLGdCQUFnQixFQUNoQixLQUFLLFlBQVksRUFFbEIsTUFBTSxtQkFBbUIsQ0FBQztBQUMzQixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFM0QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDNUQsT0FBTyxFQUFFLEtBQUssZ0JBQWdCLEVBQStCLEtBQUssTUFBTSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDckcsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3pDLE9BQU8sRUFBUSxLQUFLLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzNELE9BQU8sRUFDTCxXQUFXLEVBQ1gsdUJBQXVCLEVBQ3ZCLFdBQVcsRUFDWCwwQkFBMEIsRUFDMUIsS0FBSyxTQUFTLEVBQ2YsTUFBTSxrQkFBa0IsQ0FBQztBQUUxQixPQUFPLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMzRCxPQUFPLEtBQUssRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDhDQUE4QyxDQUFDO0FBRXhGLE9BQU8sS0FBSyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scURBQXFELENBQUM7QUFFOUYsT0FBTyxLQUFLLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNyRSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUNqRixPQUFPLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBRW5FLE9BQU8sS0FBSyxFQUFFLHVCQUF1QixFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXpFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxLQUFLLDBCQUEwQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFeEcsbURBQW1EO0FBQ25ELE1BQU0sTUFBTSwwQkFBMEIsR0FBRyxJQUFJLENBQUMsMEJBQTBCLEVBQUUsaUJBQWlCLENBQUMsR0FBRztJQUM3RixRQUFRLEVBQUUsRUFBRSxDQUFDO0lBQ2IsU0FBUyxFQUFFLFNBQVMsQ0FBQztJQUNyQixXQUFXLEVBQUUsV0FBVyxDQUFDO0lBQ3pCLHFFQUFxRTtJQUNyRSxlQUFlLEVBQUUsQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxZQUFZLEtBQUssT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdFLGNBQWMsRUFBRSxpQkFBaUIsQ0FBQztJQUNsQyxTQUFTLEVBQUUsa0JBQWtCLENBQUM7SUFDOUIsaUJBQWlCLEVBQUUsMEJBQTBCLENBQUM7SUFDOUMsa0JBQWtCLEVBQUUsa0JBQWtCLENBQUM7SUFDdkMsbUJBQW1CLEVBQUUsbUJBQW1CLENBQUM7SUFDekMsd0JBQXdCLENBQUMsRUFBRSxNQUFNLENBQUM7SUFDbEMsaUJBQWlCLENBQUMsRUFBRSxNQUFNLENBQUM7SUFDM0IsYUFBYSxDQUFDLEVBQUUsWUFBWSxDQUFDO0lBQzdCLFNBQVMsQ0FBQyxFQUFFLGdCQUFnQixDQUFDO0NBQzlCLENBQUM7QUFFRjs7R0FFRztBQUNILHFCQUFhLHNCQUF1QixTQUFRLHNCQUF1QixZQUFXLHVCQUF1Qjs7SUFDbkcsU0FBUyxPQUFpQjtJQUUxQjs7Ozs7OztPQU9HO0lBQ0gsT0FBTyxDQUFDLFFBQVEsQ0FBcUI7SUFDckMsT0FBTyxDQUFDLDJCQUEyQixDQUFrQztJQUNyRSxPQUFPLENBQUMsaUJBQWlCLENBQWlDO0lBQzFELE9BQU8sQ0FBQyxlQUFlLENBQXdCO0lBQy9DLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBb0M7SUFFbEUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUs7SUFDOUIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQVk7SUFDdEMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQWM7SUFDMUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQThEO0lBQzlGLE9BQU8sQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFvQjtJQUNuRCxPQUFPLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBcUI7SUFDL0MsT0FBTyxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBNkI7SUFDL0QsT0FBTyxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBcUI7SUFDeEQsT0FBTyxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBc0I7SUFDMUQsT0FBTyxDQUFDLHdCQUF3QixDQUFTO0lBQ3pDLFNBQVMsQ0FBQyxpQkFBaUIsRUFBRSxNQUFNLENBQUM7SUFDcEMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFlO0lBQ3JDLE9BQU8sQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQW1CO0lBRTlDLFlBQVksSUFBSSxFQUFFLDBCQUEwQixFQW1CM0M7SUFFTSx1QkFBdUIsSUFBSSxvQkFBb0IsQ0FFckQ7SUFJRDs7OztPQUlHO0lBQ0ksaUJBQWlCLENBQUMsR0FBRyxFQUFFLFdBQVcsdUJBZ0J4QztJQUVEOztPQUVHO0lBQ0ksV0FBVyxJQUFJLFdBQVcsRUFBRSxDQUVsQztJQUVNLDhCQUE4Qix3QkFFcEM7SUFFRDs7T0FFRztJQUNJLG9CQUFvQiw4QkFFMUI7SUFFRDs7T0FFRztJQUNJLGtCQUFrQjs7UUFFeEI7SUFFRDs7T0FFRztJQUNJLGNBQWMsSUFBSSxNQUFNLEVBQUUsQ0FFaEM7SUFFRDs7T0FFRztJQUNJLHlCQUF5QixpQ0FFL0I7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSSx1QkFBdUIsSUFBSSxPQUFPLENBQUMsWUFBWSxHQUFHLFNBQVMsQ0FBQyxDQUVsRTtJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSx1QkFBdUIsQ0FBQyxhQUFhLEVBQUUsWUFBWSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FHekU7SUFFRDs7Ozs7T0FLRztJQUNVLDRCQUE0QixDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLFlBQVksR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLENBVXJHO0lBNENEOzs7O09BSUc7SUFDSSw0QkFBNEIsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsUUFFekQ7SUFFRDs7OztPQUlHO0lBQ0ksNkJBQTZCLENBQUMsSUFBSSxFQUFFLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FNNUQ7SUFFYywyQkFBMkIsQ0FBQyxjQUFjLEVBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FlL0U7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkc7SUFDbUIsZUFBZSxDQUNuQyxLQUFLLEVBQUUsWUFBWSxHQUFHLFNBQVMsRUFDL0IsV0FBVyxFQUFFLEVBQUUsRUFDZixVQUFVLEVBQUUsTUFBTSxFQUNsQixlQUFlLEVBQUUsTUFBTSxFQUFFLEVBQ3pCLGVBQWUsRUFBRSxNQUFNLEVBQUUsRUFDekIsZUFBZSxFQUFFLE1BQU0sRUFBRSxFQUN6QixZQUFZLEVBQUUsRUFBRSxFQUFFLEVBQ2xCLGlCQUFpQixFQUFFLE1BQU0sRUFBRSxFQUMzQixhQUFhLEVBQUUsTUFBTSxFQUFFLEVBQ3ZCLGFBQWEsRUFBRSxNQUFNLEVBQUUsRUFDdkIsYUFBYSxFQUFFLE1BQU0sRUFBRSxFQUN2QixTQUFTLEVBQUUsTUFBTSxFQUFFLEVBQ25CLEtBQUssRUFBRSxNQUFNLEVBQ2IsTUFBTSxFQUFFLE1BQU0sRUFDZCxNQUFNLEVBQUUsVUFBVSxHQUNqQixPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FxQ3JCO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLHdCQUF3QixDQUM3QixLQUFLLEVBQUUsWUFBWSxFQUNuQixXQUFXLEVBQUUsRUFBRSxFQUNmLFVBQVUsRUFBRSxFQUFFLEVBQ2QsVUFBVSxFQUFFLFlBQVksRUFDeEIsU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUNmLFFBQVEsRUFBRSxFQUFFLEVBQ1osT0FBTyxFQUFFLE1BQU0sUUEwQmhCO0lBRUQ7Ozs7O09BS0c7SUFDVSwwQkFBMEIsQ0FBQyxjQUFjLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0saUJBU3hGO0lBRUQ7Ozs7O09BS0c7SUFDSSw2QkFBNkIsQ0FBQyxjQUFjLEVBQUUsRUFBRSxpQkFHdEQ7SUFFRDs7Ozs7O09BTUc7SUFDVSx5QkFBeUIsQ0FBQyxjQUFjLEVBQUUsRUFBRSxFQUFFLGVBQWUsRUFBRSxZQUFZLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUkxRztJQUVEOzs7Ozs7T0FNRztJQUNJLG9DQUFvQyxDQUFDLEdBQUcsRUFBRSxnQkFBZ0IsRUFBRSxPQUFPLEVBQUUsTUFBTSxRQU1qRjtJQWNEOzs7Ozs7OztPQVFHO0lBQ0csMEJBQTBCLENBQzlCLHFCQUFxQixFQUFFLFlBQVksRUFDbkMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQ2xDLFFBQVEsRUFBRSxFQUFFLEVBQ1osaUJBQWlCLEVBQUUsTUFBTSxFQUN6QixZQUFZLEVBQUUsT0FBTzs7O09Bb0d0QjtJQWNEOzs7Ozs7T0FNRztJQUNJLHVDQUF1QyxDQUM1QyxzQkFBc0IsRUFBRSxZQUFZLEVBQ3BDLFlBQVksRUFBRSxFQUFFLEVBQ2hCLGtCQUFrQixFQUFFLE1BQU0sRUFDMUIsYUFBYSxFQUFFLE9BQU8saUJBSXZCO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksMENBQTBDLENBQy9DLHNCQUFzQixFQUFFLFlBQVksRUFDcEMsWUFBWSxFQUFFLEVBQUUsRUFDaEIsa0JBQWtCLEVBQUUsTUFBTSxFQUMxQixhQUFhLEVBQUUsT0FBTyxpQkFJdkI7SUFFTSw4Q0FBOEMsQ0FBQyw4QkFBOEIsRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUUzRztJQUVNLG9DQUFvQyxDQUFDLGlCQUFpQixFQUFFLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBRXZGO1lBU2EsaUJBQWlCO0lBYXhCLG9CQUFvQixvQkFFMUI7SUFFTSx5QkFBeUIsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUcxRDtDQUNGIn0=