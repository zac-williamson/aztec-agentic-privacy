import type { ARCHIVE_HEIGHT, NOTE_HASH_TREE_HEIGHT } from '@aztec/constants';
import type { BlockNumber } from '@aztec/foundation/branded-types';
import { Fr } from '@aztec/foundation/curves/bn254';
import { Point } from '@aztec/foundation/curves/grumpkin';
import { createLogger } from '@aztec/foundation/log';
import type { MembershipWitness } from '@aztec/foundation/trees';
import type { KeyStore } from '@aztec/key-store';
import type { AuthWitness } from '@aztec/stdlib/auth-witness';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { BlockHash } from '@aztec/stdlib/block';
import type { CompleteAddress, ContractInstance } from '@aztec/stdlib/contract';
import type { AztecNode } from '@aztec/stdlib/interfaces/server';
import type { KeyValidationRequest } from '@aztec/stdlib/kernel';
import type { NoteStatus } from '@aztec/stdlib/note';
import { type NullifierMembershipWitness, PublicDataWitness } from '@aztec/stdlib/trees';
import type { BlockHeader, Capsule } from '@aztec/stdlib/tx';
import type { AccessScopes } from '../../access_scopes.js';
import type { AddressStore } from '../../storage/address_store/address_store.js';
import type { CapsuleStore } from '../../storage/capsule_store/capsule_store.js';
import type { ContractStore } from '../../storage/contract_store/contract_store.js';
import type { NoteStore } from '../../storage/note_store/note_store.js';
import type { PrivateEventStore } from '../../storage/private_event_store/private_event_store.js';
import type { RecipientTaggingStore } from '../../storage/tagging_store/recipient_tagging_store.js';
import type { SenderAddressBookStore } from '../../storage/tagging_store/sender_address_book_store.js';
import { UtilityContext } from '../noir-structs/utility_context.js';
import type { IMiscOracle, IUtilityExecutionOracle, NoteData } from './interfaces.js';
import { MessageLoadOracleInputs } from './message_load_oracle_inputs.js';
/** Args for UtilityExecutionOracle constructor. */
export type UtilityExecutionOracleArgs = {
    contractAddress: AztecAddress;
    /** List of transient auth witnesses to be used during this simulation */
    authWitnesses: AuthWitness[];
    capsules: Capsule[];
    anchorBlockHeader: BlockHeader;
    contractStore: ContractStore;
    noteStore: NoteStore;
    keyStore: KeyStore;
    addressStore: AddressStore;
    aztecNode: AztecNode;
    recipientTaggingStore: RecipientTaggingStore;
    senderAddressBookStore: SenderAddressBookStore;
    capsuleStore: CapsuleStore;
    privateEventStore: PrivateEventStore;
    jobId: string;
    log?: ReturnType<typeof createLogger>;
    scopes: AccessScopes;
};
/**
 * The oracle for an execution of utility contract functions.
 */
export declare class UtilityExecutionOracle implements IMiscOracle, IUtilityExecutionOracle {
    #private;
    isMisc: true;
    isUtility: true;
    private contractLogger;
    protected readonly contractAddress: AztecAddress;
    protected readonly authWitnesses: AuthWitness[];
    protected readonly capsules: Capsule[];
    protected readonly anchorBlockHeader: BlockHeader;
    protected readonly contractStore: ContractStore;
    protected readonly noteStore: NoteStore;
    protected readonly keyStore: KeyStore;
    protected readonly addressStore: AddressStore;
    protected readonly aztecNode: AztecNode;
    protected readonly recipientTaggingStore: RecipientTaggingStore;
    protected readonly senderAddressBookStore: SenderAddressBookStore;
    protected readonly capsuleStore: CapsuleStore;
    protected readonly privateEventStore: PrivateEventStore;
    protected readonly jobId: string;
    protected log: ReturnType<typeof createLogger>;
    protected readonly scopes: AccessScopes;
    constructor(args: UtilityExecutionOracleArgs);
    utilityAssertCompatibleOracleVersion(version: number): void;
    utilityGetRandomField(): Fr;
    utilityGetUtilityContext(): UtilityContext;
    /**
     * Retrieve keys associated with a specific master public key and app address.
     * @param pkMHash - The master public key hash.
     * @returns A Promise that resolves to nullifier keys.
     * @throws If the keys are not registered in the key store.
     * @throws If scopes are defined and the account is not in the scopes.
     */
    utilityGetKeyValidationRequest(pkMHash: Fr): Promise<KeyValidationRequest>;
    /**
     * Fetches the index and sibling path of a leaf at a given block from the note hash tree.
     * @param anchorBlockHash - The hash of a block that contains the note hash tree root in which to find the membership
     * witness.
     * @param noteHash - The note hash to find in the note hash tree.
     * @returns The membership witness containing the leaf index and sibling path
     */
    utilityGetNoteHashMembershipWitness(anchorBlockHash: BlockHash, noteHash: Fr): Promise<MembershipWitness<typeof NOTE_HASH_TREE_HEIGHT> | undefined>;
    /**
     * Fetches the index and sibling path of a block hash in the archive tree.
     *
     * Block hashes are the leaves of the archive tree. Each time a new block is added to the chain,
     * its block hash is appended as a new leaf to the archive tree.
     *
     * @param anchorBlockHash - The hash of a block that contains the archive tree root in which to find the membership
     * witness.
     * @param blockHash - The block hash to find in the archive tree.
     * @returns The membership witness containing the leaf index and sibling path
     */
    utilityGetBlockHashMembershipWitness(anchorBlockHash: BlockHash, blockHash: BlockHash): Promise<MembershipWitness<typeof ARCHIVE_HEIGHT> | undefined>;
    /**
     * Returns a nullifier membership witness for a given nullifier at a given block.
     * @param blockHash - The block hash at which to get the index.
     * @param nullifier - Nullifier we try to find witness for.
     * @returns The nullifier membership witness (if found).
     */
    utilityGetNullifierMembershipWitness(blockHash: BlockHash, nullifier: Fr): Promise<NullifierMembershipWitness | undefined>;
    /**
     * Returns a low nullifier membership witness for a given nullifier at a given block.
     * @param blockHash - The block hash at which to get the index.
     * @param nullifier - Nullifier we try to find the low nullifier witness for.
     * @returns The low nullifier membership witness (if found).
     * @remarks Low nullifier witness can be used to perform a nullifier non-inclusion proof by leveraging the "linked
     * list structure" of leaves and proving that a lower nullifier is pointing to a bigger next value than the nullifier
     * we are trying to prove non-inclusion for.
     */
    utilityGetLowNullifierMembershipWitness(blockHash: BlockHash, nullifier: Fr): Promise<NullifierMembershipWitness | undefined>;
    /**
     * Returns a public data tree witness for a given leaf slot at a given block.
     * @param blockHash - The block hash at which to get the index.
     * @param leafSlot - The slot of the public data tree to get the witness for.
     * @returns - The witness
     */
    utilityGetPublicDataWitness(blockHash: BlockHash, leafSlot: Fr): Promise<PublicDataWitness | undefined>;
    /**
     * Fetches a block header of a given block.
     * @param blockNumber - The number of a block of which to get the block header.
     * @returns Block extracted from a block with block number `blockNumber`.
     */
    utilityGetBlockHeader(blockNumber: BlockNumber): Promise<BlockHeader | undefined>;
    /**
     * Retrieve the complete address associated to a given address.
     * @param account - The account address.
     * @returns A complete address associated with the input address, or `undefined` if not registered.
     */
    utilityTryGetPublicKeysAndPartialAddress(account: AztecAddress): Promise<CompleteAddress | undefined>;
    protected getCompleteAddressOrFail(account: AztecAddress): Promise<CompleteAddress>;
    /**
     * Returns a contract instance associated with an address or throws if not found.
     * @param address - Address.
     * @returns A contract instance.
     */
    utilityGetContractInstance(address: AztecAddress): Promise<ContractInstance>;
    protected getContractInstance(address: AztecAddress): Promise<ContractInstance>;
    /**
     * Returns an auth witness for the given message hash. Checks on the list of transient witnesses
     * for this transaction first, and falls back to the local database if not found.
     * @param messageHash - Hash of the message to authenticate.
     * @returns Authentication witness for the requested message hash.
     */
    utilityGetAuthWitness(messageHash: Fr): Promise<Fr[] | undefined>;
    /**
     * Gets some notes for a contract address and storage slot.
     * Returns a flattened array containing filtered notes.
     *
     * @remarks
     * Check for pending notes with matching slot.
     * Real notes coming from DB will have a leafIndex which
     * represents their index in the note hash tree.
     *
     * @param owner - The owner of the notes. If undefined, returns notes for all owners.
     * @param storageSlot - The storage slot.
     * @param numSelects - The number of valid selects in selectBy and selectValues.
     * @param selectBy - An array of indices of the fields to selects.
     * @param selectValues - The values to match.
     * @param selectComparators - The comparators to use to match values.
     * @param sortBy - An array of indices of the fields to sort.
     * @param sortOrder - The order of the corresponding index in sortBy. (1: DESC, 2: ASC, 0: Do nothing)
     * @param limit - The number of notes to retrieve per query.
     * @param offset - The starting index for pagination.
     * @param status - The status of notes to fetch.
     * @returns Array of note data.
     */
    utilityGetNotes(owner: AztecAddress | undefined, storageSlot: Fr, numSelects: number, selectByIndexes: number[], selectByOffsets: number[], selectByLengths: number[], selectValues: Fr[], selectComparators: number[], sortByIndexes: number[], sortByOffsets: number[], sortByLengths: number[], sortOrder: number[], limit: number, offset: number, status: NoteStatus): Promise<NoteData[]>;
    /**
     * Check if a nullifier exists in the nullifier tree.
     * @param innerNullifier - The inner nullifier.
     * @returns A boolean indicating whether the nullifier exists in the tree or not.
     */
    utilityCheckNullifierExists(innerNullifier: Fr): Promise<boolean>;
    /**
     * Fetches a message from the executionStore, given its key.
     * @param contractAddress - Address of a contract by which the message was emitted.
     * @param messageHash - Hash of the message.
     * @param secret - Secret used to compute a nullifier.
     * @dev Contract address and secret are only used to compute the nullifier to get non-nullified messages
     * @returns The l1 to l2 membership witness (index of message in the tree and sibling path).
     */
    utilityGetL1ToL2MembershipWitness(contractAddress: AztecAddress, messageHash: Fr, secret: Fr): Promise<MessageLoadOracleInputs<36>>;
    /**
     * Read the public storage data.
     * @param blockHash - The block hash to read storage at.
     * @param contractAddress - The address to read storage from.
     * @param startStorageSlot - The starting storage slot.
     * @param numberOfElements - Number of elements to read from the starting storage slot.
     */
    utilityStorageRead(blockHash: BlockHash, contractAddress: AztecAddress, startStorageSlot: Fr, numberOfElements: number): Promise<Fr[]>;
    utilityLog(level: number, message: string, fields: Fr[]): Promise<void>;
    utilityFetchTaggedLogs(pendingTaggedLogArrayBaseSlot: Fr): Promise<void>;
    /**
     * Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and
     * `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them
     * queryable via `get_notes` and `getPrivateEvents`.
     *
     * This automatically clears both validation request queues, so no further work needs to be done by the caller.
     * @param contractAddress - The address of the contract that the logs are tagged for.
     * @param noteValidationRequestsArrayBaseSlot - The base slot of capsule array containing note validation requests.
     * @param eventValidationRequestsArrayBaseSlot - The base slot of capsule array containing event validation requests.
     */
    utilityValidateAndStoreEnqueuedNotesAndEvents(contractAddress: AztecAddress, noteValidationRequestsArrayBaseSlot: Fr, eventValidationRequestsArrayBaseSlot: Fr): Promise<void>;
    utilityBulkRetrieveLogs(contractAddress: AztecAddress, logRetrievalRequestsArrayBaseSlot: Fr, logRetrievalResponsesArrayBaseSlot: Fr): Promise<void>;
    utilityStoreCapsule(contractAddress: AztecAddress, slot: Fr, capsule: Fr[]): Promise<void>;
    utilityLoadCapsule(contractAddress: AztecAddress, slot: Fr): Promise<Fr[] | null>;
    utilityDeleteCapsule(contractAddress: AztecAddress, slot: Fr): Promise<void>;
    utilityCopyCapsule(contractAddress: AztecAddress, srcSlot: Fr, dstSlot: Fr, numEntries: number): Promise<void>;
    utilityAes128Decrypt(ciphertext: Buffer, iv: Buffer, symKey: Buffer): Promise<Buffer>;
    /**
     * Retrieves the shared secret for a given address and ephemeral public key.
     * @param address - The address to get the secret for.
     * @param ephPk - The ephemeral public key to get the secret for.
     * @returns The secret for the given address.
     */
    utilityGetSharedSecret(address: AztecAddress, ephPk: Point): Promise<Point>;
    protected getSharedSecret(address: AztecAddress, ephPk: Point): Promise<Point>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbGl0eV9leGVjdXRpb25fb3JhY2xlLmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udHJhY3RfZnVuY3Rpb25fc2ltdWxhdG9yL29yYWNsZS91dGlsaXR5X2V4ZWN1dGlvbl9vcmFjbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLEVBQUUsY0FBYyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDOUUsT0FBTyxLQUFLLEVBQUUsV0FBVyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFbkUsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3BELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUMxRCxPQUFPLEVBQWlELFlBQVksRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3BHLE9BQU8sS0FBSyxFQUFFLGlCQUFpQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDakUsT0FBTyxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDakQsT0FBTyxLQUFLLEVBQUUsV0FBVyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDOUQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQzNELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNoRCxPQUFPLEtBQUssRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUVoRixPQUFPLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNqRSxPQUFPLEtBQUssRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBSWpFLE9BQU8sS0FBSyxFQUFFLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3JELE9BQU8sRUFBZ0IsS0FBSywwQkFBMEIsRUFBRSxpQkFBaUIsRUFB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