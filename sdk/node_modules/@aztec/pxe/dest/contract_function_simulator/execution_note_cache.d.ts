import { Fr } from '@aztec/foundation/curves/bn254';
import type { AztecAddress } from '@aztec/stdlib/aztec-address';
import type { NoteData } from './oracle/interfaces.js';
interface PendingNote {
    note: NoteData;
    counter: number;
    noteHashForConsumption: Fr;
}
/**
 * Data that's accessible by all the function calls in an execution.
 */
export declare class ExecutionNoteCache {
    #private;
    private readonly protocolNullifier;
    /**
     * New notes created in this transaction.
     * They are pushed to this array in the same order as they are emitted.
     */
    private notes;
    /**
     * This mapping maps from a contract address to the notes in the contract.
     */
    private noteMap;
    /**
     * This maps from a contract address to the nullifiers emitted from the contract.
     * The note which is nullified might be new or not (i.e., was generated in a previous transaction).
     * Note that their value (bigint representation) is used because Frs cannot be looked up in Sets.
     */
    private nullifierMap;
    /**
     * Nullifiers emitted by private calls in this transaction.
     */
    private emittedNullifiers;
    /**
     * The counter that separates non-revertible side effects (which persist even if the tx reverts) from revertible ones.
     */
    private minRevertibleSideEffectCounter;
    private inRevertiblePhase;
    /**
     * Whether the protocol nullifier was used for nonce generation.
     * We don't need to use the protocol nullifier if a non-revertible nullifier is emitted.
     */
    private usedProtocolNullifierForNonces;
    constructor(protocolNullifier: Fr);
    /**
     * Enters the revertible phase of the transaction.
     * @param minRevertibleSideEffectCounter - The counter at which the transaction enters the revertible phase.
     */
    setMinRevertibleSideEffectCounter(minRevertibleSideEffectCounter: number): Promise<void>;
    isSideEffectCounterRevertible(sideEffectCounter: number): boolean;
    finish(): void;
    /**
     * Add a new note to cache.
     * @param note - New note created during execution.
     */
    addNewNote(note: NoteData, counter: number): void;
    /**
     * Add a nullifier to cache. It could be for a db note or a new note created during execution.
     * @param contractAddress - Contract address of the note.
     * @param innerNullifier - Inner nullifier of the note.
     * @param noteHash - A hash of the note. If this value equals 0, it means the note being nullified is from a previous
     * transaction (and thus not a new note).
     */
    nullifyNote(contractAddress: AztecAddress, innerNullifier: Fr, noteHash: Fr): Promise<number | undefined>;
    /**
     * Adds a nullifier to the cache. Note cache needs to track all nullifiers to decide which nullifier to use for note siloing.
     * @param contractAddress - Contract address that emitted the nullifier.
     * @param innerNullifier
     */
    nullifierCreated(contractAddress: AztecAddress, innerNullifier: Fr): Promise<void>;
    /**
     * Return notes created up to current point in execution.
     * If a nullifier for a note in this list is emitted, the note will be deleted.
     * @param contractAddress - Contract address of the notes.
     * @param owner - Owner of the notes. If undefined, returns all notes regardless of owner.
     * @param storageSlot - Storage slot of the notes.
     **/
    getNotes(contractAddress: AztecAddress, owner: AztecAddress | undefined, storageSlot: Fr): NoteData[];
    /**
     * Check if a note exists in the newNotes array.
     * @param contractAddress - Contract address of the note.
     * @param storageSlot - Storage slot of the note.
     * @param noteHash - A hash of the note.
     **/
    checkNoteExists(contractAddress: AztecAddress, noteHash: Fr): boolean;
    /**
     * Return all nullifiers emitted from a contract.
     * @param contractAddress - Address of the contract.
     */
    getNullifiers(contractAddress: AztecAddress): Set<bigint>;
    getAllNotes(): PendingNote[];
    /**
     * @returns All nullifiers emitted by private calls in this transaction.
     */
    getEmittedNullifiers(): Fr[];
    /**
     * @returns All nullifiers emitted by private calls in this transaction. If the protocol nullifier was used as the
     * nonce generator, it is injected as the first nullifier.
     */
    getAllNullifiers(): Fr[];
    getNonceGenerator(): Fr;
}
export {};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlY3V0aW9uX25vdGVfY2FjaGUuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250cmFjdF9mdW5jdGlvbl9zaW11bGF0b3IvZXhlY3V0aW9uX25vdGVfY2FjaGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3BELE9BQU8sS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBR2hFLE9BQU8sS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRXZELFVBQVUsV0FBVztJQUNuQixJQUFJLEVBQUUsUUFBUSxDQUFDO0lBQ2YsT0FBTyxFQUFFLE1BQU0sQ0FBQztJQUNoQixzQkFBc0IsRUFBRSxFQUFFLENBQUM7Q0FDNUI7QUFFRDs7R0FFRztBQUNILHFCQUFhLGtCQUFrQjs7SUFvQ2pCLE9BQU8sQ0FBQyxRQUFRLENBQUMsaUJBQWlCO0lBbkM5Qzs7O09BR0c7SUFDSCxPQUFPLENBQUMsS0FBSyxDQUFxQjtJQUNsQzs7T0FFRztJQUNILE9BQU8sQ0FBQyxPQUFPLENBQXlDO0lBRXhEOzs7O09BSUc7SUFDSCxPQUFPLENBQUMsWUFBWSxDQUF1QztJQUUzRDs7T0FFRztJQUNILE9BQU8sQ0FBQyxpQkFBaUIsQ0FBMEI7SUFFbkQ7O09BRUc7SUFDSCxPQUFPLENBQUMsOEJBQThCLENBQUs7SUFFM0MsT0FBTyxDQUFDLGlCQUFpQixDQUFTO0lBRWxDOzs7T0FHRztJQUNILE9BQU8sQ0FBQyw4QkFBOEIsQ0FBc0I7SUFFNUQsWUFBNkIsaUJBQWlCLEVBQUUsRUFBRSxFQUFJO0lBRXREOzs7T0FHRztJQUNVLGlDQUFpQyxDQUFDLDhCQUE4QixFQUFFLE1BQU0saUJBc0NwRjtJQUVNLDZCQUE2QixDQUFDLGlCQUFpQixFQUFFLE1BQU0sR0FBRyxPQUFPLENBS3ZFO0lBRU0sTUFBTSxTQU1aO0lBRUQ7OztPQUdHO0lBQ0ksVUFBVSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLE1BQU0sUUFTaEQ7SUFFRDs7Ozs7O09BTUc7SUFDVSxXQUFXLENBQUMsZUFBZSxFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLCtCQXlCdkY7SUFFRDs7OztPQUlHO0lBQ1UsZ0JBQWdCLENBQUMsZUFBZSxFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsRUFBRSxpQkFHOUU7SUFFRDs7Ozs7O1FBTUk7SUFDRyxRQUFRLENBQUMsZUFBZSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsWUFBWSxHQUFHLFNBQVMsRUFBRSxXQUFXLEVBQUUsRUFBRSxjQU05RjtJQUVEOzs7OztRQUtJO0lBQ0csZUFBZSxDQUFDLGVBQWUsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLEVBQUUsV0FHakU7SUFFRDs7O09BR0c7SUFDSSxhQUFhLENBQUMsZUFBZSxFQUFFLFlBQVksR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBRS9EO0lBVUQsV0FBVyxJQUFJLFdBQVcsRUFBRSxDQUUzQjtJQUVEOztPQUVHO0lBQ0gsb0JBQW9CLElBQUksRUFBRSxFQUFFLENBRTNCO0lBRUQ7OztPQUdHO0lBQ0gsZ0JBQWdCLElBQUksRUFBRSxFQUFFLENBTXZCO0lBRUQsaUJBQWlCLElBQUksRUFBRSxDQUV0QjtDQWFGIn0=