import { Timer } from '@aztec/foundation/timer';
export class BenchmarkedNodeFactory {
    static create(node) {
        // Per-method call stats
        const perMethod = {};
        // Round trip tracking
        let inFlightCount = 0;
        let currentRoundTripTimer = null;
        let currentRoundTripMethods = [];
        const roundTrips = {
            roundTrips: 0,
            totalBlockingTime: 0,
            roundTripDurations: [],
            roundTripMethods: []
        };
        return new Proxy(node, {
            get (target, prop) {
                if (prop === 'getStats') {
                    return ()=>{
                        return {
                            perMethod,
                            roundTrips
                        };
                    };
                } else {
                    return function(...args) {
                        // Track per-method stats
                        if (!perMethod[prop]) {
                            perMethod[prop] = {
                                times: []
                            };
                        }
                        // Start of a new round trip batch?
                        if (inFlightCount === 0) {
                            roundTrips.roundTrips++;
                            currentRoundTripTimer = new Timer();
                            currentRoundTripMethods = [];
                        }
                        inFlightCount++;
                        currentRoundTripMethods.push(prop);
                        const callTimer = new Timer();
                        const result = target[prop].apply(target, args);
                        // Handle completion - called when the call finishes (after Promise resolves)
                        const handleCompletion = ()=>{
                            const callTime = callTimer.ms();
                            perMethod[prop].times.push(callTime);
                            inFlightCount--;
                            // End of round trip batch - all concurrent calls completed
                            if (inFlightCount === 0 && currentRoundTripTimer) {
                                const roundTripTime = currentRoundTripTimer.ms();
                                roundTrips.totalBlockingTime += roundTripTime;
                                roundTrips.roundTripDurations.push(roundTripTime);
                                roundTrips.roundTripMethods.push(currentRoundTripMethods);
                                currentRoundTripTimer = null;
                                currentRoundTripMethods = [];
                            }
                        };
                        // If the result is a Promise, chain the completion handler
                        if (result && typeof result.then === 'function') {
                            return result.then((value)=>{
                                handleCompletion();
                                return value;
                            }, (error)=>{
                                handleCompletion();
                                throw error;
                            });
                        } else {
                            // Synchronous method - handle completion immediately
                            handleCompletion();
                            return result;
                        }
                    };
                }
            }
        });
    }
}
