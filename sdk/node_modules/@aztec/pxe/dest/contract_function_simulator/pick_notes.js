import { Fr } from '@aztec/foundation/curves/bn254';
import { Comparator } from '@aztec/stdlib/note';
/**
 * The order to sort an array.
 */ export var SortOrder = /*#__PURE__*/ function(SortOrder) {
    SortOrder[SortOrder["NADA"] = 0] = "NADA";
    SortOrder[SortOrder["DESC"] = 1] = "DESC";
    SortOrder[SortOrder["ASC"] = 2] = "ASC";
    return SortOrder;
}({});
const selectPropertyFromPackedNoteContent = (noteData, selector)=>{
    const noteValueBuffer = noteData[selector.index].toBuffer();
    const noteValue = noteValueBuffer.subarray(selector.offset, selector.offset + selector.length);
    return Fr.fromBuffer(noteValue);
};
const selectNotes = (noteDatas, selects)=>noteDatas.filter((noteData)=>selects.every(({ selector, value, comparator })=>{
            const noteValueFr = selectPropertyFromPackedNoteContent(noteData.note.items, selector);
            const comparatorSelector = {
                [Comparator.EQ]: ()=>noteValueFr.equals(value),
                [Comparator.NEQ]: ()=>!noteValueFr.equals(value),
                [Comparator.LT]: ()=>noteValueFr.lt(value),
                [Comparator.LTE]: ()=>noteValueFr.lt(value) || noteValueFr.equals(value),
                [Comparator.GT]: ()=>!noteValueFr.lt(value) && !noteValueFr.equals(value),
                [Comparator.GTE]: ()=>!noteValueFr.lt(value)
            };
            return comparatorSelector[comparator]();
        }));
const sortNotes = (a, b, sorts, level = 0)=>{
    if (sorts[level] === undefined) {
        return 0;
    }
    const { selector, order } = sorts[level];
    if (order === 0) {
        return 0;
    }
    const aValue = selectPropertyFromPackedNoteContent(a, selector);
    const bValue = selectPropertyFromPackedNoteContent(b, selector);
    const dir = order === 1 ? [
        -1,
        1
    ] : [
        1,
        -1
    ];
    return aValue.toBigInt() === bValue.toBigInt() ? sortNotes(a, b, sorts, level + 1) : aValue.toBigInt() > bValue.toBigInt() ? dir[0] : dir[1];
};
/**
 * Pick from a note array a number of notes that meet the criteria.
 */ export function pickNotes(noteDatas, { selects = [], sorts = [], limit = 0, offset = 0 }) {
    return selectNotes(noteDatas, selects).sort((a, b)=>sortNotes(a.note.items, b.note.items, sorts)).slice(offset, limit ? offset + limit : undefined);
}
