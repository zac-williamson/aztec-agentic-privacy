import { toArray } from '@aztec/foundation/iterable';
import { FunctionCall, FunctionSelector, FunctionType, contractArtifactFromBuffer, contractArtifactToBuffer, encodeArguments, getFunctionDebugMetadata } from '@aztec/stdlib/abi';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { SerializableContractInstance, getContractClassFromArtifact } from '@aztec/stdlib/contract';
import { PrivateFunctionsTree } from './private_functions_tree.js';
/**
 * ContractStore serves as a data manager and retriever for Aztec.nr contracts.
 * It provides methods to obtain contract addresses, function ABI, bytecode, and membership witnesses
 * from a given contract address and function selector. The class maintains a cache of ContractTree instances
 * to efficiently serve the requested data. It interacts with the ContractDatabase and AztecNode to fetch
 * the required information and facilitate cryptographic proof generation.
 */ export class ContractStore {
    /** Map from contract class id to private function tree. */ // TODO: Update it to be LRU cache so that it doesn't keep all the data all the time.
    #privateFunctionTrees = new Map();
    /** Map from contract address to contract class id */ #contractClassIdMap = new Map();
    #store;
    #contractArtifacts;
    #contractInstances;
    constructor(store){
        this.#store = store;
        this.#contractArtifacts = store.openMap('contract_artifacts');
        this.#contractInstances = store.openMap('contracts_instances');
    }
    // Setters
    async addContractArtifact(id, contract) {
        // Validation outside transactionAsync - these are not DB operations
        const privateFunctions = contract.functions.filter((functionArtifact)=>functionArtifact.functionType === FunctionType.PRIVATE);
        const privateSelectors = await Promise.all(privateFunctions.map(async (privateFunctionArtifact)=>(await FunctionSelector.fromNameAndParameters(privateFunctionArtifact.name, privateFunctionArtifact.parameters)).toString()));
        if (privateSelectors.length !== new Set(privateSelectors).size) {
            throw new Error('Repeated function selectors of private functions');
        }
        await this.#store.transactionAsync(()=>this.#contractArtifacts.set(id.toString(), contractArtifactToBuffer(contract)));
    }
    async addContractInstance(contract) {
        this.#contractClassIdMap.set(contract.address.toString(), contract.currentContractClassId);
        await this.#contractInstances.set(contract.address.toString(), new SerializableContractInstance(contract).toBuffer());
    }
    // Private getters
    async #getContractClassId(contractAddress) {
        if (!this.#contractClassIdMap.has(contractAddress.toString())) {
            const instance = await this.getContractInstance(contractAddress);
            if (!instance) {
                return;
            }
            this.#contractClassIdMap.set(contractAddress.toString(), instance.currentContractClassId);
        }
        return this.#contractClassIdMap.get(contractAddress.toString());
    }
    /**
   * Retrieve or create a ContractTree instance based on the provided class id.
   * If an existing tree with the same class id is found in the cache, it will be returned.
   * Otherwise, a new ContractTree instance will be created using the contract data from the database
   * and added to the cache before returning.
   *
   * @param classId - The class id of the contract for which the ContractTree is required.
   * @returns A ContractTree instance associated with the specified contract address.
   * @throws An Error if the contract is not found in the ContractDatabase.
   */ async #getPrivateFunctionTreeForClassId(classId) {
        if (!this.#privateFunctionTrees.has(classId.toString())) {
            const artifact = await this.getContractArtifact(classId);
            if (!artifact) {
                return;
            }
            const tree = await PrivateFunctionsTree.create(artifact);
            this.#privateFunctionTrees.set(classId.toString(), tree);
        }
        return this.#privateFunctionTrees.get(classId.toString());
    }
    async #getContractArtifactByAddress(contractAddress) {
        const contractClassId = await this.#getContractClassId(contractAddress);
        return contractClassId && this.getContractArtifact(contractClassId);
    }
    // Public getters
    getContractsAddresses() {
        return this.#store.transactionAsync(async ()=>{
            const keys = await toArray(this.#contractInstances.keysAsync());
            return keys.map(AztecAddress.fromString);
        });
    }
    /** Returns a contract instance for a given address. Throws if not found. */ getContractInstance(contractAddress) {
        return this.#store.transactionAsync(async ()=>{
            const contract = await this.#contractInstances.getAsync(contractAddress.toString());
            return contract && SerializableContractInstance.fromBuffer(contract).withAddress(contractAddress);
        });
    }
    getContractArtifact(contractClassId) {
        return this.#store.transactionAsync(async ()=>{
            const contract = await this.#contractArtifacts.getAsync(contractClassId.toString());
            // TODO(@spalladino): AztecAsyncMap lies and returns Uint8Arrays instead of Buffers, hence the extra Buffer.from.
            return contract && contractArtifactFromBuffer(Buffer.from(contract));
        });
    }
    /** Returns a contract class for a given class id. Throws if not found. */ async getContractClass(contractClassId) {
        const artifact = await this.getContractArtifact(contractClassId);
        return artifact && getContractClassFromArtifact(artifact);
    }
    async getContract(address) {
        const instance = await this.getContractInstance(address);
        if (!instance) {
            return;
        }
        const artifact = await this.getContractArtifact(instance.currentContractClassId);
        if (!artifact) {
            return;
        }
        return {
            ...instance,
            ...artifact
        };
    }
    /**
   * Retrieves the artifact of a specified function within a given contract.
   * The function is identified by its selector, which is a unique code generated from the function's signature.
   * Throws an error if the contract address or function selector are invalid or not found.
   *
   * @param contractAddress - The AztecAddress representing the contract containing the function.
   * @param selector - The function selector.
   * @returns The corresponding function's artifact as an object.
   */ async getFunctionArtifact(contractAddress, selector) {
        const artifact = await this.#getContractArtifactByAddress(contractAddress);
        const fnArtifact = artifact && await this.#findFunctionArtifactBySelector(artifact, selector);
        return fnArtifact && {
            ...fnArtifact,
            contractName: artifact.name
        };
    }
    async getFunctionArtifactWithDebugMetadata(contractAddress, selector) {
        const artifact = await this.getFunctionArtifact(contractAddress, selector);
        if (!artifact) {
            throw new Error(`Function artifact not found for contract ${contractAddress} and selector ${selector}.`);
        }
        const debug = await this.getFunctionDebugMetadata(contractAddress, selector);
        return {
            ...artifact,
            debug
        };
    }
    async getPublicFunctionArtifact(contractAddress) {
        const artifact = await this.#getContractArtifactByAddress(contractAddress);
        const fnArtifact = artifact && artifact.functions.find((fn)=>fn.functionType === FunctionType.PUBLIC);
        return fnArtifact && {
            ...fnArtifact,
            contractName: artifact.name
        };
    }
    async getFunctionAbi(contractAddress, selector) {
        const artifact = await this.#getContractArtifactByAddress(contractAddress);
        return artifact && await this.#findFunctionAbiBySelector(artifact, selector);
    }
    /**
   * Retrieves the debug metadata of a specified function within a given contract.
   * The function is identified by its selector, which is a unique code generated from the function's signature.
   * Returns undefined if the debug metadata for the given function is not found.
   * Throws if the contract has not been added to the database.
   *
   * @param contractAddress - The AztecAddress representing the contract containing the function.
   * @param selector - The function selector.
   * @returns The corresponding function's artifact as an object.
   */ async getFunctionDebugMetadata(contractAddress, selector) {
        const artifact = await this.#getContractArtifactByAddress(contractAddress);
        const fnArtifact = artifact && await this.#findFunctionArtifactBySelector(artifact, selector);
        return fnArtifact && getFunctionDebugMetadata(artifact, fnArtifact);
    }
    async getPublicFunctionDebugMetadata(contractAddress) {
        const artifact = await this.#getContractArtifactByAddress(contractAddress);
        const fnArtifact = artifact && artifact.functions.find((fn)=>fn.functionType === FunctionType.PUBLIC);
        return fnArtifact && getFunctionDebugMetadata(artifact, fnArtifact);
    }
    /**
   * Retrieve the function membership witness for the given contract class and function selector.
   * The function membership witness represents a proof that the function belongs to the specified contract.
   * Throws an error if the contract address or function selector is unknown.
   *
   * @param contractClassId - The id of the class.
   * @param selector - The function selector.
   * @returns A promise that resolves with the MembershipWitness instance for the specified contract's function.
   */ async getFunctionMembershipWitness(contractClassId, selector) {
        const tree = await this.#getPrivateFunctionTreeForClassId(contractClassId);
        return tree?.getFunctionMembershipWitness(selector);
    }
    async getDebugContractName(contractAddress) {
        const artifact = await this.#getContractArtifactByAddress(contractAddress);
        return artifact?.name;
    }
    async getDebugFunctionName(contractAddress, selector) {
        const artifact = await this.#getContractArtifactByAddress(contractAddress);
        const fnArtifact = artifact && await this.#findFunctionAbiBySelector(artifact, selector);
        return `${artifact?.name ?? contractAddress}:${fnArtifact?.name ?? selector}`;
    }
    async #findFunctionArtifactBySelector(artifact, selector) {
        const functions = artifact.functions;
        for(let i = 0; i < functions.length; i++){
            const fn = functions[i];
            const fnSelector = await FunctionSelector.fromNameAndParameters(fn.name, fn.parameters);
            if (fnSelector.equals(selector)) {
                return fn;
            }
        }
    }
    async #findFunctionAbiBySelector(artifact, selector) {
        const functions = [
            ...artifact.functions,
            ...artifact.nonDispatchPublicFunctions ?? []
        ];
        for(let i = 0; i < functions.length; i++){
            const fn = functions[i];
            const fnSelector = await FunctionSelector.fromNameAndParameters(fn.name, fn.parameters);
            if (fnSelector.equals(selector)) {
                return fn;
            }
        }
    }
    async getFunctionCall(functionName, args, to) {
        const contract = await this.getContract(to);
        if (!contract) {
            throw new Error(`Unknown contract ${to}: add it to PXE by calling server.addContracts(...).\nSee docs for context: https://docs.aztec.network/developers/resources/debugging/aztecnr-errors#unknown-contract-0x0-add-it-to-pxe-by-calling-serveraddcontracts`);
        }
        const functionDao = contract.functions.find((f)=>f.name === functionName);
        if (!functionDao) {
            throw new Error(`Unknown function ${functionName} in contract ${contract.name}.`);
        }
        return FunctionCall.from({
            name: functionDao.name,
            to,
            selector: await FunctionSelector.fromNameAndParameters(functionDao.name, functionDao.parameters),
            type: functionDao.functionType,
            hideMsgSender: false,
            isStatic: functionDao.isStatic,
            args: encodeArguments(functionDao, args),
            returnTypes: functionDao.returnTypes
        });
    }
}
