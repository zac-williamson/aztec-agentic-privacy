import { FUNCTION_TREE_HEIGHT } from '@aztec/constants';
import { Fr } from '@aztec/foundation/curves/bn254';
import { assertLength } from '@aztec/foundation/serialize';
import { MembershipWitness } from '@aztec/foundation/trees';
import { FunctionType } from '@aztec/stdlib/abi';
import { computePrivateFunctionLeaf, computePrivateFunctionsTree, getContractClassPrivateFunctionFromArtifact } from '@aztec/stdlib/contract';
/**
 * Represents a Merkle tree of functions for a particular Contract Class.
 * It manages the construction of the function tree, computes its root, and generates membership witnesses
 * for constrained functions. This class also enables lookup of specific function artifact using selectors.
 * It is used in combination with the AztecNode to compute various data for executing private transactions.
 */ export class PrivateFunctionsTree {
    privateFunctions;
    tree;
    constructor(privateFunctions){
        this.privateFunctions = privateFunctions;
    }
    static async create(artifact) {
        const privateFunctions = await Promise.all(artifact.functions.filter((fn)=>fn.functionType === FunctionType.PRIVATE).map(getContractClassPrivateFunctionFromArtifact));
        return new PrivateFunctionsTree(privateFunctions);
    }
    /**
   * Retrieve the membership witness of a function within a contract's function tree.
   * A membership witness represents the position and authentication path of a target function
   * in the Merkle tree of constrained functions. It is required to prove the existence of the
   * function within the contract during execution. Throws if fn does not exist or is not private.
   *
   * @param selector - The function selector.
   * @returns A MembershipWitness instance representing the position and authentication path of the function in the function tree.
   */ async getFunctionMembershipWitness(selector) {
        const fn = this.privateFunctions.find((f)=>f.selector.equals(selector));
        if (!fn) {
            throw new Error(`Private function with selector ${selector.toString()} not found in contract class.`);
        }
        const leaf = await computePrivateFunctionLeaf(fn);
        const tree = await this.getTree();
        const index = tree.getIndex(leaf);
        const path = tree.getSiblingPath(index);
        return new MembershipWitness(FUNCTION_TREE_HEIGHT, BigInt(index), assertLength(path.map(Fr.fromBuffer), FUNCTION_TREE_HEIGHT));
    }
    async getTree() {
        if (!this.tree) {
            this.tree = await computePrivateFunctionsTree(this.privateFunctions);
        }
        return this.tree;
    }
}
