import { Fr } from '@aztec/foundation/curves/bn254';
import { type Logger } from '@aztec/foundation/log';
import type { AztecAsyncKVStore } from '@aztec/kv-store';
import type { AztecAddress } from '@aztec/stdlib/aztec-address';
import type { StagedStore } from '../../job_coordinator/job_coordinator.js';
export declare class CapsuleStore implements StagedStore {
    #private;
    readonly storeName = "capsule";
    logger: Logger;
    constructor(store: AztecAsyncKVStore);
    /**
     * Commits staged data to main storage.
     * Called by JobCoordinator when a job completes successfully.
     * Note: JobCoordinator wraps all commits in a single transaction, so we don't
     * need our own transactionAsync here (and using one would deadlock on IndexedDB).
     * @param jobId - The jobId identifying which staged data to commit
     */
    commit(jobId: string): Promise<void>;
    /**
     * Discards staged data without committing.
     */
    discardStaged(jobId: string): Promise<void>;
    /**
     * Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `loadCapsule`.
     * * If data was already stored at this slot, it is overwritten.
     * @param contractAddress - The contract address to scope the data under.
     * @param slot - The slot in the database in which to store the value. Slots need not be contiguous.
     * @param capsule - An array of field elements representing the capsule.
     * @param jobId - The context in which this store will be visible until PXE decides to persist it to underlying KV store
     * @remarks A capsule is a "blob" of data that is passed to the contract through an oracle. It works similarly
     * to public contract storage in that it's indexed by the contract address and storage slot but instead of the global
     * network state it's backed by local PXE db.
     */
    storeCapsule(contractAddress: AztecAddress, slot: Fr, capsule: Fr[], jobId: string): void;
    /**
     * Returns data previously stored via `storeCapsule` in the per-contract non-volatile database.
     * @param contractAddress - The contract address under which the data is scoped.
     * @param slot - The slot in the database to read.
     * @returns The stored data or `null` if no data is stored under the slot.
     */
    loadCapsule(contractAddress: AztecAddress, slot: Fr, jobId: string): Promise<Fr[] | null>;
    /**
     * Deletes data in the per-contract non-volatile database. Does nothing if no data was present.
     * @param contractAddress - The contract address under which the data is scoped.
     * @param slot - The slot in the database to delete.
     */
    deleteCapsule(contractAddress: AztecAddress, slot: Fr, jobId: string): void;
    /**
     * Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data
     * structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.
     * Supports overlapping source and destination regions (which will result in the overlapped source values being
     * overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)
     *
     * @param contractAddress - The contract address under which the data is scoped.
     * @param srcSlot - The first slot to copy from.
     * @param dstSlot - The first slot to copy to.
     * @param numEntries - The number of entries to copy.
     */
    copyCapsule(contractAddress: AztecAddress, srcSlot: Fr, dstSlot: Fr, numEntries: number, jobId: string): Promise<void>;
    /**
     * Appends multiple capsules to a capsule array stored at the base slot.
     * The array length is stored at the base slot, and elements are stored in consecutive slots after it.
     * All operations are performed in a single transaction.
     * @param contractAddress - The contract address that owns the capsule array
     * @param baseSlot - The slot where the array length is stored
     * @param content - Array of capsule data to append
     */
    appendToCapsuleArray(contractAddress: AztecAddress, baseSlot: Fr, content: Fr[][], jobId: string): Promise<void>;
    readCapsuleArray(contractAddress: AztecAddress, baseSlot: Fr, jobId: string): Promise<Fr[][]>;
    setCapsuleArray(contractAddress: AztecAddress, baseSlot: Fr, content: Fr[][], jobId: string): Promise<void>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fwc3VsZV9zdG9yZS5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3N0b3JhZ2UvY2Fwc3VsZV9zdG9yZS9jYXBzdWxlX3N0b3JlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUNwRCxPQUFPLEVBQUUsS0FBSyxNQUFNLEVBQWdCLE1BQU0sdUJBQXVCLENBQUM7QUFDbEUsT0FBTyxLQUFLLEVBQUUsaUJBQWlCLEVBQWlCLE1BQU0saUJBQWlCLENBQUM7QUFDeEUsT0FBTyxLQUFLLEVBQUUsWUFBWSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFaEUsT0FBTyxLQUFLLEVBQUUsV0FBVyxFQUFFLE1BQU0sMENBQTBDLENBQUM7QUFFNUUscUJBQWEsWUFBYSxZQUFXLFdBQVc7O0lBQzlDLFFBQVEsQ0FBQyxTQUFTLGFBQWE7SUFZL0IsTUFBTSxFQUFFLE1BQU0sQ0FBQztJQUVmLFlBQVksS0FBSyxFQUFFLGlCQUFpQixFQVFuQztJQStERDs7Ozs7O09BTUc7SUFDRyxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBZXpDO0lBRUQ7O09BRUc7SUFDSCxhQUFhLENBQUMsS0FBSyxFQUFFLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBRzFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILFlBQVksQ0FBQyxlQUFlLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLFFBS2pGO0lBRUQ7Ozs7O09BS0c7SUFDRyxXQUFXLENBQUMsZUFBZSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQyxDQVc5RjtJQUVEOzs7O09BSUc7SUFDSCxhQUFhLENBQUMsZUFBZSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLFFBR25FO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILFdBQVcsQ0FDVCxlQUFlLEVBQUUsWUFBWSxFQUM3QixPQUFPLEVBQUUsRUFBRSxFQUNYLE9BQU8sRUFBRSxFQUFFLEVBQ1gsVUFBVSxFQUFFLE1BQU0sRUFDbEIsS0FBSyxFQUFFLE1BQU0sR0FDWixPQUFPLENBQUMsSUFBSSxDQUFDLENBMkJmO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILG9CQUFvQixDQUFDLGVBQWUsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FxQi9HO0lBRUQsZ0JBQWdCLENBQUMsZUFBZSxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0EyQjVGO0lBRUQsZUFBZSxDQUFDLGVBQWUsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxpQkEyQjFGO0NBQ0YifQ==