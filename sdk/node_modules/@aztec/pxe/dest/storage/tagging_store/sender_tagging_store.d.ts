import type { AztecAsyncKVStore } from '@aztec/kv-store';
import type { DirectionalAppTaggingSecret, PreTag } from '@aztec/stdlib/logs';
import { TxHash } from '@aztec/stdlib/tx';
import type { StagedStore } from '../../job_coordinator/job_coordinator.js';
/**
 * Data provider of tagging data used when syncing the sender tagging indexes. The recipient counterpart of this class
 * is called RecipientTaggingStore. We have the data stores separate for sender and recipient because
 * the algorithms are completely disjoint and there is not data reuse between the two.
 */
export declare class SenderTaggingStore implements StagedStore {
    #private;
    readonly storeName = "sender_tagging";
    constructor(store: AztecAsyncKVStore);
    /**
     * Writes all job-specific in-memory data to persistent storage.
     *
     * @remark This method must run in a DB transaction context. It's designed to be called from JobCoordinator#commitJob.
     */
    commit(jobId: string): Promise<void>;
    discardStaged(jobId: string): Promise<void>;
    /**
     * Stores pending indexes.
     * @remarks Ignores the index if the same preTag + txHash combination already exists in the db with the same index.
     * This is expected to happen because whenever we start sync we start from the last finalized index and we can have
     * pending indexes already stored from previous syncs.
     * @param preTags - The pre-tags containing the directional app tagging secrets and the indexes that are to be
     * stored in the db.
     * @param txHash - The tx in which the pretags were used in private logs.
     * @param jobId - job context for staged writes to this store. See `JobCoordinator` for more details.
     * @throws If any two pre-tags contain the same directional app tagging secret. This is enforced because we care
     * only about the highest index for a given secret that was used in the tx. Hence this check is a good way to catch
     * bugs.
     * @throws If the newly stored pending index is further than window length from the highest finalized index for the
     * same secret. This is enforced in order to give a guarantee to a recipient that he doesn't need to look further than
     * window length ahead of the highest finalized index.
     * @throws If a secret + txHash pair already exists in the db with a different index value. It should never happen
     * that we would attempt to store a different index for a given secret-txHash pair because we always store just the
     * highest index for a given secret-txHash pair. Hence this is a good way to catch bugs.
     * @throws If the newly stored pending index is lower than or equal to the last finalized index for the same secret.
     * This is enforced because this should never happen if the syncing is done correctly as we look for logs from higher
     * indexes than finalized ones.
     */
    storePendingIndexes(preTags: PreTag[], txHash: TxHash, jobId: string): Promise<void>;
    /**
     * Returns the transaction hashes of all pending transactions that contain indexes within a specified range
     * for a given directional app tagging secret.
     * @param secret - The directional app tagging secret to query pending indexes for.
     * @param startIndex - The lower bound of the index range (inclusive).
     * @param endIndex - The upper bound of the index range (exclusive).
     * @returns An array of unique transaction hashes for pending transactions that contain indexes in the range
     * [startIndex, endIndex). Returns an empty array if no pending indexes exist in the range.
     */
    getTxHashesOfPendingIndexes(secret: DirectionalAppTaggingSecret, startIndex: number, endIndex: number, jobId: string): Promise<TxHash[]>;
    /**
     * Returns the last (highest) finalized index for a given secret.
     * @param secret - The secret to get the last finalized index for.
     * @returns The last (highest) finalized index for the given secret.
     */
    getLastFinalizedIndex(secret: DirectionalAppTaggingSecret, jobId: string): Promise<number | undefined>;
    /**
     * Returns the last used index for a given directional app tagging secret, considering both finalized and pending
     * indexes.
     * @param secret - The directional app tagging secret to query the last used index for.
     * @returns The last used index.
     */
    getLastUsedIndex(secret: DirectionalAppTaggingSecret, jobId: string): Promise<number | undefined>;
    /**
     * Drops all pending indexes corresponding to the given transaction hashes.
     */
    dropPendingIndexes(txHashes: TxHash[], jobId: string): Promise<void>;
    /**
     * Updates pending indexes corresponding to the given transaction hashes to be finalized and prunes any lower pending
     * indexes.
     */
    finalizePendingIndexes(txHashes: TxHash[], jobId: string): Promise<void>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VuZGVyX3RhZ2dpbmdfc3RvcmUuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yYWdlL3RhZ2dpbmdfc3RvcmUvc2VuZGVyX3RhZ2dpbmdfc3RvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLEVBQUUsaUJBQWlCLEVBQWlCLE1BQU0saUJBQWlCLENBQUM7QUFDeEUsT0FBTyxLQUFLLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDOUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTFDLE9BQU8sS0FBSyxFQUFFLFdBQVcsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBRzVFOzs7O0dBSUc7QUFDSCxxQkFBYSxrQkFBbUIsWUFBVyxXQUFXOztJQUNwRCxRQUFRLENBQUMsU0FBUyxvQkFBb0I7SUE2QnRDLFlBQVksS0FBSyxFQUFFLGlCQUFpQixFQVFuQztJQTRDRDs7OztPQUlHO0lBQ0csTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQW9CekM7SUFFRCxhQUFhLENBQUMsS0FBSyxFQUFFLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBSTFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXFCRztJQUNILG1CQUFtQixDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQTBFbkY7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILDJCQUEyQixDQUN6QixNQUFNLEVBQUUsMkJBQTJCLEVBQ25DLFVBQVUsRUFBRSxNQUFNLEVBQ2xCLFFBQVEsRUFBRSxNQUFNLEVBQ2hCLEtBQUssRUFBRSxNQUFNLEdBQ1osT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBUW5CO0lBRUQ7Ozs7T0FJRztJQUNILHFCQUFxQixDQUFDLE1BQU0sRUFBRSwyQkFBMkIsRUFBRSxLQUFLLEVBQUUsTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLENBRXJHO0lBRUQ7Ozs7O09BS0c7SUFDSCxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsMkJBQTJCLEVBQUUsS0FBSyxFQUFFLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxDQWtCaEc7SUFFRDs7T0FFRztJQUNILGtCQUFrQixDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0EyQ25FO0lBRUQ7OztPQUdHO0lBQ0gsc0JBQXNCLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQTJGdkU7Q0FDRiJ9