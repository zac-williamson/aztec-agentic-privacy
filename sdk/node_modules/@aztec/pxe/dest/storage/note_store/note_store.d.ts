import type { Fr } from '@aztec/foundation/schemas';
import type { AztecAsyncKVStore } from '@aztec/kv-store';
import type { AztecAddress } from '@aztec/stdlib/aztec-address';
import type { DataInBlock } from '@aztec/stdlib/block';
import { NoteDao } from '@aztec/stdlib/note';
import type { StagedStore } from '../../job_coordinator/job_coordinator.js';
import type { NotesFilter } from '../../notes_filter.js';
/**
 * NoteStore manages the storage and retrieval of notes.
 *
 * Notes can be active or nullified. This class processes new notes, nullifications, and performs rollback handling in
 * the case of a reorg.
 **/
export declare class NoteStore implements StagedStore {
    #private;
    readonly storeName: string;
    constructor(store: AztecAsyncKVStore);
    /**
     * Adds multiple notes to the notes store under the specified scope.
     *
     * Notes are stored using their siloedNullifier as the key, which provides uniqueness. Each note is indexed by
     * multiple criteria for efficient retrieval.
     *
     * @param notes - Notes to store
     * @param scope - The scope (user/account) under which to store the notes
     * @param jobId - The job context for staged writes
     */
    addNotes(notes: NoteDao[], scope: AztecAddress, jobId: string): Promise<void[]>;
    /**
     * Retrieves notes based on the provided filter criteria.
     *
     * This method queries both active and optionally nullified notes based on the filter parameters.
     *
     * @param filter - Filter criteria including contractAddress (required), and optional owner,
     *                 storageSlot, status, scopes, and siloedNullifier.
     * @params jobId - the job context to read from.
     * @returns Filtered and deduplicated notes (a note might be present in multiple scopes - we ensure it is only
     * returned once if this is the case)
     */
    getNotes(filter: NotesFilter, jobId: string): Promise<NoteDao[]>;
    /**
     * Transitions notes from "active" to "nullified" state.
     *
     * This operation processes a batch of nullifiers to mark the corresponding notes as spent/nullified.
     * The operation is atomic - if any nullifier is not found, the entire operation fails and no notes are modified.
     *
     * applyNullifiers is idempotent: the same nullifier can be applied multiple times without error.
     * This relaxes constraints on usage of NoteService#validateAndStoreNote, which can then be run concurrently in a Promise.all
     * context without risking unnecessarily defensive checks failing.
     *
     * @param nullifiers - Array of nullifiers with their block numbers to process
     * @param jobId - The job context for staged writes
     * @returns Array of NoteDao objects that were nullified
     * @throws Error if any nullifier is not found in this notes store
     */
    applyNullifiers(nullifiers: DataInBlock<Fr>[], jobId: string): Promise<NoteDao[]>;
    /**
     * Synchronizes notes and nullifiers to a specific block number.
     *
     * This method ensures that the state of notes and nullifiers is consistent with the specified block number.
     * It restores any notes that were nullified after the given block and deletes any active notes created after that
     * block.
     *
     * IMPORTANT: This method must be called within a transaction to ensure atomicity.
     *
     * @param blockNumber - The new chain tip after a reorg
     * @param synchedBlockNumber - The block number up to which PXE managed to sync before the reorg happened.
     */
    rollback(blockNumber: number, synchedBlockNumber: number): Promise<void>;
    /**
     * Commits in memory job data to persistent storage.
     *
     * Called by JobCoordinator when a job completes successfully.
     *
     * Note: JobCoordinator wraps all commits in a single transaction, so we don't need our own transactionAsync here
     * (and using one would throw on IndexedDB as it does not support nested txs).
     *
     * @param jobId - The jobId identifying which staged data to commit
     */
    commit(jobId: string): Promise<void>;
    discardStaged(jobId: string): Promise<void>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90ZV9zdG9yZS5kLnRzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3N0b3JhZ2Uvbm90ZV9zdG9yZS9ub3RlX3N0b3JlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sS0FBSyxFQUFFLEVBQUUsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3BELE9BQU8sS0FBSyxFQUFFLGlCQUFpQixFQUFxQyxNQUFNLGlCQUFpQixDQUFDO0FBQzVGLE9BQU8sS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ2hFLE9BQU8sS0FBSyxFQUFFLFdBQVcsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxPQUFPLEVBQWMsTUFBTSxvQkFBb0IsQ0FBQztBQUV6RCxPQUFPLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUM1RSxPQUFPLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUd6RDs7Ozs7SUFLSTtBQUNKLHFCQUFhLFNBQVUsWUFBVyxXQUFXOztJQUMzQyxRQUFRLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBVTtJQStCcEMsWUFBWSxLQUFLLEVBQUUsaUJBQWlCLEVBUW5DO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0ksUUFBUSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBYXJGO0lBY0Q7Ozs7Ozs7Ozs7T0FVRztJQUNILFFBQVEsQ0FBQyxNQUFNLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBZ0cvRDtJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0gsZUFBZSxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQXlDaEY7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNVLFFBQVEsQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFLGtCQUFrQixFQUFFLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBTXBGO0lBNkVEOzs7Ozs7Ozs7T0FTRztJQUNHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FVekM7SUFFRCxhQUFhLENBQUMsS0FBSyxFQUFFLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBRzFDO0NBa0NGIn0=