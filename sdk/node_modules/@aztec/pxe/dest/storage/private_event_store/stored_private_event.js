import { Fr } from '@aztec/foundation/curves/bn254';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { EventSelector } from '@aztec/stdlib/abi';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { BlockHash } from '@aztec/stdlib/block';
import { TxHash } from '@aztec/stdlib/tx';
/** Serializable private event entry with scope tracking. */ export class StoredPrivateEvent {
    randomness;
    msgContent;
    l2BlockNumber;
    l2BlockHash;
    txHash;
    txIndexInBlock;
    eventIndexInTx;
    contractAddress;
    eventSelector;
    scopes;
    constructor(randomness, msgContent, l2BlockNumber, l2BlockHash, txHash, txIndexInBlock, eventIndexInTx, contractAddress, eventSelector, scopes){
        this.randomness = randomness;
        this.msgContent = msgContent;
        this.l2BlockNumber = l2BlockNumber;
        this.l2BlockHash = l2BlockHash;
        this.txHash = txHash;
        this.txIndexInBlock = txIndexInBlock;
        this.eventIndexInTx = eventIndexInTx;
        this.contractAddress = contractAddress;
        this.eventSelector = eventSelector;
        this.scopes = scopes;
    }
    addScope(scope) {
        this.scopes.add(scope);
    }
    toBuffer() {
        const scopesArray = [
            ...this.scopes
        ];
        return serializeToBuffer(this.randomness, this.msgContent.length, ...this.msgContent, this.l2BlockNumber, this.l2BlockHash, this.txHash, this.txIndexInBlock, this.eventIndexInTx, this.contractAddress, this.eventSelector.toBuffer(), scopesArray.length, ...scopesArray);
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const randomness = Fr.fromBuffer(reader);
        const msgContentLength = reader.readNumber();
        const msgContent = reader.readArray(msgContentLength, Fr);
        const l2BlockNumber = reader.readNumber();
        const l2BlockHash = new BlockHash(Fr.fromBuffer(reader));
        const txHash = TxHash.fromBuffer(reader);
        const txIndexInBlock = reader.readNumber();
        const eventIndexInTx = reader.readNumber();
        const contractAddress = AztecAddress.fromBuffer(reader);
        const eventSelector = EventSelector.fromBuffer(reader);
        const scopes = reader.readVector({
            fromBuffer: (r)=>r.readString()
        });
        return new StoredPrivateEvent(randomness, msgContent, l2BlockNumber, l2BlockHash, txHash, txIndexInBlock, eventIndexInTx, contractAddress, eventSelector, new Set(scopes));
    }
}
