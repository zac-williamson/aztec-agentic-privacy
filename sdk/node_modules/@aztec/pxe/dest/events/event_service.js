import { siloNullifier } from '@aztec/stdlib/hash';
export class EventService {
    anchorBlockHeader;
    aztecNode;
    privateEventStore;
    jobId;
    constructor(anchorBlockHeader, aztecNode, privateEventStore, jobId){
        this.anchorBlockHeader = anchorBlockHeader;
        this.aztecNode = aztecNode;
        this.privateEventStore = privateEventStore;
        this.jobId = jobId;
    }
    async validateAndStoreEvent(contractAddress, selector, randomness, content, eventCommitment, txHash, scope) {
        // While using 'latest' block number would be fine for private events since they cannot be accessed from Aztec.nr
        // (and thus we're less concerned about being ahead of the synced block), we use the synced block number to
        // maintain consistent behavior in the PXE. Additionally, events should never be ahead of the synced block here
        // since `fetchTaggedLogs` only processes logs up to the synced block.
        const [siloedEventCommitment, txEffect] = await Promise.all([
            siloNullifier(contractAddress, eventCommitment),
            this.aztecNode.getTxEffect(txHash)
        ]);
        const anchorBlockNumber = this.anchorBlockHeader.getBlockNumber();
        if (!txEffect) {
            throw new Error(`Could not find tx effect for tx hash ${txHash}`);
        }
        if (txEffect.l2BlockNumber > anchorBlockNumber) {
            throw new Error(`Could not find tx effect for tx hash ${txHash} as of block number ${anchorBlockNumber}`);
        }
        // Find the index of the event commitment in the nullifiers array to determine event ordering within the tx
        const eventIndexInTx = txEffect.data.nullifiers.findIndex((n)=>n.equals(siloedEventCommitment));
        if (eventIndexInTx === -1) {
            throw new Error(`Event commitment ${eventCommitment} (siloed as ${siloedEventCommitment}) is not present in tx ${txHash}`);
        }
        return this.privateEventStore.storePrivateEventLog(selector, randomness, content, siloedEventCommitment, {
            contractAddress,
            scope,
            txHash,
            l2BlockNumber: txEffect.l2BlockNumber,
            l2BlockHash: txEffect.l2BlockHash,
            txIndexInBlock: txEffect.txIndexInBlock,
            eventIndexInTx
        }, this.jobId);
    }
}
