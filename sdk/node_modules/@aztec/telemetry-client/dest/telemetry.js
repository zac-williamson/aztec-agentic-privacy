import { SpanStatusCode } from '@opentelemetry/api';
import { getTelemetryClient } from './start.js';
export { toMetricOptions, createUpDownCounterWithDefault } from './metric-utils.js';
export { SpanStatusCode, ValueType } from '@opentelemetry/api';
/**
 * Starts a new span whenever the decorated method is called.
 * @param spanName - The name of the span to create. Can be a string or a function that returns a string.
 * @param attributes - Initial attributes to set on the span. If a function is provided, it will be called with the arguments of the method.
 * @param extraAttributes - Extra attributes to set on the span after the method is called. Will be called with the return value of the method. Note: if the function throws then this will not be called.
 * @returns A decorator that wraps the method in a span.
 *
 * @privateRemarks
 * This code looks complex but it's not that difficult:
 * - decorators are functions that _replace_ a method with a different implementation
 * - normal decorators can't take function arguments, but if we write a function that returns a decorator, we can pass arguments to that function
 *
 * The trackSpan function takes a span's name and some attributes and builds a decorator that wraps a method in a span with the given name and props
 * The decorator can currently only be applied to methods on classes that have a `tracer` property. The compiler will enforce this.
 */ export function trackSpan(spanName, attributes, extraAttributes) {
    // the return value of trackSpan is a decorator
    return (originalMethod, _context)=>{
        // the return value of the decorator replaces the original method
        // in this wrapper method we start a span, call the original method, and then end the span
        return async function replacementMethod(...args) {
            const name = typeof spanName === 'function' ? spanName.call(this, ...args) : spanName;
            const currentAttrs = typeof attributes === 'function' ? await attributes.call(this, ...args) : attributes;
            // run originalMethod wrapped in an active span
            // "active" means the span will be alive for the duration of the function execution
            // and if any other spans are started during the execution of originalMethod, they will be children of this span
            // behind the scenes this uses AsyncLocalStorage https://nodejs.org/dist/latest-v22.x/docs/api/async_context.html
            return this.tracer.startActiveSpan(name, {
                attributes: currentAttrs
            }, async (span)=>{
                try {
                    const res = await originalMethod.call(this, ...args);
                    const extraAttrs = extraAttributes?.call(this, res);
                    span.setAttributes(extraAttrs ?? {});
                    span.setStatus({
                        code: SpanStatusCode.OK
                    });
                    return res;
                } catch (err) {
                    span.setStatus({
                        code: SpanStatusCode.ERROR,
                        message: String(err)
                    });
                    if (typeof err === 'string' || err && err instanceof Error) {
                        span.recordException(err);
                    }
                    throw err;
                } finally{
                    span.end();
                }
            });
        };
    };
}
/**
 * Runs an event callback in a span. The span is started immediately and completes once the callback finishes running.
 * The span will have two events added: 'callbackStart' and 'callbackEnd' to mark the start and end of the callback.
 *
 * @param tracer - The tracer instance to use
 * @param spanName - The name of the span to create
 * @param attributes - Initial attributes to set on the span
 * @param callback - The callback to wrap in a span
 *
 * @returns - A new function that wraps the callback in a span
 */ export function wrapCallbackInSpan(tracer, spanName, attributes, callback) {
    const span = tracer.startSpan(spanName, {
        attributes
    });
    return async (...args)=>{
        try {
            span.addEvent('callbackStart');
            const res = await callback(...args);
            return res;
        } catch (err) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: String(err)
            });
            throw err;
        } finally{
            span.addEvent('callbackEnd');
            span.end();
        }
    };
}
export function runInSpan(tracer, spanName, callback) {
    return (...args)=>{
        const actualTracer = typeof tracer === 'string' ? getTelemetryClient().getTracer(tracer) : tracer;
        return actualTracer.startActiveSpan(spanName, async (span)=>{
            try {
                const res = await callback(span, ...args);
                span.setStatus({
                    code: SpanStatusCode.OK
                });
                return res;
            } catch (err) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: String(err)
                });
                if (typeof err === 'string' || err && err instanceof Error) {
                    span.recordException(err);
                }
                throw err;
            } finally{
                span.end();
            }
        });
    };
}
/**
 * Execute a callback within a span immediately (for one-off traced calls).
 * Unlike runInSpan which returns a reusable function, this executes right away.
 */ export function execInSpan(tracer, spanName, callback) {
    const actualTracer = typeof tracer === 'string' ? getTelemetryClient().getTracer(tracer) : tracer;
    return actualTracer.startActiveSpan(spanName, async (span)=>{
        try {
            const res = await callback(span);
            span.setStatus({
                code: SpanStatusCode.OK
            });
            return res;
        } catch (err) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: String(err)
            });
            if (typeof err === 'string' || err && err instanceof Error) {
                span.recordException(err);
            }
            throw err;
        } finally{
            span.end();
        }
    });
}
