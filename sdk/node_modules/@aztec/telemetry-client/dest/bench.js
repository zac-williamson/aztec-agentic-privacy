import { createLogger } from '@aztec/foundation/log';
import { NoopTracer } from './noop.js';
export class BenchmarkTelemetryClient {
    meters = [];
    constructor(){
        const log = createLogger('telemetry:client');
        log.info(`Using benchmark telemetry client`);
    }
    setExportedPublicTelemetry(_prefixes) {}
    setPublicTelemetryCollectFrom(_roles) {}
    getMeter(name) {
        const meter = new InMemoryPlainMeter(name);
        this.meters.push(meter);
        return meter;
    }
    getTracer() {
        return new NoopTracer();
    }
    stop() {
        return Promise.resolve();
    }
    flush() {
        return Promise.resolve();
    }
    isEnabled() {
        return true;
    }
    getTraceContext() {
        return undefined;
    }
    extractPropagatedContext() {
        return undefined;
    }
    getMeters() {
        return this.meters;
    }
    clear() {
        this.meters.forEach((meter)=>meter.clear());
    }
}
class InMemoryPlainMeter {
    name;
    metrics;
    constructor(name){
        this.name = name;
        this.metrics = [];
    }
    clear() {
        this.metrics.forEach((metric)=>metric.clear());
    }
    createGauge(metric) {
        return this.createMetric('gauge', metric);
    }
    createObservableGauge(metric) {
        return this.createMetric('gauge', metric);
    }
    createHistogram(metric, _extraOptions) {
        return this.createMetric('histogram', metric);
    }
    createUpDownCounter(metric) {
        return this.createMetric('counter', metric);
    }
    createObservableUpDownCounter(metric) {
        return this.createMetric('counter', metric);
    }
    createMetric(type, metric) {
        const m = new InMemoryPlainMetric(type, metric.name, {
            description: metric.description,
            unit: metric.unit,
            valueType: metric.valueType
        });
        this.metrics.push(m);
        return m;
    }
    addBatchObservableCallback(_callback, _observables) {}
    removeBatchObservableCallback(_callback, _observables) {}
}
class InMemoryPlainMetric {
    type;
    name;
    points;
    description;
    unit;
    valueType;
    constructor(type, name, options){
        this.type = type;
        this.name = name;
        this.points = [];
        this.description = options?.description;
        this.unit = options?.unit;
        this.valueType = options?.valueType;
    }
    add(value, attributes, context) {
        this.points.push({
            value,
            attributes,
            context
        });
    }
    record(value, attributes, context) {
        this.points.push({
            value,
            attributes,
            context
        });
    }
    addCallback() {}
    removeCallback() {}
    getPoints() {
        return this.points;
    }
    clear() {
        this.points.splice(0, this.points.length);
    }
}
