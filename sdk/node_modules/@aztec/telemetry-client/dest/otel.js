import { addLogDataHandler } from '@aztec/foundation/log';
import { DiagConsoleLogger, DiagLogLevel, ROOT_CONTEXT, context, diag, isSpanContextValid, propagation, trace } from '@opentelemetry/api';
import { W3CTraceContextPropagator } from '@opentelemetry/core';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { HostMetrics } from '@opentelemetry/host-metrics';
import { ExplicitBucketHistogramAggregation, InstrumentType, MeterProvider, PeriodicExportingMetricReader, View } from '@opentelemetry/sdk-metrics';
import { BatchSpanProcessor, NodeTracerProvider } from '@opentelemetry/sdk-trace-node';
import { ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION } from '@opentelemetry/semantic-conventions';
import { toMetricOptions } from './metric-utils.js';
import { NodejsMetricsMonitor } from './nodejs_metrics_monitor.js';
import { OtelFilterMetricExporter, PublicOtelFilterMetricExporter } from './otel_filter_metric_exporter.js';
import { registerOtelLoggerProvider } from './otel_logger_provider.js';
import { getOtelResource } from './otel_resource.js';
/** Wraps an OpenTelemetry Meter to implement our custom Meter interface */ class WrappedMeter {
    otelMeter;
    constructor(otelMeter){
        this.otelMeter = otelMeter;
    }
    createGauge(metric) {
        return this.otelMeter.createGauge(metric.name, toMetricOptions(metric));
    }
    createObservableGauge(metric) {
        return this.otelMeter.createObservableGauge(metric.name, toMetricOptions(metric));
    }
    createHistogram(metric, extraOptions) {
        return this.otelMeter.createHistogram(metric.name, {
            ...toMetricOptions(metric),
            ...extraOptions
        });
    }
    createUpDownCounter(metric) {
        return this.otelMeter.createUpDownCounter(metric.name, toMetricOptions(metric));
    }
    createObservableUpDownCounter(metric) {
        return this.otelMeter.createObservableUpDownCounter(metric.name, toMetricOptions(metric));
    }
    addBatchObservableCallback(callback, observables) {
        this.otelMeter.addBatchObservableCallback(callback, observables);
    }
    removeBatchObservableCallback(callback, observables) {
        this.otelMeter.removeBatchObservableCallback(callback, observables);
    }
}
export class OpenTelemetryClient {
    resource;
    meterProvider;
    traceProvider;
    loggerProvider;
    publicMetricExporter;
    log;
    hostMetrics;
    nodejsMetricsMonitor;
    meters;
    tracers;
    constructor(resource, meterProvider, traceProvider, loggerProvider, publicMetricExporter, log){
        this.resource = resource;
        this.meterProvider = meterProvider;
        this.traceProvider = traceProvider;
        this.loggerProvider = loggerProvider;
        this.publicMetricExporter = publicMetricExporter;
        this.log = log;
        this.meters = new Map();
        this.tracers = new Map();
    }
    setExportedPublicTelemetry(metrics) {
        this.publicMetricExporter?.setMetricPrefixes(metrics);
    }
    setPublicTelemetryCollectFrom(roles) {
        this.publicMetricExporter?.setAllowedRoles(roles);
    }
    getMeter(name) {
        let meter = this.meters.get(name);
        if (!meter) {
            const otelMeter = this.meterProvider.getMeter(name, this.resource.attributes[ATTR_SERVICE_VERSION]);
            meter = new WrappedMeter(otelMeter);
            this.meters.set(name, meter);
        }
        return meter;
    }
    getTracer(name) {
        let tracer = this.tracers.get(name);
        if (!tracer) {
            tracer = this.traceProvider.getTracer(name, this.resource.attributes[ATTR_SERVICE_VERSION]);
            this.tracers.set(name, tracer);
        }
        return tracer;
    }
    start() {
        this.log.info('Starting OpenTelemetry client');
        diag.setLogger(new DiagConsoleLogger(), DiagLogLevel.INFO);
        // Add a callback to the logger to set context data from current trace
        // Adapted from open-telemetry/opentelemetry-js-contrib PinoInstrumentation._getMixinFunction
        addLogDataHandler((data)=>{
            const spanContext = trace.getSpan(context.active())?.spanContext();
            return spanContext && isSpanContextValid(spanContext) ? {
                ...data,
                ['trace_id']: spanContext.traceId,
                ['span_id']: spanContext.spanId,
                ['trace_flags']: `0${spanContext.traceFlags.toString(16)}`
            } : data;
        });
        this.hostMetrics = new HostMetrics({
            name: this.resource.attributes[ATTR_SERVICE_NAME],
            meterProvider: this.meterProvider
        });
        const nodejsMeter = new WrappedMeter(this.meterProvider.getMeter(this.resource.attributes[ATTR_SERVICE_NAME]));
        this.nodejsMetricsMonitor = new NodejsMetricsMonitor(nodejsMeter);
        this.hostMetrics.start();
        this.nodejsMetricsMonitor.start();
    }
    isEnabled() {
        return true;
    }
    async flush() {
        await Promise.all([
            this.meterProvider.forceFlush(),
            this.loggerProvider?.forceFlush(),
            this.traceProvider instanceof NodeTracerProvider ? this.traceProvider.forceFlush() : Promise.resolve()
        ]);
    }
    async stop() {
        this.nodejsMetricsMonitor?.stop();
        const flushAndShutdown = async (provider)=>{
            if (!provider) {
                return;
            }
            await provider.forceFlush();
            await provider.shutdown();
        };
        await Promise.all([
            flushAndShutdown(this.meterProvider),
            flushAndShutdown(this.loggerProvider),
            this.traceProvider instanceof NodeTracerProvider ? flushAndShutdown(this.traceProvider) : Promise.resolve()
        ]);
    }
    getTraceContext() {
        const carrier = {};
        propagation.inject(context.active(), carrier);
        return carrier['traceparent'];
    }
    extractPropagatedContext(traceContext) {
        const extractedContext = propagation.extract(ROOT_CONTEXT, {
            traceparent: traceContext
        });
        return extractedContext;
    }
    static createMeterProvider(resource, exporters) {
        return new MeterProvider({
            resource,
            readers: exporters.map((options)=>new PeriodicExportingMetricReader(options)),
            views: [
                // Every histogram matching the selector (type + unit) gets these custom buckets assigned
                new View({
                    instrumentType: InstrumentType.HISTOGRAM,
                    instrumentUnit: 'Mmana',
                    aggregation: new ExplicitBucketHistogramAggregation([
                        0.1,
                        0.5,
                        1,
                        2,
                        4,
                        8,
                        10,
                        25,
                        50,
                        100,
                        500,
                        1000,
                        5000,
                        10000
                    ], true)
                }),
                new View({
                    instrumentType: InstrumentType.HISTOGRAM,
                    instrumentUnit: 'tx',
                    aggregation: new ExplicitBucketHistogramAggregation(// TPS
                    [
                        0.1 * 36,
                        0.2 * 36,
                        0.5 * 36,
                        1 * 36,
                        2 * 36,
                        5 * 36,
                        10 * 36,
                        15 * 36
                    ].map(Math.ceil), true)
                }),
                new View({
                    instrumentType: InstrumentType.HISTOGRAM,
                    instrumentUnit: 's',
                    aggregation: new ExplicitBucketHistogramAggregation([
                        1,
                        2,
                        4,
                        6,
                        10,
                        15,
                        30,
                        60,
                        90,
                        120,
                        180,
                        240,
                        300,
                        480,
                        600,
                        900,
                        1200
                    ], true)
                }),
                new View({
                    instrumentType: InstrumentType.HISTOGRAM,
                    instrumentUnit: 'ms',
                    aggregation: new ExplicitBucketHistogramAggregation(// 10ms to 1 minute
                    [
                        10,
                        20,
                        35,
                        50,
                        75,
                        100,
                        250,
                        500,
                        750,
                        1_000,
                        2_500,
                        5_000,
                        7_500,
                        10_000,
                        15_000,
                        30_000,
                        60_000
                    ], true)
                }),
                new View({
                    instrumentType: InstrumentType.HISTOGRAM,
                    instrumentUnit: 'us',
                    aggregation: new ExplicitBucketHistogramAggregation(// 1us to 1s
                    [
                        5,
                        10,
                        25,
                        50,
                        75,
                        100,
                        250,
                        500,
                        750,
                        1_000,
                        2_500,
                        5_000,
                        7_500,
                        10_000,
                        25_000,
                        50_000,
                        100_000,
                        250_000,
                        500_000,
                        1_000_000
                    ], true)
                }),
                new View({
                    instrumentType: InstrumentType.HISTOGRAM,
                    instrumentUnit: 'By',
                    aggregation: new ExplicitBucketHistogramAggregation(// from 32 bytes to 2MB
                    [
                        32,
                        64,
                        128,
                        256,
                        512,
                        1024,
                        2048,
                        4096,
                        8192,
                        16384,
                        32768,
                        65536,
                        131072,
                        262144,
                        524288,
                        1048576,
                        1572864,
                        2097152
                    ], true)
                }),
                new View({
                    instrumentType: InstrumentType.HISTOGRAM,
                    instrumentUnit: 'gas/s',
                    aggregation: new ExplicitBucketHistogramAggregation([
                        1_000,
                        5_000,
                        10_000,
                        25_000,
                        50_000,
                        100_000,
                        250_000,
                        500_000,
                        750_000,
                        1_000_000,
                        2_000_000,
                        4_000_000,
                        8_000_000,
                        10_000_000,
                        15_000_000,
                        30_000_000
                    ], true)
                }),
                new View({
                    instrumentType: InstrumentType.HISTOGRAM,
                    instrumentUnit: 'mana/s',
                    aggregation: new ExplicitBucketHistogramAggregation([
                        1_000,
                        5_000,
                        10_000,
                        25_000,
                        50_000,
                        100_000,
                        250_000,
                        500_000,
                        750_000,
                        1_000_000,
                        2_000_000,
                        4_000_000,
                        8_000_000,
                        10_000_000,
                        15_000_000,
                        30_000_000
                    ], true)
                }),
                new View({
                    instrumentType: InstrumentType.HISTOGRAM,
                    instrumentUnit: 'gas/block',
                    aggregation: new ExplicitBucketHistogramAggregation([
                        1_000,
                        5_000,
                        10_000,
                        25_000,
                        50_000,
                        100_000,
                        250_000,
                        500_000,
                        750_000,
                        1_000_000,
                        2_000_000,
                        4_000_000,
                        8_000_000,
                        10_000_000,
                        15_000_000,
                        30_000_000
                    ], true)
                }),
                new View({
                    instrumentType: InstrumentType.HISTOGRAM,
                    instrumentUnit: 'gas/tx',
                    aggregation: new ExplicitBucketHistogramAggregation([
                        25_000,
                        50_000,
                        100_000,
                        250_000,
                        500_000,
                        750_000,
                        1_000_000,
                        2_000_000,
                        4_000_000,
                        8_000_000,
                        10_000_000,
                        15_000_000,
                        30_000_000
                    ], true)
                })
            ]
        });
    }
    static getCustomClientFactory(config) {
        return (resource, log)=>{
            const tracerProvider = new NodeTracerProvider({
                resource,
                spanProcessors: config.tracesCollectorUrl ? [
                    new BatchSpanProcessor(new OTLPTraceExporter({
                        url: config.tracesCollectorUrl.href
                    }))
                ] : []
            });
            tracerProvider.register({
                propagator: new W3CTraceContextPropagator()
            });
            const exporters = [];
            if (config.metricsCollectorUrl) {
                // Default to a blacklist that is empty (allow all metrics)
                let filter = [];
                let mode = 'deny';
                if (config.otelExcludeMetrics.length > 0) {
                    // Implement a blacklist as specified in config
                    log.info(`Excluding metrics from export: ${config.otelExcludeMetrics}`);
                    filter = config.otelExcludeMetrics;
                    mode = 'deny';
                } else if (config.otelIncludeMetrics.length > 0) {
                    // Implement a whitelist as specified in config
                    log.info(`Including only specified metrics for export: ${config.otelIncludeMetrics}`);
                    filter = config.otelIncludeMetrics;
                    mode = 'allow';
                }
                exporters.push({
                    exporter: new OtelFilterMetricExporter(new OTLPMetricExporter({
                        url: config.metricsCollectorUrl.href
                    }), filter, mode),
                    exportTimeoutMillis: config.otelExportTimeoutMs,
                    exportIntervalMillis: config.otelCollectIntervalMs
                });
            }
            let publicExporter;
            if (config.publicMetricsCollectorUrl && !config.publicMetricsOptOut) {
                log.info(`Exporting public metrics: ${config.publicIncludeMetrics}`, {
                    publicMetrics: config.publicIncludeMetrics,
                    collectorUrl: config.publicMetricsCollectorUrl
                });
                publicExporter = new PublicOtelFilterMetricExporter(config.publicMetricsCollectFrom, new OTLPMetricExporter({
                    url: config.publicMetricsCollectorUrl.href
                }), config.publicIncludeMetrics);
                exporters.push({
                    exporter: publicExporter,
                    exportTimeoutMillis: config.otelExportTimeoutMs,
                    exportIntervalMillis: config.otelCollectIntervalMs
                });
            }
            const meterProvider = OpenTelemetryClient.createMeterProvider(resource, exporters);
            const loggerProvider = registerOtelLoggerProvider(resource, config.logsCollectorUrl);
            return new OpenTelemetryClient(resource, meterProvider, tracerProvider, loggerProvider, publicExporter, log);
        };
    }
    static createAndStart(config, log) {
        const resource = getOtelResource();
        const factory = OpenTelemetryClient.getCustomClientFactory(config);
        const service = factory(resource, log);
        service.start();
        return service;
    }
}
