import { type AttributeValue, type BatchObservableCallback, type Context, type MetricOptions, type Observable, type BatchObservableResult as OtelBatchObservableResult, type Gauge as OtelGauge, type Histogram as OtelHistogram, type ObservableGauge as OtelObservableGauge, type ObservableResult as OtelObservableResult, type ObservableUpDownCounter as OtelObservableUpDownCounter, type UpDownCounter as OtelUpDownCounter, type Span, type Tracer } from '@opentelemetry/api';
import type * as Attributes from './attributes.js';
import type { MetricDefinition } from './metrics.js';
export { toMetricOptions, createUpDownCounterWithDefault } from './metric-utils.js';
export { type Span, SpanStatusCode, ValueType, type Context } from '@opentelemetry/api';
type ValuesOf<T> = T extends Record<string, infer U> ? U : never;
type AttributeNames = ValuesOf<typeof Attributes>;
/**
 * This is a set of attributes that could lead to high cardinality in the metrics.
 * If you find yourself wanting to capture this data in a metric consider if it makes sense to capture
 * as the metric value instead of an attribute or consider logging instead.
 *
 * Think twice before removing an attribute from this list.
 */
type BannedMetricAttributeNames = (typeof Attributes)['BLOCK_NUMBER' | 'BLOCK_ARCHIVE' | 'SLOT_NUMBER' | 'BLOCK_PARENT' | 'BLOCK_CANDIDATE_TXS_COUNT' | 'BLOCK_TXS_COUNT' | 'BLOCK_SIZE' | 'EPOCH_SIZE' | 'EPOCH_NUMBER' | 'TX_HASH' | 'PROVING_JOB_ID' | 'P2P_ID' | 'P2P_REQ_RESP_BATCH_REQUESTS_COUNT' | 'TARGET_ADDRESS' | 'MANA_USED' | 'TOTAL_INSTRUCTIONS'];
/** Global registry of attributes */
export type AttributesType = Partial<Record<AttributeNames, AttributeValue>>;
export type AllowedAttributeNames = Exclude<AttributeNames, BannedMetricAttributeNames>;
/** Subset of attributes allowed to be added to metrics */
export type MetricAttributesType = Partial<Record<AllowedAttributeNames, AttributeValue>>;
/** Re-export MetricDefinition for convenience */
export type { MetricDefinition } from './metrics.js';
export type Gauge = OtelGauge<MetricAttributesType>;
export type Histogram = OtelHistogram<MetricAttributesType>;
export type UpDownCounter = OtelUpDownCounter<MetricAttributesType>;
export type ObservableGauge = OtelObservableGauge<MetricAttributesType>;
export type ObservableUpDownCounter = OtelObservableUpDownCounter<MetricAttributesType>;
export type ObservableResult = OtelObservableResult<MetricAttributesType>;
export type BatchObservableResult = OtelBatchObservableResult<MetricAttributesType>;
export type { Tracer };
/**
 * A meter that provides instruments for recording metrics.
 */
export interface Meter {
    /**
     * Creates a new gauge instrument. A gauge is a metric that represents a single numerical value that can arbitrarily go up and down.
     * @param metric - The metric definition
     */
    createGauge(metric: MetricDefinition): Gauge;
    /**
     * Creates a new observable gauge instrument. A gauge is a metric that represents a single numerical value that can arbitrarily go up and down.
     * @param metric - The metric definition
     */
    createObservableGauge(metric: MetricDefinition): ObservableGauge;
    addBatchObservableCallback(callback: BatchObservableCallback<AttributesType>, observables: Observable<AttributesType>[]): void;
    removeBatchObservableCallback(callback: BatchObservableCallback<AttributesType>, observables: Observable<AttributesType>[]): void;
    /**
     * Creates a new histogram instrument. A histogram is a metric that samples observations (usually things like request durations or response sizes) and counts them in configurable buckets.
     * @param metric - The metric definition
     * @param extraOptions - Optional extra options (e.g., advice for bucket boundaries)
     */
    createHistogram(metric: MetricDefinition, extraOptions?: Partial<MetricOptions>): Histogram;
    /**
     * Creates a new counter instrument. A counter can go up or down with a delta from the previous value.
     * @param metric - The metric definition
     */
    createUpDownCounter(metric: MetricDefinition): UpDownCounter;
    /**
     * Creates a new observable up/down counter instrument.
     * @param metric - The metric definition
     */
    createObservableUpDownCounter(metric: MetricDefinition): ObservableUpDownCounter;
}
/**
 * A telemetry client that provides meters for recording metrics.
 */
export interface TelemetryClient {
    /**
     * Whether the client is enabled and reporting metrics.
     **/
    isEnabled(): boolean;
    /**
     * Creates a new meter
     * @param name - The name of the meter.
     */
    getMeter(name: string): Meter;
    /**
     * Creates a new tracer
     * @param name - The name of the tracer.
     */
    getTracer(name: string): Tracer;
    /**
     * Stops the telemetry client.
     */
    stop(): Promise<void>;
    /**
     * Flushes the telemetry client.
     */
    flush(): Promise<void>;
    /**
     * Updates what telemetry is exported to the public collector
     */
    setExportedPublicTelemetry(prefixes: string[]): void;
    /**
     * Updates the roles that would share telemetry (if enabled)
     */
    setPublicTelemetryCollectFrom(roles: string[]): void;
    /**
     * Get current trace context as an opaque string for propagation.
     * Returns the W3C traceparent header value if a trace is active, undefined otherwise.
     */
    getTraceContext(): string | undefined;
    /**
     * Recreates a context propagated by a remote system
     */
    extractPropagatedContext(traceContext: string): Context | undefined;
}
/** Objects that adhere to this interface can use @trackSpan */
export interface Traceable {
    tracer: Tracer;
}
type SpanDecorator<T extends Traceable, F extends (...args: any[]) => any> = (originalMethod: F, context: ClassMethodDecoratorContext<T>) => F;
/**
 * Starts a new span whenever the decorated method is called.
 * @param spanName - The name of the span to create. Can be a string or a function that returns a string.
 * @param attributes - Initial attributes to set on the span. If a function is provided, it will be called with the arguments of the method.
 * @param extraAttributes - Extra attributes to set on the span after the method is called. Will be called with the return value of the method. Note: if the function throws then this will not be called.
 * @returns A decorator that wraps the method in a span.
 *
 * @privateRemarks
 * This code looks complex but it's not that difficult:
 * - decorators are functions that _replace_ a method with a different implementation
 * - normal decorators can't take function arguments, but if we write a function that returns a decorator, we can pass arguments to that function
 *
 * The trackSpan function takes a span's name and some attributes and builds a decorator that wraps a method in a span with the given name and props
 * The decorator can currently only be applied to methods on classes that have a `tracer` property. The compiler will enforce this.
 */
export declare function trackSpan<T extends Traceable, F extends (...args: any[]) => any>(spanName: string | ((this: T, ...args: Parameters<F>) => string), attributes?: AttributesType | ((this: T, ...args: Parameters<F>) => Promise<AttributesType> | AttributesType), extraAttributes?: (this: T, returnValue: Awaited<ReturnType<F>>) => AttributesType): SpanDecorator<T, F>;
/**
 * Runs an event callback in a span. The span is started immediately and completes once the callback finishes running.
 * The span will have two events added: 'callbackStart' and 'callbackEnd' to mark the start and end of the callback.
 *
 * @param tracer - The tracer instance to use
 * @param spanName - The name of the span to create
 * @param attributes - Initial attributes to set on the span
 * @param callback - The callback to wrap in a span
 *
 * @returns - A new function that wraps the callback in a span
 */
export declare function wrapCallbackInSpan<F extends (...args: any[]) => any>(tracer: Tracer, spanName: string, attributes: AttributesType, callback: F): F;
export declare function runInSpan<A extends any[], R>(tracer: Tracer | string, spanName: string, callback: (span: Span, ...args: A) => Promise<R>): (...args: A) => Promise<R>;
/**
 * Execute a callback within a span immediately (for one-off traced calls).
 * Unlike runInSpan which returns a reusable function, this executes right away.
 */
export declare function execInSpan<R>(tracer: Tracer | string, spanName: string, callback: (span: Span) => Promise<R>): Promise<R>;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVsZW1ldHJ5LmQudHMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdGVsZW1ldHJ5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxLQUFLLGNBQWMsRUFDbkIsS0FBSyx1QkFBdUIsRUFDNUIsS0FBSyxPQUFPLEVBQ1osS0FBSyxhQUFhLEVBQ2xCLEtBQUssVUFBVSxFQUNmLEtBQUsscUJBQXFCLElBQUkseUJBQXlCLEVBQ3ZELEtBQUssS0FBSyxJQUFJLFNBQVMsRUFDdkIsS0FBSyxTQUFTLElBQUksYUFBYSxFQUMvQixLQUFLLGVBQWUsSUFBSSxtQkFBbUIsRUFDM0MsS0FBSyxnQkFBZ0IsSUFBSSxvQkFBb0IsRUFDN0MsS0FBSyx1QkFBdUIsSUFBSSwyQkFBMkIsRUFDM0QsS0FBSyxhQUFhLElBQUksaUJBQWlCLEVBQ3ZDLEtBQUssSUFBSSxFQUVULEtBQUssTUFBTSxFQUNaLE1BQU0sb0JBQW9CLENBQUM7QUFFNUIsT0FBTyxLQUFLLEtBQUssVUFBVSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sS0FBSyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBR3JELE9BQU8sRUFBRSxlQUFlLEVBQUUsOEJBQThCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUVwRixPQUFPLEVBQUUsS0FBSyxJQUFJLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxLQUFLLE9BQU8sRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXhGLEtBQUssUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7QUFFakUsS0FBSyxjQUFjLEdBQUcsUUFBUSxDQUFDLE9BQU8sVUFBVSxDQUFDLENBQUM7QUFFbEQ7Ozs7OztHQU1HO0FBQ0gsS0FBSywwQkFBMEIsR0FBRyxDQUFDLE9BQU8sVUFBVSxDQUFDLENBQ2pELGNBQWMsR0FDZCxlQUFlLEdBQ2YsYUFBYSxHQUNiLGNBQWMsR0FDZCwyQkFBMkIsR0FDM0IsaUJBQWlCLEdBQ2pCLFlBQVksR0FDWixZQUFZLEdBQ1osY0FBYyxHQUNkLFNBQVMsR0FDVCxnQkFBZ0IsR0FDaEIsUUFBUSxHQUNSLG1DQUFtQyxHQUNuQyxnQkFBZ0IsR0FDaEIsV0FBVyxHQUNYLG9CQUFvQixDQUFDLENBQUM7QUFFMUIsb0NBQW9DO0FBQ3BDLE1BQU0sTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztBQUU3RSxNQUFNLE1BQU0scUJBQXFCLEdBQUcsT0FBTyxDQUFDLGNBQWMsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO0FBRXhGLDBEQUEwRDtBQUMxRCxNQUFNLE1BQU0sb0JBQW9CLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO0FBRTFGLGlEQUFpRDtBQUNqRCxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFFckQsTUFBTSxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUNwRCxNQUFNLE1BQU0sU0FBUyxHQUFHLGFBQWEsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQzVELE1BQU0sTUFBTSxhQUFhLEdBQUcsaUJBQWlCLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUNwRSxNQUFNLE1BQU0sZUFBZSxHQUFHLG1CQUFtQixDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDeEUsTUFBTSxNQUFNLHVCQUF1QixHQUFHLDJCQUEyQixDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDeEYsTUFBTSxNQUFNLGdCQUFnQixHQUFHLG9CQUFvQixDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDMUUsTUFBTSxNQUFNLHFCQUFxQixHQUFHLHlCQUF5QixDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFFcEYsWUFBWSxFQUFFLE1BQU0sRUFBRSxDQUFDO0FBR3ZCOztHQUVHO0FBQ0gsTUFBTSxXQUFXLEtBQUs7SUFDcEI7OztPQUdHO0lBQ0gsV0FBVyxDQUFDLE1BQU0sRUFBRSxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7SUFFN0M7OztPQUdHO0lBQ0gscUJBQXFCLENBQUMsTUFBTSxFQUFFLGdCQUFnQixHQUFHLGVBQWUsQ0FBQztJQUVqRSwwQkFBMEIsQ0FDeEIsUUFBUSxFQUFFLHVCQUF1QixDQUFDLGNBQWMsQ0FBQyxFQUNqRCxXQUFXLEVBQUUsVUFBVSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEdBQ3hDLElBQUksQ0FBQztJQUVSLDZCQUE2QixDQUMzQixRQUFRLEVBQUUsdUJBQXVCLENBQUMsY0FBYyxDQUFDLEVBQ2pELFdBQVcsRUFBRSxVQUFVLENBQUMsY0FBYyxDQUFDLEVBQUUsR0FDeEMsSUFBSSxDQUFDO0lBRVI7Ozs7T0FJRztJQUNILGVBQWUsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsWUFBWSxDQUFDLEVBQUUsT0FBTyxDQUFDLGFBQWEsQ0FBQyxHQUFHLFNBQVMsQ0FBQztJQUU1Rjs7O09BR0c7SUFDSCxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLEdBQUcsYUFBYSxDQUFDO0lBRTdEOzs7T0FHRztJQUNILDZCQUE2QixDQUFDLE1BQU0sRUFBRSxnQkFBZ0IsR0FBRyx1QkFBdUIsQ0FBQztDQUNsRjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxXQUFXLGVBQWU7SUFDOUI7O1FBRUk7SUFDSixTQUFTLElBQUksT0FBTyxDQUFDO0lBQ3JCOzs7T0FHRztJQUNILFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUU5Qjs7O09BR0c7SUFDSCxTQUFTLENBQUMsSUFBSSxFQUFFLE1BQU0sR0FBRyxNQUFNLENBQUM7SUFFaEM7O09BRUc7SUFDSCxJQUFJLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXRCOztPQUVHO0lBQ0gsS0FBSyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV2Qjs7T0FFRztJQUNILDBCQUEwQixDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUM7SUFFckQ7O09BRUc7SUFDSCw2QkFBNkIsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBRXJEOzs7T0FHRztJQUNILGVBQWUsSUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFDO0lBRXRDOztPQUVHO0lBQ0gsd0JBQXdCLENBQUMsWUFBWSxFQUFFLE1BQU0sR0FBRyxPQUFPLEdBQUcsU0FBUyxDQUFDO0NBQ3JFO0FBRUQsK0RBQStEO0FBQy9ELE1BQU0sV0FBVyxTQUFTO0lBQ3hCLE1BQU0sRUFBRSxNQUFNLENBQUM7Q0FDaEI7QUFFRCxLQUFLLGFBQWEsQ0FBQyxDQUFDLFNBQVMsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxFQUFFLEdBQUcsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUMzRSxjQUFjLEVBQUUsQ0FBQyxFQUNqQixPQUFPLEVBQUUsMkJBQTJCLENBQUMsQ0FBQyxDQUFDLEtBQ3BDLENBQUMsQ0FBQztBQUVQOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsd0JBQWdCLFNBQVMsQ0FBQyxDQUFDLFNBQVMsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxFQUFFLEdBQUcsRUFBRSxLQUFLLEdBQUcsRUFDOUUsUUFBUSxFQUFFLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxHQUFHLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDLEVBQ2hFLFVBQVUsQ0FBQyxFQUFFLGNBQWMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxHQUFHLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssT0FBTyxDQUFDLGNBQWMsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxFQUM3RyxlQUFlLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxjQUFjLEdBQ2pGLGFBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBNkNyQjtBQUVEOzs7Ozs7Ozs7O0dBVUc7QUFDSCx3QkFBZ0Isa0JBQWtCLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLEVBQUUsR0FBRyxFQUFFLEtBQUssR0FBRyxFQUNsRSxNQUFNLEVBQUUsTUFBTSxFQUNkLFFBQVEsRUFBRSxNQUFNLEVBQ2hCLFVBQVUsRUFBRSxjQUFjLEVBQzFCLFFBQVEsRUFBRSxDQUFDLEdBQ1YsQ0FBQyxDQWtCSDtBQUVELHdCQUFnQixTQUFTLENBQUMsQ0FBQyxTQUFTLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFDMUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxNQUFNLEVBQ3ZCLFFBQVEsRUFBRSxNQUFNLEVBQ2hCLFFBQVEsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxLQUFLLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FDL0MsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxDQXlCNUI7QUFFRDs7O0dBR0c7QUFDSCx3QkFBZ0IsVUFBVSxDQUFDLENBQUMsRUFDMUIsTUFBTSxFQUFFLE1BQU0sR0FBRyxNQUFNLEVBQ3ZCLFFBQVEsRUFBRSxNQUFNLEVBQ2hCLFFBQVEsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUNuQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBaUJaIn0=