import { createLogger } from '@aztec/foundation/log';
import { Timer } from '@aztec/foundation/timer';
import { Registry } from 'prom-client';
export var MessageSource = /*#__PURE__*/ function(MessageSource) {
    MessageSource["forward"] = "forward";
    MessageSource["publish"] = "publish";
    return MessageSource;
}({});
/**Otel MetricsType Adapters
 *
 * Some dependencies we use export metrics directly in a Prometheus format
 * This adapter is used to convert those metrics to a format that we can use with OpenTelemetry
 *
 * Affected services include:
 * - chainsafe/gossipsub
 * - libp2p
 */ export class OtelGauge {
    logger;
    labelNames;
    gauge;
    currentValue;
    labeledValues;
    collectFns;
    _collect;
    get collect() {
        return this._collect;
    }
    set collect(fn) {
        this._collect = fn;
    }
    constructor(logger, meter, name, help, labelNames = []){
        this.logger = logger;
        this.labelNames = labelNames;
        this.currentValue = 0;
        this.labeledValues = new Map();
        this.collectFns = [];
        this._collect = ()=>{};
        const metricDef = {
            name,
            description: help
        };
        this.gauge = meter.createObservableGauge(metricDef);
        // Only observe in the callback when collect() is called
        this.gauge.addCallback(this.handleObservation.bind(this));
    }
    /**
   * Add a collect callback
   * @param collectFn - Callback function
   */ addCollect(collectFn) {
        this.collectFns.push(collectFn);
    }
    handleObservation(result) {
        // Execute the main collect function if assigned
        this._collect();
        // Execute all the collect functions
        for (const fn of this.collectFns){
            fn(this);
        }
        // Report the current values
        if (this.labelNames.length === 0) {
            result.observe(this.currentValue);
            return;
        }
        for (const [labelStr, value] of this.labeledValues.entries()){
            const labels = parseLabelsSafely(labelStr, this.logger);
            if (labels) {
                result.observe(value, labels);
            }
        }
    }
    inc(labelsOrValue, value) {
        if (typeof labelsOrValue === 'number') {
            this.currentValue += labelsOrValue;
            return;
        }
        if (labelsOrValue) {
            validateLabels(labelsOrValue, this.labelNames, 'Gauge');
            const labelKey = JSON.stringify(labelsOrValue);
            const currentValue = this.labeledValues.get(labelKey) ?? 0;
            this.labeledValues.set(labelKey, currentValue + (value ?? 1));
            return;
        }
        this.currentValue += value ?? 1;
    }
    set(labelsOrValue, value) {
        if (typeof labelsOrValue === 'number') {
            this.currentValue = labelsOrValue;
            return;
        }
        validateLabels(labelsOrValue, this.labelNames, 'Gauge');
        const labelKey = JSON.stringify(labelsOrValue);
        this.labeledValues.set(labelKey, value);
    }
    /**
   * Decrements the gauge value
   * @param labels - Optional labels object
   */ dec(labels) {
        if (labels) {
            validateLabels(labels, this.labelNames, 'Gauge');
            const labelKey = JSON.stringify(labels);
            const currentValue = this.labeledValues.get(labelKey) ?? 0;
            this.labeledValues.set(labelKey, currentValue - 1);
            return;
        }
        this.currentValue -= 1;
    }
    /**
   * Resets the gauge to initial state
   */ reset() {
        this.currentValue = 0;
        this.labeledValues.clear();
    }
}
/**
 * Implementation of a Histogram collector
 */ export class OtelHistogram {
    logger;
    labelNames;
    histogram;
    constructor(logger, meter, name, help, buckets = [], labelNames = []){
        this.logger = logger;
        this.labelNames = labelNames;
        const metricDef = {
            name,
            description: help
        };
        this.histogram = meter.createHistogram(metricDef, {
            advice: buckets.length ? {
                explicitBucketBoundaries: buckets
            } : undefined
        });
    }
    /**
   * Starts a timer and returns a function that when called will record the time elapsed
   * @param labels - Optional labels for the observation
   */ startTimer(labels) {
        if (labels) {
            validateLabels(labels, this.labelNames, 'Histogram');
        }
        const timer = new Timer();
        return ()=>{
            // Use timer.s() here to get the duration in seconds since this is only currently used by gossipsub_heartbeat_duration_seconds
            const duration = timer.s();
            if (labels) {
                this.observe(labels, duration);
            } else {
                this.observe(duration);
            }
        };
    }
    observe(labelsOrValue, value) {
        if (typeof labelsOrValue === 'number') {
            this.histogram.record(labelsOrValue);
        } else {
            validateLabels(labelsOrValue, this.labelNames, 'Histogram');
            this.histogram.record(value, labelsOrValue);
        }
    }
    reset() {
        // OpenTelemetry histograms cannot be reset, but we implement the interface
        this.logger.silent('OpenTelemetry histograms cannot be fully reset');
    }
}
/**
 * Implementation of an AvgMinMax collector
 */ export class OtelAvgMinMax {
    logger;
    labelNames;
    gauges;
    currentValues;
    labeledValues;
    constructor(logger, meter, name, help, labelNames = []){
        this.logger = logger;
        this.labelNames = labelNames;
        this.currentValues = [];
        this.labeledValues = new Map();
        // Create three separate gauges for avg, min, and max
        this.gauges = {
            avg: meter.createObservableGauge({
                name: `${name}_avg`,
                description: `${help} (average)`
            }),
            min: meter.createObservableGauge({
                name: `${name}_min`,
                description: `${help} (minimum)`
            }),
            max: meter.createObservableGauge({
                name: `${name}_max`,
                description: `${help} (maximum)`
            })
        };
        // Register callbacks for each gauge
        this.gauges.avg.addCallback(this.observeAvg.bind(this));
        this.gauges.min.addCallback(this.observeMin.bind(this));
        this.gauges.max.addCallback(this.observeMax.bind(this));
    }
    set(labelsOrValues, values) {
        if (Array.isArray(labelsOrValues)) {
            this.currentValues = labelsOrValues;
            return;
        } else {
            validateLabels(labelsOrValues, this.labelNames, 'AvgMinMax');
            const labelKey = JSON.stringify(labelsOrValues);
            this.labeledValues.set(labelKey, values || []);
        }
    }
    /**
   * Resets all stored values
   */ reset() {
        this.currentValues = [];
        this.labeledValues.clear();
    }
    /**
   * General function to observe an aggregation
   * @param result - Observer result
   * @param aggregateFn - Function that calculates the aggregation
   */ observeAggregation(result, aggregateFn) {
        // Observe unlabeled values
        if (this.currentValues.length > 0) {
            result.observe(aggregateFn(this.currentValues));
        }
        // Observe labeled values
        for (const [labelStr, values] of this.labeledValues.entries()){
            if (values.length > 0) {
                const labels = parseLabelsSafely(labelStr, this.logger);
                if (labels) {
                    result.observe(aggregateFn(values), labels);
                }
            }
        }
    }
    observeAvg(result) {
        this.observeAggregation(result, (arr)=>arr.reduce((sum, val)=>sum + val, 0) / arr.length);
    }
    observeMin(result) {
        this.observeAggregation(result, (arr)=>Math.min.apply(null, arr));
    }
    observeMax(result) {
        this.observeAggregation(result, (arr)=>Math.max.apply(null, arr));
    }
}
/**
 * Validates that provided labels match the expected schema
 * @param labels - Labels object to validate
 * @param labelNames - Array of allowed label names
 * @param metricType - Type of metric for error message ('Gauge', 'Histogram', 'AvgMinMax')
 * @throws Error if invalid labels are provided
 */ function validateLabels(labels, labelNames, metricType) {
    if (labelNames.length === 0) {
        throw new Error(`${metricType} was initialized without labels support`);
    }
    for (const key of Object.keys(labels)){
        if (!labelNames.includes(key)) {
            throw new Error(`Invalid label key: ${key}`);
        }
    }
}
/**
 * Safely parses label string back to object
 * @param labelStr - Stringified labels object
 * @param logger - Logger instance for error reporting
 * @returns Labels object or null if parsing fails
 */ function parseLabelsSafely(labelStr, logger) {
    try {
        return JSON.parse(labelStr);
    } catch  {
        logger.error(`Failed to parse label string: ${labelStr}`);
        return null;
    }
}
/**
 * Otel metrics Adapter
 *
 * Maps the PromClient based MetricsRegister from gossipsub and discv5 services to the Otel MetricsRegister
 */ export class OtelMetricsAdapter extends Registry {
    meter;
    logger;
    constructor(telemetryClient, bindings){
        super();
        this.logger = createLogger('telemetry:otel-metrics-adapter', bindings);
        this.meter = telemetryClient.getMeter('metrics-adapter');
    }
    gauge(configuration) {
        return new OtelGauge(this.logger, this.meter, configuration.name, configuration.help, configuration.labelNames);
    }
    histogram(configuration) {
        return new OtelHistogram(this.logger, this.meter, configuration.name, configuration.help, configuration.buckets, configuration.labelNames);
    }
    avgMinMax(configuration) {
        return new OtelAvgMinMax(this.logger, this.meter, configuration.name, configuration.help, configuration.labelNames);
    }
}
