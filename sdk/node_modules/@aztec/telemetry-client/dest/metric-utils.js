/** Extracts OpenTelemetry MetricOptions from a MetricDefinition */ export function toMetricOptions(def) {
    return {
        description: def.description,
        unit: def.unit,
        valueType: def.valueType
    };
}
/**
 * Expands an attribute values map into all combinations of attribute objects.
 * Example: { status: ['ok', 'fail'], type: ['a', 'b'] } =>
 *   [{ status: 'ok', type: 'a' }, { status: 'ok', type: 'b' }, { status: 'fail', type: 'a' }, { status: 'fail', type: 'b' }]
 */ export function expandAttributeCombinations(attrMap) {
    const keys = Object.keys(attrMap);
    if (keys.length === 0) {
        return [
            {}
        ];
    }
    const result = [];
    function generate(index, current) {
        if (index === keys.length) {
            result.push({
                ...current
            });
            return;
        }
        const key = keys[index];
        for (const value of attrMap[key]){
            current[key] = value;
            generate(index + 1, current);
        }
    }
    generate(0, {});
    return result;
}
/**
 * Creates an UpDownCounter and initializes it to 0.
 * @param meter - The meter to create the counter on
 * @param metric - The metric definition
 * @param attributes - Optional attributes for initialization. Can be:
 *   - AttributeValuesMap: mapping of attribute keys to arrays of possible values (generates cartesian product)
 *   - MetricAttributesType[]: explicit array of attribute objects
 *   - undefined: initializes without attributes
 */ export function createUpDownCounterWithDefault(meter, metric, attributes = undefined) {
    const counter = meter.createUpDownCounter(metric);
    if (attributes === undefined) {
        counter.add(0);
    } else if (Array.isArray(attributes)) {
        for (const attrs of attributes){
            counter.add(0, attrs);
        }
    } else {
        const combinations = expandAttributeCombinations(attributes);
        for (const attrs of combinations){
            counter.add(0, attrs);
        }
    }
    return counter;
}
