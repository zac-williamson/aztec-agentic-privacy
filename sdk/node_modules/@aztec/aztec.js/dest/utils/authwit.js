import { Fr } from '@aztec/foundation/curves/bn254';
import { ProtocolContractAddress } from '@aztec/protocol-contracts';
import { FunctionType } from '@aztec/stdlib/abi';
import { computeInnerAuthWitHash, computeOuterAuthWitHash } from '@aztec/stdlib/auth-witness';
import { computeVarArgsHash } from '@aztec/stdlib/hash';
import { ContractFunctionInteraction } from '../contract/contract_function_interaction.js';
/** Identifies ContractFunctionInteractionCallIntents */ export function isContractFunctionInteractionCallIntent(messageHashOrIntent) {
    return 'caller' in messageHashOrIntent && 'action' in messageHashOrIntent && messageHashOrIntent.action instanceof ContractFunctionInteraction;
}
/**
 * Compute an authentication witness message hash from an intent and metadata
 *
 * If using the `IntentInnerHash`, the consumer is the address that can "consume" the authwit, for token approvals it is the token contract itself.
 * The `innerHash` itself will be the message that a contract is allowed to execute.
 * At the point of "approval checking", the validating contract (account for private and registry for public) will be computing the message hash
 * (`H(consumer, chainid, version, inner_hash)`) where the all but the `inner_hash` is injected from the context (consumer = msg_sender),
 * and use it for the authentication check.
 * Therefore, any allowed `innerHash` will therefore also have information around where it can be spent (version, chainId) and who can spend it (consumer).
 *
 * If using the `CallIntent`, the caller is the address that is making the call, for a token approval from Alice to Bob, this would be Bob.
 * The action is then used along with the `caller` to compute the `innerHash` and the consumer.
 *
 *
 * @param intent - The intent to approve (consumer and innerHash or caller and action)
 *                 The consumer is the address that can "consume" the authwit, for token approvals it is the token contract itself.
 *                 The caller is the address that is making the call, for a token approval from Alice to Bob, this would be Bob.
 *                 The caller becomes part of the `inner_hash` and is dealt with entirely in application logic.
 * @param metadata - The metadata for the intent (chainId, version)
 * @returns The message hash for the action
 */ export const computeAuthWitMessageHash = async (intent, metadata)=>{
    const chainId = metadata.chainId;
    const version = metadata.version;
    if ('caller' in intent) {
        const call = isContractFunctionInteractionCallIntent(intent) ? await intent.action.getFunctionCall() : intent.call;
        return computeOuterAuthWitHash(call.to, chainId, version, await computeInnerAuthWitHashFromAction(intent.caller, call));
    } else {
        const inner = Buffer.isBuffer(intent.innerHash) ? Fr.fromBuffer(intent.innerHash) : intent.innerHash;
        return computeOuterAuthWitHash(intent.consumer, chainId, version, inner);
    }
};
/**
 * Compute an authentication witness message hash from an intent and metadata. This is just
 * a wrapper around computeAuthwitMessageHash that allows receiving an already computed messageHash as input
 * @param messageHashOrIntent - The precomputed messageHash or intent to approve (consumer and innerHash or caller and call/action)
 * @param metadata - The metadata for the intent (chainId, version)
 * @returns The message hash for the intent
 */ export async function getMessageHashFromIntent(messageHashOrIntent, chainInfo) {
    let messageHash;
    const { chainId, version } = chainInfo;
    if (messageHashOrIntent instanceof Fr) {
        messageHash = messageHashOrIntent;
    } else {
        messageHash = await computeAuthWitMessageHash(messageHashOrIntent, {
            chainId,
            version
        });
    }
    return messageHash;
}
/**
 * Computes the inner authwitness hash for either a function call or an action, for it to later be combined with the metadata
 * required for the outer hash and eventually the full AuthWitness.
 * @param caller - Who is going to be calling the function
 * @param action - The action to compute the inner hash from
 * @returns The inner hash for the action
 **/ export const computeInnerAuthWitHashFromAction = async (caller, action)=>{
    const call = action instanceof ContractFunctionInteraction ? await action.getFunctionCall() : action;
    return computeInnerAuthWitHash([
        caller.toField(),
        call.selector.toField(),
        await computeVarArgsHash(call.args)
    ]);
};
/**
 * Lookup the validity of an authwit in private and public contexts.
 *
 * Uses the chain id and version of the wallet.
 *
 * @param wallet - The wallet use to simulate and read the public data
 * @param onBehalfOf - The address of the "approver"
 * @param intent - The consumer and inner hash or the caller and action to lookup
 * @param witness - The computed authentication witness to check
 * @returns - A struct containing the validity of the authwit in private and public contexts.
 */ export async function lookupValidity(wallet, onBehalfOf, intent, witness) {
    let innerHash, consumer;
    if ('caller' in intent) {
        const call = isContractFunctionInteractionCallIntent(intent) ? await intent.action.getFunctionCall() : intent.call;
        innerHash = await computeInnerAuthWitHashFromAction(intent.caller, call);
        consumer = call.to;
    } else {
        ({ innerHash, consumer } = intent);
    }
    const chainInfo = await wallet.getChainInfo();
    const messageHash = await getMessageHashFromIntent(intent, chainInfo);
    const results = {
        isValidInPrivate: false,
        isValidInPublic: false
    };
    // Check private
    const lookupValidityAbi = {
        name: 'lookup_validity',
        isInitializer: false,
        functionType: FunctionType.UTILITY,
        isOnlySelf: false,
        isStatic: false,
        parameters: [
            {
                name: 'consumer',
                type: {
                    fields: [
                        {
                            name: 'inner',
                            type: {
                                kind: 'field'
                            }
                        }
                    ],
                    kind: 'struct',
                    path: 'aztec::protocol_types::address::aztec_address::AztecAddress'
                },
                visibility: 'private'
            },
            {
                name: 'inner_hash',
                type: {
                    kind: 'field'
                },
                visibility: 'private'
            }
        ],
        returnTypes: [
            {
                kind: 'boolean'
            }
        ],
        errorTypes: {}
    };
    try {
        results.isValidInPrivate = await new ContractFunctionInteraction(wallet, onBehalfOf, lookupValidityAbi, [
            consumer,
            innerHash
        ]).simulate({
            from: onBehalfOf,
            authWitnesses: [
                witness
            ]
        });
    // TODO: Narrow down the error to make sure simulation failed due to an invalid authwit
    // eslint-disable-next-line no-empty
    } catch  {}
    // check public
    const isConsumableAbi = {
        name: 'utility_is_consumable',
        isInitializer: false,
        functionType: FunctionType.UTILITY,
        isOnlySelf: false,
        isStatic: false,
        parameters: [
            {
                name: 'address',
                type: {
                    fields: [
                        {
                            name: 'inner',
                            type: {
                                kind: 'field'
                            }
                        }
                    ],
                    kind: 'struct',
                    path: 'authwit::aztec::protocol_types::address::aztec_address::AztecAddress'
                },
                visibility: 'private'
            },
            {
                name: 'message_hash',
                type: {
                    kind: 'field'
                },
                visibility: 'private'
            }
        ],
        returnTypes: [
            {
                kind: 'boolean'
            }
        ],
        errorTypes: {}
    };
    results.isValidInPublic = await new ContractFunctionInteraction(wallet, ProtocolContractAddress.AuthRegistry, isConsumableAbi, [
        onBehalfOf,
        messageHash
    ]).simulate({
        from: onBehalfOf
    });
    return results;
}
/**
 * Convenience class designed to wrap the very common interaction of setting a public authwit in the AuthRegistry contract
 */ export class SetPublicAuthwitContractInteraction extends ContractFunctionInteraction {
    from;
    constructor(wallet, from, messageHash, authorized){
        super(wallet, ProtocolContractAddress.AuthRegistry, SetPublicAuthwitContractInteraction.getSetAuthorizedAbi(), [
            messageHash,
            authorized
        ]), this.from = from;
    }
    static async create(wallet, from, messageHashOrIntent, authorized) {
        const chainInfo = await wallet.getChainInfo();
        const messageHash = await getMessageHashFromIntent(messageHashOrIntent, chainInfo);
        return new SetPublicAuthwitContractInteraction(wallet, from, messageHash, authorized);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    simulate(options = {}) {
        return super.simulate({
            ...options,
            from: this.from
        });
    }
    /**
   * Overrides the profile method, adding the sender of the authwit (authorizer) as from
   * and preventing misuse
   * @param options - Same options as `simulate`, plus profiling method
   * @returns An object containing the function return value and profile result.
   */ profile(options = {
        profileMode: 'gates'
    }) {
        return super.profile({
            ...options,
            from: this.from
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    send(options) {
        return super.send({
            ...options,
            from: this.from
        });
    }
    static getSetAuthorizedAbi() {
        return {
            name: 'set_authorized',
            isInitializer: false,
            functionType: FunctionType.PUBLIC,
            isOnlySelf: true,
            isStatic: false,
            parameters: [
                {
                    name: 'message_hash',
                    type: {
                        kind: 'field'
                    },
                    visibility: 'private'
                },
                {
                    name: 'authorize',
                    type: {
                        kind: 'boolean'
                    },
                    visibility: 'private'
                }
            ],
            returnTypes: [],
            errorTypes: {}
        };
    }
}
