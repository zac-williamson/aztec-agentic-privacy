import { Fr } from '@aztec/foundation/curves/bn254';
import { ProtocolContractAddress } from '@aztec/protocol-contracts';
import { FunctionCall, FunctionSelector, FunctionType } from '@aztec/stdlib/abi';
import { ExecutionPayload } from '@aztec/stdlib/tx';
/**
 * Pay fee directly with Fee Juice claimed in the same tx. Claiming consumes an L1 to L2 message that "contains"
 * the fee juice bridged from L1.
 */ export class FeeJuicePaymentMethodWithClaim {
    sender;
    claim;
    constructor(sender, claim){
        this.sender = sender;
        this.claim = claim;
    }
    /**
   * Creates an execution payload to pay the fee in Fee Juice.
   * @returns An execution payload that just contains the `claim_and_end_setup` function call.
   */ async getExecutionPayload() {
        const selector = await FunctionSelector.fromSignature('claim_and_end_setup((Field),u128,Field,Field)');
        return new ExecutionPayload([
            FunctionCall.from({
                name: 'claim_and_end_setup',
                to: ProtocolContractAddress.FeeJuice,
                selector,
                type: FunctionType.PRIVATE,
                hideMsgSender: false,
                isStatic: false,
                args: [
                    this.sender.toField(),
                    new Fr(this.claim.claimAmount),
                    this.claim.claimSecret,
                    new Fr(this.claim.messageLeafIndex)
                ],
                returnTypes: []
            })
        ], [], [], [], this.sender);
    }
    getAsset() {
        return Promise.resolve(ProtocolContractAddress.FeeJuice);
    }
    getFeePayer() {
        return Promise.resolve(this.sender);
    }
    getGasSettings() {
        return;
    }
}
