import { FunctionCall, FunctionSelector, FunctionType, decodeFromAbi, encodeArguments } from '@aztec/stdlib/abi';
import { collectOffchainEffects } from '@aztec/stdlib/tx';
import { ExecutionPayload, mergeExecutionPayloads } from '@aztec/stdlib/tx';
import { BaseContractInteraction } from './base_contract_interaction.js';
import { getGasLimits } from './get_gas_limits.js';
import { toProfileOptions, toSimulateOptions } from './interaction_options.js';
/**
 * This is the class that is returned when calling e.g. `contract.methods.myMethod(arg0, arg1)`.
 * It contains available interactions one can call on a method, including view.
 */ export class ContractFunctionInteraction extends BaseContractInteraction {
    contractAddress;
    functionDao;
    args;
    extraHashedArgs;
    constructor(wallet, contractAddress, functionDao, args, authWitnesses = [], capsules = [], extraHashedArgs = []){
        super(wallet, authWitnesses, capsules), this.contractAddress = contractAddress, this.functionDao = functionDao, this.args = args, this.extraHashedArgs = extraHashedArgs;
        if (args.some((arg)=>arg === undefined || arg === null)) {
            throw new Error(`All function interaction arguments must be defined and not null. Received: ${args}`);
        }
    }
    /**
   * Returns the encoded function call wrapped by this interaction
   * Useful when generating authwits
   * @returns An encoded function call
   */ async getFunctionCall() {
        const args = encodeArguments(this.functionDao, this.args);
        return FunctionCall.from({
            name: this.functionDao.name,
            to: this.contractAddress,
            selector: await FunctionSelector.fromNameAndParameters(this.functionDao.name, this.functionDao.parameters),
            type: this.functionDao.functionType,
            hideMsgSender: false,
            isStatic: this.functionDao.isStatic,
            args,
            returnTypes: this.functionDao.returnTypes
        });
    }
    /**
   * Returns the execution payload that allows this operation to happen on chain.
   * @param options - Configuration options.
   * @returns The execution payload for this operation
   */ async request(options = {}) {
        const calls = [
            await this.getFunctionCall()
        ];
        const { authWitnesses, capsules } = options;
        const feeExecutionPayload = options.fee?.paymentMethod ? await options.fee.paymentMethod.getExecutionPayload() : undefined;
        const functionExecutionPayload = new ExecutionPayload(calls, this.authWitnesses.concat(authWitnesses ?? []), this.capsules.concat(capsules ?? []), this.extraHashedArgs);
        const finalExecutionPayload = feeExecutionPayload ? mergeExecutionPayloads([
            feeExecutionPayload,
            functionExecutionPayload
        ]) : functionExecutionPayload;
        return finalExecutionPayload;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async simulate(options) {
        // docs:end:simulate
        if (this.functionDao.functionType == FunctionType.UTILITY) {
            const call = await this.getFunctionCall();
            const utilityResult = await this.wallet.simulateUtility(call, {
                scope: options.from,
                authWitnesses: options.authWitnesses
            });
            // Decode the raw field elements to the actual return type
            const returnValue = utilityResult.result ? decodeFromAbi(this.functionDao.returnTypes, utilityResult.result) : [];
            if (options.includeMetadata) {
                return {
                    stats: utilityResult.stats,
                    result: returnValue
                };
            } else {
                return returnValue;
            }
        }
        const executionPayload = await this.request(options);
        const simulatedTx = await this.wallet.simulateTx(executionPayload, toSimulateOptions(options));
        let rawReturnValues;
        if (this.functionDao.functionType == FunctionType.PRIVATE) {
            if (simulatedTx.getPrivateReturnValues().nested.length > 0) {
                // The function invoked is private and it was called via an account contract
                // TODO(#10631): There is a bug here: this branch might be triggered when there is no-account contract as well
                rawReturnValues = simulatedTx.getPrivateReturnValues().nested[0].values;
            } else {
                // The function invoked is private and it was called directly (without account contract)
                rawReturnValues = simulatedTx.getPrivateReturnValues().values;
            }
        } else {
            // For public functions we retrieve the first values directly from the public output.
            rawReturnValues = simulatedTx.getPublicReturnValues()?.[0]?.values;
        }
        const returnValue = rawReturnValues ? decodeFromAbi(this.functionDao.returnTypes, rawReturnValues) : [];
        if (options.includeMetadata || options.fee?.estimateGas) {
            const { gasLimits, teardownGasLimits } = getGasLimits(simulatedTx, options.fee?.estimatedGasPadding);
            this.log.verbose(`Estimated gas limits for tx: DA=${gasLimits.daGas} L2=${gasLimits.l2Gas} teardownDA=${teardownGasLimits.daGas} teardownL2=${teardownGasLimits.l2Gas}`);
            return {
                stats: simulatedTx.stats,
                offchainEffects: collectOffchainEffects(simulatedTx.privateExecutionResult),
                result: returnValue,
                estimatedGas: {
                    gasLimits,
                    teardownGasLimits
                }
            };
        } else {
            return returnValue;
        }
    }
    /**
   * Simulate a transaction and profile the gate count for each function in the transaction.
   * @param options - Same options as `simulate`, plus profiling method
   *
   * @returns An object containing the function return value and profile result.
   */ async profile(options) {
        if (this.functionDao.functionType == FunctionType.UTILITY) {
            throw new Error("Can't profile a utility function.");
        }
        const executionPayload = await this.request(options);
        return await this.wallet.profileTx(executionPayload, toProfileOptions(options));
    }
    /**
   * Augments this ContractFunctionInteraction with additional metadata, such as authWitnesses, capsules, and extraHashedArgs.
   * This is useful when creating a "batteries included" interaction, such as registering a contract class with its associated
   * capsule instead of having the user provide them externally.
   * @param options - An object containing the metadata to add to the interaction
   * @returns A new ContractFunctionInteraction with the added metadata, but calling the same original function in the same manner
   */ with({ authWitnesses = [], capsules = [], extraHashedArgs = [] }) {
        return new ContractFunctionInteraction(this.wallet, this.contractAddress, this.functionDao, this.args, this.authWitnesses.concat(authWitnesses), this.capsules.concat(capsules), this.extraHashedArgs.concat(extraHashedArgs));
    }
}
