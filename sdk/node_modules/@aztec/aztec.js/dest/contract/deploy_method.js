import { Fr } from '@aztec/foundation/curves/bn254';
import { getInitializer } from '@aztec/stdlib/abi';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { computePartialAddress, getContractClassFromArtifact, getContractInstanceFromInstantiationParams } from '@aztec/stdlib/contract';
import { collectOffchainEffects } from '@aztec/stdlib/tx';
import { mergeExecutionPayloads } from '@aztec/stdlib/tx';
import { publishContractClass } from '../deployment/publish_class.js';
import { publishInstance } from '../deployment/publish_instance.js';
import { BaseContractInteraction } from './base_contract_interaction.js';
import { ContractFunctionInteraction } from './contract_function_interaction.js';
import { getGasLimits } from './get_gas_limits.js';
import { NO_WAIT, toProfileOptions, toSendOptions, toSimulateOptions } from './interaction_options.js';
/**
 * Contract interaction for deployment.
 * Handles class publication, instance publication, and initialization of the contract.
 *
 * Note that for some contracts, a tx is not required as part of its "creation":
 * If there are no public functions, and if there are no initialization functions,
 * then technically the contract has already been "created", and all of the contract's
 * functions (private and utility) can be interacted-with immediately, without any
 * "deployment tx".
 */ export class DeployMethod extends BaseContractInteraction {
    publicKeys;
    artifact;
    postDeployCtor;
    args;
    /** The contract instance to be deployed. */ instance;
    /** Constructor function to call. */ constructorArtifact;
    constructor(publicKeys, wallet, artifact, postDeployCtor, args = [], constructorNameOrArtifact, authWitnesses = [], capsules = []){
        super(wallet, authWitnesses, capsules), this.publicKeys = publicKeys, this.artifact = artifact, this.postDeployCtor = postDeployCtor, this.args = args, this.instance = undefined;
        this.constructorArtifact = getInitializer(artifact, constructorNameOrArtifact);
    }
    /**
   * Returns the execution payload that allows this operation to happen on chain.
   * @param options - Configuration options.
   * @returns The execution payload for this operation
   */ async request(options) {
        const publication = await this.getPublicationExecutionPayload(options);
        if (!options?.skipRegistration) {
            await this.wallet.registerContract(await this.getInstance(options), this.artifact);
        }
        const initialization = await this.getInitializationExecutionPayload(options);
        const feeExecutionPayload = options?.fee?.paymentMethod ? await options.fee.paymentMethod.getExecutionPayload() : undefined;
        const finalExecutionPayload = feeExecutionPayload ? mergeExecutionPayloads([
            feeExecutionPayload,
            publication,
            initialization
        ]) : mergeExecutionPayloads([
            publication,
            initialization
        ]);
        if (!finalExecutionPayload.calls.length) {
            throw new Error(`No transactions are needed to publish or initialize contract ${this.artifact.name}`);
        }
        return finalExecutionPayload;
    }
    convertDeployOptionsToRequestOptions(options) {
        return {
            ...options,
            deployer: !options?.universalDeploy ? options.from : undefined
        };
    }
    /**
   * Converts DeployOptions to SendOptions, stripping out the returnReceipt flag if present.
   * @param options - Deploy options with wait parameter
   * @returns Send options with wait parameter
   */ convertDeployOptionsToSendOptions(options) {
        return {
            ...toSendOptions({
                ...options,
                wait: options.wait
            })
        };
    }
    /**
   * Adds this contract to the wallet and returns the Contract object.
   * @param options - Deployment options.
   */ async register(options) {
        const instance = await this.getInstance(options);
        await this.wallet.registerContract(instance, this.artifact);
        return this.postDeployCtor(instance, this.wallet);
    }
    /**
   * Returns an execution payload for:
   * - publication of the contract class and
   * - publication of the contract instance to enable public execution
   * depending on the provided options.
   * @param options - Contract creation options.
   * @returns An execution payload with potentially calls (and bytecode capsule) to the class registry and instance registry.
   */ async getPublicationExecutionPayload(options) {
        const calls = [];
        // Set contract instance object so it's available for populating the DeploySendTx object
        const instance = await this.getInstance(options);
        // Obtain contract class from artifact and check it matches the reported one by the instance.
        // TODO(@spalladino): We're unnecessarily calculating the contract class multiple times here.
        const contractClass = await getContractClassFromArtifact(this.artifact);
        if (!instance.currentContractClassId.equals(contractClass.id)) {
            throw new Error(`Contract class mismatch when deploying contract: got ${instance.currentContractClassId.toString()} from instance and ${contractClass.id.toString()} from artifact`);
        }
        // Publish the contract class if it hasn't been published already.
        if (!options?.skipClassPublication) {
            const classMetadata = await this.wallet.getContractClassMetadata(contractClass.id);
            if (!classMetadata.isContractClassPubliclyRegistered) {
                this.log.info(`Creating request for publishing contract class ${contractClass.id.toString()} as part of deployment for ${instance.address.toString()}`);
                const registerContractClassInteraction = await publishContractClass(this.wallet, this.artifact);
                calls.push(await registerContractClassInteraction.request());
            } else {
                this.log.debug(`Skipping contract class publication for ${contractClass.id.toString()} as it is already registered`);
            }
        }
        // Publish the contract instance:
        if (!options?.skipInstancePublication) {
            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/15596):
            // Read the artifact, and if there are no public functions, warn the caller that publication of the
            // contract instance is not necessary (until such time as they wish to update the instance (i.e. change its class_id)).
            const deploymentInteraction = publishInstance(this.wallet, instance);
            calls.push(await deploymentInteraction.request());
        }
        return mergeExecutionPayloads(calls);
    }
    /**
   * Returns the calls necessary to initialize the contract.
   * @param options - Deployment options.
   * @returns - An array of function calls.
   */ async getInitializationExecutionPayload(options) {
        const executionsPayloads = [];
        if (this.constructorArtifact && !options?.skipInitialization) {
            const { address } = await this.getInstance(options);
            const constructorCall = new ContractFunctionInteraction(this.wallet, address, this.constructorArtifact, this.args);
            executionsPayloads.push(await constructorCall.request());
        }
        return mergeExecutionPayloads(executionsPayloads);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async send(options) {
        const executionPayload = await this.request(this.convertDeployOptionsToRequestOptions(options));
        const sendOptions = this.convertDeployOptionsToSendOptions(options);
        if (options.wait === NO_WAIT) {
            const txHash = await this.wallet.sendTx(executionPayload, sendOptions);
            this.log.debug(`Sent deployment tx ${txHash.hash} of ${this.artifact.name} contract`);
            return txHash;
        }
        const receipt = await this.wallet.sendTx(executionPayload, sendOptions);
        this.log.debug(`Deployed ${this.artifact.name} contract in tx ${receipt.txHash}`);
        // Attach contract instance
        const instance = await this.getInstance(options);
        const contract = this.postDeployCtor(instance, this.wallet);
        // Return full receipt if requested, otherwise just the contract
        if (options.wait && typeof options.wait === 'object' && options.wait.returnReceipt) {
            return {
                ...receipt,
                contract,
                instance
            };
        }
        return contract;
    }
    /**
   * Builds the contract instance and returns it.
   *
   * @param options - An object containing various initialization and publication options.
   * @returns An instance object.
   */ async getInstance(options) {
        if (!this.instance) {
            this.instance = await getContractInstanceFromInstantiationParams(this.artifact, {
                constructorArgs: this.args,
                salt: options?.contractAddressSalt ?? Fr.random(),
                publicKeys: this.publicKeys,
                constructorArtifact: this.constructorArtifact,
                deployer: options?.deployer ? options.deployer : AztecAddress.ZERO
            });
        }
        return this.instance;
    }
    /**
   * Simulate the deployment
   *
   * @param options - An optional object containing additional configuration for the simulation.
   * @returns A simulation result object containing metadata of the execution, including gas
   * estimations (if requested via options), execution statistics and emitted offchain effects
   */ async simulate(options) {
        const executionPayload = await this.request(this.convertDeployOptionsToRequestOptions(options));
        const simulatedTx = await this.wallet.simulateTx(executionPayload, toSimulateOptions(options));
        const { gasLimits, teardownGasLimits } = getGasLimits(simulatedTx, options.fee?.estimatedGasPadding);
        this.log.verbose(`Estimated gas limits for tx: DA=${gasLimits.daGas} L2=${gasLimits.l2Gas} teardownDA=${teardownGasLimits.daGas} teardownL2=${teardownGasLimits.l2Gas}`);
        return {
            stats: simulatedTx.stats,
            offchainEffects: collectOffchainEffects(simulatedTx.privateExecutionResult),
            result: undefined,
            estimatedGas: {
                gasLimits,
                teardownGasLimits
            }
        };
    }
    /**
   * Simulate a deployment and profile the gate count for each function in the transaction.
   * @param options - Same options as `send`, plus extra profiling options.
   *
   * @returns An object containing the function return value and profile result.
   */ async profile(options) {
        const executionPayload = await this.request(this.convertDeployOptionsToRequestOptions(options));
        return await this.wallet.profileTx(executionPayload, {
            ...toProfileOptions(options),
            profileMode: options.profileMode,
            skipProofGeneration: options.skipProofGeneration
        });
    }
    /** Return this deployment address. */ get address() {
        return this.instance?.address;
    }
    /** Returns the partial address for this deployment. */ get partialAddress() {
        return this.instance && computePartialAddress(this.instance);
    }
    /**
   * Augments this DeployMethod with additional metadata, such as authWitnesses and capsules.
   * @param options - An object containing the metadata to add to the interaction
   * @returns A new DeployMethod with the added metadata, but calling the same original function in the same manner
   */ with({ authWitnesses = [], capsules = [] }) {
        return new DeployMethod(this.publicKeys, this.wallet, this.artifact, this.postDeployCtor, this.args, this.constructorArtifact?.name, this.authWitnesses.concat(authWitnesses), this.capsules.concat(capsules));
    }
}
