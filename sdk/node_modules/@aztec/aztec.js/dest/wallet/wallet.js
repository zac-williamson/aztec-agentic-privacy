import { BlockNumberPositiveSchema } from '@aztec/foundation/branded-types';
import { AbiTypeSchema, ContractArtifactSchema, FunctionCall } from '@aztec/stdlib/abi';
import { AuthWitness } from '@aztec/stdlib/auth-witness';
import { ContractInstanceWithAddressSchema } from '@aztec/stdlib/contract';
import { Gas } from '@aztec/stdlib/gas';
import { AbiDecodedSchema, optional, schemas, zodFor } from '@aztec/stdlib/schemas';
import { Capsule, HashedValues, TxHash, TxProfileResult, TxReceipt, TxSimulationResult, UtilitySimulationResult, inTxSchema } from '@aztec/stdlib/tx';
import { z } from 'zod';
import { NO_WAIT } from '../contract/interaction_options.js';
export const ExecutionPayloadSchema = z.object({
    calls: z.array(FunctionCall.schema),
    authWitnesses: z.array(AuthWitness.schema),
    capsules: z.array(Capsule.schema),
    extraHashedArgs: z.array(HashedValues.schema),
    feePayer: optional(schemas.AztecAddress)
});
export const GasSettingsOptionSchema = z.object({
    gasSettings: optional(z.object({
        gasLimits: optional(Gas.schema),
        teardownGasLimits: optional(Gas.schema),
        maxFeePerGas: optional(z.object({
            feePerDaGas: schemas.BigInt,
            feePerL2Gas: schemas.BigInt
        })),
        maxPriorityFeePerGas: optional(z.object({
            feePerDaGas: schemas.BigInt,
            feePerL2Gas: schemas.BigInt
        }))
    }))
});
export const WalletSimulationFeeOptionSchema = GasSettingsOptionSchema.extend({
    estimatedGasPadding: optional(z.number()),
    estimateGas: optional(z.boolean())
});
export const WaitOptsSchema = z.object({
    ignoreDroppedReceiptsFor: optional(z.number()),
    timeout: optional(z.number()),
    interval: optional(z.number()),
    dontThrowOnRevert: optional(z.boolean())
});
export const SendOptionsSchema = z.object({
    from: schemas.AztecAddress,
    authWitnesses: optional(z.array(AuthWitness.schema)),
    capsules: optional(z.array(Capsule.schema)),
    fee: optional(GasSettingsOptionSchema),
    wait: optional(z.union([
        z.literal(NO_WAIT),
        WaitOptsSchema
    ]))
});
export const SimulateOptionsSchema = z.object({
    from: schemas.AztecAddress,
    authWitnesses: optional(z.array(AuthWitness.schema)),
    capsules: optional(z.array(Capsule.schema)),
    fee: optional(WalletSimulationFeeOptionSchema),
    skipTxValidation: optional(z.boolean()),
    skipFeeEnforcement: optional(z.boolean()),
    includeMetadata: optional(z.boolean())
});
export const ProfileOptionsSchema = SimulateOptionsSchema.extend({
    profileMode: z.enum([
        'gates',
        'execution-steps',
        'full'
    ]),
    skipProofGeneration: optional(z.boolean())
});
export const MessageHashOrIntentSchema = z.union([
    z.object({
        consumer: schemas.AztecAddress,
        innerHash: schemas.Fr
    }),
    z.object({
        caller: schemas.AztecAddress,
        call: FunctionCall.schema
    })
]);
export const EventMetadataDefinitionSchema = z.object({
    eventSelector: schemas.EventSelector,
    abiType: AbiTypeSchema,
    fieldNames: z.array(z.string())
});
const EventFilterBaseSchema = z.object({
    txHash: optional(TxHash.schema),
    fromBlock: optional(BlockNumberPositiveSchema),
    toBlock: optional(BlockNumberPositiveSchema)
});
export const PrivateEventFilterSchema = EventFilterBaseSchema.extend({
    contractAddress: schemas.AztecAddress,
    scopes: z.array(schemas.AztecAddress)
});
export const PublicEventFilterSchema = EventFilterBaseSchema.extend({
    contractAddress: optional(schemas.AztecAddress)
});
export const PrivateEventSchema = zodFor()(z.object({
    event: AbiDecodedSchema,
    metadata: inTxSchema()
}));
export const PublicEventSchema = zodFor()(z.object({
    event: AbiDecodedSchema,
    metadata: z.intersection(inTxSchema(), z.object({
        contractAddress: schemas.AztecAddress
    }))
}));
export const ContractMetadataSchema = z.object({
    instance: optional(ContractInstanceWithAddressSchema),
    isContractInitialized: z.boolean(),
    isContractPublished: z.boolean(),
    isContractUpdated: z.boolean(),
    updatedContractClassId: optional(schemas.Fr)
});
export const ContractClassMetadataSchema = z.object({
    isArtifactRegistered: z.boolean(),
    isContractClassPubliclyRegistered: z.boolean()
});
export const ContractFunctionPatternSchema = z.object({
    contract: z.union([
        schemas.AztecAddress,
        z.literal('*')
    ]),
    function: z.union([
        z.string(),
        z.literal('*')
    ])
});
export const AccountsCapabilitySchema = z.object({
    type: z.literal('accounts'),
    canGet: optional(z.boolean()),
    canCreateAuthWit: optional(z.boolean())
});
export const GrantedAccountsCapabilitySchema = AccountsCapabilitySchema.extend({
    accounts: z.array(z.object({
        alias: z.string(),
        item: schemas.AztecAddress
    }))
});
export const ContractsCapabilitySchema = z.object({
    type: z.literal('contracts'),
    contracts: z.union([
        z.literal('*'),
        z.array(schemas.AztecAddress)
    ]),
    canRegister: optional(z.boolean()),
    canGetMetadata: optional(z.boolean())
});
export const GrantedContractsCapabilitySchema = ContractsCapabilitySchema;
export const ContractClassesCapabilitySchema = z.object({
    type: z.literal('contractClasses'),
    classes: z.union([
        z.literal('*'),
        z.array(schemas.Fr)
    ]),
    canGetMetadata: z.boolean()
});
export const GrantedContractClassesCapabilitySchema = ContractClassesCapabilitySchema;
export const SimulationCapabilitySchema = z.object({
    type: z.literal('simulation'),
    transactions: optional(z.object({
        scope: z.union([
            z.literal('*'),
            z.array(ContractFunctionPatternSchema)
        ])
    })),
    utilities: optional(z.object({
        scope: z.union([
            z.literal('*'),
            z.array(ContractFunctionPatternSchema)
        ])
    }))
});
export const GrantedSimulationCapabilitySchema = SimulationCapabilitySchema;
export const TransactionCapabilitySchema = z.object({
    type: z.literal('transaction'),
    scope: z.union([
        z.literal('*'),
        z.array(ContractFunctionPatternSchema)
    ])
});
export const GrantedTransactionCapabilitySchema = TransactionCapabilitySchema;
export const DataCapabilitySchema = z.object({
    type: z.literal('data'),
    addressBook: optional(z.boolean()),
    privateEvents: optional(z.object({
        contracts: z.union([
            z.literal('*'),
            z.array(schemas.AztecAddress)
        ])
    }))
});
export const GrantedDataCapabilitySchema = DataCapabilitySchema;
export const CapabilitySchema = z.discriminatedUnion('type', [
    AccountsCapabilitySchema,
    ContractsCapabilitySchema,
    ContractClassesCapabilitySchema,
    SimulationCapabilitySchema,
    TransactionCapabilitySchema,
    DataCapabilitySchema
]);
export const GrantedCapabilitySchema = z.discriminatedUnion('type', [
    GrantedAccountsCapabilitySchema,
    GrantedContractsCapabilitySchema,
    GrantedContractClassesCapabilitySchema,
    GrantedSimulationCapabilitySchema,
    GrantedTransactionCapabilitySchema,
    GrantedDataCapabilitySchema
]);
export const AppCapabilitiesSchema = z.object({
    version: z.literal('1.0'),
    metadata: z.object({
        name: z.string(),
        version: z.string(),
        description: optional(z.string()),
        url: optional(z.string()),
        icon: optional(z.string())
    }),
    capabilities: z.array(CapabilitySchema),
    behavior: optional(z.object({
        mode: optional(z.enum([
            'strict',
            'permissive'
        ])),
        expiration: optional(z.number())
    }))
});
export const WalletCapabilitiesSchema = z.object({
    version: z.literal('1.0'),
    granted: z.array(GrantedCapabilitySchema),
    wallet: z.object({
        name: z.string(),
        version: z.string()
    }),
    expiresAt: optional(z.number())
});
/**
 * Record of all wallet method schemas (excluding batch).
 * This is the single source of truth for method schemas - batch schemas are derived from this.
 */ const WalletMethodSchemas = {
    getChainInfo: z.function().args().returns(z.object({
        chainId: schemas.Fr,
        version: schemas.Fr
    })),
    getContractMetadata: z.function().args(schemas.AztecAddress).returns(ContractMetadataSchema),
    getContractClassMetadata: z.function().args(schemas.Fr).returns(ContractClassMetadataSchema),
    getPrivateEvents: z.function().args(EventMetadataDefinitionSchema, PrivateEventFilterSchema).returns(z.array(PrivateEventSchema)),
    registerSender: z.function().args(schemas.AztecAddress, optional(z.string())).returns(schemas.AztecAddress),
    getAddressBook: z.function().args().returns(z.array(z.object({
        alias: z.string(),
        item: schemas.AztecAddress
    }))),
    getAccounts: z.function().args().returns(z.array(z.object({
        alias: z.string(),
        item: schemas.AztecAddress
    }))),
    registerContract: z.function().args(ContractInstanceWithAddressSchema, optional(ContractArtifactSchema), optional(schemas.Fr)).returns(ContractInstanceWithAddressSchema),
    simulateTx: z.function().args(ExecutionPayloadSchema, SimulateOptionsSchema).returns(TxSimulationResult.schema),
    simulateUtility: z.function().args(FunctionCall.schema, z.object({
        scope: schemas.AztecAddress,
        authWitnesses: optional(z.array(AuthWitness.schema))
    })).returns(UtilitySimulationResult.schema),
    profileTx: z.function().args(ExecutionPayloadSchema, ProfileOptionsSchema).returns(TxProfileResult.schema),
    sendTx: z.function().args(ExecutionPayloadSchema, SendOptionsSchema).returns(z.union([
        TxHash.schema,
        TxReceipt.schema
    ])),
    createAuthWit: z.function().args(schemas.AztecAddress, MessageHashOrIntentSchema).returns(AuthWitness.schema),
    requestCapabilities: z.function().args(AppCapabilitiesSchema).returns(WalletCapabilitiesSchema)
};
/**
 * Creates batch schemas from the individual wallet methods.
 * This allows us to define them once and derive batch schemas automatically,
 * reducing duplication and ensuring consistency.
 */ function createBatchSchemas(methodSchemas) {
    const names = Object.keys(methodSchemas);
    const namesAndArgs = names.map((name)=>z.object({
            name: z.literal(name),
            args: methodSchemas[name].parameters()
        }));
    const namesAndReturns = names.map((name)=>z.object({
            name: z.literal(name),
            result: methodSchemas[name].returnType()
        }));
    // Type assertion needed because discriminatedUnion expects a tuple type [T, T, ...T[]]
    // but we're building the array dynamically. The runtime behavior is correct.
    return {
        input: z.discriminatedUnion('name', namesAndArgs),
        output: z.discriminatedUnion('name', namesAndReturns)
    };
}
const { input: BatchedMethodSchema, output: BatchedResultSchema } = createBatchSchemas(WalletMethodSchemas);
export { BatchedMethodSchema, BatchedResultSchema };
export const WalletSchema = {
    ...WalletMethodSchemas,
    // @ts-expect-error - ApiSchemaFor cannot properly type generic methods with readonly arrays
    batch: z.function().args(z.array(BatchedMethodSchema)).returns(z.array(BatchedResultSchema))
};
