/**
 * The `contract` module provides utilities for deploying and interacting with contracts, based on a
 * `Wallet` instance and a compiled artifact. Refer to the {@link account} module for how to obtain a valid
 * `Wallet` instance, and to the {@link https://docs.aztec.network/developers/aztec-nr/compiling_contracts | Compiling contracts}
 * section of the documentation for how to generate an artifact out of your Noir source code.
 *
 * The {@link Contract} class is the main class in this module, and provides static methods for deploying
 * a contract or interacting with an already deployed one. The `methods` property of the contract instance
 * provides access to private, public, and simulate methods, that can be invoked in a transaction via `send()`,
 * or can be queried via `simulate()`.
 *
 * ```ts
 * // Deploy and get the contract instance directly (default behavior)
 * const contract = await Contract.deploy(wallet, MyContractArtifact, [...constructorArgs]).send({ from: accountAddress });
 * console.log(`Contract deployed at ${contract.address}`);
 *
 * // Or get the full receipt with contract and instance
 * const receipt = await Contract.deploy(wallet, MyContractArtifact, [...constructorArgs]).send({
 *   from: accountAddress,
 *   wait: { returnReceipt: true }
 * });
 * console.log(`Contract deployed at ${receipt.contract.address}`);
 * ```
 *
 * ```ts
 * const contract = Contract.at(address, MyContractArtifact, wallet);
 * await contract.methods.mint(1000, owner).send({ from: accountAddress });
 * console.log(`Total supply is now ${await contract.methods.totalSupply().simulate()}`);
 * ```
 *
 * The result of calling a method in a contract instance, such as `contract.methods.mint(1000, owner)`
 * in the example, is a {@link ContractFunctionInteraction} instance. Usually this will be just sent as
 * a transaction to the network via the `send` method, but you can also `simulate` it without sending,
 * or obtaining the `request` for aggregating into a {@link BatchCall}.
 *
 * The `send` method returns a {@link TxReceipt} by default (waits for the transaction to be mined).
 * If you pass `wait: NO_WAIT` in the options, it will return a {@link TxHash} immediately without waiting.
 *
 * @remarks If you are using typescript, consider using the
 * {@link https://docs.aztec.network/developers/aztec-nr/compiling_contracts#use-generated-interfaces | autogenerated type-safe interfaces}
 * for interacting with your contracts.
 *
 * @packageDocumentation
 */
export { Contract } from '../contract/contract.js';
export { ContractFunctionInteraction } from '../contract/contract_function_interaction.js';

export {
  NO_WAIT,
  type NoWait,
  type RequestInteractionOptions,
  type SendInteractionOptions,
  type ProfileInteractionOptions,
  type SimulateInteractionOptions,
  type InteractionFeeOptions,
  type InteractionWaitOptions,
  type GasSettingsOption,
  type SendReturn,
  type SimulationReturn,
  toProfileOptions,
  toSendOptions,
  toSimulateOptions,
} from '../contract/interaction_options.js';

export { DefaultWaitOpts, type WaitOpts } from '../contract/wait_opts.js';
export { ContractBase, type ContractMethod, type ContractStorageLayout } from '../contract/contract_base.js';
export { BatchCall } from '../contract/batch_call.js';
export {
  type DeployOptions,
  type DeployReturn,
  type DeployTxReceipt,
  type DeployWaitOptions,
  type DeployInteractionWaitOptions,
  DeployMethod,
  type RequestDeployOptions,
  type SimulateDeployOptions,
} from '../contract/deploy_method.js';
export { waitForProven, type WaitForProvenOpts, DefaultWaitForProvenOpts } from '../contract/wait_for_proven.js';
export { getGasLimits } from '../contract/get_gas_limits.js';

export {
  type PartialAddress,
  type ContractClassWithId,
  type ContractInstanceWithAddress,
  getContractClassFromArtifact,
  getContractInstanceFromInstantiationParams,
  type NodeInfo,
} from '@aztec/stdlib/contract';
