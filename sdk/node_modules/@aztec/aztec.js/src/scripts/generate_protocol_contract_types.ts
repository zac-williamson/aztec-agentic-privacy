/**
 * Generates type-safe contract wrappers for protocol contracts.
 * These wrappers use a minimal artifact (without bytecode) since PXE already has the full artifacts registered.
 */
import { generateTypescriptContractInterface } from '@aztec/builder/codegen';
import {
  type ContractArtifact,
  type FunctionAbi,
  FunctionType,
  getAllFunctionAbis,
  loadContractArtifact,
} from '@aztec/stdlib/abi';
import type { NoirCompiledContract } from '@aztec/stdlib/noir';

import { promises as fs } from 'fs';
import path from 'path';

const log = console.log;

const noirContractsRoot = path.join(import.meta.dirname, '../../../../noir-projects/noir-contracts');
const srcPath = path.join(noirContractsRoot, 'target');
const outputDir = path.join(import.meta.dirname, '../contract/protocol_contracts');

function toKebabCase(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

function functionTypeToEnum(type: FunctionType): string {
  switch (type) {
    case FunctionType.PRIVATE:
      return 'FunctionType.PRIVATE';
    case FunctionType.PUBLIC:
      return 'FunctionType.PUBLIC';
    case FunctionType.UTILITY:
      return 'FunctionType.UTILITY';
  }
}

function generateFunctionAbiJson(abi: FunctionAbi): string {
  const baseObj = {
    name: abi.name,
    isOnlySelf: abi.isOnlySelf,
    isStatic: abi.isStatic,
    isInitializer: abi.isInitializer,
    parameters: abi.parameters,
    returnTypes: abi.returnTypes,
    errorTypes: abi.errorTypes,
  };
  const jsonStr = JSON.stringify(baseObj);
  return jsonStr.replace('{', `{ functionType: ${functionTypeToEnum(abi.functionType)},`);
}

function generateProtocolContractArtifact(input: ContractArtifact): string {
  const allAbis = getAllFunctionAbis(input);
  const functionAbis = input.functions.map(f => allAbis.find(abi => abi.name === f.name)!);
  const nonDispatchAbis = input.nonDispatchPublicFunctions;

  const functionsArray = functionAbis
    .map(abi => `{ ...${generateFunctionAbiJson(abi)}, bytecode: Buffer.from([]), debugSymbols: '' }`)
    .join(',\n    ');

  const nonDispatchArray = nonDispatchAbis.map(abi => generateFunctionAbiJson(abi)).join(',\n    ');

  return `{
  name: '${input.name}',
  functions: [
    ${functionsArray}
  ],
  nonDispatchPublicFunctions: [
    ${nonDispatchArray}
  ],
  outputs: { structs: {}, globals: {} },
  storageLayout: {},
  fileMap: {},
}`;
}

async function generateProtocolContractInterface(
  input: ContractArtifact,
  protocolContractName: string,
): Promise<string> {
  const baseInterface = await generateTypescriptContractInterface(input);

  // Match everything between "public declare methods: {" and the closing "};"
  const methodsMatch = baseInterface.match(/public declare methods: \{([\s\S]*?)\n  \};/);
  if (!methodsMatch) {
    throw new Error('Could not extract methods from generated interface');
  }

  const artifactCode = generateProtocolContractArtifact(input);
  const contractName = `${input.name}Contract`;

  return `
/* Autogenerated file, do not edit! */

/* eslint-disable */
import { ProtocolContractAddress } from '@aztec/protocol-contracts';
import { FunctionType } from '@aztec/stdlib/abi';

import type { ContractArtifact } from '../../api/abi.js';
import { PublicKeys } from '../../api/keys.js';
import type { AztecAddressLike, EthAddressLike, FieldLike, FunctionSelectorLike, WrappedFieldLike } from '../../utils/abi_types.js';
import { ContractBase, type ContractMethod } from '../contract_base.js';
import { ContractFunctionInteraction } from '../contract_function_interaction.js';
import type { Wallet } from '../../wallet/wallet.js';

const ${contractName}Artifact: ContractArtifact = ${artifactCode};

export class ${contractName} extends ContractBase {
  private constructor(wallet: Wallet) {
    super(ProtocolContractAddress.${protocolContractName}, ${contractName}Artifact, wallet);
  }

  public static at(wallet: Wallet): ${contractName} {
    return new ${contractName}(wallet);
  }

  public declare methods: {${methodsMatch[1]}
  };
}
`;
}

async function main() {
  await fs.rm(outputDir, { recursive: true, force: true });
  await fs.mkdir(outputDir, { recursive: true });

  const srcNames = JSON.parse(
    await fs.readFile(path.join(noirContractsRoot, 'protocol_contracts.json'), 'utf8'),
  ) as string[];

  for (const srcName of srcNames) {
    // srcName is like "auth_registry_contract-AuthRegistry", split to get the contract name
    const name = srcName.split('-')[1];
    const artifactPath = path.join(srcPath, `${srcName}.json`);
    const json = JSON.parse(await fs.readFile(artifactPath, 'utf8')) as NoirCompiledContract;
    const contractArtifact = loadContractArtifact(json);

    const content = await generateProtocolContractInterface(contractArtifact, name);
    const fileName = `${toKebabCase(name)}.ts`;
    await fs.writeFile(path.join(outputDir, fileName), content);

    log(`Generated ${fileName}`);
  }
}

main().catch(err => {
  console.error('Error generating protocol contract types:', err);
  process.exit(1);
});
