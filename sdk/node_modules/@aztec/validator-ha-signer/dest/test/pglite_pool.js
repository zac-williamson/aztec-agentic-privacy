/**
 * Vendored pg-compatible Pool/Client wrapper for PGlite.
 *
 * Copied from @middle-management/pglite-pg-adapter v0.0.3
 * https://www.npmjs.com/package/@middle-management/pglite-pg-adapter
 *
 * Modifications:
 * - Converted to ESM and TypeScript
 * - Uses PGliteInterface instead of PGlite class to avoid TypeScript
 *   type mismatches from ESM/CJS dual package resolution with private fields
 * - Simplified rowCount calculation to handle CTEs properly
 */ import { EventEmitter } from 'events';
import { Readable, Writable } from 'stream';
export class Client extends EventEmitter {
    pglite;
    _connected = false;
    host;
    port;
    ssl;
    connection;
    // Stub implementations for pg compatibility
    copyFrom = ()=>new Writable();
    copyTo = ()=>new Readable();
    pauseDrain = ()=>{};
    resumeDrain = ()=>{};
    escapeLiteral = (str)=>`'${str.replace(/'/g, "''")}'`;
    escapeIdentifier = (str)=>`"${str.replace(/"/g, '""')}"`;
    setTypeParser = ()=>{};
    getTypeParser = ()=>(value)=>value;
    constructor(config){
        super();
        this.pglite = config.pglite;
        this.host = config.host || 'localhost';
        this.port = config.port || 5432;
        this.ssl = typeof config.ssl === 'boolean' ? config.ssl : !!config.ssl;
        this.connection = {};
    }
    connect() {
        if (this._connected) {
            return Promise.resolve();
        }
        this._connected = true;
        this.emit('connect');
        return Promise.resolve();
    }
    end() {
        if (!this._connected) {
            return Promise.resolve();
        }
        this._connected = false;
        this.emit('end');
        return Promise.resolve();
    }
    async query(text, values) {
        if (!this._connected) {
            throw new Error('Client is not connected');
        }
        const result = await this.pglite.query(text, values);
        return this.convertPGliteResult(result);
    }
    convertPGliteResult(result) {
        return {
            command: '',
            rowCount: 'affectedRows' in result ? result.affectedRows ?? 0 : result.rows.length,
            oid: 0,
            fields: result.fields.map((field)=>({
                    name: field.name,
                    tableID: 0,
                    columnID: 0,
                    dataTypeID: field.dataTypeID,
                    dataTypeSize: -1,
                    dataTypeModifier: -1,
                    format: 'text'
                })),
            rows: result.rows
        };
    }
    get connected() {
        return this._connected;
    }
}
export class Pool extends EventEmitter {
    clients = [];
    availableClients = [];
    waitingQueue = [];
    _ended = false;
    pglite;
    _config;
    expiredCount = 0;
    options;
    constructor(config){
        super();
        this._config = {
            max: 10,
            min: 0,
            ...config
        };
        this.pglite = config.pglite;
        this.options = config;
    }
    get totalCount() {
        return this.clients.length;
    }
    get idleCount() {
        return this.availableClients.length;
    }
    get waitingCount() {
        return this.waitingQueue.length;
    }
    get ending() {
        return this._ended;
    }
    get ended() {
        return this._ended;
    }
    connect() {
        if (this._ended) {
            return Promise.reject(new Error('Pool is ended'));
        }
        if (this.availableClients.length > 0) {
            const client = this.availableClients.pop();
            client._markInUse();
            return Promise.resolve(client);
        }
        if (this.clients.length < (this._config.max || 10)) {
            const client = new PoolClient(this.pglite, this);
            this.clients.push(client);
            return Promise.resolve(client);
        }
        return new Promise((resolve)=>{
            this.waitingQueue.push(resolve);
        });
    }
    async query(text, values) {
        const client = await this.connect();
        try {
            return await client.query(text, values);
        } finally{
            client.release();
        }
    }
    releaseClient(client) {
        const index = this.clients.indexOf(client);
        if (index !== -1) {
            client._markAvailable();
            if (this.waitingQueue.length > 0) {
                const resolve = this.waitingQueue.shift();
                client._markInUse();
                resolve(client);
            } else {
                this.availableClients.push(client);
            }
        }
    }
    end() {
        this._ended = true;
        this.clients.forEach((client)=>client._markReleased());
        this.clients = [];
        this.availableClients = [];
        this.emit('end');
        return Promise.resolve();
    }
}
export class PoolClient extends Client {
    pool;
    _released = false;
    _inUse = true;
    _userReleased = false;
    constructor(pglite, pool){
        super({
            pglite
        });
        this.pool = pool;
        this._connected = true;
    }
    async query(text, values) {
        if (this._userReleased && !this._inUse) {
            throw new Error('Client has been released back to the pool');
        }
        const result = await this.pglite.query(text, values);
        return this.convertPGliteResult(result);
    }
    release() {
        if (this._released || this._userReleased) {
            return;
        }
        this._userReleased = true;
        this.pool.releaseClient(this);
    }
    end() {
        this.release();
        return Promise.resolve();
    }
    _markInUse() {
        this._inUse = true;
        this._userReleased = false;
    }
    _markAvailable() {
        this._inUse = false;
        this._userReleased = false;
    }
    _markReleased() {
        this._released = true;
        this._inUse = false;
        this._userReleased = true;
    }
    get connected() {
        return this._connected && !this._released;
    }
}
