/**
 * PostgreSQL implementation of SlashingProtectionDatabase
 */
import { SlotNumber } from '@aztec/foundation/branded-types';
import { EthAddress } from '@aztec/foundation/eth-address';
import type { QueryResult, QueryResultRow } from 'pg';
import type { SlashingProtectionDatabase, TryInsertOrGetResult } from '../types.js';
import type { CheckAndRecordParams, DutyType } from './types.js';
/**
 * Minimal pool interface for database operations.
 * Both pg.Pool and test adapters (e.g., PGlite) satisfy this interface.
 */
export interface QueryablePool {
    query<R extends QueryResultRow = any>(text: string, values?: any[]): Promise<QueryResult<R>>;
    end(): Promise<void>;
}
/**
 * PostgreSQL implementation of the slashing protection database
 */
export declare class PostgresSlashingProtectionDatabase implements SlashingProtectionDatabase {
    private readonly pool;
    private readonly log;
    constructor(pool: QueryablePool);
    /**
     * Verify that database migrations have been run and schema version matches.
     * Should be called once at startup.
     *
     * @throws Error if migrations haven't been run or schema version is outdated
     */
    initialize(): Promise<void>;
    /**
     * Atomically try to insert a new duty record, or get the existing one if present.
     *
     * @returns { isNew: true, record } if we successfully inserted and acquired the lock
     * @returns { isNew: false, record } if a record already exists. lock_token is empty if the record already exists.
     *
     * Retries if no rows are returned, which can happen under high concurrency
     * when another transaction just committed the row but it's not yet visible.
     */
    tryInsertOrGetExisting(params: CheckAndRecordParams): Promise<TryInsertOrGetResult>;
    /**
     * Update a duty to 'signed' status with the signature.
     * Only succeeds if the lockToken matches (caller must be the one who created the duty).
     *
     * @returns true if the update succeeded, false if token didn't match or duty not found
     */
    updateDutySigned(rollupAddress: EthAddress, validatorAddress: EthAddress, slot: SlotNumber, dutyType: DutyType, signature: string, lockToken: string, blockIndexWithinCheckpoint: number): Promise<boolean>;
    /**
     * Delete a duty record.
     * Only succeeds if the lockToken matches (caller must be the one who created the duty).
     * Used when signing fails to allow another node/attempt to retry.
     *
     * @returns true if the delete succeeded, false if token didn't match or duty not found
     */
    deleteDuty(rollupAddress: EthAddress, validatorAddress: EthAddress, slot: SlotNumber, dutyType: DutyType, lockToken: string, blockIndexWithinCheckpoint: number): Promise<boolean>;
    /**
     * Convert a database row to a ValidatorDutyRecord
     */
    private rowToRecord;
    /**
     * Close the database connection pool
     */
    close(): Promise<void>;
    /**
     * Cleanup own stuck duties
     * @returns the number of duties cleaned up
     */
    cleanupOwnStuckDuties(nodeId: string, maxAgeMs: number): Promise<number>;
    /**
     * Cleanup duties with outdated rollup address.
     * Removes all duties where the rollup address doesn't match the current one.
     * Used after a rollup upgrade to clean up duties for the old rollup.
     * @returns the number of duties cleaned up
     */
    cleanupOutdatedRollupDuties(currentRollupAddress: EthAddress): Promise<number>;
    /**
     * Cleanup old signed duties.
     * Removes only signed duties older than the specified age.
     * Does not remove 'signing' duties as they may be in progress.
     * @returns the number of duties cleaned up
     */
    cleanupOldDuties(maxAgeMs: number): Promise<number>;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zdGdyZXMuZC50cyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kYi9wb3N0Z3Jlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7R0FFRztBQUNILE9BQU8sRUFBZSxVQUFVLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUUxRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFJM0QsT0FBTyxLQUFLLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxNQUFNLElBQUksQ0FBQztBQUV0RCxPQUFPLEtBQUssRUFBRSwwQkFBMEIsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQVVwRixPQUFPLEtBQUssRUFBRSxvQkFBb0IsRUFBVyxRQUFRLEVBQXVDLE1BQU0sWUFBWSxDQUFDO0FBRy9HOzs7R0FHRztBQUNILE1BQU0sV0FBVyxhQUFhO0lBQzVCLEtBQUssQ0FBQyxDQUFDLFNBQVMsY0FBYyxHQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3RixHQUFHLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3RCO0FBRUQ7O0dBRUc7QUFDSCxxQkFBYSxrQ0FBbUMsWUFBVywwQkFBMEI7SUFHdkUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJO0lBRmpDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFTO0lBRTdCLFlBQTZCLElBQUksRUFBRSxhQUFhLEVBRS9DO0lBRUQ7Ozs7O09BS0c7SUFDRyxVQUFVLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxDQWdDaEM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNHLHNCQUFzQixDQUFDLE1BQU0sRUFBRSxvQkFBb0IsR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FvRHhGO0lBRUQ7Ozs7O09BS0c7SUFDRyxnQkFBZ0IsQ0FDcEIsYUFBYSxFQUFFLFVBQVUsRUFDekIsZ0JBQWdCLEVBQUUsVUFBVSxFQUM1QixJQUFJLEVBQUUsVUFBVSxFQUNoQixRQUFRLEVBQUUsUUFBUSxFQUNsQixTQUFTLEVBQUUsTUFBTSxFQUNqQixTQUFTLEVBQUUsTUFBTSxFQUNqQiwwQkFBMEIsRUFBRSxNQUFNLEdBQ2pDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FzQmxCO0lBRUQ7Ozs7OztPQU1HO0lBQ0csVUFBVSxDQUNkLGFBQWEsRUFBRSxVQUFVLEVBQ3pCLGdCQUFnQixFQUFFLFVBQVUsRUFDNUIsSUFBSSxFQUFFLFVBQVUsRUFDaEIsUUFBUSxFQUFFLFFBQVEsRUFDbEIsU0FBUyxFQUFFLE1BQU0sRUFDakIsMEJBQTBCLEVBQUUsTUFBTSxHQUNqQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBcUJsQjtJQUVEOztPQUVHO0lBQ0gsT0FBTyxDQUFDLFdBQVc7SUFtQm5COztPQUVHO0lBQ0csS0FBSyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FHM0I7SUFFRDs7O09BR0c7SUFDRyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUc3RTtJQUVEOzs7OztPQUtHO0lBQ0csMkJBQTJCLENBQUMsb0JBQW9CLEVBQUUsVUFBVSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FHbkY7SUFFRDs7Ozs7T0FLRztJQUNHLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUd4RDtDQUNGIn0=