/**
 * Custom errors for the validator HA signer
 */ /**
 * Thrown when a duty has already been signed (by any node).
 * This is expected behavior in an HA setup - all nodes try to sign,
 * the first one wins, and subsequent attempts get this error.
 */ export class DutyAlreadySignedError extends Error {
    slot;
    dutyType;
    blockIndexWithinCheckpoint;
    signedByNode;
    constructor(slot, dutyType, blockIndexWithinCheckpoint, signedByNode){
        super(`Duty ${dutyType} for slot ${slot} already signed by node ${signedByNode}`), this.slot = slot, this.dutyType = dutyType, this.blockIndexWithinCheckpoint = blockIndexWithinCheckpoint, this.signedByNode = signedByNode;
        this.name = 'DutyAlreadySignedError';
    }
}
/**
 * Thrown when attempting to sign data that conflicts with an already-signed duty.
 * This means the same validator tried to sign DIFFERENT data for the same slot.
 *
 * This is expected in HA setups where nodes may build different blocks
 * (e.g., different transaction ordering) - the protection prevents double-signing.
 */ export class SlashingProtectionError extends Error {
    slot;
    dutyType;
    blockIndexWithinCheckpoint;
    existingMessageHash;
    attemptedMessageHash;
    signedByNode;
    constructor(slot, dutyType, blockIndexWithinCheckpoint, existingMessageHash, attemptedMessageHash, signedByNode){
        super(`Slashing protection: ${dutyType} for slot ${slot} was already signed with different data. ` + `Existing: ${existingMessageHash.slice(0, 10)}..., Attempted: ${attemptedMessageHash.slice(0, 10)}...`), this.slot = slot, this.dutyType = dutyType, this.blockIndexWithinCheckpoint = blockIndexWithinCheckpoint, this.existingMessageHash = existingMessageHash, this.attemptedMessageHash = attemptedMessageHash, this.signedByNode = signedByNode;
        this.name = 'SlashingProtectionError';
    }
}
