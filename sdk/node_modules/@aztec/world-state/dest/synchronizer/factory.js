import { getTelemetryClient } from '@aztec/telemetry-client';
import { WorldStateInstrumentation } from '../instrumentation/instrumentation.js';
import { NativeWorldStateService } from '../native/native_world_state.js';
import { ServerWorldStateSynchronizer } from './server_world_state_synchronizer.js';
export async function createWorldStateSynchronizer(config, l2BlockSource, prefilledPublicData = [], client = getTelemetryClient(), bindings) {
    const instrumentation = new WorldStateInstrumentation(client);
    const merkleTrees = await createWorldState(config, prefilledPublicData, instrumentation, bindings);
    return new ServerWorldStateSynchronizer(merkleTrees, l2BlockSource, config, instrumentation);
}
export async function createWorldState(config, prefilledPublicData = [], instrumentation = new WorldStateInstrumentation(getTelemetryClient()), bindings) {
    const dataDirectory = config.worldStateDataDirectory ?? config.dataDirectory;
    const dataStoreMapSizeKb = config.worldStateDbMapSizeKb ?? config.dataStoreMapSizeKb;
    const wsTreeMapSizes = {
        archiveTreeMapSizeKb: config.archiveTreeMapSizeKb ?? dataStoreMapSizeKb,
        nullifierTreeMapSizeKb: config.nullifierTreeMapSizeKb ?? dataStoreMapSizeKb,
        noteHashTreeMapSizeKb: config.noteHashTreeMapSizeKb ?? dataStoreMapSizeKb,
        messageTreeMapSizeKb: config.messageTreeMapSizeKb ?? dataStoreMapSizeKb,
        publicDataTreeMapSizeKb: config.publicDataTreeMapSizeKb ?? dataStoreMapSizeKb
    };
    if (!config.l1Contracts?.rollupAddress) {
        throw new Error('Rollup address is required to create a world state synchronizer.');
    }
    // If a data directory is provided in config, then create a persistent store.
    const merkleTrees = dataDirectory ? await NativeWorldStateService.new(config.l1Contracts.rollupAddress, dataDirectory, wsTreeMapSizes, prefilledPublicData, instrumentation, bindings) : await NativeWorldStateService.tmp(config.l1Contracts.rollupAddress, ![
        'true',
        '1'
    ].includes(process.env.DEBUG_WORLD_STATE), prefilledPublicData, instrumentation, bindings);
    return merkleTrees;
}
