import { MerkleTreeId } from '@aztec/stdlib/trees';
export var InsertionType = /*#__PURE__*/ function(InsertionType) {
    InsertionType[InsertionType["BATCH"] = 0] = "BATCH";
    InsertionType[InsertionType["SEQUENTIAL"] = 1] = "SEQUENTIAL";
    return InsertionType;
}({});
export var DataRetrievalType = /*#__PURE__*/ function(DataRetrievalType) {
    DataRetrievalType[DataRetrievalType["SIBLING_PATH"] = 0] = "SIBLING_PATH";
    DataRetrievalType[DataRetrievalType["LEAF_PREIMAGE"] = 1] = "LEAF_PREIMAGE";
    DataRetrievalType[DataRetrievalType["LEAF_VALUE"] = 2] = "LEAF_VALUE";
    DataRetrievalType[DataRetrievalType["LEAF_INDICES"] = 3] = "LEAF_INDICES";
    DataRetrievalType[DataRetrievalType["LOW_LEAF"] = 4] = "LOW_LEAF";
    return DataRetrievalType;
}({});
export class NativeBenchMetics {
    blockSyncMetrics = [];
    insertionMetrics = [];
    dataRetrievalMetrics = [];
    toPrettyString() {
        let pretty = '';
        pretty += `Block sync metrics:\n`;
        for (const metric of this.blockSyncMetrics){
            pretty += `  ${metric.numTxs} txs, ${metric.numLeaves} leaves: ${metric.value} ms\n`;
        }
        pretty += `Insertion metrics:\n`;
        for (const metric of this.insertionMetrics){
            pretty += `  ${MerkleTreeId[metric.treeType]}: ${InsertionType[metric.insertionType]} (${metric.numLeaves} leaves): ${metric.value} ms\n`;
        }
        pretty += `Data retrieval metrics:\n`;
        for (const metric of this.dataRetrievalMetrics){
            pretty += `  ${DataRetrievalType[metric.retrievalType]}: ${metric.value} us\n`;
        }
        return pretty;
    }
    addBlockSyncMetric(numTxs, numLeaves, value) {
        this.blockSyncMetrics.push({
            numTxs,
            numLeaves,
            value
        });
    }
    addInsertionMetric(treeId, insertionType, numLeaves, value) {
        this.insertionMetrics.push({
            treeType: treeId,
            insertionType,
            numLeaves,
            value
        });
    }
    addDataRetrievalMetric(retrievalType, value) {
        this.dataRetrievalMetrics.push({
            retrievalType,
            value: value
        });
    }
    toGithubActionBenchmarkJSON(indent = 2) {
        const data = [];
        for (const blockSync of this.blockSyncMetrics){
            data.push({
                name: `Block Sync/${blockSync.numTxs} txs/${blockSync.numLeaves} leaves per tx`,
                value: blockSync.value,
                unit: 'ms'
            });
        }
        for (const insertion of this.insertionMetrics){
            data.push({
                name: `Tree Insertion/${MerkleTreeId[insertion.treeType]}/${InsertionType[insertion.insertionType]}/${insertion.numLeaves} leaves`,
                value: insertion.value,
                unit: 'ms'
            });
        }
        for (const retrieval of this.dataRetrievalMetrics){
            data.push({
                name: `Data Retrieval/${DataRetrievalType[retrieval.retrievalType]}`,
                value: retrieval.value,
                unit: 'us'
            });
        }
        return JSON.stringify(data, null, indent);
    }
}
