var _computedKey;
import { BlockNumber } from '@aztec/foundation/branded-types';
import { Fr } from '@aztec/foundation/curves/bn254';
import { createLogger } from '@aztec/foundation/log';
import { serializeToBuffer } from '@aztec/foundation/serialize';
import { sleep } from '@aztec/foundation/sleep';
import { SiblingPath } from '@aztec/foundation/trees';
import { MerkleTreeId, NullifierLeaf, NullifierLeafPreimage, PublicDataTreeLeaf, PublicDataTreeLeafPreimage } from '@aztec/stdlib/trees';
import { PartialStateReference, StateReference } from '@aztec/stdlib/tx';
import { WorldStateRevisionWithHandle } from '@aztec/stdlib/world-state';
import assert from 'assert';
import { WorldStateMessageType, blockStateReference, treeStateReferenceToSnapshot } from './message.js';
export class MerkleTreesFacade {
    instance;
    initialHeader;
    revision;
    constructor(instance, initialHeader, revision){
        this.instance = instance;
        this.initialHeader = initialHeader;
        this.revision = revision;
    }
    getInitialHeader() {
        return this.initialHeader;
    }
    getRevision() {
        return WorldStateRevisionWithHandle.fromWorldStateRevision(this.revision, this.instance.getHandle());
    }
    findLeafIndices(treeId, values) {
        return this.findLeafIndicesAfter(treeId, values, 0n);
    }
    async findSiblingPaths(treeId, values) {
        const response = await this.instance.call(WorldStateMessageType.FIND_SIBLING_PATHS, {
            leaves: values.map((leaf)=>serializeLeaf(hydrateLeaf(treeId, leaf))),
            revision: this.revision,
            treeId
        });
        return response.paths.map((path)=>{
            if (!path) {
                return undefined;
            }
            return {
                path: new SiblingPath(path.path.length, path.path),
                index: BigInt(path.index)
            };
        });
    }
    async findLeafIndicesAfter(treeId, leaves, startIndex) {
        const response = await this.instance.call(WorldStateMessageType.FIND_LEAF_INDICES, {
            leaves: leaves.map((leaf)=>serializeLeaf(hydrateLeaf(treeId, leaf))),
            revision: this.revision,
            treeId,
            startIndex
        });
        return response.indices.map((index)=>{
            if (typeof index === 'number' || typeof index === 'bigint') {
                return BigInt(index);
            } else {
                return undefined;
            }
        });
    }
    async getLeafPreimage(treeId, leafIndex) {
        const resp = await this.instance.call(WorldStateMessageType.GET_LEAF_PREIMAGE, {
            leafIndex,
            revision: this.revision,
            treeId
        });
        return resp ? deserializeIndexedLeaf(resp) : undefined;
    }
    async getLeafValue(treeId, leafIndex) {
        const resp = await this.instance.call(WorldStateMessageType.GET_LEAF_VALUE, {
            leafIndex,
            revision: this.revision,
            treeId
        });
        if (!resp) {
            return undefined;
        }
        const leaf = deserializeLeafValue(resp);
        if (leaf instanceof Fr) {
            return leaf;
        } else {
            return leaf.toBuffer();
        }
    }
    async getPreviousValueIndex(treeId, value) {
        const resp = await this.instance.call(WorldStateMessageType.FIND_LOW_LEAF, {
            key: new Fr(value),
            revision: this.revision,
            treeId
        });
        return {
            alreadyPresent: resp.alreadyPresent,
            index: BigInt(resp.index)
        };
    }
    async getSiblingPath(treeId, leafIndex) {
        const siblingPath = await this.instance.call(WorldStateMessageType.GET_SIBLING_PATH, {
            leafIndex,
            revision: this.revision,
            treeId
        });
        return new SiblingPath(siblingPath.length, siblingPath);
    }
    async getStateReference() {
        const resp = await this.instance.call(WorldStateMessageType.GET_STATE_REFERENCE, {
            revision: this.revision
        });
        return new StateReference(treeStateReferenceToSnapshot(resp.state[MerkleTreeId.L1_TO_L2_MESSAGE_TREE]), new PartialStateReference(treeStateReferenceToSnapshot(resp.state[MerkleTreeId.NOTE_HASH_TREE]), treeStateReferenceToSnapshot(resp.state[MerkleTreeId.NULLIFIER_TREE]), treeStateReferenceToSnapshot(resp.state[MerkleTreeId.PUBLIC_DATA_TREE])));
    }
    async getInitialStateReference() {
        const resp = await this.instance.call(WorldStateMessageType.GET_INITIAL_STATE_REFERENCE, {
            canonical: true
        });
        return new StateReference(treeStateReferenceToSnapshot(resp.state[MerkleTreeId.L1_TO_L2_MESSAGE_TREE]), new PartialStateReference(treeStateReferenceToSnapshot(resp.state[MerkleTreeId.NOTE_HASH_TREE]), treeStateReferenceToSnapshot(resp.state[MerkleTreeId.NULLIFIER_TREE]), treeStateReferenceToSnapshot(resp.state[MerkleTreeId.PUBLIC_DATA_TREE])));
    }
    async getTreeInfo(treeId) {
        const resp = await this.instance.call(WorldStateMessageType.GET_TREE_INFO, {
            treeId: treeId,
            revision: this.revision
        });
        return {
            depth: resp.depth,
            root: resp.root,
            size: BigInt(resp.size),
            treeId
        };
    }
    async getBlockNumbersForLeafIndices(treeId, leafIndices) {
        const response = await this.instance.call(WorldStateMessageType.GET_BLOCK_NUMBERS_FOR_LEAF_INDICES, {
            treeId,
            revision: this.revision,
            leafIndices
        });
        return response.blockNumbers.map((x)=>x === undefined || x === null ? undefined : BlockNumber(Number(x)));
    }
}
_computedKey = Symbol.asyncDispose;
export class MerkleTreesForkFacade extends MerkleTreesFacade {
    opts;
    log;
    constructor(instance, initialHeader, revision, opts){
        assert.notEqual(revision.forkId, 0, 'Fork ID must be set');
        assert.equal(revision.includeUncommitted, true, 'Fork must include uncommitted data');
        super(instance, initialHeader, revision), this.opts = opts, this.log = createLogger('world-state:merkle-trees-fork-facade');
    }
    async updateArchive(header) {
        await this.instance.call(WorldStateMessageType.UPDATE_ARCHIVE, {
            forkId: this.revision.forkId,
            blockHeaderHash: (await header.hash()).toBuffer(),
            blockStateRef: blockStateReference(header.state)
        });
    }
    async appendLeaves(treeId, leaves) {
        await this.instance.call(WorldStateMessageType.APPEND_LEAVES, {
            leaves: leaves.map((leaf)=>leaf),
            forkId: this.revision.forkId,
            treeId
        });
    }
    async batchInsert(treeId, rawLeaves, subtreeHeight) {
        const leaves = rawLeaves.map((leaf)=>hydrateLeaf(treeId, leaf)).map(serializeLeaf);
        const resp = await this.instance.call(WorldStateMessageType.BATCH_INSERT, {
            leaves,
            treeId,
            forkId: this.revision.forkId,
            subtreeDepth: subtreeHeight
        });
        return {
            newSubtreeSiblingPath: new SiblingPath(resp.subtree_path.length, resp.subtree_path),
            sortedNewLeaves: resp.sorted_leaves.map(([leaf])=>leaf).map(deserializeLeafValue).map(serializeToBuffer),
            sortedNewLeavesIndexes: resp.sorted_leaves.map(([, index])=>index),
            lowLeavesWitnessData: resp.low_leaf_witness_data.map((data)=>({
                    index: BigInt(data.index),
                    leafPreimage: deserializeIndexedLeaf(data.leaf),
                    siblingPath: new SiblingPath(data.path.length, data.path)
                }))
        };
    }
    async sequentialInsert(treeId, rawLeaves) {
        const leaves = rawLeaves.map((leaf)=>hydrateLeaf(treeId, leaf)).map(serializeLeaf);
        const resp = await this.instance.call(WorldStateMessageType.SEQUENTIAL_INSERT, {
            leaves,
            treeId,
            forkId: this.revision.forkId
        });
        return {
            lowLeavesWitnessData: resp.low_leaf_witness_data.map((data)=>({
                    index: BigInt(data.index),
                    leafPreimage: deserializeIndexedLeaf(data.leaf),
                    siblingPath: new SiblingPath(data.path.length, data.path)
                })),
            insertionWitnessData: resp.insertion_witness_data.map((data)=>({
                    index: BigInt(data.index),
                    leafPreimage: deserializeIndexedLeaf(data.leaf),
                    siblingPath: new SiblingPath(data.path.length, data.path)
                }))
        };
    }
    async close() {
        assert.notEqual(this.revision.forkId, 0, 'Fork ID must be set');
        try {
            await this.instance.call(WorldStateMessageType.DELETE_FORK, {
                forkId: this.revision.forkId
            });
        } catch (err) {
            // Ignore errors due to native instance being closed during shutdown.
            // This can happen when validators are still processing block proposals while the node is stopping.
            if (err?.message === 'Native instance is closed') {
                return;
            }
            throw err;
        }
    }
    async [_computedKey]() {
        if (this.opts.closeDelayMs) {
            void sleep(this.opts.closeDelayMs).then(()=>this.close()).catch((err)=>{
                if (err && 'message' in err && err.message === 'Native instance is closed') {
                    return; // Ignore errors due to native instance being closed
                }
                this.log.warn('Error closing MerkleTreesForkFacade after delay', {
                    err
                });
            });
        } else {
            await this.close();
        }
    }
    async createCheckpoint() {
        assert.notEqual(this.revision.forkId, 0, 'Fork ID must be set');
        await this.instance.call(WorldStateMessageType.CREATE_CHECKPOINT, {
            forkId: this.revision.forkId
        });
    }
    async commitCheckpoint() {
        assert.notEqual(this.revision.forkId, 0, 'Fork ID must be set');
        await this.instance.call(WorldStateMessageType.COMMIT_CHECKPOINT, {
            forkId: this.revision.forkId
        });
    }
    async revertCheckpoint() {
        assert.notEqual(this.revision.forkId, 0, 'Fork ID must be set');
        await this.instance.call(WorldStateMessageType.REVERT_CHECKPOINT, {
            forkId: this.revision.forkId
        });
    }
    async commitAllCheckpoints() {
        assert.notEqual(this.revision.forkId, 0, 'Fork ID must be set');
        await this.instance.call(WorldStateMessageType.COMMIT_ALL_CHECKPOINTS, {
            forkId: this.revision.forkId
        });
    }
    async revertAllCheckpoints() {
        assert.notEqual(this.revision.forkId, 0, 'Fork ID must be set');
        await this.instance.call(WorldStateMessageType.REVERT_ALL_CHECKPOINTS, {
            forkId: this.revision.forkId
        });
    }
}
function hydrateLeaf(treeId, leaf) {
    if (leaf instanceof Fr) {
        return leaf;
    } else if (treeId === MerkleTreeId.NULLIFIER_TREE) {
        return NullifierLeaf.fromBuffer(leaf);
    } else if (treeId === MerkleTreeId.PUBLIC_DATA_TREE) {
        return PublicDataTreeLeaf.fromBuffer(leaf);
    } else {
        return Fr.fromBuffer(leaf);
    }
}
export function serializeLeaf(leaf) {
    if (leaf instanceof Fr) {
        return leaf.toBuffer();
    } else if (leaf instanceof NullifierLeaf) {
        return {
            nullifier: leaf.nullifier.toBuffer()
        };
    } else {
        return {
            value: leaf.value.toBuffer(),
            slot: leaf.slot.toBuffer()
        };
    }
}
function deserializeLeafValue(leaf) {
    if (Buffer.isBuffer(leaf)) {
        return Fr.fromBuffer(leaf);
    } else if ('slot' in leaf) {
        return new PublicDataTreeLeaf(Fr.fromBuffer(leaf.slot), Fr.fromBuffer(leaf.value));
    } else {
        return new NullifierLeaf(Fr.fromBuffer(leaf.nullifier));
    }
}
function deserializeIndexedLeaf(leafPreimage) {
    if ('slot' in leafPreimage.leaf) {
        return new PublicDataTreeLeafPreimage(new PublicDataTreeLeaf(Fr.fromBuffer(leafPreimage.leaf.slot), Fr.fromBuffer(leafPreimage.leaf.value)), Fr.fromBuffer(leafPreimage.nextKey), BigInt(leafPreimage.nextIndex));
    } else if ('nullifier' in leafPreimage.leaf) {
        return new NullifierLeafPreimage(new NullifierLeaf(Fr.fromBuffer(leafPreimage.leaf.nullifier)), Fr.fromBuffer(leafPreimage.nextKey), BigInt(leafPreimage.nextIndex));
    } else {
        throw new Error('Invalid leaf type');
    }
}
