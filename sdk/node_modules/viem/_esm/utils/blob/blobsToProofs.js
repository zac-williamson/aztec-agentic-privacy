import { hexToBytes } from '../encoding/toBytes.js';
import { bytesToHex } from '../encoding/toHex.js';
/**
 * Compute the proofs for a list of blobs and their commitments.
 *
 * Returns an array of proof arrays, where each inner array contains the proofs for one blob:
 * - EIP-4844: Each blob has 1 proof
 * - EIP-7594: Each blob has 128 cell proofs
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const proofs = blobsToProofs({ blobs, commitments, kzg })
 * // proofs = [[proof1], [proof2]] - one proof per blob
 * ```
 *
 * @example
 * ```ts
 * // EIP-7594 (PeerDAS) blobs
 * import {
 *   blobsToCommitments,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const proofs = blobsToProofs({ blobs, commitments, kzg, blobVersion: '7594' })
 * // proofs = [[proof1, proof2, ...proof128], [proof129, ...]] - 128 proofs per blob
 * ```
 */
export function blobsToProofs(parameters) {
    const { kzg, blobVersion = '4844' } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
    const blobs = (typeof parameters.blobs[0] === 'string'
        ? parameters.blobs.map((x) => hexToBytes(x))
        : parameters.blobs);
    const commitments = (typeof parameters.commitments[0] === 'string'
        ? parameters.commitments.map((x) => hexToBytes(x))
        : parameters.commitments);
    const proofs = [];
    if (blobVersion === '7594') {
        // EIP-7594: Use computeCellsAndKzgProofs and return cell proofs for each blob
        if (!kzg.computeCellsAndKzgProofs) {
            throw new Error('KZG implementation does not support computeCellsAndKzgProofs (required for EIP-7594)');
        }
        for (let i = 0; i < blobs.length; i++) {
            const blob = blobs[i];
            const [_cells, cellProofs] = kzg.computeCellsAndKzgProofs(blob);
            // Each blob gets its own array of cell proofs
            proofs.push(cellProofs);
        }
    }
    else {
        // EIP-4844: Use computeBlobKzgProof (one proof per blob, wrapped in array)
        for (let i = 0; i < blobs.length; i++) {
            const blob = blobs[i];
            const commitment = commitments[i];
            proofs.push([Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment))]);
        }
    }
    return (to === 'bytes'
        ? proofs
        : proofs.map((blobProofs) => blobProofs.map((proof) => bytesToHex(proof))));
}
//# sourceMappingURL=blobsToProofs.js.map